{
  "version": 3,
  "sources": ["src/app/shared/services/csv.service.ts", "src/app/shared/utils/string.utils.ts", "src/app/admin/products/services/admin-product.service.ts"],
  "sourcesContent": ["import { Injectable } from '@angular/core';\r\n\r\nexport interface CsvImportResult<T> {\r\n  data: Partial<T>[];\r\n  errors: number;\r\n}\r\n\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class CsvService {\r\n  constructor() {}\r\n\r\n  async parse<T>(file: File, parser: (values: string[], headers: string[]) => T | null): Promise<CsvImportResult<T>> {\r\n    return new Promise((resolve, reject) => {\r\n      const reader = new FileReader();\r\n      \r\n      reader.onload = (e: ProgressEvent<FileReader>) => {\r\n        try {\r\n          const csv = e.target?.result as string;\r\n          if (!csv) {\r\n            reject(new Error('Empty file'));\r\n            return;\r\n          }\r\n          \r\n          const lines = csv.split(/\\r\\n|\\n/);\r\n          const headers = lines[0].split(',').map(h => h.trim());\r\n          \r\n          const data: Partial<T>[] = [];\r\n          let errorCount = 0;\r\n\r\n          for (let i = 1; i < lines.length; i++) {\r\n            const line = lines[i].trim();\r\n            if (!line) continue;\r\n\r\n            const values = this.parseLine(line);\r\n            \r\n            if (values.length !== headers.length) {\r\n              console.warn(`Skipping line ${i + 1}: Column count mismatch`);\r\n              errorCount++;\r\n              continue;\r\n            }\r\n\r\n            const item = parser(values, headers);\r\n            if (item) {\r\n              data.push(item);\r\n            } else {\r\n              errorCount++;\r\n            }\r\n          }\r\n\r\n          resolve({ data, errors: errorCount });\r\n        } catch (error) {\r\n          reject(error);\r\n        }\r\n      };\r\n\r\n      reader.onerror = (error) => reject(error);\r\n      reader.readAsText(file);\r\n    });\r\n  }\r\n\r\n  exportToCsv<T>(data: T[], filename: string, headers: (keyof T | string)[]): void {\r\n    if (!data.length) return;\r\n\r\n    const csvContent = [\r\n      headers.join(','),\r\n      ...data.map(item => {\r\n        return headers.map(header => {\r\n          const value = (item as any)[header];\r\n          const safeValue = value === undefined || value === null ? '' : value;\r\n          \r\n          if (typeof safeValue === 'string' && (safeValue.includes(',') || safeValue.includes('\"') || safeValue.includes('\\n'))) {\r\n            return `\"${safeValue.replace(/\"/g, '\"\"')}\"`;\r\n          }\r\n          return safeValue;\r\n        }).join(',');\r\n      })\r\n    ].join('\\n');\r\n\r\n    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });\r\n    const link = document.createElement('a');\r\n    const url = URL.createObjectURL(blob);\r\n    \r\n    link.setAttribute('href', url);\r\n    link.setAttribute('download', `${filename}_${new Date().toISOString().split('T')[0]}.csv`);\r\n    link.style.visibility = 'hidden';\r\n    document.body.appendChild(link);\r\n    link.click();\r\n    document.body.removeChild(link);\r\n  }\r\n\r\n  private parseLine(line: string): string[] {\r\n    const values: string[] = [];\r\n    let inQuotes = false;\r\n    let currentValue = '';\r\n    \r\n    for (let char of line) {\r\n      if (char === '\"') {\r\n        inQuotes = !inQuotes;\r\n      } else if (char === ',' && !inQuotes) {\r\n        values.push(currentValue);\r\n        currentValue = '';\r\n      } else {\r\n        currentValue += char;\r\n      }\r\n    }\r\n    values.push(currentValue);\r\n    return values;\r\n  }\r\n}\r\n", "export class StringUtils {\r\n  static slugify(text: string): string {\r\n    return text\r\n      .toString()\r\n      .toLowerCase()\r\n      .trim()\r\n      .replace(/\\s+/g, '-')\r\n      .replace(/&/g, '-and-')\r\n      .replace(/[^a-z0-9-]/g, '')\r\n      .replace(/-+/g, '-');\r\n  }\r\n\r\n  static capitalize(text: string): string {\r\n    if (!text) return '';\r\n    return text.charAt(0).toUpperCase() + text.slice(1);\r\n  }\r\n}\r\n", "import { Injectable, inject } from '@angular/core';\r\nimport { Product } from '@app/features/products/domain/entities/product.entity';\r\nimport { Brand } from '@app/features/products/domain/entities/brand.entity';\r\nimport { Category } from '@app/features/products/domain/entities/category.entity';\r\nimport { ProductRepository } from '@app/features/products/domain/repositories/product.repository';\r\nimport { BrandRepository } from '@app/features/products/domain/repositories/brand.repository';\r\nimport { CategoryRepository } from '@app/features/products/domain/repositories/category.repository';\r\nimport { AuthService } from '@app/core/services/auth.service';\r\nimport { CsvService } from '@app/shared/services/csv.service';\r\nimport { StringUtils } from '@app/shared/utils/string.utils';\r\nimport { firstValueFrom } from 'rxjs';\r\n\r\n@Injectable({\r\n    providedIn: 'root'\r\n})\r\nexport class AdminProductService {\r\n    private productRepo = inject(ProductRepository);\r\n    private brandRepo = inject(BrandRepository);\r\n    private categoryRepo = inject(CategoryRepository);\r\n    private csvService = inject(CsvService);\r\n    // Needed for storage and bulk ops not yet in repo\r\n    private auth = inject(AuthService);\r\n    private supabase = this.auth.getSupabaseClient();\r\n\r\n    async getProducts(): Promise<Product[]> {\r\n        return firstValueFrom(this.productRepo.getAll());\r\n    }\r\n\r\n    async getProduct(id: string): Promise<Product> {\r\n        return firstValueFrom(this.productRepo.getById(id));\r\n    }\r\n\r\n    async getBrands(): Promise<Brand[]> {\r\n        return firstValueFrom(this.brandRepo.getAll());\r\n    }\r\n\r\n    async getCategories(): Promise<Category[]> {\r\n        return firstValueFrom(this.categoryRepo.getAll());\r\n    }\r\n\r\n    async createProduct(payload: Partial<Product>): Promise<void> {\r\n        await firstValueFrom(this.productRepo.create(payload as Product));\r\n    }\r\n\r\n    async updateProduct(id: string, payload: Partial<Product>): Promise<void> {\r\n        await firstValueFrom(this.productRepo.update(id, payload));\r\n    }\r\n\r\n    async uploadImage(file: File): Promise<string> {\r\n        const filePath = `products/${Date.now()}-${file.name}`;\r\n        const { data, error } = await this.supabase.storage.from('public-assets').upload(filePath, file);\r\n\r\n        if (error) throw error;\r\n\r\n        const { data: publicUrl } = this.supabase.storage.from('public-assets').getPublicUrl(data.path);\r\n        return publicUrl.publicUrl;\r\n    }\r\n\r\n    slugify(text: string): string {\r\n        return StringUtils.slugify(text);\r\n    }\r\n\r\n    async exportProductsToCSV(): Promise<void> {\r\n        const products = await this.getProducts();\r\n        if (!products.length) return;\r\n\r\n        const headers = [\r\n            'id', 'name', 'slug', 'description', 'price', \r\n            'stock', 'category_id', 'brand_id', 'image_url', \r\n            'is_active', 'is_featured', 'sku', 'barcode'\r\n        ];\r\n\r\n        this.csvService.exportToCsv(products, 'products_export', headers);\r\n    }\r\n\r\n    async importProductsFromCSV(file: File): Promise<{ success: number; errors: number }> {\r\n        return new Promise((resolve, reject) => {\r\n            const reader = new FileReader();\r\n            \r\n            reader.onload = async (e: ProgressEvent<FileReader>) => {\r\n                try {\r\n                    const csv = e.target?.result as string;\r\n                    if (!csv) throw new Error('Empty file');\r\n                    \r\n                    // Use CsvService logic if we want, but since we have specific mapping logic here that relies on indices...\r\n                    // Actually, CsvService parses lines. We can reuse parseLine logic if public, or just refactor whole thing.\r\n                    // Let's rely on standard CsvService.\r\n                    // Wait, CsvService returns parsed objects based on a callback.\r\n                    \r\n                    const result = await this.csvService.parse<Product>(file, (values, headers) => {\r\n                        const product: Record<string, any> = {};\r\n                        \r\n                        headers.forEach((header: string, index: number) => {\r\n                            let value = values[index]?.trim();\r\n                             // Remove surrounding quotes if present (CsvService handles this if parseLine does, but CsvService.parseLine handles quotes internally)\r\n                             // wait, CsvService.parse calls parseLine which returns clean values?\r\n                             // Yes, parseLine in CsvService handles quotes and returns clean values.\r\n                             // So we just take the value.\r\n                            \r\n                            if (value === '' || value === undefined) {\r\n                                product[header] = null;\r\n                            } else if (header === 'price' || header === 'stock' || header === 'min_stock_alert') {\r\n                                product[header] = Number(value);\r\n                            } else if (header === 'is_active' || header === 'is_featured') {\r\n                                product[header] = value.toLowerCase() === 'true';\r\n                            } else {\r\n                                product[header] = value;\r\n                            }\r\n                        });\r\n\r\n                        // Remove id if it's empty or new placeholder to allow auto-generation\r\n                        if (!product['id'] || product['id'] === 'new') {\r\n                             delete product['id'];\r\n                        }\r\n\r\n                        // Basic validation\r\n                        if (product['name'] && (product['price'] === undefined || product['price'] >= 0)) {\r\n                             return product as Product;\r\n                        }\r\n                        return null;\r\n                    });\r\n                    \r\n                    const productsToUpsert = result.data;\r\n                    \r\n                    if (productsToUpsert.length > 0) {\r\n                        const { error } = await this.supabase\r\n                            .from('products')\r\n                            .upsert(productsToUpsert, { onConflict: 'id' }); \r\n\r\n                        if (error) throw error;\r\n                    }\r\n\r\n                    resolve({ success: productsToUpsert.length, errors: result.errors });\r\n                } catch (error) {\r\n                    reject(error);\r\n                }\r\n            };\r\n\r\n            reader.onerror = (error) => reject(error);\r\n            reader.readAsText(file);\r\n        });\r\n    }\r\n\r\n    async bulkUpdate(ids: string[], payload: Partial<Product>): Promise<void> {\r\n        const { error } = await this.supabase\r\n            .from('products')\r\n            .update(payload)\r\n            .in('id', ids);\r\n\r\n        if (error) throw error;\r\n    }\r\n\r\n    async bulkIncreasePrice(ids: string[], percentage: number): Promise<void> {\r\n        // Strategy: Fetch current prices, calculate new ones, and update.\r\n        // For distinct values, we unfortunately need individual updates or an Upsert.\r\n        // Supabase/PostgREST doesn't support \"price = price * 1.1\" in simple update yet without RPC.\r\n        \r\n        // 1. Get current products\r\n        const { data: products, error } = await this.supabase\r\n            .from('products')\r\n            .select('id, price')\r\n            .in('id', ids);\r\n\r\n        if (error) throw error;\r\n        if (!products || products.length === 0) return;\r\n\r\n        // 2. Prepare updates\r\n        const updates = products.map(p => ({\r\n            id: p.id,\r\n            price: Math.round(p.price * (1 + percentage / 100)) // Round to integer for simplicity, or 2 decimals\r\n        }));\r\n\r\n        // 3. Perform Upsert (efficient batch update)\r\n        // Note: This requires the table to have a primary key on ID (standard)\r\n        // We only send ID and Price, so we must rely on Supabase not clearing other fields on upsert \r\n        // IF we use 'ignoreDuplicates: false' (default).\r\n        // However, standard upsert replaces the row. \r\n        // BETTER APPROACH SAFE: Parallel Updates for now to avoid overwriting other fields \r\n        // if upsert behavior isn't strictly PATCh. \r\n        // Actually, upsert overwrites. We don't want that.\r\n        // Let's use Promise.all with a concurrency limit if possible, or just Promise.all for now (Batch size usually < 50).\r\n        \r\n        const BATCH_SIZE = 5;\r\n        for (let i = 0; i < updates.length; i += BATCH_SIZE) {\r\n             const batch = updates.slice(i, i + BATCH_SIZE);\r\n             await Promise.all(batch.map(u => \r\n                 this.supabase.from('products').update({ price: u.price }).eq('id', u.id)\r\n             ));\r\n        }\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
