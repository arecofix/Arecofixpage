import './polyfills.server.mjs';
import {
  AdminRepairService
} from "./chunk-OZKI3SM7.mjs";
import {
  AdminProductService
} from "./chunk-2STRLRHX.mjs";
import {
  RepairStatus
} from "./chunk-65P2T3U5.mjs";
import {
  CompanyService
} from "./chunk-BBYC5QHM.mjs";
import "./chunk-6TWNUMFJ.mjs";
import "./chunk-WPRKDIZO.mjs";
import "./chunk-XL3PKKWP.mjs";
import "./chunk-XSIYETXB.mjs";
import {
  CheckboxControlValueAccessor,
  DefaultValueAccessor,
  FormsModule,
  MinValidator,
  NgControlStatus,
  NgControlStatusGroup,
  NgForm,
  NgModel,
  NgSelectOption,
  NumberValueAccessor,
  RequiredValidator,
  SelectControlValueAccessor,
  ɵNgNoValidate,
  ɵNgSelectMultipleOption
} from "./chunk-EBVHUSN7.mjs";
import "./chunk-EIU5CNMA.mjs";
import "./chunk-KAY2H7H4.mjs";
import "./chunk-QOHRYQPW.mjs";
import {
  environment
} from "./chunk-R72SLW3B.mjs";
import {
  ActivatedRoute,
  DomSanitizer,
  Router,
  RouterLink
} from "./chunk-GLYZDHZB.mjs";
import {
  CommonModule,
  CurrencyPipe,
  DatePipe,
  DecimalPipe
} from "./chunk-NQCCIK3J.mjs";
import {
  ChangeDetectionStrategy,
  Component,
  EventEmitter,
  Input,
  Output,
  Renderer2,
  ViewChild,
  computed,
  inject,
  setClassMetadata,
  signal,
  ɵsetClassDebugInfo,
  ɵɵNgOnChangesFeature,
  ɵɵadvance,
  ɵɵclassMap,
  ɵɵclassProp,
  ɵɵconditional,
  ɵɵconditionalCreate,
  ɵɵdefineComponent,
  ɵɵdomElement,
  ɵɵelement,
  ɵɵelementEnd,
  ɵɵelementStart,
  ɵɵgetCurrentView,
  ɵɵlistener,
  ɵɵloadQuery,
  ɵɵnextContext,
  ɵɵpipe,
  ɵɵpipeBind2,
  ɵɵpipeBind4,
  ɵɵproperty,
  ɵɵqueryRefresh,
  ɵɵrepeater,
  ɵɵrepeaterCreate,
  ɵɵrepeaterTrackByIdentity,
  ɵɵrepeaterTrackByIndex,
  ɵɵresetView,
  ɵɵrestoreView,
  ɵɵsanitizeUrl,
  ɵɵtext,
  ɵɵtextInterpolate,
  ɵɵtextInterpolate1,
  ɵɵtwoWayBindingSet,
  ɵɵtwoWayListener,
  ɵɵtwoWayProperty,
  ɵɵviewQuery
} from "./chunk-RN3QJLYL.mjs";
import "./chunk-SCNXJUDC.mjs";
import {
  __commonJS,
  __esm,
  __export,
  __require,
  __spreadProps,
  __spreadValues,
  __toCommonJS,
  __toESM
} from "./chunk-TB3YAHZW.mjs";

// node_modules/qrcode/lib/can-promise.js
var require_can_promise = __commonJS({
  "node_modules/qrcode/lib/can-promise.js"(exports, module) {
    "use strict";
    module.exports = function() {
      return typeof Promise === "function" && Promise.prototype && Promise.prototype.then;
    };
  }
});

// node_modules/qrcode/lib/core/utils.js
var require_utils = __commonJS({
  "node_modules/qrcode/lib/core/utils.js"(exports) {
    "use strict";
    var toSJISFunction;
    var CODEWORDS_COUNT = [
      0,
      // Not used
      26,
      44,
      70,
      100,
      134,
      172,
      196,
      242,
      292,
      346,
      404,
      466,
      532,
      581,
      655,
      733,
      815,
      901,
      991,
      1085,
      1156,
      1258,
      1364,
      1474,
      1588,
      1706,
      1828,
      1921,
      2051,
      2185,
      2323,
      2465,
      2611,
      2761,
      2876,
      3034,
      3196,
      3362,
      3532,
      3706
    ];
    exports.getSymbolSize = function getSymbolSize(version) {
      if (!version) throw new Error('"version" cannot be null or undefined');
      if (version < 1 || version > 40) throw new Error('"version" should be in range from 1 to 40');
      return version * 4 + 17;
    };
    exports.getSymbolTotalCodewords = function getSymbolTotalCodewords(version) {
      return CODEWORDS_COUNT[version];
    };
    exports.getBCHDigit = function(data) {
      let digit = 0;
      while (data !== 0) {
        digit++;
        data >>>= 1;
      }
      return digit;
    };
    exports.setToSJISFunction = function setToSJISFunction(f2) {
      if (typeof f2 !== "function") {
        throw new Error('"toSJISFunc" is not a valid function.');
      }
      toSJISFunction = f2;
    };
    exports.isKanjiModeEnabled = function() {
      return typeof toSJISFunction !== "undefined";
    };
    exports.toSJIS = function toSJIS(kanji) {
      return toSJISFunction(kanji);
    };
  }
});

// node_modules/qrcode/lib/core/error-correction-level.js
var require_error_correction_level = __commonJS({
  "node_modules/qrcode/lib/core/error-correction-level.js"(exports) {
    "use strict";
    exports.L = { bit: 1 };
    exports.M = { bit: 0 };
    exports.Q = { bit: 3 };
    exports.H = { bit: 2 };
    function fromString(string) {
      if (typeof string !== "string") {
        throw new Error("Param is not a string");
      }
      const lcStr = string.toLowerCase();
      switch (lcStr) {
        case "l":
        case "low":
          return exports.L;
        case "m":
        case "medium":
          return exports.M;
        case "q":
        case "quartile":
          return exports.Q;
        case "h":
        case "high":
          return exports.H;
        default:
          throw new Error("Unknown EC Level: " + string);
      }
    }
    exports.isValid = function isValid(level) {
      return level && typeof level.bit !== "undefined" && level.bit >= 0 && level.bit < 4;
    };
    exports.from = function from(value, defaultValue) {
      if (exports.isValid(value)) {
        return value;
      }
      try {
        return fromString(value);
      } catch (e2) {
        return defaultValue;
      }
    };
  }
});

// node_modules/qrcode/lib/core/bit-buffer.js
var require_bit_buffer = __commonJS({
  "node_modules/qrcode/lib/core/bit-buffer.js"(exports, module) {
    "use strict";
    function BitBuffer() {
      this.buffer = [];
      this.length = 0;
    }
    BitBuffer.prototype = {
      get: function(index) {
        const bufIndex = Math.floor(index / 8);
        return (this.buffer[bufIndex] >>> 7 - index % 8 & 1) === 1;
      },
      put: function(num, length) {
        for (let i = 0; i < length; i++) {
          this.putBit((num >>> length - i - 1 & 1) === 1);
        }
      },
      getLengthInBits: function() {
        return this.length;
      },
      putBit: function(bit) {
        const bufIndex = Math.floor(this.length / 8);
        if (this.buffer.length <= bufIndex) {
          this.buffer.push(0);
        }
        if (bit) {
          this.buffer[bufIndex] |= 128 >>> this.length % 8;
        }
        this.length++;
      }
    };
    module.exports = BitBuffer;
  }
});

// node_modules/qrcode/lib/core/bit-matrix.js
var require_bit_matrix = __commonJS({
  "node_modules/qrcode/lib/core/bit-matrix.js"(exports, module) {
    "use strict";
    function BitMatrix(size) {
      if (!size || size < 1) {
        throw new Error("BitMatrix size must be defined and greater than 0");
      }
      this.size = size;
      this.data = new Uint8Array(size * size);
      this.reservedBit = new Uint8Array(size * size);
    }
    BitMatrix.prototype.set = function(row, col, value, reserved) {
      const index = row * this.size + col;
      this.data[index] = value;
      if (reserved) this.reservedBit[index] = true;
    };
    BitMatrix.prototype.get = function(row, col) {
      return this.data[row * this.size + col];
    };
    BitMatrix.prototype.xor = function(row, col, value) {
      this.data[row * this.size + col] ^= value;
    };
    BitMatrix.prototype.isReserved = function(row, col) {
      return this.reservedBit[row * this.size + col];
    };
    module.exports = BitMatrix;
  }
});

// node_modules/qrcode/lib/core/alignment-pattern.js
var require_alignment_pattern = __commonJS({
  "node_modules/qrcode/lib/core/alignment-pattern.js"(exports) {
    "use strict";
    var getSymbolSize = require_utils().getSymbolSize;
    exports.getRowColCoords = function getRowColCoords(version) {
      if (version === 1) return [];
      const posCount = Math.floor(version / 7) + 2;
      const size = getSymbolSize(version);
      const intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2;
      const positions = [size - 7];
      for (let i = 1; i < posCount - 1; i++) {
        positions[i] = positions[i - 1] - intervals;
      }
      positions.push(6);
      return positions.reverse();
    };
    exports.getPositions = function getPositions(version) {
      const coords = [];
      const pos = exports.getRowColCoords(version);
      const posLength = pos.length;
      for (let i = 0; i < posLength; i++) {
        for (let j = 0; j < posLength; j++) {
          if (i === 0 && j === 0 || // top-left
          i === 0 && j === posLength - 1 || // bottom-left
          i === posLength - 1 && j === 0) {
            continue;
          }
          coords.push([pos[i], pos[j]]);
        }
      }
      return coords;
    };
  }
});

// node_modules/qrcode/lib/core/finder-pattern.js
var require_finder_pattern = __commonJS({
  "node_modules/qrcode/lib/core/finder-pattern.js"(exports) {
    "use strict";
    var getSymbolSize = require_utils().getSymbolSize;
    var FINDER_PATTERN_SIZE = 7;
    exports.getPositions = function getPositions(version) {
      const size = getSymbolSize(version);
      return [
        // top-left
        [0, 0],
        // top-right
        [size - FINDER_PATTERN_SIZE, 0],
        // bottom-left
        [0, size - FINDER_PATTERN_SIZE]
      ];
    };
  }
});

// node_modules/qrcode/lib/core/mask-pattern.js
var require_mask_pattern = __commonJS({
  "node_modules/qrcode/lib/core/mask-pattern.js"(exports) {
    "use strict";
    exports.Patterns = {
      PATTERN000: 0,
      PATTERN001: 1,
      PATTERN010: 2,
      PATTERN011: 3,
      PATTERN100: 4,
      PATTERN101: 5,
      PATTERN110: 6,
      PATTERN111: 7
    };
    var PenaltyScores = {
      N1: 3,
      N2: 3,
      N3: 40,
      N4: 10
    };
    exports.isValid = function isValid(mask) {
      return mask != null && mask !== "" && !isNaN(mask) && mask >= 0 && mask <= 7;
    };
    exports.from = function from(value) {
      return exports.isValid(value) ? parseInt(value, 10) : void 0;
    };
    exports.getPenaltyN1 = function getPenaltyN1(data) {
      const size = data.size;
      let points = 0;
      let sameCountCol = 0;
      let sameCountRow = 0;
      let lastCol = null;
      let lastRow = null;
      for (let row = 0; row < size; row++) {
        sameCountCol = sameCountRow = 0;
        lastCol = lastRow = null;
        for (let col = 0; col < size; col++) {
          let module2 = data.get(row, col);
          if (module2 === lastCol) {
            sameCountCol++;
          } else {
            if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
            lastCol = module2;
            sameCountCol = 1;
          }
          module2 = data.get(col, row);
          if (module2 === lastRow) {
            sameCountRow++;
          } else {
            if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
            lastRow = module2;
            sameCountRow = 1;
          }
        }
        if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
        if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
      }
      return points;
    };
    exports.getPenaltyN2 = function getPenaltyN2(data) {
      const size = data.size;
      let points = 0;
      for (let row = 0; row < size - 1; row++) {
        for (let col = 0; col < size - 1; col++) {
          const last = data.get(row, col) + data.get(row, col + 1) + data.get(row + 1, col) + data.get(row + 1, col + 1);
          if (last === 4 || last === 0) points++;
        }
      }
      return points * PenaltyScores.N2;
    };
    exports.getPenaltyN3 = function getPenaltyN3(data) {
      const size = data.size;
      let points = 0;
      let bitsCol = 0;
      let bitsRow = 0;
      for (let row = 0; row < size; row++) {
        bitsCol = bitsRow = 0;
        for (let col = 0; col < size; col++) {
          bitsCol = bitsCol << 1 & 2047 | data.get(row, col);
          if (col >= 10 && (bitsCol === 1488 || bitsCol === 93)) points++;
          bitsRow = bitsRow << 1 & 2047 | data.get(col, row);
          if (col >= 10 && (bitsRow === 1488 || bitsRow === 93)) points++;
        }
      }
      return points * PenaltyScores.N3;
    };
    exports.getPenaltyN4 = function getPenaltyN4(data) {
      let darkCount = 0;
      const modulesCount = data.data.length;
      for (let i = 0; i < modulesCount; i++) darkCount += data.data[i];
      const k = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);
      return k * PenaltyScores.N4;
    };
    function getMaskAt(maskPattern, i, j) {
      switch (maskPattern) {
        case exports.Patterns.PATTERN000:
          return (i + j) % 2 === 0;
        case exports.Patterns.PATTERN001:
          return i % 2 === 0;
        case exports.Patterns.PATTERN010:
          return j % 3 === 0;
        case exports.Patterns.PATTERN011:
          return (i + j) % 3 === 0;
        case exports.Patterns.PATTERN100:
          return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0;
        case exports.Patterns.PATTERN101:
          return i * j % 2 + i * j % 3 === 0;
        case exports.Patterns.PATTERN110:
          return (i * j % 2 + i * j % 3) % 2 === 0;
        case exports.Patterns.PATTERN111:
          return (i * j % 3 + (i + j) % 2) % 2 === 0;
        default:
          throw new Error("bad maskPattern:" + maskPattern);
      }
    }
    exports.applyMask = function applyMask(pattern, data) {
      const size = data.size;
      for (let col = 0; col < size; col++) {
        for (let row = 0; row < size; row++) {
          if (data.isReserved(row, col)) continue;
          data.xor(row, col, getMaskAt(pattern, row, col));
        }
      }
    };
    exports.getBestMask = function getBestMask(data, setupFormatFunc) {
      const numPatterns = Object.keys(exports.Patterns).length;
      let bestPattern = 0;
      let lowerPenalty = Infinity;
      for (let p = 0; p < numPatterns; p++) {
        setupFormatFunc(p);
        exports.applyMask(p, data);
        const penalty = exports.getPenaltyN1(data) + exports.getPenaltyN2(data) + exports.getPenaltyN3(data) + exports.getPenaltyN4(data);
        exports.applyMask(p, data);
        if (penalty < lowerPenalty) {
          lowerPenalty = penalty;
          bestPattern = p;
        }
      }
      return bestPattern;
    };
  }
});

// node_modules/qrcode/lib/core/error-correction-code.js
var require_error_correction_code = __commonJS({
  "node_modules/qrcode/lib/core/error-correction-code.js"(exports) {
    "use strict";
    var ECLevel = require_error_correction_level();
    var EC_BLOCKS_TABLE = [
      // L  M  Q  H
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      1,
      2,
      2,
      4,
      1,
      2,
      4,
      4,
      2,
      4,
      4,
      4,
      2,
      4,
      6,
      5,
      2,
      4,
      6,
      6,
      2,
      5,
      8,
      8,
      4,
      5,
      8,
      8,
      4,
      5,
      8,
      11,
      4,
      8,
      10,
      11,
      4,
      9,
      12,
      16,
      4,
      9,
      16,
      16,
      6,
      10,
      12,
      18,
      6,
      10,
      17,
      16,
      6,
      11,
      16,
      19,
      6,
      13,
      18,
      21,
      7,
      14,
      21,
      25,
      8,
      16,
      20,
      25,
      8,
      17,
      23,
      25,
      9,
      17,
      23,
      34,
      9,
      18,
      25,
      30,
      10,
      20,
      27,
      32,
      12,
      21,
      29,
      35,
      12,
      23,
      34,
      37,
      12,
      25,
      34,
      40,
      13,
      26,
      35,
      42,
      14,
      28,
      38,
      45,
      15,
      29,
      40,
      48,
      16,
      31,
      43,
      51,
      17,
      33,
      45,
      54,
      18,
      35,
      48,
      57,
      19,
      37,
      51,
      60,
      19,
      38,
      53,
      63,
      20,
      40,
      56,
      66,
      21,
      43,
      59,
      70,
      22,
      45,
      62,
      74,
      24,
      47,
      65,
      77,
      25,
      49,
      68,
      81
    ];
    var EC_CODEWORDS_TABLE = [
      // L  M  Q  H
      7,
      10,
      13,
      17,
      10,
      16,
      22,
      28,
      15,
      26,
      36,
      44,
      20,
      36,
      52,
      64,
      26,
      48,
      72,
      88,
      36,
      64,
      96,
      112,
      40,
      72,
      108,
      130,
      48,
      88,
      132,
      156,
      60,
      110,
      160,
      192,
      72,
      130,
      192,
      224,
      80,
      150,
      224,
      264,
      96,
      176,
      260,
      308,
      104,
      198,
      288,
      352,
      120,
      216,
      320,
      384,
      132,
      240,
      360,
      432,
      144,
      280,
      408,
      480,
      168,
      308,
      448,
      532,
      180,
      338,
      504,
      588,
      196,
      364,
      546,
      650,
      224,
      416,
      600,
      700,
      224,
      442,
      644,
      750,
      252,
      476,
      690,
      816,
      270,
      504,
      750,
      900,
      300,
      560,
      810,
      960,
      312,
      588,
      870,
      1050,
      336,
      644,
      952,
      1110,
      360,
      700,
      1020,
      1200,
      390,
      728,
      1050,
      1260,
      420,
      784,
      1140,
      1350,
      450,
      812,
      1200,
      1440,
      480,
      868,
      1290,
      1530,
      510,
      924,
      1350,
      1620,
      540,
      980,
      1440,
      1710,
      570,
      1036,
      1530,
      1800,
      570,
      1064,
      1590,
      1890,
      600,
      1120,
      1680,
      1980,
      630,
      1204,
      1770,
      2100,
      660,
      1260,
      1860,
      2220,
      720,
      1316,
      1950,
      2310,
      750,
      1372,
      2040,
      2430
    ];
    exports.getBlocksCount = function getBlocksCount(version, errorCorrectionLevel) {
      switch (errorCorrectionLevel) {
        case ECLevel.L:
          return EC_BLOCKS_TABLE[(version - 1) * 4 + 0];
        case ECLevel.M:
          return EC_BLOCKS_TABLE[(version - 1) * 4 + 1];
        case ECLevel.Q:
          return EC_BLOCKS_TABLE[(version - 1) * 4 + 2];
        case ECLevel.H:
          return EC_BLOCKS_TABLE[(version - 1) * 4 + 3];
        default:
          return void 0;
      }
    };
    exports.getTotalCodewordsCount = function getTotalCodewordsCount(version, errorCorrectionLevel) {
      switch (errorCorrectionLevel) {
        case ECLevel.L:
          return EC_CODEWORDS_TABLE[(version - 1) * 4 + 0];
        case ECLevel.M:
          return EC_CODEWORDS_TABLE[(version - 1) * 4 + 1];
        case ECLevel.Q:
          return EC_CODEWORDS_TABLE[(version - 1) * 4 + 2];
        case ECLevel.H:
          return EC_CODEWORDS_TABLE[(version - 1) * 4 + 3];
        default:
          return void 0;
      }
    };
  }
});

// node_modules/qrcode/lib/core/galois-field.js
var require_galois_field = __commonJS({
  "node_modules/qrcode/lib/core/galois-field.js"(exports) {
    "use strict";
    var EXP_TABLE = new Uint8Array(512);
    var LOG_TABLE = new Uint8Array(256);
    (function initTables() {
      let x = 1;
      for (let i = 0; i < 255; i++) {
        EXP_TABLE[i] = x;
        LOG_TABLE[x] = i;
        x <<= 1;
        if (x & 256) {
          x ^= 285;
        }
      }
      for (let i = 255; i < 512; i++) {
        EXP_TABLE[i] = EXP_TABLE[i - 255];
      }
    })();
    exports.log = function log(n) {
      if (n < 1) throw new Error("log(" + n + ")");
      return LOG_TABLE[n];
    };
    exports.exp = function exp(n) {
      return EXP_TABLE[n];
    };
    exports.mul = function mul(x, y) {
      if (x === 0 || y === 0) return 0;
      return EXP_TABLE[LOG_TABLE[x] + LOG_TABLE[y]];
    };
  }
});

// node_modules/qrcode/lib/core/polynomial.js
var require_polynomial = __commonJS({
  "node_modules/qrcode/lib/core/polynomial.js"(exports) {
    "use strict";
    var GF = require_galois_field();
    exports.mul = function mul(p1, p2) {
      const coeff = new Uint8Array(p1.length + p2.length - 1);
      for (let i = 0; i < p1.length; i++) {
        for (let j = 0; j < p2.length; j++) {
          coeff[i + j] ^= GF.mul(p1[i], p2[j]);
        }
      }
      return coeff;
    };
    exports.mod = function mod(divident, divisor) {
      let result = new Uint8Array(divident);
      while (result.length - divisor.length >= 0) {
        const coeff = result[0];
        for (let i = 0; i < divisor.length; i++) {
          result[i] ^= GF.mul(divisor[i], coeff);
        }
        let offset = 0;
        while (offset < result.length && result[offset] === 0) offset++;
        result = result.slice(offset);
      }
      return result;
    };
    exports.generateECPolynomial = function generateECPolynomial(degree) {
      let poly = new Uint8Array([1]);
      for (let i = 0; i < degree; i++) {
        poly = exports.mul(poly, new Uint8Array([1, GF.exp(i)]));
      }
      return poly;
    };
  }
});

// node_modules/qrcode/lib/core/reed-solomon-encoder.js
var require_reed_solomon_encoder = __commonJS({
  "node_modules/qrcode/lib/core/reed-solomon-encoder.js"(exports, module) {
    "use strict";
    var Polynomial = require_polynomial();
    function ReedSolomonEncoder(degree) {
      this.genPoly = void 0;
      this.degree = degree;
      if (this.degree) this.initialize(this.degree);
    }
    ReedSolomonEncoder.prototype.initialize = function initialize(degree) {
      this.degree = degree;
      this.genPoly = Polynomial.generateECPolynomial(this.degree);
    };
    ReedSolomonEncoder.prototype.encode = function encode2(data) {
      if (!this.genPoly) {
        throw new Error("Encoder not initialized");
      }
      const paddedData = new Uint8Array(data.length + this.degree);
      paddedData.set(data);
      const remainder = Polynomial.mod(paddedData, this.genPoly);
      const start = this.degree - remainder.length;
      if (start > 0) {
        const buff = new Uint8Array(this.degree);
        buff.set(remainder, start);
        return buff;
      }
      return remainder;
    };
    module.exports = ReedSolomonEncoder;
  }
});

// node_modules/qrcode/lib/core/version-check.js
var require_version_check = __commonJS({
  "node_modules/qrcode/lib/core/version-check.js"(exports) {
    "use strict";
    exports.isValid = function isValid(version) {
      return !isNaN(version) && version >= 1 && version <= 40;
    };
  }
});

// node_modules/qrcode/lib/core/regex.js
var require_regex = __commonJS({
  "node_modules/qrcode/lib/core/regex.js"(exports) {
    "use strict";
    var numeric = "[0-9]+";
    var alphanumeric = "[A-Z $%*+\\-./:]+";
    var kanji = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
    kanji = kanji.replace(/u/g, "\\u");
    var byte = "(?:(?![A-Z0-9 $%*+\\-./:]|" + kanji + ")(?:.|[\r\n]))+";
    exports.KANJI = new RegExp(kanji, "g");
    exports.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
    exports.BYTE = new RegExp(byte, "g");
    exports.NUMERIC = new RegExp(numeric, "g");
    exports.ALPHANUMERIC = new RegExp(alphanumeric, "g");
    var TEST_KANJI = new RegExp("^" + kanji + "$");
    var TEST_NUMERIC = new RegExp("^" + numeric + "$");
    var TEST_ALPHANUMERIC = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
    exports.testKanji = function testKanji(str) {
      return TEST_KANJI.test(str);
    };
    exports.testNumeric = function testNumeric(str) {
      return TEST_NUMERIC.test(str);
    };
    exports.testAlphanumeric = function testAlphanumeric(str) {
      return TEST_ALPHANUMERIC.test(str);
    };
  }
});

// node_modules/qrcode/lib/core/mode.js
var require_mode = __commonJS({
  "node_modules/qrcode/lib/core/mode.js"(exports) {
    "use strict";
    var VersionCheck = require_version_check();
    var Regex = require_regex();
    exports.NUMERIC = {
      id: "Numeric",
      bit: 1 << 0,
      ccBits: [10, 12, 14]
    };
    exports.ALPHANUMERIC = {
      id: "Alphanumeric",
      bit: 1 << 1,
      ccBits: [9, 11, 13]
    };
    exports.BYTE = {
      id: "Byte",
      bit: 1 << 2,
      ccBits: [8, 16, 16]
    };
    exports.KANJI = {
      id: "Kanji",
      bit: 1 << 3,
      ccBits: [8, 10, 12]
    };
    exports.MIXED = {
      bit: -1
    };
    exports.getCharCountIndicator = function getCharCountIndicator(mode, version) {
      if (!mode.ccBits) throw new Error("Invalid mode: " + mode);
      if (!VersionCheck.isValid(version)) {
        throw new Error("Invalid version: " + version);
      }
      if (version >= 1 && version < 10) return mode.ccBits[0];
      else if (version < 27) return mode.ccBits[1];
      return mode.ccBits[2];
    };
    exports.getBestModeForData = function getBestModeForData(dataStr) {
      if (Regex.testNumeric(dataStr)) return exports.NUMERIC;
      else if (Regex.testAlphanumeric(dataStr)) return exports.ALPHANUMERIC;
      else if (Regex.testKanji(dataStr)) return exports.KANJI;
      else return exports.BYTE;
    };
    exports.toString = function toString3(mode) {
      if (mode && mode.id) return mode.id;
      throw new Error("Invalid mode");
    };
    exports.isValid = function isValid(mode) {
      return mode && mode.bit && mode.ccBits;
    };
    function fromString(string) {
      if (typeof string !== "string") {
        throw new Error("Param is not a string");
      }
      const lcStr = string.toLowerCase();
      switch (lcStr) {
        case "numeric":
          return exports.NUMERIC;
        case "alphanumeric":
          return exports.ALPHANUMERIC;
        case "kanji":
          return exports.KANJI;
        case "byte":
          return exports.BYTE;
        default:
          throw new Error("Unknown mode: " + string);
      }
    }
    exports.from = function from(value, defaultValue) {
      if (exports.isValid(value)) {
        return value;
      }
      try {
        return fromString(value);
      } catch (e2) {
        return defaultValue;
      }
    };
  }
});

// node_modules/qrcode/lib/core/version.js
var require_version = __commonJS({
  "node_modules/qrcode/lib/core/version.js"(exports) {
    "use strict";
    var Utils = require_utils();
    var ECCode = require_error_correction_code();
    var ECLevel = require_error_correction_level();
    var Mode = require_mode();
    var VersionCheck = require_version_check();
    var G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;
    var G18_BCH = Utils.getBCHDigit(G18);
    function getBestVersionForDataLength(mode, length, errorCorrectionLevel) {
      for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
        if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode)) {
          return currentVersion;
        }
      }
      return void 0;
    }
    function getReservedBitsCount(mode, version) {
      return Mode.getCharCountIndicator(mode, version) + 4;
    }
    function getTotalBitsFromDataArray(segments, version) {
      let totalBits = 0;
      segments.forEach(function(data) {
        const reservedBits = getReservedBitsCount(data.mode, version);
        totalBits += reservedBits + data.getBitsLength();
      });
      return totalBits;
    }
    function getBestVersionForMixedData(segments, errorCorrectionLevel) {
      for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
        const length = getTotalBitsFromDataArray(segments, currentVersion);
        if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, Mode.MIXED)) {
          return currentVersion;
        }
      }
      return void 0;
    }
    exports.from = function from(value, defaultValue) {
      if (VersionCheck.isValid(value)) {
        return parseInt(value, 10);
      }
      return defaultValue;
    };
    exports.getCapacity = function getCapacity(version, errorCorrectionLevel, mode) {
      if (!VersionCheck.isValid(version)) {
        throw new Error("Invalid QR Code version");
      }
      if (typeof mode === "undefined") mode = Mode.BYTE;
      const totalCodewords = Utils.getSymbolTotalCodewords(version);
      const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);
      const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
      if (mode === Mode.MIXED) return dataTotalCodewordsBits;
      const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode, version);
      switch (mode) {
        case Mode.NUMERIC:
          return Math.floor(usableBits / 10 * 3);
        case Mode.ALPHANUMERIC:
          return Math.floor(usableBits / 11 * 2);
        case Mode.KANJI:
          return Math.floor(usableBits / 13);
        case Mode.BYTE:
        default:
          return Math.floor(usableBits / 8);
      }
    };
    exports.getBestVersionForData = function getBestVersionForData(data, errorCorrectionLevel) {
      let seg;
      const ecl = ECLevel.from(errorCorrectionLevel, ECLevel.M);
      if (Array.isArray(data)) {
        if (data.length > 1) {
          return getBestVersionForMixedData(data, ecl);
        }
        if (data.length === 0) {
          return 1;
        }
        seg = data[0];
      } else {
        seg = data;
      }
      return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);
    };
    exports.getEncodedBits = function getEncodedBits(version) {
      if (!VersionCheck.isValid(version) || version < 7) {
        throw new Error("Invalid QR Code version");
      }
      let d = version << 12;
      while (Utils.getBCHDigit(d) - G18_BCH >= 0) {
        d ^= G18 << Utils.getBCHDigit(d) - G18_BCH;
      }
      return version << 12 | d;
    };
  }
});

// node_modules/qrcode/lib/core/format-info.js
var require_format_info = __commonJS({
  "node_modules/qrcode/lib/core/format-info.js"(exports) {
    "use strict";
    var Utils = require_utils();
    var G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;
    var G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;
    var G15_BCH = Utils.getBCHDigit(G15);
    exports.getEncodedBits = function getEncodedBits(errorCorrectionLevel, mask) {
      const data = errorCorrectionLevel.bit << 3 | mask;
      let d = data << 10;
      while (Utils.getBCHDigit(d) - G15_BCH >= 0) {
        d ^= G15 << Utils.getBCHDigit(d) - G15_BCH;
      }
      return (data << 10 | d) ^ G15_MASK;
    };
  }
});

// node_modules/qrcode/lib/core/numeric-data.js
var require_numeric_data = __commonJS({
  "node_modules/qrcode/lib/core/numeric-data.js"(exports, module) {
    "use strict";
    var Mode = require_mode();
    function NumericData(data) {
      this.mode = Mode.NUMERIC;
      this.data = data.toString();
    }
    NumericData.getBitsLength = function getBitsLength(length) {
      return 10 * Math.floor(length / 3) + (length % 3 ? length % 3 * 3 + 1 : 0);
    };
    NumericData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    NumericData.prototype.getBitsLength = function getBitsLength() {
      return NumericData.getBitsLength(this.data.length);
    };
    NumericData.prototype.write = function write(bitBuffer) {
      let i, group, value;
      for (i = 0; i + 3 <= this.data.length; i += 3) {
        group = this.data.substr(i, 3);
        value = parseInt(group, 10);
        bitBuffer.put(value, 10);
      }
      const remainingNum = this.data.length - i;
      if (remainingNum > 0) {
        group = this.data.substr(i);
        value = parseInt(group, 10);
        bitBuffer.put(value, remainingNum * 3 + 1);
      }
    };
    module.exports = NumericData;
  }
});

// node_modules/qrcode/lib/core/alphanumeric-data.js
var require_alphanumeric_data = __commonJS({
  "node_modules/qrcode/lib/core/alphanumeric-data.js"(exports, module) {
    "use strict";
    var Mode = require_mode();
    var ALPHA_NUM_CHARS = [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z",
      " ",
      "$",
      "%",
      "*",
      "+",
      "-",
      ".",
      "/",
      ":"
    ];
    function AlphanumericData(data) {
      this.mode = Mode.ALPHANUMERIC;
      this.data = data;
    }
    AlphanumericData.getBitsLength = function getBitsLength(length) {
      return 11 * Math.floor(length / 2) + 6 * (length % 2);
    };
    AlphanumericData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    AlphanumericData.prototype.getBitsLength = function getBitsLength() {
      return AlphanumericData.getBitsLength(this.data.length);
    };
    AlphanumericData.prototype.write = function write(bitBuffer) {
      let i;
      for (i = 0; i + 2 <= this.data.length; i += 2) {
        let value = ALPHA_NUM_CHARS.indexOf(this.data[i]) * 45;
        value += ALPHA_NUM_CHARS.indexOf(this.data[i + 1]);
        bitBuffer.put(value, 11);
      }
      if (this.data.length % 2) {
        bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i]), 6);
      }
    };
    module.exports = AlphanumericData;
  }
});

// node_modules/qrcode/lib/core/byte-data.js
var require_byte_data = __commonJS({
  "node_modules/qrcode/lib/core/byte-data.js"(exports, module) {
    "use strict";
    var Mode = require_mode();
    function ByteData(data) {
      this.mode = Mode.BYTE;
      if (typeof data === "string") {
        this.data = new TextEncoder().encode(data);
      } else {
        this.data = new Uint8Array(data);
      }
    }
    ByteData.getBitsLength = function getBitsLength(length) {
      return length * 8;
    };
    ByteData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    ByteData.prototype.getBitsLength = function getBitsLength() {
      return ByteData.getBitsLength(this.data.length);
    };
    ByteData.prototype.write = function(bitBuffer) {
      for (let i = 0, l = this.data.length; i < l; i++) {
        bitBuffer.put(this.data[i], 8);
      }
    };
    module.exports = ByteData;
  }
});

// node_modules/qrcode/lib/core/kanji-data.js
var require_kanji_data = __commonJS({
  "node_modules/qrcode/lib/core/kanji-data.js"(exports, module) {
    "use strict";
    var Mode = require_mode();
    var Utils = require_utils();
    function KanjiData(data) {
      this.mode = Mode.KANJI;
      this.data = data;
    }
    KanjiData.getBitsLength = function getBitsLength(length) {
      return length * 13;
    };
    KanjiData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    KanjiData.prototype.getBitsLength = function getBitsLength() {
      return KanjiData.getBitsLength(this.data.length);
    };
    KanjiData.prototype.write = function(bitBuffer) {
      let i;
      for (i = 0; i < this.data.length; i++) {
        let value = Utils.toSJIS(this.data[i]);
        if (value >= 33088 && value <= 40956) {
          value -= 33088;
        } else if (value >= 57408 && value <= 60351) {
          value -= 49472;
        } else {
          throw new Error(
            "Invalid SJIS character: " + this.data[i] + "\nMake sure your charset is UTF-8"
          );
        }
        value = (value >>> 8 & 255) * 192 + (value & 255);
        bitBuffer.put(value, 13);
      }
    };
    module.exports = KanjiData;
  }
});

// node_modules/dijkstrajs/dijkstra.js
var require_dijkstra = __commonJS({
  "node_modules/dijkstrajs/dijkstra.js"(exports, module) {
    "use strict";
    var dijkstra = {
      single_source_shortest_paths: function(graph, s, d) {
        var predecessors = {};
        var costs = {};
        costs[s] = 0;
        var open = dijkstra.PriorityQueue.make();
        open.push(s, 0);
        var closest, u2, v, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;
        while (!open.empty()) {
          closest = open.pop();
          u2 = closest.value;
          cost_of_s_to_u = closest.cost;
          adjacent_nodes = graph[u2] || {};
          for (v in adjacent_nodes) {
            if (adjacent_nodes.hasOwnProperty(v)) {
              cost_of_e = adjacent_nodes[v];
              cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;
              cost_of_s_to_v = costs[v];
              first_visit = typeof costs[v] === "undefined";
              if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
                costs[v] = cost_of_s_to_u_plus_cost_of_e;
                open.push(v, cost_of_s_to_u_plus_cost_of_e);
                predecessors[v] = u2;
              }
            }
          }
        }
        if (typeof d !== "undefined" && typeof costs[d] === "undefined") {
          var msg = ["Could not find a path from ", s, " to ", d, "."].join("");
          throw new Error(msg);
        }
        return predecessors;
      },
      extract_shortest_path_from_predecessor_list: function(predecessors, d) {
        var nodes = [];
        var u2 = d;
        var predecessor;
        while (u2) {
          nodes.push(u2);
          predecessor = predecessors[u2];
          u2 = predecessors[u2];
        }
        nodes.reverse();
        return nodes;
      },
      find_path: function(graph, s, d) {
        var predecessors = dijkstra.single_source_shortest_paths(graph, s, d);
        return dijkstra.extract_shortest_path_from_predecessor_list(
          predecessors,
          d
        );
      },
      /**
       * A very naive priority queue implementation.
       */
      PriorityQueue: {
        make: function(opts) {
          var T2 = dijkstra.PriorityQueue, t = {}, key;
          opts = opts || {};
          for (key in T2) {
            if (T2.hasOwnProperty(key)) {
              t[key] = T2[key];
            }
          }
          t.queue = [];
          t.sorter = opts.sorter || T2.default_sorter;
          return t;
        },
        default_sorter: function(a2, b) {
          return a2.cost - b.cost;
        },
        /**
         * Add a new item to the queue and ensure the highest priority element
         * is at the front of the queue.
         */
        push: function(value, cost) {
          var item = { value, cost };
          this.queue.push(item);
          this.queue.sort(this.sorter);
        },
        /**
         * Return the highest priority element in the queue.
         */
        pop: function() {
          return this.queue.shift();
        },
        empty: function() {
          return this.queue.length === 0;
        }
      }
    };
    if (typeof module !== "undefined") {
      module.exports = dijkstra;
    }
  }
});

// node_modules/qrcode/lib/core/segments.js
var require_segments = __commonJS({
  "node_modules/qrcode/lib/core/segments.js"(exports) {
    "use strict";
    var Mode = require_mode();
    var NumericData = require_numeric_data();
    var AlphanumericData = require_alphanumeric_data();
    var ByteData = require_byte_data();
    var KanjiData = require_kanji_data();
    var Regex = require_regex();
    var Utils = require_utils();
    var dijkstra = require_dijkstra();
    function getStringByteLength(str) {
      return unescape(encodeURIComponent(str)).length;
    }
    function getSegments(regex, mode, str) {
      const segments = [];
      let result;
      while ((result = regex.exec(str)) !== null) {
        segments.push({
          data: result[0],
          index: result.index,
          mode,
          length: result[0].length
        });
      }
      return segments;
    }
    function getSegmentsFromString(dataStr) {
      const numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr);
      const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr);
      let byteSegs;
      let kanjiSegs;
      if (Utils.isKanjiModeEnabled()) {
        byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr);
        kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr);
      } else {
        byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr);
        kanjiSegs = [];
      }
      const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);
      return segs.sort(function(s1, s2) {
        return s1.index - s2.index;
      }).map(function(obj) {
        return {
          data: obj.data,
          mode: obj.mode,
          length: obj.length
        };
      });
    }
    function getSegmentBitsLength(length, mode) {
      switch (mode) {
        case Mode.NUMERIC:
          return NumericData.getBitsLength(length);
        case Mode.ALPHANUMERIC:
          return AlphanumericData.getBitsLength(length);
        case Mode.KANJI:
          return KanjiData.getBitsLength(length);
        case Mode.BYTE:
          return ByteData.getBitsLength(length);
      }
    }
    function mergeSegments(segs) {
      return segs.reduce(function(acc, curr) {
        const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
        if (prevSeg && prevSeg.mode === curr.mode) {
          acc[acc.length - 1].data += curr.data;
          return acc;
        }
        acc.push(curr);
        return acc;
      }, []);
    }
    function buildNodes(segs) {
      const nodes = [];
      for (let i = 0; i < segs.length; i++) {
        const seg = segs[i];
        switch (seg.mode) {
          case Mode.NUMERIC:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.ALPHANUMERIC, length: seg.length },
              { data: seg.data, mode: Mode.BYTE, length: seg.length }
            ]);
            break;
          case Mode.ALPHANUMERIC:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.BYTE, length: seg.length }
            ]);
            break;
          case Mode.KANJI:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
            ]);
            break;
          case Mode.BYTE:
            nodes.push([
              { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
            ]);
        }
      }
      return nodes;
    }
    function buildGraph(nodes, version) {
      const table = {};
      const graph = { start: {} };
      let prevNodeIds = ["start"];
      for (let i = 0; i < nodes.length; i++) {
        const nodeGroup = nodes[i];
        const currentNodeIds = [];
        for (let j = 0; j < nodeGroup.length; j++) {
          const node = nodeGroup[j];
          const key = "" + i + j;
          currentNodeIds.push(key);
          table[key] = { node, lastCount: 0 };
          graph[key] = {};
          for (let n = 0; n < prevNodeIds.length; n++) {
            const prevNodeId = prevNodeIds[n];
            if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {
              graph[prevNodeId][key] = getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);
              table[prevNodeId].lastCount += node.length;
            } else {
              if (table[prevNodeId]) table[prevNodeId].lastCount = node.length;
              graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) + 4 + Mode.getCharCountIndicator(node.mode, version);
            }
          }
        }
        prevNodeIds = currentNodeIds;
      }
      for (let n = 0; n < prevNodeIds.length; n++) {
        graph[prevNodeIds[n]].end = 0;
      }
      return { map: graph, table };
    }
    function buildSingleSegment(data, modesHint) {
      let mode;
      const bestMode = Mode.getBestModeForData(data);
      mode = Mode.from(modesHint, bestMode);
      if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {
        throw new Error('"' + data + '" cannot be encoded with mode ' + Mode.toString(mode) + ".\n Suggested mode is: " + Mode.toString(bestMode));
      }
      if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {
        mode = Mode.BYTE;
      }
      switch (mode) {
        case Mode.NUMERIC:
          return new NumericData(data);
        case Mode.ALPHANUMERIC:
          return new AlphanumericData(data);
        case Mode.KANJI:
          return new KanjiData(data);
        case Mode.BYTE:
          return new ByteData(data);
      }
    }
    exports.fromArray = function fromArray(array) {
      return array.reduce(function(acc, seg) {
        if (typeof seg === "string") {
          acc.push(buildSingleSegment(seg, null));
        } else if (seg.data) {
          acc.push(buildSingleSegment(seg.data, seg.mode));
        }
        return acc;
      }, []);
    };
    exports.fromString = function fromString(data, version) {
      const segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled());
      const nodes = buildNodes(segs);
      const graph = buildGraph(nodes, version);
      const path = dijkstra.find_path(graph.map, "start", "end");
      const optimizedSegs = [];
      for (let i = 1; i < path.length - 1; i++) {
        optimizedSegs.push(graph.table[path[i]].node);
      }
      return exports.fromArray(mergeSegments(optimizedSegs));
    };
    exports.rawSplit = function rawSplit(data) {
      return exports.fromArray(
        getSegmentsFromString(data, Utils.isKanjiModeEnabled())
      );
    };
  }
});

// node_modules/qrcode/lib/core/qrcode.js
var require_qrcode = __commonJS({
  "node_modules/qrcode/lib/core/qrcode.js"(exports) {
    "use strict";
    var Utils = require_utils();
    var ECLevel = require_error_correction_level();
    var BitBuffer = require_bit_buffer();
    var BitMatrix = require_bit_matrix();
    var AlignmentPattern = require_alignment_pattern();
    var FinderPattern = require_finder_pattern();
    var MaskPattern = require_mask_pattern();
    var ECCode = require_error_correction_code();
    var ReedSolomonEncoder = require_reed_solomon_encoder();
    var Version = require_version();
    var FormatInfo = require_format_info();
    var Mode = require_mode();
    var Segments = require_segments();
    function setupFinderPattern(matrix2, version) {
      const size = matrix2.size;
      const pos = FinderPattern.getPositions(version);
      for (let i = 0; i < pos.length; i++) {
        const row = pos[i][0];
        const col = pos[i][1];
        for (let r = -1; r <= 7; r++) {
          if (row + r <= -1 || size <= row + r) continue;
          for (let c = -1; c <= 7; c++) {
            if (col + c <= -1 || size <= col + c) continue;
            if (r >= 0 && r <= 6 && (c === 0 || c === 6) || c >= 0 && c <= 6 && (r === 0 || r === 6) || r >= 2 && r <= 4 && c >= 2 && c <= 4) {
              matrix2.set(row + r, col + c, true, true);
            } else {
              matrix2.set(row + r, col + c, false, true);
            }
          }
        }
      }
    }
    function setupTimingPattern(matrix2) {
      const size = matrix2.size;
      for (let r = 8; r < size - 8; r++) {
        const value = r % 2 === 0;
        matrix2.set(r, 6, value, true);
        matrix2.set(6, r, value, true);
      }
    }
    function setupAlignmentPattern(matrix2, version) {
      const pos = AlignmentPattern.getPositions(version);
      for (let i = 0; i < pos.length; i++) {
        const row = pos[i][0];
        const col = pos[i][1];
        for (let r = -2; r <= 2; r++) {
          for (let c = -2; c <= 2; c++) {
            if (r === -2 || r === 2 || c === -2 || c === 2 || r === 0 && c === 0) {
              matrix2.set(row + r, col + c, true, true);
            } else {
              matrix2.set(row + r, col + c, false, true);
            }
          }
        }
      }
    }
    function setupVersionInfo(matrix2, version) {
      const size = matrix2.size;
      const bits = Version.getEncodedBits(version);
      let row, col, mod;
      for (let i = 0; i < 18; i++) {
        row = Math.floor(i / 3);
        col = i % 3 + size - 8 - 3;
        mod = (bits >> i & 1) === 1;
        matrix2.set(row, col, mod, true);
        matrix2.set(col, row, mod, true);
      }
    }
    function setupFormatInfo(matrix2, errorCorrectionLevel, maskPattern) {
      const size = matrix2.size;
      const bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern);
      let i, mod;
      for (i = 0; i < 15; i++) {
        mod = (bits >> i & 1) === 1;
        if (i < 6) {
          matrix2.set(i, 8, mod, true);
        } else if (i < 8) {
          matrix2.set(i + 1, 8, mod, true);
        } else {
          matrix2.set(size - 15 + i, 8, mod, true);
        }
        if (i < 8) {
          matrix2.set(8, size - i - 1, mod, true);
        } else if (i < 9) {
          matrix2.set(8, 15 - i - 1 + 1, mod, true);
        } else {
          matrix2.set(8, 15 - i - 1, mod, true);
        }
      }
      matrix2.set(size - 8, 8, 1, true);
    }
    function setupData(matrix2, data) {
      const size = matrix2.size;
      let inc = -1;
      let row = size - 1;
      let bitIndex = 7;
      let byteIndex = 0;
      for (let col = size - 1; col > 0; col -= 2) {
        if (col === 6) col--;
        while (true) {
          for (let c = 0; c < 2; c++) {
            if (!matrix2.isReserved(row, col - c)) {
              let dark = false;
              if (byteIndex < data.length) {
                dark = (data[byteIndex] >>> bitIndex & 1) === 1;
              }
              matrix2.set(row, col - c, dark);
              bitIndex--;
              if (bitIndex === -1) {
                byteIndex++;
                bitIndex = 7;
              }
            }
          }
          row += inc;
          if (row < 0 || size <= row) {
            row -= inc;
            inc = -inc;
            break;
          }
        }
      }
    }
    function createData(version, errorCorrectionLevel, segments) {
      const buffer = new BitBuffer();
      segments.forEach(function(data) {
        buffer.put(data.mode.bit, 4);
        buffer.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version));
        data.write(buffer);
      });
      const totalCodewords = Utils.getSymbolTotalCodewords(version);
      const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);
      const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
      if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
        buffer.put(0, 4);
      }
      while (buffer.getLengthInBits() % 8 !== 0) {
        buffer.putBit(0);
      }
      const remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8;
      for (let i = 0; i < remainingByte; i++) {
        buffer.put(i % 2 ? 17 : 236, 8);
      }
      return createCodewords(buffer, version, errorCorrectionLevel);
    }
    function createCodewords(bitBuffer, version, errorCorrectionLevel) {
      const totalCodewords = Utils.getSymbolTotalCodewords(version);
      const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);
      const dataTotalCodewords = totalCodewords - ecTotalCodewords;
      const ecTotalBlocks = ECCode.getBlocksCount(version, errorCorrectionLevel);
      const blocksInGroup2 = totalCodewords % ecTotalBlocks;
      const blocksInGroup1 = ecTotalBlocks - blocksInGroup2;
      const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);
      const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
      const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;
      const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;
      const rs = new ReedSolomonEncoder(ecCount);
      let offset = 0;
      const dcData = new Array(ecTotalBlocks);
      const ecData = new Array(ecTotalBlocks);
      let maxDataSize = 0;
      const buffer = new Uint8Array(bitBuffer.buffer);
      for (let b = 0; b < ecTotalBlocks; b++) {
        const dataSize = b < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;
        dcData[b] = buffer.slice(offset, offset + dataSize);
        ecData[b] = rs.encode(dcData[b]);
        offset += dataSize;
        maxDataSize = Math.max(maxDataSize, dataSize);
      }
      const data = new Uint8Array(totalCodewords);
      let index = 0;
      let i, r;
      for (i = 0; i < maxDataSize; i++) {
        for (r = 0; r < ecTotalBlocks; r++) {
          if (i < dcData[r].length) {
            data[index++] = dcData[r][i];
          }
        }
      }
      for (i = 0; i < ecCount; i++) {
        for (r = 0; r < ecTotalBlocks; r++) {
          data[index++] = ecData[r][i];
        }
      }
      return data;
    }
    function createSymbol(data, version, errorCorrectionLevel, maskPattern) {
      let segments;
      if (Array.isArray(data)) {
        segments = Segments.fromArray(data);
      } else if (typeof data === "string") {
        let estimatedVersion = version;
        if (!estimatedVersion) {
          const rawSegments = Segments.rawSplit(data);
          estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel);
        }
        segments = Segments.fromString(data, estimatedVersion || 40);
      } else {
        throw new Error("Invalid data");
      }
      const bestVersion = Version.getBestVersionForData(segments, errorCorrectionLevel);
      if (!bestVersion) {
        throw new Error("The amount of data is too big to be stored in a QR Code");
      }
      if (!version) {
        version = bestVersion;
      } else if (version < bestVersion) {
        throw new Error(
          "\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " + bestVersion + ".\n"
        );
      }
      const dataBits = createData(version, errorCorrectionLevel, segments);
      const moduleCount = Utils.getSymbolSize(version);
      const modules = new BitMatrix(moduleCount);
      setupFinderPattern(modules, version);
      setupTimingPattern(modules);
      setupAlignmentPattern(modules, version);
      setupFormatInfo(modules, errorCorrectionLevel, 0);
      if (version >= 7) {
        setupVersionInfo(modules, version);
      }
      setupData(modules, dataBits);
      if (isNaN(maskPattern)) {
        maskPattern = MaskPattern.getBestMask(
          modules,
          setupFormatInfo.bind(null, modules, errorCorrectionLevel)
        );
      }
      MaskPattern.applyMask(maskPattern, modules);
      setupFormatInfo(modules, errorCorrectionLevel, maskPattern);
      return {
        modules,
        version,
        errorCorrectionLevel,
        maskPattern,
        segments
      };
    }
    exports.create = function create(data, options) {
      if (typeof data === "undefined" || data === "") {
        throw new Error("No input text");
      }
      let errorCorrectionLevel = ECLevel.M;
      let version;
      let mask;
      if (typeof options !== "undefined") {
        errorCorrectionLevel = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);
        version = Version.from(options.version);
        mask = MaskPattern.from(options.maskPattern);
        if (options.toSJISFunc) {
          Utils.setToSJISFunction(options.toSJISFunc);
        }
      }
      return createSymbol(data, version, errorCorrectionLevel, mask);
    };
  }
});

// node_modules/pngjs/lib/chunkstream.js
var require_chunkstream = __commonJS({
  "node_modules/pngjs/lib/chunkstream.js"(exports, module) {
    "use strict";
    var util = __require("util");
    var Stream = __require("stream");
    var ChunkStream = module.exports = function() {
      Stream.call(this);
      this._buffers = [];
      this._buffered = 0;
      this._reads = [];
      this._paused = false;
      this._encoding = "utf8";
      this.writable = true;
    };
    util.inherits(ChunkStream, Stream);
    ChunkStream.prototype.read = function(length, callback) {
      this._reads.push({
        length: Math.abs(length),
        // if length < 0 then at most this length
        allowLess: length < 0,
        func: callback
      });
      process.nextTick(
        function() {
          this._process();
          if (this._paused && this._reads && this._reads.length > 0) {
            this._paused = false;
            this.emit("drain");
          }
        }.bind(this)
      );
    };
    ChunkStream.prototype.write = function(data, encoding) {
      if (!this.writable) {
        this.emit("error", new Error("Stream not writable"));
        return false;
      }
      let dataBuffer;
      if (Buffer.isBuffer(data)) {
        dataBuffer = data;
      } else {
        dataBuffer = Buffer.from(data, encoding || this._encoding);
      }
      this._buffers.push(dataBuffer);
      this._buffered += dataBuffer.length;
      this._process();
      if (this._reads && this._reads.length === 0) {
        this._paused = true;
      }
      return this.writable && !this._paused;
    };
    ChunkStream.prototype.end = function(data, encoding) {
      if (data) {
        this.write(data, encoding);
      }
      this.writable = false;
      if (!this._buffers) {
        return;
      }
      if (this._buffers.length === 0) {
        this._end();
      } else {
        this._buffers.push(null);
        this._process();
      }
    };
    ChunkStream.prototype.destroySoon = ChunkStream.prototype.end;
    ChunkStream.prototype._end = function() {
      if (this._reads.length > 0) {
        this.emit("error", new Error("Unexpected end of input"));
      }
      this.destroy();
    };
    ChunkStream.prototype.destroy = function() {
      if (!this._buffers) {
        return;
      }
      this.writable = false;
      this._reads = null;
      this._buffers = null;
      this.emit("close");
    };
    ChunkStream.prototype._processReadAllowingLess = function(read) {
      this._reads.shift();
      let smallerBuf = this._buffers[0];
      if (smallerBuf.length > read.length) {
        this._buffered -= read.length;
        this._buffers[0] = smallerBuf.slice(read.length);
        read.func.call(this, smallerBuf.slice(0, read.length));
      } else {
        this._buffered -= smallerBuf.length;
        this._buffers.shift();
        read.func.call(this, smallerBuf);
      }
    };
    ChunkStream.prototype._processRead = function(read) {
      this._reads.shift();
      let pos = 0;
      let count = 0;
      let data = Buffer.alloc(read.length);
      while (pos < read.length) {
        let buf = this._buffers[count++];
        let len = Math.min(buf.length, read.length - pos);
        buf.copy(data, pos, 0, len);
        pos += len;
        if (len !== buf.length) {
          this._buffers[--count] = buf.slice(len);
        }
      }
      if (count > 0) {
        this._buffers.splice(0, count);
      }
      this._buffered -= read.length;
      read.func.call(this, data);
    };
    ChunkStream.prototype._process = function() {
      try {
        while (this._buffered > 0 && this._reads && this._reads.length > 0) {
          let read = this._reads[0];
          if (read.allowLess) {
            this._processReadAllowingLess(read);
          } else if (this._buffered >= read.length) {
            this._processRead(read);
          } else {
            break;
          }
        }
        if (this._buffers && !this.writable) {
          this._end();
        }
      } catch (ex) {
        this.emit("error", ex);
      }
    };
  }
});

// node_modules/pngjs/lib/interlace.js
var require_interlace = __commonJS({
  "node_modules/pngjs/lib/interlace.js"(exports) {
    "use strict";
    var imagePasses = [
      {
        // pass 1 - 1px
        x: [0],
        y: [0]
      },
      {
        // pass 2 - 1px
        x: [4],
        y: [0]
      },
      {
        // pass 3 - 2px
        x: [0, 4],
        y: [4]
      },
      {
        // pass 4 - 4px
        x: [2, 6],
        y: [0, 4]
      },
      {
        // pass 5 - 8px
        x: [0, 2, 4, 6],
        y: [2, 6]
      },
      {
        // pass 6 - 16px
        x: [1, 3, 5, 7],
        y: [0, 2, 4, 6]
      },
      {
        // pass 7 - 32px
        x: [0, 1, 2, 3, 4, 5, 6, 7],
        y: [1, 3, 5, 7]
      }
    ];
    exports.getImagePasses = function(width, height) {
      let images = [];
      let xLeftOver = width % 8;
      let yLeftOver = height % 8;
      let xRepeats = (width - xLeftOver) / 8;
      let yRepeats = (height - yLeftOver) / 8;
      for (let i = 0; i < imagePasses.length; i++) {
        let pass = imagePasses[i];
        let passWidth = xRepeats * pass.x.length;
        let passHeight = yRepeats * pass.y.length;
        for (let j = 0; j < pass.x.length; j++) {
          if (pass.x[j] < xLeftOver) {
            passWidth++;
          } else {
            break;
          }
        }
        for (let j = 0; j < pass.y.length; j++) {
          if (pass.y[j] < yLeftOver) {
            passHeight++;
          } else {
            break;
          }
        }
        if (passWidth > 0 && passHeight > 0) {
          images.push({ width: passWidth, height: passHeight, index: i });
        }
      }
      return images;
    };
    exports.getInterlaceIterator = function(width) {
      return function(x, y, pass) {
        let outerXLeftOver = x % imagePasses[pass].x.length;
        let outerX = (x - outerXLeftOver) / imagePasses[pass].x.length * 8 + imagePasses[pass].x[outerXLeftOver];
        let outerYLeftOver = y % imagePasses[pass].y.length;
        let outerY = (y - outerYLeftOver) / imagePasses[pass].y.length * 8 + imagePasses[pass].y[outerYLeftOver];
        return outerX * 4 + outerY * width * 4;
      };
    };
  }
});

// node_modules/pngjs/lib/paeth-predictor.js
var require_paeth_predictor = __commonJS({
  "node_modules/pngjs/lib/paeth-predictor.js"(exports, module) {
    "use strict";
    module.exports = function paethPredictor2(left, above, upLeft) {
      let paeth = left + above - upLeft;
      let pLeft = Math.abs(paeth - left);
      let pAbove = Math.abs(paeth - above);
      let pUpLeft = Math.abs(paeth - upLeft);
      if (pLeft <= pAbove && pLeft <= pUpLeft) {
        return left;
      }
      if (pAbove <= pUpLeft) {
        return above;
      }
      return upLeft;
    };
  }
});

// node_modules/pngjs/lib/filter-parse.js
var require_filter_parse = __commonJS({
  "node_modules/pngjs/lib/filter-parse.js"(exports, module) {
    "use strict";
    var interlaceUtils = require_interlace();
    var paethPredictor2 = require_paeth_predictor();
    function getByteWidth(width, bpp, depth) {
      let byteWidth = width * bpp;
      if (depth !== 8) {
        byteWidth = Math.ceil(byteWidth / (8 / depth));
      }
      return byteWidth;
    }
    var Filter = module.exports = function(bitmapInfo, dependencies) {
      let width = bitmapInfo.width;
      let height = bitmapInfo.height;
      let interlace = bitmapInfo.interlace;
      let bpp = bitmapInfo.bpp;
      let depth = bitmapInfo.depth;
      this.read = dependencies.read;
      this.write = dependencies.write;
      this.complete = dependencies.complete;
      this._imageIndex = 0;
      this._images = [];
      if (interlace) {
        let passes = interlaceUtils.getImagePasses(width, height);
        for (let i = 0; i < passes.length; i++) {
          this._images.push({
            byteWidth: getByteWidth(passes[i].width, bpp, depth),
            height: passes[i].height,
            lineIndex: 0
          });
        }
      } else {
        this._images.push({
          byteWidth: getByteWidth(width, bpp, depth),
          height,
          lineIndex: 0
        });
      }
      if (depth === 8) {
        this._xComparison = bpp;
      } else if (depth === 16) {
        this._xComparison = bpp * 2;
      } else {
        this._xComparison = 1;
      }
    };
    Filter.prototype.start = function() {
      this.read(
        this._images[this._imageIndex].byteWidth + 1,
        this._reverseFilterLine.bind(this)
      );
    };
    Filter.prototype._unFilterType1 = function(rawData, unfilteredLine, byteWidth) {
      let xComparison = this._xComparison;
      let xBiggerThan = xComparison - 1;
      for (let x = 0; x < byteWidth; x++) {
        let rawByte = rawData[1 + x];
        let f1Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
        unfilteredLine[x] = rawByte + f1Left;
      }
    };
    Filter.prototype._unFilterType2 = function(rawData, unfilteredLine, byteWidth) {
      let lastLine = this._lastLine;
      for (let x = 0; x < byteWidth; x++) {
        let rawByte = rawData[1 + x];
        let f2Up = lastLine ? lastLine[x] : 0;
        unfilteredLine[x] = rawByte + f2Up;
      }
    };
    Filter.prototype._unFilterType3 = function(rawData, unfilteredLine, byteWidth) {
      let xComparison = this._xComparison;
      let xBiggerThan = xComparison - 1;
      let lastLine = this._lastLine;
      for (let x = 0; x < byteWidth; x++) {
        let rawByte = rawData[1 + x];
        let f3Up = lastLine ? lastLine[x] : 0;
        let f3Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
        let f3Add = Math.floor((f3Left + f3Up) / 2);
        unfilteredLine[x] = rawByte + f3Add;
      }
    };
    Filter.prototype._unFilterType4 = function(rawData, unfilteredLine, byteWidth) {
      let xComparison = this._xComparison;
      let xBiggerThan = xComparison - 1;
      let lastLine = this._lastLine;
      for (let x = 0; x < byteWidth; x++) {
        let rawByte = rawData[1 + x];
        let f4Up = lastLine ? lastLine[x] : 0;
        let f4Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
        let f4UpLeft = x > xBiggerThan && lastLine ? lastLine[x - xComparison] : 0;
        let f4Add = paethPredictor2(f4Left, f4Up, f4UpLeft);
        unfilteredLine[x] = rawByte + f4Add;
      }
    };
    Filter.prototype._reverseFilterLine = function(rawData) {
      let filter = rawData[0];
      let unfilteredLine;
      let currentImage = this._images[this._imageIndex];
      let byteWidth = currentImage.byteWidth;
      if (filter === 0) {
        unfilteredLine = rawData.slice(1, byteWidth + 1);
      } else {
        unfilteredLine = Buffer.alloc(byteWidth);
        switch (filter) {
          case 1:
            this._unFilterType1(rawData, unfilteredLine, byteWidth);
            break;
          case 2:
            this._unFilterType2(rawData, unfilteredLine, byteWidth);
            break;
          case 3:
            this._unFilterType3(rawData, unfilteredLine, byteWidth);
            break;
          case 4:
            this._unFilterType4(rawData, unfilteredLine, byteWidth);
            break;
          default:
            throw new Error("Unrecognised filter type - " + filter);
        }
      }
      this.write(unfilteredLine);
      currentImage.lineIndex++;
      if (currentImage.lineIndex >= currentImage.height) {
        this._lastLine = null;
        this._imageIndex++;
        currentImage = this._images[this._imageIndex];
      } else {
        this._lastLine = unfilteredLine;
      }
      if (currentImage) {
        this.read(currentImage.byteWidth + 1, this._reverseFilterLine.bind(this));
      } else {
        this._lastLine = null;
        this.complete();
      }
    };
  }
});

// node_modules/pngjs/lib/filter-parse-async.js
var require_filter_parse_async = __commonJS({
  "node_modules/pngjs/lib/filter-parse-async.js"(exports, module) {
    "use strict";
    var util = __require("util");
    var ChunkStream = require_chunkstream();
    var Filter = require_filter_parse();
    var FilterAsync = module.exports = function(bitmapInfo) {
      ChunkStream.call(this);
      let buffers = [];
      let that = this;
      this._filter = new Filter(bitmapInfo, {
        read: this.read.bind(this),
        write: function(buffer) {
          buffers.push(buffer);
        },
        complete: function() {
          that.emit("complete", Buffer.concat(buffers));
        }
      });
      this._filter.start();
    };
    util.inherits(FilterAsync, ChunkStream);
  }
});

// node_modules/pngjs/lib/constants.js
var require_constants = __commonJS({
  "node_modules/pngjs/lib/constants.js"(exports, module) {
    "use strict";
    module.exports = {
      PNG_SIGNATURE: [137, 80, 78, 71, 13, 10, 26, 10],
      TYPE_IHDR: 1229472850,
      TYPE_IEND: 1229278788,
      TYPE_IDAT: 1229209940,
      TYPE_PLTE: 1347179589,
      TYPE_tRNS: 1951551059,
      // eslint-disable-line camelcase
      TYPE_gAMA: 1732332865,
      // eslint-disable-line camelcase
      // color-type bits
      COLORTYPE_GRAYSCALE: 0,
      COLORTYPE_PALETTE: 1,
      COLORTYPE_COLOR: 2,
      COLORTYPE_ALPHA: 4,
      // e.g. grayscale and alpha
      // color-type combinations
      COLORTYPE_PALETTE_COLOR: 3,
      COLORTYPE_COLOR_ALPHA: 6,
      COLORTYPE_TO_BPP_MAP: {
        0: 1,
        2: 3,
        3: 1,
        4: 2,
        6: 4
      },
      GAMMA_DIVISION: 1e5
    };
  }
});

// node_modules/pngjs/lib/crc.js
var require_crc = __commonJS({
  "node_modules/pngjs/lib/crc.js"(exports, module) {
    "use strict";
    var crcTable3 = [];
    (function() {
      for (let i = 0; i < 256; i++) {
        let currentCrc = i;
        for (let j = 0; j < 8; j++) {
          if (currentCrc & 1) {
            currentCrc = 3988292384 ^ currentCrc >>> 1;
          } else {
            currentCrc = currentCrc >>> 1;
          }
        }
        crcTable3[i] = currentCrc;
      }
    })();
    var CrcCalculator = module.exports = function() {
      this._crc = -1;
    };
    CrcCalculator.prototype.write = function(data) {
      for (let i = 0; i < data.length; i++) {
        this._crc = crcTable3[(this._crc ^ data[i]) & 255] ^ this._crc >>> 8;
      }
      return true;
    };
    CrcCalculator.prototype.crc32 = function() {
      return this._crc ^ -1;
    };
    CrcCalculator.crc32 = function(buf) {
      let crc2 = -1;
      for (let i = 0; i < buf.length; i++) {
        crc2 = crcTable3[(crc2 ^ buf[i]) & 255] ^ crc2 >>> 8;
      }
      return crc2 ^ -1;
    };
  }
});

// node_modules/pngjs/lib/parser.js
var require_parser = __commonJS({
  "node_modules/pngjs/lib/parser.js"(exports, module) {
    "use strict";
    var constants2 = require_constants();
    var CrcCalculator = require_crc();
    var Parser2 = module.exports = function(options, dependencies) {
      this._options = options;
      options.checkCRC = options.checkCRC !== false;
      this._hasIHDR = false;
      this._hasIEND = false;
      this._emittedHeadersFinished = false;
      this._palette = [];
      this._colorType = 0;
      this._chunks = {};
      this._chunks[constants2.TYPE_IHDR] = this._handleIHDR.bind(this);
      this._chunks[constants2.TYPE_IEND] = this._handleIEND.bind(this);
      this._chunks[constants2.TYPE_IDAT] = this._handleIDAT.bind(this);
      this._chunks[constants2.TYPE_PLTE] = this._handlePLTE.bind(this);
      this._chunks[constants2.TYPE_tRNS] = this._handleTRNS.bind(this);
      this._chunks[constants2.TYPE_gAMA] = this._handleGAMA.bind(this);
      this.read = dependencies.read;
      this.error = dependencies.error;
      this.metadata = dependencies.metadata;
      this.gamma = dependencies.gamma;
      this.transColor = dependencies.transColor;
      this.palette = dependencies.palette;
      this.parsed = dependencies.parsed;
      this.inflateData = dependencies.inflateData;
      this.finished = dependencies.finished;
      this.simpleTransparency = dependencies.simpleTransparency;
      this.headersFinished = dependencies.headersFinished || function() {
      };
    };
    Parser2.prototype.start = function() {
      this.read(constants2.PNG_SIGNATURE.length, this._parseSignature.bind(this));
    };
    Parser2.prototype._parseSignature = function(data) {
      let signature = constants2.PNG_SIGNATURE;
      for (let i = 0; i < signature.length; i++) {
        if (data[i] !== signature[i]) {
          this.error(new Error("Invalid file signature"));
          return;
        }
      }
      this.read(8, this._parseChunkBegin.bind(this));
    };
    Parser2.prototype._parseChunkBegin = function(data) {
      let length = data.readUInt32BE(0);
      let type = data.readUInt32BE(4);
      let name = "";
      for (let i = 4; i < 8; i++) {
        name += String.fromCharCode(data[i]);
      }
      let ancillary = Boolean(data[4] & 32);
      if (!this._hasIHDR && type !== constants2.TYPE_IHDR) {
        this.error(new Error("Expected IHDR on beggining"));
        return;
      }
      this._crc = new CrcCalculator();
      this._crc.write(Buffer.from(name));
      if (this._chunks[type]) {
        return this._chunks[type](length);
      }
      if (!ancillary) {
        this.error(new Error("Unsupported critical chunk type " + name));
        return;
      }
      this.read(length + 4, this._skipChunk.bind(this));
    };
    Parser2.prototype._skipChunk = function() {
      this.read(8, this._parseChunkBegin.bind(this));
    };
    Parser2.prototype._handleChunkEnd = function() {
      this.read(4, this._parseChunkEnd.bind(this));
    };
    Parser2.prototype._parseChunkEnd = function(data) {
      let fileCrc = data.readInt32BE(0);
      let calcCrc = this._crc.crc32();
      if (this._options.checkCRC && calcCrc !== fileCrc) {
        this.error(new Error("Crc error - " + fileCrc + " - " + calcCrc));
        return;
      }
      if (!this._hasIEND) {
        this.read(8, this._parseChunkBegin.bind(this));
      }
    };
    Parser2.prototype._handleIHDR = function(length) {
      this.read(length, this._parseIHDR.bind(this));
    };
    Parser2.prototype._parseIHDR = function(data) {
      this._crc.write(data);
      let width = data.readUInt32BE(0);
      let height = data.readUInt32BE(4);
      let depth = data[8];
      let colorType = data[9];
      let compr = data[10];
      let filter = data[11];
      let interlace = data[12];
      if (depth !== 8 && depth !== 4 && depth !== 2 && depth !== 1 && depth !== 16) {
        this.error(new Error("Unsupported bit depth " + depth));
        return;
      }
      if (!(colorType in constants2.COLORTYPE_TO_BPP_MAP)) {
        this.error(new Error("Unsupported color type"));
        return;
      }
      if (compr !== 0) {
        this.error(new Error("Unsupported compression method"));
        return;
      }
      if (filter !== 0) {
        this.error(new Error("Unsupported filter method"));
        return;
      }
      if (interlace !== 0 && interlace !== 1) {
        this.error(new Error("Unsupported interlace method"));
        return;
      }
      this._colorType = colorType;
      let bpp = constants2.COLORTYPE_TO_BPP_MAP[this._colorType];
      this._hasIHDR = true;
      this.metadata({
        width,
        height,
        depth,
        interlace: Boolean(interlace),
        palette: Boolean(colorType & constants2.COLORTYPE_PALETTE),
        color: Boolean(colorType & constants2.COLORTYPE_COLOR),
        alpha: Boolean(colorType & constants2.COLORTYPE_ALPHA),
        bpp,
        colorType
      });
      this._handleChunkEnd();
    };
    Parser2.prototype._handlePLTE = function(length) {
      this.read(length, this._parsePLTE.bind(this));
    };
    Parser2.prototype._parsePLTE = function(data) {
      this._crc.write(data);
      let entries = Math.floor(data.length / 3);
      for (let i = 0; i < entries; i++) {
        this._palette.push([data[i * 3], data[i * 3 + 1], data[i * 3 + 2], 255]);
      }
      this.palette(this._palette);
      this._handleChunkEnd();
    };
    Parser2.prototype._handleTRNS = function(length) {
      this.simpleTransparency();
      this.read(length, this._parseTRNS.bind(this));
    };
    Parser2.prototype._parseTRNS = function(data) {
      this._crc.write(data);
      if (this._colorType === constants2.COLORTYPE_PALETTE_COLOR) {
        if (this._palette.length === 0) {
          this.error(new Error("Transparency chunk must be after palette"));
          return;
        }
        if (data.length > this._palette.length) {
          this.error(new Error("More transparent colors than palette size"));
          return;
        }
        for (let i = 0; i < data.length; i++) {
          this._palette[i][3] = data[i];
        }
        this.palette(this._palette);
      }
      if (this._colorType === constants2.COLORTYPE_GRAYSCALE) {
        this.transColor([data.readUInt16BE(0)]);
      }
      if (this._colorType === constants2.COLORTYPE_COLOR) {
        this.transColor([
          data.readUInt16BE(0),
          data.readUInt16BE(2),
          data.readUInt16BE(4)
        ]);
      }
      this._handleChunkEnd();
    };
    Parser2.prototype._handleGAMA = function(length) {
      this.read(length, this._parseGAMA.bind(this));
    };
    Parser2.prototype._parseGAMA = function(data) {
      this._crc.write(data);
      this.gamma(data.readUInt32BE(0) / constants2.GAMMA_DIVISION);
      this._handleChunkEnd();
    };
    Parser2.prototype._handleIDAT = function(length) {
      if (!this._emittedHeadersFinished) {
        this._emittedHeadersFinished = true;
        this.headersFinished();
      }
      this.read(-length, this._parseIDAT.bind(this, length));
    };
    Parser2.prototype._parseIDAT = function(length, data) {
      this._crc.write(data);
      if (this._colorType === constants2.COLORTYPE_PALETTE_COLOR && this._palette.length === 0) {
        throw new Error("Expected palette not found");
      }
      this.inflateData(data);
      let leftOverLength = length - data.length;
      if (leftOverLength > 0) {
        this._handleIDAT(leftOverLength);
      } else {
        this._handleChunkEnd();
      }
    };
    Parser2.prototype._handleIEND = function(length) {
      this.read(length, this._parseIEND.bind(this));
    };
    Parser2.prototype._parseIEND = function(data) {
      this._crc.write(data);
      this._hasIEND = true;
      this._handleChunkEnd();
      if (this.finished) {
        this.finished();
      }
    };
  }
});

// node_modules/pngjs/lib/bitmapper.js
var require_bitmapper = __commonJS({
  "node_modules/pngjs/lib/bitmapper.js"(exports) {
    "use strict";
    var interlaceUtils = require_interlace();
    var pixelBppMapper = [
      // 0 - dummy entry
      function() {
      },
      // 1 - L
      // 0: 0, 1: 0, 2: 0, 3: 0xff
      function(pxData, data, pxPos, rawPos) {
        if (rawPos === data.length) {
          throw new Error("Ran out of data");
        }
        let pixel = data[rawPos];
        pxData[pxPos] = pixel;
        pxData[pxPos + 1] = pixel;
        pxData[pxPos + 2] = pixel;
        pxData[pxPos + 3] = 255;
      },
      // 2 - LA
      // 0: 0, 1: 0, 2: 0, 3: 1
      function(pxData, data, pxPos, rawPos) {
        if (rawPos + 1 >= data.length) {
          throw new Error("Ran out of data");
        }
        let pixel = data[rawPos];
        pxData[pxPos] = pixel;
        pxData[pxPos + 1] = pixel;
        pxData[pxPos + 2] = pixel;
        pxData[pxPos + 3] = data[rawPos + 1];
      },
      // 3 - RGB
      // 0: 0, 1: 1, 2: 2, 3: 0xff
      function(pxData, data, pxPos, rawPos) {
        if (rawPos + 2 >= data.length) {
          throw new Error("Ran out of data");
        }
        pxData[pxPos] = data[rawPos];
        pxData[pxPos + 1] = data[rawPos + 1];
        pxData[pxPos + 2] = data[rawPos + 2];
        pxData[pxPos + 3] = 255;
      },
      // 4 - RGBA
      // 0: 0, 1: 1, 2: 2, 3: 3
      function(pxData, data, pxPos, rawPos) {
        if (rawPos + 3 >= data.length) {
          throw new Error("Ran out of data");
        }
        pxData[pxPos] = data[rawPos];
        pxData[pxPos + 1] = data[rawPos + 1];
        pxData[pxPos + 2] = data[rawPos + 2];
        pxData[pxPos + 3] = data[rawPos + 3];
      }
    ];
    var pixelBppCustomMapper = [
      // 0 - dummy entry
      function() {
      },
      // 1 - L
      // 0: 0, 1: 0, 2: 0, 3: 0xff
      function(pxData, pixelData, pxPos, maxBit) {
        let pixel = pixelData[0];
        pxData[pxPos] = pixel;
        pxData[pxPos + 1] = pixel;
        pxData[pxPos + 2] = pixel;
        pxData[pxPos + 3] = maxBit;
      },
      // 2 - LA
      // 0: 0, 1: 0, 2: 0, 3: 1
      function(pxData, pixelData, pxPos) {
        let pixel = pixelData[0];
        pxData[pxPos] = pixel;
        pxData[pxPos + 1] = pixel;
        pxData[pxPos + 2] = pixel;
        pxData[pxPos + 3] = pixelData[1];
      },
      // 3 - RGB
      // 0: 0, 1: 1, 2: 2, 3: 0xff
      function(pxData, pixelData, pxPos, maxBit) {
        pxData[pxPos] = pixelData[0];
        pxData[pxPos + 1] = pixelData[1];
        pxData[pxPos + 2] = pixelData[2];
        pxData[pxPos + 3] = maxBit;
      },
      // 4 - RGBA
      // 0: 0, 1: 1, 2: 2, 3: 3
      function(pxData, pixelData, pxPos) {
        pxData[pxPos] = pixelData[0];
        pxData[pxPos + 1] = pixelData[1];
        pxData[pxPos + 2] = pixelData[2];
        pxData[pxPos + 3] = pixelData[3];
      }
    ];
    function bitRetriever(data, depth) {
      let leftOver = [];
      let i = 0;
      function split() {
        if (i === data.length) {
          throw new Error("Ran out of data");
        }
        let byte = data[i];
        i++;
        let byte8, byte7, byte6, byte5, byte4, byte3, byte2, byte1;
        switch (depth) {
          default:
            throw new Error("unrecognised depth");
          case 16:
            byte2 = data[i];
            i++;
            leftOver.push((byte << 8) + byte2);
            break;
          case 4:
            byte2 = byte & 15;
            byte1 = byte >> 4;
            leftOver.push(byte1, byte2);
            break;
          case 2:
            byte4 = byte & 3;
            byte3 = byte >> 2 & 3;
            byte2 = byte >> 4 & 3;
            byte1 = byte >> 6 & 3;
            leftOver.push(byte1, byte2, byte3, byte4);
            break;
          case 1:
            byte8 = byte & 1;
            byte7 = byte >> 1 & 1;
            byte6 = byte >> 2 & 1;
            byte5 = byte >> 3 & 1;
            byte4 = byte >> 4 & 1;
            byte3 = byte >> 5 & 1;
            byte2 = byte >> 6 & 1;
            byte1 = byte >> 7 & 1;
            leftOver.push(byte1, byte2, byte3, byte4, byte5, byte6, byte7, byte8);
            break;
        }
      }
      return {
        get: function(count) {
          while (leftOver.length < count) {
            split();
          }
          let returner = leftOver.slice(0, count);
          leftOver = leftOver.slice(count);
          return returner;
        },
        resetAfterLine: function() {
          leftOver.length = 0;
        },
        end: function() {
          if (i !== data.length) {
            throw new Error("extra data found");
          }
        }
      };
    }
    function mapImage8Bit(image2, pxData, getPxPos, bpp, data, rawPos) {
      let imageWidth = image2.width;
      let imageHeight = image2.height;
      let imagePass = image2.index;
      for (let y = 0; y < imageHeight; y++) {
        for (let x = 0; x < imageWidth; x++) {
          let pxPos = getPxPos(x, y, imagePass);
          pixelBppMapper[bpp](pxData, data, pxPos, rawPos);
          rawPos += bpp;
        }
      }
      return rawPos;
    }
    function mapImageCustomBit(image2, pxData, getPxPos, bpp, bits, maxBit) {
      let imageWidth = image2.width;
      let imageHeight = image2.height;
      let imagePass = image2.index;
      for (let y = 0; y < imageHeight; y++) {
        for (let x = 0; x < imageWidth; x++) {
          let pixelData = bits.get(bpp);
          let pxPos = getPxPos(x, y, imagePass);
          pixelBppCustomMapper[bpp](pxData, pixelData, pxPos, maxBit);
        }
        bits.resetAfterLine();
      }
    }
    exports.dataToBitMap = function(data, bitmapInfo) {
      let width = bitmapInfo.width;
      let height = bitmapInfo.height;
      let depth = bitmapInfo.depth;
      let bpp = bitmapInfo.bpp;
      let interlace = bitmapInfo.interlace;
      let bits;
      if (depth !== 8) {
        bits = bitRetriever(data, depth);
      }
      let pxData;
      if (depth <= 8) {
        pxData = Buffer.alloc(width * height * 4);
      } else {
        pxData = new Uint16Array(width * height * 4);
      }
      let maxBit = Math.pow(2, depth) - 1;
      let rawPos = 0;
      let images;
      let getPxPos;
      if (interlace) {
        images = interlaceUtils.getImagePasses(width, height);
        getPxPos = interlaceUtils.getInterlaceIterator(width, height);
      } else {
        let nonInterlacedPxPos = 0;
        getPxPos = function() {
          let returner = nonInterlacedPxPos;
          nonInterlacedPxPos += 4;
          return returner;
        };
        images = [{ width, height }];
      }
      for (let imageIndex = 0; imageIndex < images.length; imageIndex++) {
        if (depth === 8) {
          rawPos = mapImage8Bit(
            images[imageIndex],
            pxData,
            getPxPos,
            bpp,
            data,
            rawPos
          );
        } else {
          mapImageCustomBit(
            images[imageIndex],
            pxData,
            getPxPos,
            bpp,
            bits,
            maxBit
          );
        }
      }
      if (depth === 8) {
        if (rawPos !== data.length) {
          throw new Error("extra data found");
        }
      } else {
        bits.end();
      }
      return pxData;
    };
  }
});

// node_modules/pngjs/lib/format-normaliser.js
var require_format_normaliser = __commonJS({
  "node_modules/pngjs/lib/format-normaliser.js"(exports, module) {
    "use strict";
    function dePalette(indata, outdata, width, height, palette) {
      let pxPos = 0;
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          let color2 = palette[indata[pxPos]];
          if (!color2) {
            throw new Error("index " + indata[pxPos] + " not in palette");
          }
          for (let i = 0; i < 4; i++) {
            outdata[pxPos + i] = color2[i];
          }
          pxPos += 4;
        }
      }
    }
    function replaceTransparentColor(indata, outdata, width, height, transColor) {
      let pxPos = 0;
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          let makeTrans = false;
          if (transColor.length === 1) {
            if (transColor[0] === indata[pxPos]) {
              makeTrans = true;
            }
          } else if (transColor[0] === indata[pxPos] && transColor[1] === indata[pxPos + 1] && transColor[2] === indata[pxPos + 2]) {
            makeTrans = true;
          }
          if (makeTrans) {
            for (let i = 0; i < 4; i++) {
              outdata[pxPos + i] = 0;
            }
          }
          pxPos += 4;
        }
      }
    }
    function scaleDepth(indata, outdata, width, height, depth) {
      let maxOutSample = 255;
      let maxInSample = Math.pow(2, depth) - 1;
      let pxPos = 0;
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          for (let i = 0; i < 4; i++) {
            outdata[pxPos + i] = Math.floor(
              indata[pxPos + i] * maxOutSample / maxInSample + 0.5
            );
          }
          pxPos += 4;
        }
      }
    }
    module.exports = function(indata, imageData) {
      let depth = imageData.depth;
      let width = imageData.width;
      let height = imageData.height;
      let colorType = imageData.colorType;
      let transColor = imageData.transColor;
      let palette = imageData.palette;
      let outdata = indata;
      if (colorType === 3) {
        dePalette(indata, outdata, width, height, palette);
      } else {
        if (transColor) {
          replaceTransparentColor(indata, outdata, width, height, transColor);
        }
        if (depth !== 8) {
          if (depth === 16) {
            outdata = Buffer.alloc(width * height * 4);
          }
          scaleDepth(indata, outdata, width, height, depth);
        }
      }
      return outdata;
    };
  }
});

// node_modules/pngjs/lib/parser-async.js
var require_parser_async = __commonJS({
  "node_modules/pngjs/lib/parser-async.js"(exports, module) {
    "use strict";
    var util = __require("util");
    var zlib = __require("zlib");
    var ChunkStream = require_chunkstream();
    var FilterAsync = require_filter_parse_async();
    var Parser2 = require_parser();
    var bitmapper = require_bitmapper();
    var formatNormaliser = require_format_normaliser();
    var ParserAsync = module.exports = function(options) {
      ChunkStream.call(this);
      this._parser = new Parser2(options, {
        read: this.read.bind(this),
        error: this._handleError.bind(this),
        metadata: this._handleMetaData.bind(this),
        gamma: this.emit.bind(this, "gamma"),
        palette: this._handlePalette.bind(this),
        transColor: this._handleTransColor.bind(this),
        finished: this._finished.bind(this),
        inflateData: this._inflateData.bind(this),
        simpleTransparency: this._simpleTransparency.bind(this),
        headersFinished: this._headersFinished.bind(this)
      });
      this._options = options;
      this.writable = true;
      this._parser.start();
    };
    util.inherits(ParserAsync, ChunkStream);
    ParserAsync.prototype._handleError = function(err2) {
      this.emit("error", err2);
      this.writable = false;
      this.destroy();
      if (this._inflate && this._inflate.destroy) {
        this._inflate.destroy();
      }
      if (this._filter) {
        this._filter.destroy();
        this._filter.on("error", function() {
        });
      }
      this.errord = true;
    };
    ParserAsync.prototype._inflateData = function(data) {
      if (!this._inflate) {
        if (this._bitmapInfo.interlace) {
          this._inflate = zlib.createInflate();
          this._inflate.on("error", this.emit.bind(this, "error"));
          this._filter.on("complete", this._complete.bind(this));
          this._inflate.pipe(this._filter);
        } else {
          let rowSize = (this._bitmapInfo.width * this._bitmapInfo.bpp * this._bitmapInfo.depth + 7 >> 3) + 1;
          let imageSize = rowSize * this._bitmapInfo.height;
          let chunkSize = Math.max(imageSize, zlib.Z_MIN_CHUNK);
          this._inflate = zlib.createInflate({ chunkSize });
          let leftToInflate = imageSize;
          let emitError = this.emit.bind(this, "error");
          this._inflate.on("error", function(err2) {
            if (!leftToInflate) {
              return;
            }
            emitError(err2);
          });
          this._filter.on("complete", this._complete.bind(this));
          let filterWrite = this._filter.write.bind(this._filter);
          this._inflate.on("data", function(chunk) {
            if (!leftToInflate) {
              return;
            }
            if (chunk.length > leftToInflate) {
              chunk = chunk.slice(0, leftToInflate);
            }
            leftToInflate -= chunk.length;
            filterWrite(chunk);
          });
          this._inflate.on("end", this._filter.end.bind(this._filter));
        }
      }
      this._inflate.write(data);
    };
    ParserAsync.prototype._handleMetaData = function(metaData) {
      this._metaData = metaData;
      this._bitmapInfo = Object.create(metaData);
      this._filter = new FilterAsync(this._bitmapInfo);
    };
    ParserAsync.prototype._handleTransColor = function(transColor) {
      this._bitmapInfo.transColor = transColor;
    };
    ParserAsync.prototype._handlePalette = function(palette) {
      this._bitmapInfo.palette = palette;
    };
    ParserAsync.prototype._simpleTransparency = function() {
      this._metaData.alpha = true;
    };
    ParserAsync.prototype._headersFinished = function() {
      this.emit("metadata", this._metaData);
    };
    ParserAsync.prototype._finished = function() {
      if (this.errord) {
        return;
      }
      if (!this._inflate) {
        this.emit("error", "No Inflate block");
      } else {
        this._inflate.end();
      }
    };
    ParserAsync.prototype._complete = function(filteredData) {
      if (this.errord) {
        return;
      }
      let normalisedBitmapData;
      try {
        let bitmapData = bitmapper.dataToBitMap(filteredData, this._bitmapInfo);
        normalisedBitmapData = formatNormaliser(bitmapData, this._bitmapInfo);
        bitmapData = null;
      } catch (ex) {
        this._handleError(ex);
        return;
      }
      this.emit("parsed", normalisedBitmapData);
    };
  }
});

// node_modules/pngjs/lib/bitpacker.js
var require_bitpacker = __commonJS({
  "node_modules/pngjs/lib/bitpacker.js"(exports, module) {
    "use strict";
    var constants2 = require_constants();
    module.exports = function(dataIn, width, height, options) {
      let outHasAlpha = [constants2.COLORTYPE_COLOR_ALPHA, constants2.COLORTYPE_ALPHA].indexOf(
        options.colorType
      ) !== -1;
      if (options.colorType === options.inputColorType) {
        let bigEndian = (function() {
          let buffer = new ArrayBuffer(2);
          new DataView(buffer).setInt16(
            0,
            256,
            true
            /* littleEndian */
          );
          return new Int16Array(buffer)[0] !== 256;
        })();
        if (options.bitDepth === 8 || options.bitDepth === 16 && bigEndian) {
          return dataIn;
        }
      }
      let data = options.bitDepth !== 16 ? dataIn : new Uint16Array(dataIn.buffer);
      let maxValue = 255;
      let inBpp = constants2.COLORTYPE_TO_BPP_MAP[options.inputColorType];
      if (inBpp === 4 && !options.inputHasAlpha) {
        inBpp = 3;
      }
      let outBpp = constants2.COLORTYPE_TO_BPP_MAP[options.colorType];
      if (options.bitDepth === 16) {
        maxValue = 65535;
        outBpp *= 2;
      }
      let outData = Buffer.alloc(width * height * outBpp);
      let inIndex = 0;
      let outIndex = 0;
      let bgColor = options.bgColor || {};
      if (bgColor.red === void 0) {
        bgColor.red = maxValue;
      }
      if (bgColor.green === void 0) {
        bgColor.green = maxValue;
      }
      if (bgColor.blue === void 0) {
        bgColor.blue = maxValue;
      }
      function getRGBA() {
        let red;
        let green;
        let blue;
        let alpha = maxValue;
        switch (options.inputColorType) {
          case constants2.COLORTYPE_COLOR_ALPHA:
            alpha = data[inIndex + 3];
            red = data[inIndex];
            green = data[inIndex + 1];
            blue = data[inIndex + 2];
            break;
          case constants2.COLORTYPE_COLOR:
            red = data[inIndex];
            green = data[inIndex + 1];
            blue = data[inIndex + 2];
            break;
          case constants2.COLORTYPE_ALPHA:
            alpha = data[inIndex + 1];
            red = data[inIndex];
            green = red;
            blue = red;
            break;
          case constants2.COLORTYPE_GRAYSCALE:
            red = data[inIndex];
            green = red;
            blue = red;
            break;
          default:
            throw new Error(
              "input color type:" + options.inputColorType + " is not supported at present"
            );
        }
        if (options.inputHasAlpha) {
          if (!outHasAlpha) {
            alpha /= maxValue;
            red = Math.min(
              Math.max(Math.round((1 - alpha) * bgColor.red + alpha * red), 0),
              maxValue
            );
            green = Math.min(
              Math.max(Math.round((1 - alpha) * bgColor.green + alpha * green), 0),
              maxValue
            );
            blue = Math.min(
              Math.max(Math.round((1 - alpha) * bgColor.blue + alpha * blue), 0),
              maxValue
            );
          }
        }
        return { red, green, blue, alpha };
      }
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          let rgba = getRGBA(data, inIndex);
          switch (options.colorType) {
            case constants2.COLORTYPE_COLOR_ALPHA:
            case constants2.COLORTYPE_COLOR:
              if (options.bitDepth === 8) {
                outData[outIndex] = rgba.red;
                outData[outIndex + 1] = rgba.green;
                outData[outIndex + 2] = rgba.blue;
                if (outHasAlpha) {
                  outData[outIndex + 3] = rgba.alpha;
                }
              } else {
                outData.writeUInt16BE(rgba.red, outIndex);
                outData.writeUInt16BE(rgba.green, outIndex + 2);
                outData.writeUInt16BE(rgba.blue, outIndex + 4);
                if (outHasAlpha) {
                  outData.writeUInt16BE(rgba.alpha, outIndex + 6);
                }
              }
              break;
            case constants2.COLORTYPE_ALPHA:
            case constants2.COLORTYPE_GRAYSCALE: {
              let grayscale = (rgba.red + rgba.green + rgba.blue) / 3;
              if (options.bitDepth === 8) {
                outData[outIndex] = grayscale;
                if (outHasAlpha) {
                  outData[outIndex + 1] = rgba.alpha;
                }
              } else {
                outData.writeUInt16BE(grayscale, outIndex);
                if (outHasAlpha) {
                  outData.writeUInt16BE(rgba.alpha, outIndex + 2);
                }
              }
              break;
            }
            default:
              throw new Error("unrecognised color Type " + options.colorType);
          }
          inIndex += inBpp;
          outIndex += outBpp;
        }
      }
      return outData;
    };
  }
});

// node_modules/pngjs/lib/filter-pack.js
var require_filter_pack = __commonJS({
  "node_modules/pngjs/lib/filter-pack.js"(exports, module) {
    "use strict";
    var paethPredictor2 = require_paeth_predictor();
    function filterNone(pxData, pxPos, byteWidth, rawData, rawPos) {
      for (let x = 0; x < byteWidth; x++) {
        rawData[rawPos + x] = pxData[pxPos + x];
      }
    }
    function filterSumNone(pxData, pxPos, byteWidth) {
      let sum = 0;
      let length = pxPos + byteWidth;
      for (let i = pxPos; i < length; i++) {
        sum += Math.abs(pxData[i]);
      }
      return sum;
    }
    function filterSub(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
      for (let x = 0; x < byteWidth; x++) {
        let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        let val = pxData[pxPos + x] - left;
        rawData[rawPos + x] = val;
      }
    }
    function filterSumSub(pxData, pxPos, byteWidth, bpp) {
      let sum = 0;
      for (let x = 0; x < byteWidth; x++) {
        let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        let val = pxData[pxPos + x] - left;
        sum += Math.abs(val);
      }
      return sum;
    }
    function filterUp(pxData, pxPos, byteWidth, rawData, rawPos) {
      for (let x = 0; x < byteWidth; x++) {
        let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        let val = pxData[pxPos + x] - up;
        rawData[rawPos + x] = val;
      }
    }
    function filterSumUp(pxData, pxPos, byteWidth) {
      let sum = 0;
      let length = pxPos + byteWidth;
      for (let x = pxPos; x < length; x++) {
        let up = pxPos > 0 ? pxData[x - byteWidth] : 0;
        let val = pxData[x] - up;
        sum += Math.abs(val);
      }
      return sum;
    }
    function filterAvg(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
      for (let x = 0; x < byteWidth; x++) {
        let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        let val = pxData[pxPos + x] - (left + up >> 1);
        rawData[rawPos + x] = val;
      }
    }
    function filterSumAvg(pxData, pxPos, byteWidth, bpp) {
      let sum = 0;
      for (let x = 0; x < byteWidth; x++) {
        let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        let val = pxData[pxPos + x] - (left + up >> 1);
        sum += Math.abs(val);
      }
      return sum;
    }
    function filterPaeth(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
      for (let x = 0; x < byteWidth; x++) {
        let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        let upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
        let val = pxData[pxPos + x] - paethPredictor2(left, up, upleft);
        rawData[rawPos + x] = val;
      }
    }
    function filterSumPaeth(pxData, pxPos, byteWidth, bpp) {
      let sum = 0;
      for (let x = 0; x < byteWidth; x++) {
        let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        let upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
        let val = pxData[pxPos + x] - paethPredictor2(left, up, upleft);
        sum += Math.abs(val);
      }
      return sum;
    }
    var filters = {
      0: filterNone,
      1: filterSub,
      2: filterUp,
      3: filterAvg,
      4: filterPaeth
    };
    var filterSums = {
      0: filterSumNone,
      1: filterSumSub,
      2: filterSumUp,
      3: filterSumAvg,
      4: filterSumPaeth
    };
    module.exports = function(pxData, width, height, options, bpp) {
      let filterTypes;
      if (!("filterType" in options) || options.filterType === -1) {
        filterTypes = [0, 1, 2, 3, 4];
      } else if (typeof options.filterType === "number") {
        filterTypes = [options.filterType];
      } else {
        throw new Error("unrecognised filter types");
      }
      if (options.bitDepth === 16) {
        bpp *= 2;
      }
      let byteWidth = width * bpp;
      let rawPos = 0;
      let pxPos = 0;
      let rawData = Buffer.alloc((byteWidth + 1) * height);
      let sel = filterTypes[0];
      for (let y = 0; y < height; y++) {
        if (filterTypes.length > 1) {
          let min = Infinity;
          for (let i = 0; i < filterTypes.length; i++) {
            let sum = filterSums[filterTypes[i]](pxData, pxPos, byteWidth, bpp);
            if (sum < min) {
              sel = filterTypes[i];
              min = sum;
            }
          }
        }
        rawData[rawPos] = sel;
        rawPos++;
        filters[sel](pxData, pxPos, byteWidth, rawData, rawPos, bpp);
        rawPos += byteWidth;
        pxPos += byteWidth;
      }
      return rawData;
    };
  }
});

// node_modules/pngjs/lib/packer.js
var require_packer = __commonJS({
  "node_modules/pngjs/lib/packer.js"(exports, module) {
    "use strict";
    var constants2 = require_constants();
    var CrcStream = require_crc();
    var bitPacker = require_bitpacker();
    var filter = require_filter_pack();
    var zlib = __require("zlib");
    var Packer = module.exports = function(options) {
      this._options = options;
      options.deflateChunkSize = options.deflateChunkSize || 32 * 1024;
      options.deflateLevel = options.deflateLevel != null ? options.deflateLevel : 9;
      options.deflateStrategy = options.deflateStrategy != null ? options.deflateStrategy : 3;
      options.inputHasAlpha = options.inputHasAlpha != null ? options.inputHasAlpha : true;
      options.deflateFactory = options.deflateFactory || zlib.createDeflate;
      options.bitDepth = options.bitDepth || 8;
      options.colorType = typeof options.colorType === "number" ? options.colorType : constants2.COLORTYPE_COLOR_ALPHA;
      options.inputColorType = typeof options.inputColorType === "number" ? options.inputColorType : constants2.COLORTYPE_COLOR_ALPHA;
      if ([
        constants2.COLORTYPE_GRAYSCALE,
        constants2.COLORTYPE_COLOR,
        constants2.COLORTYPE_COLOR_ALPHA,
        constants2.COLORTYPE_ALPHA
      ].indexOf(options.colorType) === -1) {
        throw new Error(
          "option color type:" + options.colorType + " is not supported at present"
        );
      }
      if ([
        constants2.COLORTYPE_GRAYSCALE,
        constants2.COLORTYPE_COLOR,
        constants2.COLORTYPE_COLOR_ALPHA,
        constants2.COLORTYPE_ALPHA
      ].indexOf(options.inputColorType) === -1) {
        throw new Error(
          "option input color type:" + options.inputColorType + " is not supported at present"
        );
      }
      if (options.bitDepth !== 8 && options.bitDepth !== 16) {
        throw new Error(
          "option bit depth:" + options.bitDepth + " is not supported at present"
        );
      }
    };
    Packer.prototype.getDeflateOptions = function() {
      return {
        chunkSize: this._options.deflateChunkSize,
        level: this._options.deflateLevel,
        strategy: this._options.deflateStrategy
      };
    };
    Packer.prototype.createDeflate = function() {
      return this._options.deflateFactory(this.getDeflateOptions());
    };
    Packer.prototype.filterData = function(data, width, height) {
      let packedData = bitPacker(data, width, height, this._options);
      let bpp = constants2.COLORTYPE_TO_BPP_MAP[this._options.colorType];
      let filteredData = filter(packedData, width, height, this._options, bpp);
      return filteredData;
    };
    Packer.prototype._packChunk = function(type, data) {
      let len = data ? data.length : 0;
      let buf = Buffer.alloc(len + 12);
      buf.writeUInt32BE(len, 0);
      buf.writeUInt32BE(type, 4);
      if (data) {
        data.copy(buf, 8);
      }
      buf.writeInt32BE(
        CrcStream.crc32(buf.slice(4, buf.length - 4)),
        buf.length - 4
      );
      return buf;
    };
    Packer.prototype.packGAMA = function(gamma) {
      let buf = Buffer.alloc(4);
      buf.writeUInt32BE(Math.floor(gamma * constants2.GAMMA_DIVISION), 0);
      return this._packChunk(constants2.TYPE_gAMA, buf);
    };
    Packer.prototype.packIHDR = function(width, height) {
      let buf = Buffer.alloc(13);
      buf.writeUInt32BE(width, 0);
      buf.writeUInt32BE(height, 4);
      buf[8] = this._options.bitDepth;
      buf[9] = this._options.colorType;
      buf[10] = 0;
      buf[11] = 0;
      buf[12] = 0;
      return this._packChunk(constants2.TYPE_IHDR, buf);
    };
    Packer.prototype.packIDAT = function(data) {
      return this._packChunk(constants2.TYPE_IDAT, data);
    };
    Packer.prototype.packIEND = function() {
      return this._packChunk(constants2.TYPE_IEND, null);
    };
  }
});

// node_modules/pngjs/lib/packer-async.js
var require_packer_async = __commonJS({
  "node_modules/pngjs/lib/packer-async.js"(exports, module) {
    "use strict";
    var util = __require("util");
    var Stream = __require("stream");
    var constants2 = require_constants();
    var Packer = require_packer();
    var PackerAsync = module.exports = function(opt) {
      Stream.call(this);
      let options = opt || {};
      this._packer = new Packer(options);
      this._deflate = this._packer.createDeflate();
      this.readable = true;
    };
    util.inherits(PackerAsync, Stream);
    PackerAsync.prototype.pack = function(data, width, height, gamma) {
      this.emit("data", Buffer.from(constants2.PNG_SIGNATURE));
      this.emit("data", this._packer.packIHDR(width, height));
      if (gamma) {
        this.emit("data", this._packer.packGAMA(gamma));
      }
      let filteredData = this._packer.filterData(data, width, height);
      this._deflate.on("error", this.emit.bind(this, "error"));
      this._deflate.on(
        "data",
        function(compressedData) {
          this.emit("data", this._packer.packIDAT(compressedData));
        }.bind(this)
      );
      this._deflate.on(
        "end",
        function() {
          this.emit("data", this._packer.packIEND());
          this.emit("end");
        }.bind(this)
      );
      this._deflate.end(filteredData);
    };
  }
});

// node_modules/pngjs/lib/sync-inflate.js
var require_sync_inflate = __commonJS({
  "node_modules/pngjs/lib/sync-inflate.js"(exports, module) {
    "use strict";
    var assert = __require("assert").ok;
    var zlib = __require("zlib");
    var util = __require("util");
    var kMaxLength = __require("buffer").kMaxLength;
    function Inflate2(opts) {
      if (!(this instanceof Inflate2)) {
        return new Inflate2(opts);
      }
      if (opts && opts.chunkSize < zlib.Z_MIN_CHUNK) {
        opts.chunkSize = zlib.Z_MIN_CHUNK;
      }
      zlib.Inflate.call(this, opts);
      this._offset = this._offset === void 0 ? this._outOffset : this._offset;
      this._buffer = this._buffer || this._outBuffer;
      if (opts && opts.maxLength != null) {
        this._maxLength = opts.maxLength;
      }
    }
    function createInflate(opts) {
      return new Inflate2(opts);
    }
    function _close(engine, callback) {
      if (callback) {
        process.nextTick(callback);
      }
      if (!engine._handle) {
        return;
      }
      engine._handle.close();
      engine._handle = null;
    }
    Inflate2.prototype._processChunk = function(chunk, flushFlag, asyncCb) {
      if (typeof asyncCb === "function") {
        return zlib.Inflate._processChunk.call(this, chunk, flushFlag, asyncCb);
      }
      let self2 = this;
      let availInBefore = chunk && chunk.length;
      let availOutBefore = this._chunkSize - this._offset;
      let leftToInflate = this._maxLength;
      let inOff = 0;
      let buffers = [];
      let nread = 0;
      let error;
      this.on("error", function(err2) {
        error = err2;
      });
      function handleChunk(availInAfter, availOutAfter) {
        if (self2._hadError) {
          return;
        }
        let have = availOutBefore - availOutAfter;
        assert(have >= 0, "have should not go down");
        if (have > 0) {
          let out = self2._buffer.slice(self2._offset, self2._offset + have);
          self2._offset += have;
          if (out.length > leftToInflate) {
            out = out.slice(0, leftToInflate);
          }
          buffers.push(out);
          nread += out.length;
          leftToInflate -= out.length;
          if (leftToInflate === 0) {
            return false;
          }
        }
        if (availOutAfter === 0 || self2._offset >= self2._chunkSize) {
          availOutBefore = self2._chunkSize;
          self2._offset = 0;
          self2._buffer = Buffer.allocUnsafe(self2._chunkSize);
        }
        if (availOutAfter === 0) {
          inOff += availInBefore - availInAfter;
          availInBefore = availInAfter;
          return true;
        }
        return false;
      }
      assert(this._handle, "zlib binding closed");
      let res;
      do {
        res = this._handle.writeSync(
          flushFlag,
          chunk,
          // in
          inOff,
          // in_off
          availInBefore,
          // in_len
          this._buffer,
          // out
          this._offset,
          //out_off
          availOutBefore
        );
        res = res || this._writeState;
      } while (!this._hadError && handleChunk(res[0], res[1]));
      if (this._hadError) {
        throw error;
      }
      if (nread >= kMaxLength) {
        _close(this);
        throw new RangeError(
          "Cannot create final Buffer. It would be larger than 0x" + kMaxLength.toString(16) + " bytes"
        );
      }
      let buf = Buffer.concat(buffers, nread);
      _close(this);
      return buf;
    };
    util.inherits(Inflate2, zlib.Inflate);
    function zlibBufferSync(engine, buffer) {
      if (typeof buffer === "string") {
        buffer = Buffer.from(buffer);
      }
      if (!(buffer instanceof Buffer)) {
        throw new TypeError("Not a string or buffer");
      }
      let flushFlag = engine._finishFlushFlag;
      if (flushFlag == null) {
        flushFlag = zlib.Z_FINISH;
      }
      return engine._processChunk(buffer, flushFlag);
    }
    function inflateSync(buffer, opts) {
      return zlibBufferSync(new Inflate2(opts), buffer);
    }
    module.exports = exports = inflateSync;
    exports.Inflate = Inflate2;
    exports.createInflate = createInflate;
    exports.inflateSync = inflateSync;
  }
});

// node_modules/pngjs/lib/sync-reader.js
var require_sync_reader = __commonJS({
  "node_modules/pngjs/lib/sync-reader.js"(exports, module) {
    "use strict";
    var SyncReader = module.exports = function(buffer) {
      this._buffer = buffer;
      this._reads = [];
    };
    SyncReader.prototype.read = function(length, callback) {
      this._reads.push({
        length: Math.abs(length),
        // if length < 0 then at most this length
        allowLess: length < 0,
        func: callback
      });
    };
    SyncReader.prototype.process = function() {
      while (this._reads.length > 0 && this._buffer.length) {
        let read = this._reads[0];
        if (this._buffer.length && (this._buffer.length >= read.length || read.allowLess)) {
          this._reads.shift();
          let buf = this._buffer;
          this._buffer = buf.slice(read.length);
          read.func.call(this, buf.slice(0, read.length));
        } else {
          break;
        }
      }
      if (this._reads.length > 0) {
        return new Error("There are some read requests waitng on finished stream");
      }
      if (this._buffer.length > 0) {
        return new Error("unrecognised content at end of stream");
      }
    };
  }
});

// node_modules/pngjs/lib/filter-parse-sync.js
var require_filter_parse_sync = __commonJS({
  "node_modules/pngjs/lib/filter-parse-sync.js"(exports) {
    "use strict";
    var SyncReader = require_sync_reader();
    var Filter = require_filter_parse();
    exports.process = function(inBuffer, bitmapInfo) {
      let outBuffers = [];
      let reader = new SyncReader(inBuffer);
      let filter = new Filter(bitmapInfo, {
        read: reader.read.bind(reader),
        write: function(bufferPart) {
          outBuffers.push(bufferPart);
        },
        complete: function() {
        }
      });
      filter.start();
      reader.process();
      return Buffer.concat(outBuffers);
    };
  }
});

// node_modules/pngjs/lib/parser-sync.js
var require_parser_sync = __commonJS({
  "node_modules/pngjs/lib/parser-sync.js"(exports, module) {
    "use strict";
    var hasSyncZlib = true;
    var zlib = __require("zlib");
    var inflateSync = require_sync_inflate();
    if (!zlib.deflateSync) {
      hasSyncZlib = false;
    }
    var SyncReader = require_sync_reader();
    var FilterSync = require_filter_parse_sync();
    var Parser2 = require_parser();
    var bitmapper = require_bitmapper();
    var formatNormaliser = require_format_normaliser();
    module.exports = function(buffer, options) {
      if (!hasSyncZlib) {
        throw new Error(
          "To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0"
        );
      }
      let err2;
      function handleError(_err_) {
        err2 = _err_;
      }
      let metaData;
      function handleMetaData(_metaData_) {
        metaData = _metaData_;
      }
      function handleTransColor(transColor) {
        metaData.transColor = transColor;
      }
      function handlePalette(palette) {
        metaData.palette = palette;
      }
      function handleSimpleTransparency() {
        metaData.alpha = true;
      }
      let gamma;
      function handleGamma(_gamma_) {
        gamma = _gamma_;
      }
      let inflateDataList = [];
      function handleInflateData(inflatedData2) {
        inflateDataList.push(inflatedData2);
      }
      let reader = new SyncReader(buffer);
      let parser = new Parser2(options, {
        read: reader.read.bind(reader),
        error: handleError,
        metadata: handleMetaData,
        gamma: handleGamma,
        palette: handlePalette,
        transColor: handleTransColor,
        inflateData: handleInflateData,
        simpleTransparency: handleSimpleTransparency
      });
      parser.start();
      reader.process();
      if (err2) {
        throw err2;
      }
      let inflateData = Buffer.concat(inflateDataList);
      inflateDataList.length = 0;
      let inflatedData;
      if (metaData.interlace) {
        inflatedData = zlib.inflateSync(inflateData);
      } else {
        let rowSize = (metaData.width * metaData.bpp * metaData.depth + 7 >> 3) + 1;
        let imageSize = rowSize * metaData.height;
        inflatedData = inflateSync(inflateData, {
          chunkSize: imageSize,
          maxLength: imageSize
        });
      }
      inflateData = null;
      if (!inflatedData || !inflatedData.length) {
        throw new Error("bad png - invalid inflate data response");
      }
      let unfilteredData = FilterSync.process(inflatedData, metaData);
      inflateData = null;
      let bitmapData = bitmapper.dataToBitMap(unfilteredData, metaData);
      unfilteredData = null;
      let normalisedBitmapData = formatNormaliser(bitmapData, metaData);
      metaData.data = normalisedBitmapData;
      metaData.gamma = gamma || 0;
      return metaData;
    };
  }
});

// node_modules/pngjs/lib/packer-sync.js
var require_packer_sync = __commonJS({
  "node_modules/pngjs/lib/packer-sync.js"(exports, module) {
    "use strict";
    var hasSyncZlib = true;
    var zlib = __require("zlib");
    if (!zlib.deflateSync) {
      hasSyncZlib = false;
    }
    var constants2 = require_constants();
    var Packer = require_packer();
    module.exports = function(metaData, opt) {
      if (!hasSyncZlib) {
        throw new Error(
          "To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0"
        );
      }
      let options = opt || {};
      let packer = new Packer(options);
      let chunks = [];
      chunks.push(Buffer.from(constants2.PNG_SIGNATURE));
      chunks.push(packer.packIHDR(metaData.width, metaData.height));
      if (metaData.gamma) {
        chunks.push(packer.packGAMA(metaData.gamma));
      }
      let filteredData = packer.filterData(
        metaData.data,
        metaData.width,
        metaData.height
      );
      let compressedData = zlib.deflateSync(
        filteredData,
        packer.getDeflateOptions()
      );
      filteredData = null;
      if (!compressedData || !compressedData.length) {
        throw new Error("bad png - invalid compressed data response");
      }
      chunks.push(packer.packIDAT(compressedData));
      chunks.push(packer.packIEND());
      return Buffer.concat(chunks);
    };
  }
});

// node_modules/pngjs/lib/png-sync.js
var require_png_sync = __commonJS({
  "node_modules/pngjs/lib/png-sync.js"(exports) {
    "use strict";
    var parse2 = require_parser_sync();
    var pack2 = require_packer_sync();
    exports.read = function(buffer, options) {
      return parse2(buffer, options || {});
    };
    exports.write = function(png, options) {
      return pack2(png, options);
    };
  }
});

// node_modules/pngjs/lib/png.js
var require_png = __commonJS({
  "node_modules/pngjs/lib/png.js"(exports) {
    "use strict";
    var util = __require("util");
    var Stream = __require("stream");
    var Parser2 = require_parser_async();
    var Packer = require_packer_async();
    var PNGSync = require_png_sync();
    var PNG = exports.PNG = function(options) {
      Stream.call(this);
      options = options || {};
      this.width = options.width | 0;
      this.height = options.height | 0;
      this.data = this.width > 0 && this.height > 0 ? Buffer.alloc(4 * this.width * this.height) : null;
      if (options.fill && this.data) {
        this.data.fill(0);
      }
      this.gamma = 0;
      this.readable = this.writable = true;
      this._parser = new Parser2(options);
      this._parser.on("error", this.emit.bind(this, "error"));
      this._parser.on("close", this._handleClose.bind(this));
      this._parser.on("metadata", this._metadata.bind(this));
      this._parser.on("gamma", this._gamma.bind(this));
      this._parser.on(
        "parsed",
        function(data) {
          this.data = data;
          this.emit("parsed", data);
        }.bind(this)
      );
      this._packer = new Packer(options);
      this._packer.on("data", this.emit.bind(this, "data"));
      this._packer.on("end", this.emit.bind(this, "end"));
      this._parser.on("close", this._handleClose.bind(this));
      this._packer.on("error", this.emit.bind(this, "error"));
    };
    util.inherits(PNG, Stream);
    PNG.sync = PNGSync;
    PNG.prototype.pack = function() {
      if (!this.data || !this.data.length) {
        this.emit("error", "No data provided");
        return this;
      }
      process.nextTick(
        function() {
          this._packer.pack(this.data, this.width, this.height, this.gamma);
        }.bind(this)
      );
      return this;
    };
    PNG.prototype.parse = function(data, callback) {
      if (callback) {
        let onParsed, onError;
        onParsed = function(parsedData) {
          this.removeListener("error", onError);
          this.data = parsedData;
          callback(null, this);
        }.bind(this);
        onError = function(err2) {
          this.removeListener("parsed", onParsed);
          callback(err2, null);
        }.bind(this);
        this.once("parsed", onParsed);
        this.once("error", onError);
      }
      this.end(data);
      return this;
    };
    PNG.prototype.write = function(data) {
      this._parser.write(data);
      return true;
    };
    PNG.prototype.end = function(data) {
      this._parser.end(data);
    };
    PNG.prototype._metadata = function(metadata) {
      this.width = metadata.width;
      this.height = metadata.height;
      this.emit("metadata", metadata);
    };
    PNG.prototype._gamma = function(gamma) {
      this.gamma = gamma;
    };
    PNG.prototype._handleClose = function() {
      if (!this._parser.writable && !this._packer.readable) {
        this.emit("close");
      }
    };
    PNG.bitblt = function(src, dst, srcX, srcY, width, height, deltaX, deltaY) {
      srcX |= 0;
      srcY |= 0;
      width |= 0;
      height |= 0;
      deltaX |= 0;
      deltaY |= 0;
      if (srcX > src.width || srcY > src.height || srcX + width > src.width || srcY + height > src.height) {
        throw new Error("bitblt reading outside image");
      }
      if (deltaX > dst.width || deltaY > dst.height || deltaX + width > dst.width || deltaY + height > dst.height) {
        throw new Error("bitblt writing outside image");
      }
      for (let y = 0; y < height; y++) {
        src.data.copy(
          dst.data,
          (deltaY + y) * dst.width + deltaX << 2,
          (srcY + y) * src.width + srcX << 2,
          (srcY + y) * src.width + srcX + width << 2
        );
      }
    };
    PNG.prototype.bitblt = function(dst, srcX, srcY, width, height, deltaX, deltaY) {
      PNG.bitblt(this, dst, srcX, srcY, width, height, deltaX, deltaY);
      return this;
    };
    PNG.adjustGamma = function(src) {
      if (src.gamma) {
        for (let y = 0; y < src.height; y++) {
          for (let x = 0; x < src.width; x++) {
            let idx = src.width * y + x << 2;
            for (let i = 0; i < 3; i++) {
              let sample = src.data[idx + i] / 255;
              sample = Math.pow(sample, 1 / 2.2 / src.gamma);
              src.data[idx + i] = Math.round(sample * 255);
            }
          }
        }
        src.gamma = 0;
      }
    };
    PNG.prototype.adjustGamma = function() {
      PNG.adjustGamma(this);
    };
  }
});

// node_modules/qrcode/lib/renderer/utils.js
var require_utils2 = __commonJS({
  "node_modules/qrcode/lib/renderer/utils.js"(exports) {
    "use strict";
    function hex2rgba(hex) {
      if (typeof hex === "number") {
        hex = hex.toString();
      }
      if (typeof hex !== "string") {
        throw new Error("Color should be defined as hex string");
      }
      let hexCode = hex.slice().replace("#", "").split("");
      if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
        throw new Error("Invalid hex color: " + hex);
      }
      if (hexCode.length === 3 || hexCode.length === 4) {
        hexCode = Array.prototype.concat.apply([], hexCode.map(function(c) {
          return [c, c];
        }));
      }
      if (hexCode.length === 6) hexCode.push("F", "F");
      const hexValue = parseInt(hexCode.join(""), 16);
      return {
        r: hexValue >> 24 & 255,
        g: hexValue >> 16 & 255,
        b: hexValue >> 8 & 255,
        a: hexValue & 255,
        hex: "#" + hexCode.slice(0, 6).join("")
      };
    }
    exports.getOptions = function getOptions(options) {
      if (!options) options = {};
      if (!options.color) options.color = {};
      const margin = typeof options.margin === "undefined" || options.margin === null || options.margin < 0 ? 4 : options.margin;
      const width = options.width && options.width >= 21 ? options.width : void 0;
      const scale = options.scale || 4;
      return {
        width,
        scale: width ? 4 : scale,
        margin,
        color: {
          dark: hex2rgba(options.color.dark || "#000000ff"),
          light: hex2rgba(options.color.light || "#ffffffff")
        },
        type: options.type,
        rendererOpts: options.rendererOpts || {}
      };
    };
    exports.getScale = function getScale(qrSize, opts) {
      return opts.width && opts.width >= qrSize + opts.margin * 2 ? opts.width / (qrSize + opts.margin * 2) : opts.scale;
    };
    exports.getImageWidth = function getImageWidth(qrSize, opts) {
      const scale = exports.getScale(qrSize, opts);
      return Math.floor((qrSize + opts.margin * 2) * scale);
    };
    exports.qrToImageData = function qrToImageData(imgData, qr, opts) {
      const size = qr.modules.size;
      const data = qr.modules.data;
      const scale = exports.getScale(size, opts);
      const symbolSize = Math.floor((size + opts.margin * 2) * scale);
      const scaledMargin = opts.margin * scale;
      const palette = [opts.color.light, opts.color.dark];
      for (let i = 0; i < symbolSize; i++) {
        for (let j = 0; j < symbolSize; j++) {
          let posDst = (i * symbolSize + j) * 4;
          let pxColor = opts.color.light;
          if (i >= scaledMargin && j >= scaledMargin && i < symbolSize - scaledMargin && j < symbolSize - scaledMargin) {
            const iSrc = Math.floor((i - scaledMargin) / scale);
            const jSrc = Math.floor((j - scaledMargin) / scale);
            pxColor = palette[data[iSrc * size + jSrc] ? 1 : 0];
          }
          imgData[posDst++] = pxColor.r;
          imgData[posDst++] = pxColor.g;
          imgData[posDst++] = pxColor.b;
          imgData[posDst] = pxColor.a;
        }
      }
    };
  }
});

// node_modules/qrcode/lib/renderer/png.js
var require_png2 = __commonJS({
  "node_modules/qrcode/lib/renderer/png.js"(exports) {
    "use strict";
    var fs = __require("fs");
    var PNG = require_png().PNG;
    var Utils = require_utils2();
    exports.render = function render(qrData, options) {
      const opts = Utils.getOptions(options);
      const pngOpts = opts.rendererOpts;
      const size = Utils.getImageWidth(qrData.modules.size, opts);
      pngOpts.width = size;
      pngOpts.height = size;
      const pngImage = new PNG(pngOpts);
      Utils.qrToImageData(pngImage.data, qrData, opts);
      return pngImage;
    };
    exports.renderToDataURL = function renderToDataURL(qrData, options, cb) {
      if (typeof cb === "undefined") {
        cb = options;
        options = void 0;
      }
      exports.renderToBuffer(qrData, options, function(err2, output) {
        if (err2) cb(err2);
        let url = "data:image/png;base64,";
        url += output.toString("base64");
        cb(null, url);
      });
    };
    exports.renderToBuffer = function renderToBuffer(qrData, options, cb) {
      if (typeof cb === "undefined") {
        cb = options;
        options = void 0;
      }
      const png = exports.render(qrData, options);
      const buffer = [];
      png.on("error", cb);
      png.on("data", function(data) {
        buffer.push(data);
      });
      png.on("end", function() {
        cb(null, Buffer.concat(buffer));
      });
      png.pack();
    };
    exports.renderToFile = function renderToFile(path, qrData, options, cb) {
      if (typeof cb === "undefined") {
        cb = options;
        options = void 0;
      }
      let called = false;
      const done = (...args) => {
        if (called) return;
        called = true;
        cb.apply(null, args);
      };
      const stream = fs.createWriteStream(path);
      stream.on("error", done);
      stream.on("close", done);
      exports.renderToFileStream(stream, qrData, options);
    };
    exports.renderToFileStream = function renderToFileStream(stream, qrData, options) {
      const png = exports.render(qrData, options);
      png.pack().pipe(stream);
    };
  }
});

// node_modules/qrcode/lib/renderer/utf8.js
var require_utf8 = __commonJS({
  "node_modules/qrcode/lib/renderer/utf8.js"(exports) {
    "use strict";
    var Utils = require_utils2();
    var BLOCK_CHAR = {
      WW: " ",
      WB: "\u2584",
      BB: "\u2588",
      BW: "\u2580"
    };
    var INVERTED_BLOCK_CHAR = {
      BB: " ",
      BW: "\u2584",
      WW: "\u2588",
      WB: "\u2580"
    };
    function getBlockChar(top, bottom, blocks) {
      if (top && bottom) return blocks.BB;
      if (top && !bottom) return blocks.BW;
      if (!top && bottom) return blocks.WB;
      return blocks.WW;
    }
    exports.render = function(qrData, options, cb) {
      const opts = Utils.getOptions(options);
      let blocks = BLOCK_CHAR;
      if (opts.color.dark.hex === "#ffffff" || opts.color.light.hex === "#000000") {
        blocks = INVERTED_BLOCK_CHAR;
      }
      const size = qrData.modules.size;
      const data = qrData.modules.data;
      let output = "";
      let hMargin = Array(size + opts.margin * 2 + 1).join(blocks.WW);
      hMargin = Array(opts.margin / 2 + 1).join(hMargin + "\n");
      const vMargin = Array(opts.margin + 1).join(blocks.WW);
      output += hMargin;
      for (let i = 0; i < size; i += 2) {
        output += vMargin;
        for (let j = 0; j < size; j++) {
          const topModule = data[i * size + j];
          const bottomModule = data[(i + 1) * size + j];
          output += getBlockChar(topModule, bottomModule, blocks);
        }
        output += vMargin + "\n";
      }
      output += hMargin.slice(0, -1);
      if (typeof cb === "function") {
        cb(null, output);
      }
      return output;
    };
    exports.renderToFile = function renderToFile(path, qrData, options, cb) {
      if (typeof cb === "undefined") {
        cb = options;
        options = void 0;
      }
      const fs = __require("fs");
      const utf8 = exports.render(qrData, options);
      fs.writeFile(path, utf8, cb);
    };
  }
});

// node_modules/qrcode/lib/renderer/terminal/terminal.js
var require_terminal = __commonJS({
  "node_modules/qrcode/lib/renderer/terminal/terminal.js"(exports) {
    "use strict";
    exports.render = function(qrData, options, cb) {
      const size = qrData.modules.size;
      const data = qrData.modules.data;
      const black = "\x1B[40m  \x1B[0m";
      const white = "\x1B[47m  \x1B[0m";
      let output = "";
      const hMargin = Array(size + 3).join(white);
      const vMargin = Array(2).join(white);
      output += hMargin + "\n";
      for (let i = 0; i < size; ++i) {
        output += white;
        for (let j = 0; j < size; j++) {
          output += data[i * size + j] ? black : white;
        }
        output += vMargin + "\n";
      }
      output += hMargin + "\n";
      if (typeof cb === "function") {
        cb(null, output);
      }
      return output;
    };
  }
});

// node_modules/qrcode/lib/renderer/terminal/terminal-small.js
var require_terminal_small = __commonJS({
  "node_modules/qrcode/lib/renderer/terminal/terminal-small.js"(exports) {
    "use strict";
    var backgroundWhite = "\x1B[47m";
    var backgroundBlack = "\x1B[40m";
    var foregroundWhite = "\x1B[37m";
    var foregroundBlack = "\x1B[30m";
    var reset = "\x1B[0m";
    var lineSetupNormal = backgroundWhite + foregroundBlack;
    var lineSetupInverse = backgroundBlack + foregroundWhite;
    var createPalette = function(lineSetup, foregroundWhite2, foregroundBlack2) {
      return {
        // 1 ... white, 2 ... black, 0 ... transparent (default)
        "00": reset + " " + lineSetup,
        "01": reset + foregroundWhite2 + "\u2584" + lineSetup,
        "02": reset + foregroundBlack2 + "\u2584" + lineSetup,
        10: reset + foregroundWhite2 + "\u2580" + lineSetup,
        11: " ",
        12: "\u2584",
        20: reset + foregroundBlack2 + "\u2580" + lineSetup,
        21: "\u2580",
        22: "\u2588"
      };
    };
    var mkCodePixel = function(modules, size, x, y) {
      const sizePlus = size + 1;
      if (x >= sizePlus || y >= sizePlus || y < -1 || x < -1) return "0";
      if (x >= size || y >= size || y < 0 || x < 0) return "1";
      const idx = y * size + x;
      return modules[idx] ? "2" : "1";
    };
    var mkCode = function(modules, size, x, y) {
      return mkCodePixel(modules, size, x, y) + mkCodePixel(modules, size, x, y + 1);
    };
    exports.render = function(qrData, options, cb) {
      const size = qrData.modules.size;
      const data = qrData.modules.data;
      const inverse = !!(options && options.inverse);
      const lineSetup = options && options.inverse ? lineSetupInverse : lineSetupNormal;
      const white = inverse ? foregroundBlack : foregroundWhite;
      const black = inverse ? foregroundWhite : foregroundBlack;
      const palette = createPalette(lineSetup, white, black);
      const newLine = reset + "\n" + lineSetup;
      let output = lineSetup;
      for (let y = -1; y < size + 1; y += 2) {
        for (let x = -1; x < size; x++) {
          output += palette[mkCode(data, size, x, y)];
        }
        output += palette[mkCode(data, size, size, y)] + newLine;
      }
      output += reset;
      if (typeof cb === "function") {
        cb(null, output);
      }
      return output;
    };
  }
});

// node_modules/qrcode/lib/renderer/terminal.js
var require_terminal2 = __commonJS({
  "node_modules/qrcode/lib/renderer/terminal.js"(exports) {
    "use strict";
    var big = require_terminal();
    var small = require_terminal_small();
    exports.render = function(qrData, options, cb) {
      if (options && options.small) {
        return small.render(qrData, options, cb);
      }
      return big.render(qrData, options, cb);
    };
  }
});

// node_modules/qrcode/lib/renderer/svg-tag.js
var require_svg_tag = __commonJS({
  "node_modules/qrcode/lib/renderer/svg-tag.js"(exports) {
    "use strict";
    var Utils = require_utils2();
    function getColorAttrib(color2, attrib) {
      const alpha = color2.a / 255;
      const str = attrib + '="' + color2.hex + '"';
      return alpha < 1 ? str + " " + attrib + '-opacity="' + alpha.toFixed(2).slice(1) + '"' : str;
    }
    function svgCmd(cmd, x, y) {
      let str = cmd + x;
      if (typeof y !== "undefined") str += " " + y;
      return str;
    }
    function qrToPath(data, size, margin) {
      let path = "";
      let moveBy = 0;
      let newRow = false;
      let lineLength = 0;
      for (let i = 0; i < data.length; i++) {
        const col = Math.floor(i % size);
        const row = Math.floor(i / size);
        if (!col && !newRow) newRow = true;
        if (data[i]) {
          lineLength++;
          if (!(i > 0 && col > 0 && data[i - 1])) {
            path += newRow ? svgCmd("M", col + margin, 0.5 + row + margin) : svgCmd("m", moveBy, 0);
            moveBy = 0;
            newRow = false;
          }
          if (!(col + 1 < size && data[i + 1])) {
            path += svgCmd("h", lineLength);
            lineLength = 0;
          }
        } else {
          moveBy++;
        }
      }
      return path;
    }
    exports.render = function render(qrData, options, cb) {
      const opts = Utils.getOptions(options);
      const size = qrData.modules.size;
      const data = qrData.modules.data;
      const qrcodesize = size + opts.margin * 2;
      const bg = !opts.color.light.a ? "" : "<path " + getColorAttrib(opts.color.light, "fill") + ' d="M0 0h' + qrcodesize + "v" + qrcodesize + 'H0z"/>';
      const path = "<path " + getColorAttrib(opts.color.dark, "stroke") + ' d="' + qrToPath(data, size, opts.margin) + '"/>';
      const viewBox = 'viewBox="0 0 ' + qrcodesize + " " + qrcodesize + '"';
      const width = !opts.width ? "" : 'width="' + opts.width + '" height="' + opts.width + '" ';
      const svgTag = '<svg xmlns="http://www.w3.org/2000/svg" ' + width + viewBox + ' shape-rendering="crispEdges">' + bg + path + "</svg>\n";
      if (typeof cb === "function") {
        cb(null, svgTag);
      }
      return svgTag;
    };
  }
});

// node_modules/qrcode/lib/renderer/svg.js
var require_svg = __commonJS({
  "node_modules/qrcode/lib/renderer/svg.js"(exports) {
    "use strict";
    var svgTagRenderer = require_svg_tag();
    exports.render = svgTagRenderer.render;
    exports.renderToFile = function renderToFile(path, qrData, options, cb) {
      if (typeof cb === "undefined") {
        cb = options;
        options = void 0;
      }
      const fs = __require("fs");
      const svgTag = exports.render(qrData, options);
      const xmlStr = '<?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">' + svgTag;
      fs.writeFile(path, xmlStr, cb);
    };
  }
});

// node_modules/qrcode/lib/renderer/canvas.js
var require_canvas = __commonJS({
  "node_modules/qrcode/lib/renderer/canvas.js"(exports) {
    "use strict";
    var Utils = require_utils2();
    function clearCanvas(ctx, canvas, size) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (!canvas.style) canvas.style = {};
      canvas.height = size;
      canvas.width = size;
      canvas.style.height = size + "px";
      canvas.style.width = size + "px";
    }
    function getCanvasElement() {
      try {
        return document.createElement("canvas");
      } catch (e2) {
        throw new Error("You need to specify a canvas element");
      }
    }
    exports.render = function render(qrData, canvas, options) {
      let opts = options;
      let canvasEl = canvas;
      if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
        opts = canvas;
        canvas = void 0;
      }
      if (!canvas) {
        canvasEl = getCanvasElement();
      }
      opts = Utils.getOptions(opts);
      const size = Utils.getImageWidth(qrData.modules.size, opts);
      const ctx = canvasEl.getContext("2d");
      const image2 = ctx.createImageData(size, size);
      Utils.qrToImageData(image2.data, qrData, opts);
      clearCanvas(ctx, canvasEl, size);
      ctx.putImageData(image2, 0, 0);
      return canvasEl;
    };
    exports.renderToDataURL = function renderToDataURL(qrData, canvas, options) {
      let opts = options;
      if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
        opts = canvas;
        canvas = void 0;
      }
      if (!opts) opts = {};
      const canvasEl = exports.render(qrData, canvas, opts);
      const type = opts.type || "image/png";
      const rendererOpts = opts.rendererOpts || {};
      return canvasEl.toDataURL(type, rendererOpts.quality);
    };
  }
});

// node_modules/qrcode/lib/browser.js
var require_browser = __commonJS({
  "node_modules/qrcode/lib/browser.js"(exports) {
    "use strict";
    var canPromise = require_can_promise();
    var QRCode = require_qrcode();
    var CanvasRenderer2 = require_canvas();
    var SvgRenderer = require_svg_tag();
    function renderCanvas(renderFunc, canvas, text, opts, cb) {
      const args = [].slice.call(arguments, 1);
      const argsNum = args.length;
      const isLastArgCb = typeof args[argsNum - 1] === "function";
      if (!isLastArgCb && !canPromise()) {
        throw new Error("Callback required as last argument");
      }
      if (isLastArgCb) {
        if (argsNum < 2) {
          throw new Error("Too few arguments provided");
        }
        if (argsNum === 2) {
          cb = text;
          text = canvas;
          canvas = opts = void 0;
        } else if (argsNum === 3) {
          if (canvas.getContext && typeof cb === "undefined") {
            cb = opts;
            opts = void 0;
          } else {
            cb = opts;
            opts = text;
            text = canvas;
            canvas = void 0;
          }
        }
      } else {
        if (argsNum < 1) {
          throw new Error("Too few arguments provided");
        }
        if (argsNum === 1) {
          text = canvas;
          canvas = opts = void 0;
        } else if (argsNum === 2 && !canvas.getContext) {
          opts = text;
          text = canvas;
          canvas = void 0;
        }
        return new Promise(function(resolve, reject) {
          try {
            const data = QRCode.create(text, opts);
            resolve(renderFunc(data, canvas, opts));
          } catch (e2) {
            reject(e2);
          }
        });
      }
      try {
        const data = QRCode.create(text, opts);
        cb(null, renderFunc(data, canvas, opts));
      } catch (e2) {
        cb(e2);
      }
    }
    exports.create = QRCode.create;
    exports.toCanvas = renderCanvas.bind(null, CanvasRenderer2.render);
    exports.toDataURL = renderCanvas.bind(null, CanvasRenderer2.renderToDataURL);
    exports.toString = renderCanvas.bind(null, function(data, _, opts) {
      return SvgRenderer.render(data, opts);
    });
  }
});

// node_modules/qrcode/lib/server.js
var require_server = __commonJS({
  "node_modules/qrcode/lib/server.js"(exports) {
    "use strict";
    var canPromise = require_can_promise();
    var QRCode = require_qrcode();
    var PngRenderer = require_png2();
    var Utf8Renderer = require_utf8();
    var TerminalRenderer = require_terminal2();
    var SvgRenderer = require_svg();
    function checkParams(text, opts, cb) {
      if (typeof text === "undefined") {
        throw new Error("String required as first argument");
      }
      if (typeof cb === "undefined") {
        cb = opts;
        opts = {};
      }
      if (typeof cb !== "function") {
        if (!canPromise()) {
          throw new Error("Callback required as last argument");
        } else {
          opts = cb || {};
          cb = null;
        }
      }
      return {
        opts,
        cb
      };
    }
    function getTypeFromFilename(path) {
      return path.slice((path.lastIndexOf(".") - 1 >>> 0) + 2).toLowerCase();
    }
    function getRendererFromType(type) {
      switch (type) {
        case "svg":
          return SvgRenderer;
        case "txt":
        case "utf8":
          return Utf8Renderer;
        case "png":
        case "image/png":
        default:
          return PngRenderer;
      }
    }
    function getStringRendererFromType(type) {
      switch (type) {
        case "svg":
          return SvgRenderer;
        case "terminal":
          return TerminalRenderer;
        case "utf8":
        default:
          return Utf8Renderer;
      }
    }
    function render(renderFunc, text, params) {
      if (!params.cb) {
        return new Promise(function(resolve, reject) {
          try {
            const data = QRCode.create(text, params.opts);
            return renderFunc(data, params.opts, function(err2, data2) {
              return err2 ? reject(err2) : resolve(data2);
            });
          } catch (e2) {
            reject(e2);
          }
        });
      }
      try {
        const data = QRCode.create(text, params.opts);
        return renderFunc(data, params.opts, params.cb);
      } catch (e2) {
        params.cb(e2);
      }
    }
    exports.create = QRCode.create;
    exports.toCanvas = require_browser().toCanvas;
    exports.toString = function toString3(text, opts, cb) {
      const params = checkParams(text, opts, cb);
      const type = params.opts ? params.opts.type : void 0;
      const renderer = getStringRendererFromType(type);
      return render(renderer.render, text, params);
    };
    exports.toDataURL = function toDataURL2(text, opts, cb) {
      const params = checkParams(text, opts, cb);
      const renderer = getRendererFromType(params.opts.type);
      return render(renderer.renderToDataURL, text, params);
    };
    exports.toBuffer = function toBuffer(text, opts, cb) {
      const params = checkParams(text, opts, cb);
      const renderer = getRendererFromType(params.opts.type);
      return render(renderer.renderToBuffer, text, params);
    };
    exports.toFile = function toFile(path, text, opts, cb) {
      if (typeof path !== "string" || !(typeof text === "string" || typeof text === "object")) {
        throw new Error("Invalid argument");
      }
      if (arguments.length < 3 && !canPromise()) {
        throw new Error("Too few arguments provided");
      }
      const params = checkParams(text, opts, cb);
      const type = params.opts.type || getTypeFromFilename(path);
      const renderer = getRendererFromType(type);
      const renderToFile = renderer.renderToFile.bind(null, path);
      return render(renderToFile, text, params);
    };
    exports.toFileStream = function toFileStream(stream, text, opts) {
      if (arguments.length < 2) {
        throw new Error("Too few arguments provided");
      }
      const params = checkParams(text, opts, stream.emit.bind(stream, "error"));
      const renderer = getRendererFromType("png");
      const renderToFileStream = renderer.renderToFileStream.bind(null, stream);
      render(renderToFileStream, text, params);
    };
  }
});

// node_modules/qrcode/lib/index.js
var require_lib = __commonJS({
  "node_modules/qrcode/lib/index.js"(exports, module) {
    "use strict";
    module.exports = require_server();
  }
});

// node_modules/fflate/lib/node.cjs
var require_node = __commonJS({
  "node_modules/fflate/lib/node.cjs"(exports) {
    "use strict";
    var Worker;
    var workerAdd = ";var __w=require('worker_threads');__w.parentPort.on('message',function(m){onmessage({data:m})}),postMessage=function(m,t){__w.parentPort.postMessage(m,t)},close=process.exit;self=global";
    try {
      Worker = __require("worker_threads").Worker;
    } catch (e2) {
    }
    var node_worker_1 = {};
    node_worker_1["default"] = Worker ? function(c, _, msg, transfer, cb) {
      var done = false;
      var w = new Worker(c + workerAdd, { eval: true }).on("error", function(e2) {
        return cb(e2, null);
      }).on("message", function(m) {
        return cb(null, m);
      }).on("exit", function(c2) {
        if (c2 && !done)
          cb(new Error("exited with code " + c2), null);
      });
      w.postMessage(msg, transfer);
      w.terminate = function() {
        done = true;
        return Worker.prototype.terminate.call(w);
      };
      return w;
    } : function(_, __, ___, ____, cb) {
      setImmediate(function() {
        return cb(new Error("async operations unsupported - update to Node 12+ (or Node 10-11 with the --experimental-worker CLI flag)"), null);
      });
      var NOP = function() {
      };
      return {
        terminate: NOP,
        postMessage: NOP
      };
    };
    var u8 = Uint8Array;
    var u16 = Uint16Array;
    var i32 = Int32Array;
    var fleb = new u8([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      2,
      3,
      3,
      3,
      3,
      4,
      4,
      4,
      4,
      5,
      5,
      5,
      5,
      0,
      /* unused */
      0,
      0,
      /* impossible */
      0
    ]);
    var fdeb = new u8([
      0,
      0,
      0,
      0,
      1,
      1,
      2,
      2,
      3,
      3,
      4,
      4,
      5,
      5,
      6,
      6,
      7,
      7,
      8,
      8,
      9,
      9,
      10,
      10,
      11,
      11,
      12,
      12,
      13,
      13,
      /* unused */
      0,
      0
    ]);
    var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    var freb = function(eb, start) {
      var b = new u16(31);
      for (var i2 = 0; i2 < 31; ++i2) {
        b[i2] = start += 1 << eb[i2 - 1];
      }
      var r = new i32(b[30]);
      for (var i2 = 1; i2 < 30; ++i2) {
        for (var j = b[i2]; j < b[i2 + 1]; ++j) {
          r[j] = j - b[i2] << 5 | i2;
        }
      }
      return { b, r };
    };
    var _a2 = freb(fleb, 2);
    var fl = _a2.b;
    var revfl = _a2.r;
    fl[28] = 258, revfl[258] = 28;
    var _b = freb(fdeb, 0);
    var fd = _b.b;
    var revfd = _b.r;
    var rev = new u16(32768);
    for (i = 0; i < 32768; ++i) {
      x = (i & 43690) >> 1 | (i & 21845) << 1;
      x = (x & 52428) >> 2 | (x & 13107) << 2;
      x = (x & 61680) >> 4 | (x & 3855) << 4;
      rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;
    }
    var x;
    var i;
    var hMap = (function(cd, mb, r) {
      var s = cd.length;
      var i2 = 0;
      var l = new u16(mb);
      for (; i2 < s; ++i2) {
        if (cd[i2])
          ++l[cd[i2] - 1];
      }
      var le = new u16(mb);
      for (i2 = 1; i2 < mb; ++i2) {
        le[i2] = le[i2 - 1] + l[i2 - 1] << 1;
      }
      var co;
      if (r) {
        co = new u16(1 << mb);
        var rvb = 15 - mb;
        for (i2 = 0; i2 < s; ++i2) {
          if (cd[i2]) {
            var sv = i2 << 4 | cd[i2];
            var r_1 = mb - cd[i2];
            var v = le[cd[i2] - 1]++ << r_1;
            for (var m = v | (1 << r_1) - 1; v <= m; ++v) {
              co[rev[v] >> rvb] = sv;
            }
          }
        }
      } else {
        co = new u16(s);
        for (i2 = 0; i2 < s; ++i2) {
          if (cd[i2]) {
            co[i2] = rev[le[cd[i2] - 1]++] >> 15 - cd[i2];
          }
        }
      }
      return co;
    });
    var flt = new u8(288);
    for (i = 0; i < 144; ++i)
      flt[i] = 8;
    var i;
    for (i = 144; i < 256; ++i)
      flt[i] = 9;
    var i;
    for (i = 256; i < 280; ++i)
      flt[i] = 7;
    var i;
    for (i = 280; i < 288; ++i)
      flt[i] = 8;
    var i;
    var fdt = new u8(32);
    for (i = 0; i < 32; ++i)
      fdt[i] = 5;
    var i;
    var flm = /* @__PURE__ */ hMap(flt, 9, 0);
    var flrm = /* @__PURE__ */ hMap(flt, 9, 1);
    var fdm = /* @__PURE__ */ hMap(fdt, 5, 0);
    var fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);
    var max = function(a2) {
      var m = a2[0];
      for (var i2 = 1; i2 < a2.length; ++i2) {
        if (a2[i2] > m)
          m = a2[i2];
      }
      return m;
    };
    var bits = function(d, p, m) {
      var o = p / 8 | 0;
      return (d[o] | d[o + 1] << 8) >> (p & 7) & m;
    };
    var bits16 = function(d, p) {
      var o = p / 8 | 0;
      return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);
    };
    var shft = function(p) {
      return (p + 7) / 8 | 0;
    };
    var slc = function(v, s, e2) {
      if (s == null || s < 0)
        s = 0;
      if (e2 == null || e2 > v.length)
        e2 = v.length;
      return new u8(v.subarray(s, e2));
    };
    exports.FlateErrorCode = {
      UnexpectedEOF: 0,
      InvalidBlockType: 1,
      InvalidLengthLiteral: 2,
      InvalidDistance: 3,
      StreamFinished: 4,
      NoStreamHandler: 5,
      InvalidHeader: 6,
      NoCallback: 7,
      InvalidUTF8: 8,
      ExtraFieldTooLong: 9,
      InvalidDate: 10,
      FilenameTooLong: 11,
      StreamFinishing: 12,
      InvalidZipData: 13,
      UnknownCompressionMethod: 14
    };
    var ec = [
      "unexpected EOF",
      "invalid block type",
      "invalid length/literal",
      "invalid distance",
      "stream finished",
      "no stream handler",
      ,
      "no callback",
      "invalid UTF-8 data",
      "extra field too long",
      "date not in range 1980-2099",
      "filename too long",
      "stream finishing",
      "invalid zip data"
      // determined by unknown compression method
    ];
    var err2 = function(ind, msg, nt) {
      var e2 = new Error(msg || ec[ind]);
      e2.code = ind;
      if (Error.captureStackTrace)
        Error.captureStackTrace(e2, err2);
      if (!nt)
        throw e2;
      return e2;
    };
    var inflt = function(dat, st, buf, dict) {
      var sl = dat.length, dl = dict ? dict.length : 0;
      if (!sl || st.f && !st.l)
        return buf || new u8(0);
      var noBuf = !buf;
      var resize = noBuf || st.i != 2;
      var noSt = st.i;
      if (noBuf)
        buf = new u8(sl * 3);
      var cbuf = function(l2) {
        var bl = buf.length;
        if (l2 > bl) {
          var nbuf = new u8(Math.max(bl * 2, l2));
          nbuf.set(buf);
          buf = nbuf;
        }
      };
      var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
      var tbts = sl * 8;
      do {
        if (!lm) {
          final = bits(dat, pos, 1);
          var type = bits(dat, pos + 1, 3);
          pos += 3;
          if (!type) {
            var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;
            if (t > sl) {
              if (noSt)
                err2(0);
              break;
            }
            if (resize)
              cbuf(bt + l);
            buf.set(dat.subarray(s, t), bt);
            st.b = bt += l, st.p = pos = t * 8, st.f = final;
            continue;
          } else if (type == 1)
            lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
          else if (type == 2) {
            var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
            var tl = hLit + bits(dat, pos + 5, 31) + 1;
            pos += 14;
            var ldt = new u8(tl);
            var clt = new u8(19);
            for (var i2 = 0; i2 < hcLen; ++i2) {
              clt[clim[i2]] = bits(dat, pos + i2 * 3, 7);
            }
            pos += hcLen * 3;
            var clb = max(clt), clbmsk = (1 << clb) - 1;
            var clm = hMap(clt, clb, 1);
            for (var i2 = 0; i2 < tl; ) {
              var r = clm[bits(dat, pos, clbmsk)];
              pos += r & 15;
              var s = r >> 4;
              if (s < 16) {
                ldt[i2++] = s;
              } else {
                var c = 0, n = 0;
                if (s == 16)
                  n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i2 - 1];
                else if (s == 17)
                  n = 3 + bits(dat, pos, 7), pos += 3;
                else if (s == 18)
                  n = 11 + bits(dat, pos, 127), pos += 7;
                while (n--)
                  ldt[i2++] = c;
              }
            }
            var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
            lbt = max(lt);
            dbt = max(dt);
            lm = hMap(lt, lbt, 1);
            dm = hMap(dt, dbt, 1);
          } else
            err2(1);
          if (pos > tbts) {
            if (noSt)
              err2(0);
            break;
          }
        }
        if (resize)
          cbuf(bt + 131072);
        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
        var lpos = pos;
        for (; ; lpos = pos) {
          var c = lm[bits16(dat, pos) & lms], sym = c >> 4;
          pos += c & 15;
          if (pos > tbts) {
            if (noSt)
              err2(0);
            break;
          }
          if (!c)
            err2(2);
          if (sym < 256)
            buf[bt++] = sym;
          else if (sym == 256) {
            lpos = pos, lm = null;
            break;
          } else {
            var add = sym - 254;
            if (sym > 264) {
              var i2 = sym - 257, b = fleb[i2];
              add = bits(dat, pos, (1 << b) - 1) + fl[i2];
              pos += b;
            }
            var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;
            if (!d)
              err2(3);
            pos += d & 15;
            var dt = fd[dsym];
            if (dsym > 3) {
              var b = fdeb[dsym];
              dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
            }
            if (pos > tbts) {
              if (noSt)
                err2(0);
              break;
            }
            if (resize)
              cbuf(bt + 131072);
            var end = bt + add;
            if (bt < dt) {
              var shift = dl - dt, dend = Math.min(dt, end);
              if (shift + bt < 0)
                err2(3);
              for (; bt < dend; ++bt)
                buf[bt] = dict[shift + bt];
            }
            for (; bt < end; ++bt)
              buf[bt] = buf[bt - dt];
          }
        }
        st.l = lm, st.p = lpos, st.b = bt, st.f = final;
        if (lm)
          final = 1, st.m = lbt, st.d = dm, st.n = dbt;
      } while (!final);
      return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);
    };
    var wbits = function(d, p, v) {
      v <<= p & 7;
      var o = p / 8 | 0;
      d[o] |= v;
      d[o + 1] |= v >> 8;
    };
    var wbits16 = function(d, p, v) {
      v <<= p & 7;
      var o = p / 8 | 0;
      d[o] |= v;
      d[o + 1] |= v >> 8;
      d[o + 2] |= v >> 16;
    };
    var hTree = function(d, mb) {
      var t = [];
      for (var i2 = 0; i2 < d.length; ++i2) {
        if (d[i2])
          t.push({ s: i2, f: d[i2] });
      }
      var s = t.length;
      var t2 = t.slice();
      if (!s)
        return { t: et, l: 0 };
      if (s == 1) {
        var v = new u8(t[0].s + 1);
        v[t[0].s] = 1;
        return { t: v, l: 1 };
      }
      t.sort(function(a2, b) {
        return a2.f - b.f;
      });
      t.push({ s: -1, f: 25001 });
      var l = t[0], r = t[1], i0 = 0, i1 = 1, i22 = 2;
      t[0] = { s: -1, f: l.f + r.f, l, r };
      while (i1 != s - 1) {
        l = t[t[i0].f < t[i22].f ? i0++ : i22++];
        r = t[i0 != i1 && t[i0].f < t[i22].f ? i0++ : i22++];
        t[i1++] = { s: -1, f: l.f + r.f, l, r };
      }
      var maxSym = t2[0].s;
      for (var i2 = 1; i2 < s; ++i2) {
        if (t2[i2].s > maxSym)
          maxSym = t2[i2].s;
      }
      var tr = new u16(maxSym + 1);
      var mbt = ln(t[i1 - 1], tr, 0);
      if (mbt > mb) {
        var i2 = 0, dt = 0;
        var lft = mbt - mb, cst = 1 << lft;
        t2.sort(function(a2, b) {
          return tr[b.s] - tr[a2.s] || a2.f - b.f;
        });
        for (; i2 < s; ++i2) {
          var i2_1 = t2[i2].s;
          if (tr[i2_1] > mb) {
            dt += cst - (1 << mbt - tr[i2_1]);
            tr[i2_1] = mb;
          } else
            break;
        }
        dt >>= lft;
        while (dt > 0) {
          var i2_2 = t2[i2].s;
          if (tr[i2_2] < mb)
            dt -= 1 << mb - tr[i2_2]++ - 1;
          else
            ++i2;
        }
        for (; i2 >= 0 && dt; --i2) {
          var i2_3 = t2[i2].s;
          if (tr[i2_3] == mb) {
            --tr[i2_3];
            ++dt;
          }
        }
        mbt = mb;
      }
      return { t: new u8(tr), l: mbt };
    };
    var ln = function(n, l, d) {
      return n.s == -1 ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1)) : l[n.s] = d;
    };
    var lc = function(c) {
      var s = c.length;
      while (s && !c[--s])
        ;
      var cl = new u16(++s);
      var cli = 0, cln = c[0], cls = 1;
      var w = function(v) {
        cl[cli++] = v;
      };
      for (var i2 = 1; i2 <= s; ++i2) {
        if (c[i2] == cln && i2 != s)
          ++cls;
        else {
          if (!cln && cls > 2) {
            for (; cls > 138; cls -= 138)
              w(32754);
            if (cls > 2) {
              w(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);
              cls = 0;
            }
          } else if (cls > 3) {
            w(cln), --cls;
            for (; cls > 6; cls -= 6)
              w(8304);
            if (cls > 2)
              w(cls - 3 << 5 | 8208), cls = 0;
          }
          while (cls--)
            w(cln);
          cls = 1;
          cln = c[i2];
        }
      }
      return { c: cl.subarray(0, cli), n: s };
    };
    var clen = function(cf, cl) {
      var l = 0;
      for (var i2 = 0; i2 < cl.length; ++i2)
        l += cf[i2] * cl[i2];
      return l;
    };
    var wfblk = function(out, pos, dat) {
      var s = dat.length;
      var o = shft(pos + 2);
      out[o] = s & 255;
      out[o + 1] = s >> 8;
      out[o + 2] = out[o] ^ 255;
      out[o + 3] = out[o + 1] ^ 255;
      for (var i2 = 0; i2 < s; ++i2)
        out[o + i2 + 4] = dat[i2];
      return (o + 4 + s) * 8;
    };
    var wblk = function(dat, out, final, syms, lf, df, eb, li, bs, bl, p) {
      wbits(out, p++, final);
      ++lf[256];
      var _a3 = hTree(lf, 15), dlt = _a3.t, mlb = _a3.l;
      var _b2 = hTree(df, 15), ddt = _b2.t, mdb = _b2.l;
      var _c = lc(dlt), lclt = _c.c, nlc = _c.n;
      var _d = lc(ddt), lcdt = _d.c, ndc = _d.n;
      var lcfreq = new u16(19);
      for (var i2 = 0; i2 < lclt.length; ++i2)
        ++lcfreq[lclt[i2] & 31];
      for (var i2 = 0; i2 < lcdt.length; ++i2)
        ++lcfreq[lcdt[i2] & 31];
      var _e = hTree(lcfreq, 7), lct = _e.t, mlcb = _e.l;
      var nlcc = 19;
      for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)
        ;
      var flen = bl + 5 << 3;
      var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
      var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + 2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18];
      if (bs >= 0 && flen <= ftlen && flen <= dtlen)
        return wfblk(out, p, dat.subarray(bs, bs + bl));
      var lm, ll, dm, dl;
      wbits(out, p, 1 + (dtlen < ftlen)), p += 2;
      if (dtlen < ftlen) {
        lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
        var llm = hMap(lct, mlcb, 0);
        wbits(out, p, nlc - 257);
        wbits(out, p + 5, ndc - 1);
        wbits(out, p + 10, nlcc - 4);
        p += 14;
        for (var i2 = 0; i2 < nlcc; ++i2)
          wbits(out, p + 3 * i2, lct[clim[i2]]);
        p += 3 * nlcc;
        var lcts = [lclt, lcdt];
        for (var it = 0; it < 2; ++it) {
          var clct = lcts[it];
          for (var i2 = 0; i2 < clct.length; ++i2) {
            var len = clct[i2] & 31;
            wbits(out, p, llm[len]), p += lct[len];
            if (len > 15)
              wbits(out, p, clct[i2] >> 5 & 127), p += clct[i2] >> 12;
          }
        }
      } else {
        lm = flm, ll = flt, dm = fdm, dl = fdt;
      }
      for (var i2 = 0; i2 < li; ++i2) {
        var sym = syms[i2];
        if (sym > 255) {
          var len = sym >> 18 & 31;
          wbits16(out, p, lm[len + 257]), p += ll[len + 257];
          if (len > 7)
            wbits(out, p, sym >> 23 & 31), p += fleb[len];
          var dst = sym & 31;
          wbits16(out, p, dm[dst]), p += dl[dst];
          if (dst > 3)
            wbits16(out, p, sym >> 5 & 8191), p += fdeb[dst];
        } else {
          wbits16(out, p, lm[sym]), p += ll[sym];
        }
      }
      wbits16(out, p, lm[256]);
      return p + ll[256];
    };
    var deo = /* @__PURE__ */ new i32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);
    var et = /* @__PURE__ */ new u8(0);
    var dflt = function(dat, lvl, plvl, pre, post, st) {
      var s = st.z || dat.length;
      var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7e3)) + post);
      var w = o.subarray(pre, o.length - post);
      var lst = st.l;
      var pos = (st.r || 0) & 7;
      if (lvl) {
        if (pos)
          w[0] = st.r >> 3;
        var opt = deo[lvl - 1];
        var n = opt >> 13, c = opt & 8191;
        var msk_1 = (1 << plvl) - 1;
        var prev = st.p || new u16(32768), head = st.h || new u16(msk_1 + 1);
        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;
        var hsh = function(i3) {
          return (dat[i3] ^ dat[i3 + 1] << bs1_1 ^ dat[i3 + 2] << bs2_1) & msk_1;
        };
        var syms = new i32(25e3);
        var lf = new u16(288), df = new u16(32);
        var lc_1 = 0, eb = 0, i2 = st.i || 0, li = 0, wi = st.w || 0, bs = 0;
        for (; i2 + 2 < s; ++i2) {
          var hv = hsh(i2);
          var imod = i2 & 32767, pimod = head[hv];
          prev[imod] = pimod;
          head[hv] = imod;
          if (wi <= i2) {
            var rem = s - i2;
            if ((lc_1 > 7e3 || li > 24576) && (rem > 423 || !lst)) {
              pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i2 - bs, pos);
              li = lc_1 = eb = 0, bs = i2;
              for (var j = 0; j < 286; ++j)
                lf[j] = 0;
              for (var j = 0; j < 30; ++j)
                df[j] = 0;
            }
            var l = 2, d = 0, ch_1 = c, dif = imod - pimod & 32767;
            if (rem > 2 && hv == hsh(i2 - dif)) {
              var maxn = Math.min(n, rem) - 1;
              var maxd = Math.min(32767, i2);
              var ml = Math.min(258, rem);
              while (dif <= maxd && --ch_1 && imod != pimod) {
                if (dat[i2 + l] == dat[i2 + l - dif]) {
                  var nl = 0;
                  for (; nl < ml && dat[i2 + nl] == dat[i2 + nl - dif]; ++nl)
                    ;
                  if (nl > l) {
                    l = nl, d = dif;
                    if (nl > maxn)
                      break;
                    var mmd = Math.min(dif, nl - 2);
                    var md = 0;
                    for (var j = 0; j < mmd; ++j) {
                      var ti = i2 - dif + j & 32767;
                      var pti = prev[ti];
                      var cd = ti - pti & 32767;
                      if (cd > md)
                        md = cd, pimod = ti;
                    }
                  }
                }
                imod = pimod, pimod = prev[imod];
                dif += imod - pimod & 32767;
              }
            }
            if (d) {
              syms[li++] = 268435456 | revfl[l] << 18 | revfd[d];
              var lin = revfl[l] & 31, din = revfd[d] & 31;
              eb += fleb[lin] + fdeb[din];
              ++lf[257 + lin];
              ++df[din];
              wi = i2 + l;
              ++lc_1;
            } else {
              syms[li++] = dat[i2];
              ++lf[dat[i2]];
            }
          }
        }
        for (i2 = Math.max(i2, wi); i2 < s; ++i2) {
          syms[li++] = dat[i2];
          ++lf[dat[i2]];
        }
        pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i2 - bs, pos);
        if (!lst) {
          st.r = pos & 7 | w[pos / 8 | 0] << 3;
          pos -= 7;
          st.h = head, st.p = prev, st.i = i2, st.w = wi;
        }
      } else {
        for (var i2 = st.w || 0; i2 < s + lst; i2 += 65535) {
          var e2 = i2 + 65535;
          if (e2 >= s) {
            w[pos / 8 | 0] = lst;
            e2 = s;
          }
          pos = wfblk(w, pos + 1, dat.subarray(i2, e2));
        }
        st.i = s;
      }
      return slc(o, 0, pre + shft(pos) + post);
    };
    var crct = /* @__PURE__ */ (function() {
      var t = new Int32Array(256);
      for (var i2 = 0; i2 < 256; ++i2) {
        var c = i2, k = 9;
        while (--k)
          c = (c & 1 && -306674912) ^ c >>> 1;
        t[i2] = c;
      }
      return t;
    })();
    var crc2 = function() {
      var c = -1;
      return {
        p: function(d) {
          var cr = c;
          for (var i2 = 0; i2 < d.length; ++i2)
            cr = crct[cr & 255 ^ d[i2]] ^ cr >>> 8;
          c = cr;
        },
        d: function() {
          return ~c;
        }
      };
    };
    var adler = function() {
      var a2 = 1, b = 0;
      return {
        p: function(d) {
          var n = a2, m = b;
          var l = d.length | 0;
          for (var i2 = 0; i2 != l; ) {
            var e2 = Math.min(i2 + 2655, l);
            for (; i2 < e2; ++i2)
              m += n += d[i2];
            n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);
          }
          a2 = n, b = m;
        },
        d: function() {
          a2 %= 65521, b %= 65521;
          return (a2 & 255) << 24 | (a2 & 65280) << 8 | (b & 255) << 8 | b >> 8;
        }
      };
    };
    var dopt = function(dat, opt, pre, post, st) {
      if (!st) {
        st = { l: 1 };
        if (opt.dictionary) {
          var dict = opt.dictionary.subarray(-32768);
          var newDat = new u8(dict.length + dat.length);
          newDat.set(dict);
          newDat.set(dat, dict.length);
          dat = newDat;
          st.w = dict.length;
        }
      }
      return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? st.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 20 : 12 + opt.mem, pre, post, st);
    };
    var mrg = function(a2, b) {
      var o = {};
      for (var k in a2)
        o[k] = a2[k];
      for (var k in b)
        o[k] = b[k];
      return o;
    };
    var wcln = function(fn, fnStr, td2) {
      var dt = fn();
      var st = fn.toString();
      var ks = st.slice(st.indexOf("[") + 1, st.lastIndexOf("]")).replace(/\s+/g, "").split(",");
      for (var i2 = 0; i2 < dt.length; ++i2) {
        var v = dt[i2], k = ks[i2];
        if (typeof v == "function") {
          fnStr += ";" + k + "=";
          var st_1 = v.toString();
          if (v.prototype) {
            if (st_1.indexOf("[native code]") != -1) {
              var spInd = st_1.indexOf(" ", 8) + 1;
              fnStr += st_1.slice(spInd, st_1.indexOf("(", spInd));
            } else {
              fnStr += st_1;
              for (var t in v.prototype)
                fnStr += ";" + k + ".prototype." + t + "=" + v.prototype[t].toString();
            }
          } else
            fnStr += st_1;
        } else
          td2[k] = v;
      }
      return fnStr;
    };
    var ch = [];
    var cbfs = function(v) {
      var tl = [];
      for (var k in v) {
        if (v[k].buffer) {
          tl.push((v[k] = new v[k].constructor(v[k])).buffer);
        }
      }
      return tl;
    };
    var wrkr = function(fns, init, id, cb) {
      if (!ch[id]) {
        var fnStr = "", td_1 = {}, m = fns.length - 1;
        for (var i2 = 0; i2 < m; ++i2)
          fnStr = wcln(fns[i2], fnStr, td_1);
        ch[id] = { c: wcln(fns[m], fnStr, td_1), e: td_1 };
      }
      var td2 = mrg({}, ch[id].e);
      return (0, node_worker_1.default)(ch[id].c + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + init.toString() + "}", id, td2, cbfs(td2), cb);
    };
    var bInflt = function() {
      return [u8, u16, i32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, ec, hMap, max, bits, bits16, shft, slc, err2, inflt, inflateSync, pbf, gopt];
    };
    var bDflt = function() {
      return [u8, u16, i32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf];
    };
    var gze = function() {
      return [gzh, gzhl, wbytes, crc2, crct];
    };
    var guze = function() {
      return [gzs, gzl];
    };
    var zle = function() {
      return [zlh, wbytes, adler];
    };
    var zule = function() {
      return [zls];
    };
    var pbf = function(msg) {
      return postMessage(msg, [msg.buffer]);
    };
    var gopt = function(o) {
      return o && {
        out: o.size && new u8(o.size),
        dictionary: o.dictionary
      };
    };
    var cbify = function(dat, opts, fns, init, id, cb) {
      var w = wrkr(fns, init, id, function(err3, dat2) {
        w.terminate();
        cb(err3, dat2);
      });
      w.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);
      return function() {
        w.terminate();
      };
    };
    var astrm = function(strm) {
      strm.ondata = function(dat, final) {
        return postMessage([dat, final], [dat.buffer]);
      };
      return function(ev) {
        if (ev.data.length) {
          strm.push(ev.data[0], ev.data[1]);
          postMessage([ev.data[0].length]);
        } else
          strm.flush();
      };
    };
    var astrmify = function(fns, strm, opts, init, id, flush, ext) {
      var t;
      var w = wrkr(fns, init, id, function(err3, dat) {
        if (err3)
          w.terminate(), strm.ondata.call(strm, err3);
        else if (!Array.isArray(dat))
          ext(dat);
        else if (dat.length == 1) {
          strm.queuedSize -= dat[0];
          if (strm.ondrain)
            strm.ondrain(dat[0]);
        } else {
          if (dat[1])
            w.terminate();
          strm.ondata.call(strm, err3, dat[0], dat[1]);
        }
      });
      w.postMessage(opts);
      strm.queuedSize = 0;
      strm.push = function(d, f2) {
        if (!strm.ondata)
          err2(5);
        if (t)
          strm.ondata(err2(4, 0, 1), null, !!f2);
        strm.queuedSize += d.length;
        w.postMessage([d, t = f2], [d.buffer]);
      };
      strm.terminate = function() {
        w.terminate();
      };
      if (flush) {
        strm.flush = function() {
          w.postMessage([]);
        };
      }
    };
    var b2 = function(d, b) {
      return d[b] | d[b + 1] << 8;
    };
    var b4 = function(d, b) {
      return (d[b] | d[b + 1] << 8 | d[b + 2] << 16 | d[b + 3] << 24) >>> 0;
    };
    var b8 = function(d, b) {
      return b4(d, b) + b4(d, b + 4) * 4294967296;
    };
    var wbytes = function(d, b, v) {
      for (; v; ++b)
        d[b] = v, v >>>= 8;
    };
    var gzh = function(c, o) {
      var fn = o.filename;
      c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3;
      if (o.mtime != 0)
        wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1e3));
      if (fn) {
        c[3] = 8;
        for (var i2 = 0; i2 <= fn.length; ++i2)
          c[i2 + 10] = fn.charCodeAt(i2);
      }
    };
    var gzs = function(d) {
      if (d[0] != 31 || d[1] != 139 || d[2] != 8)
        err2(6, "invalid gzip data");
      var flg = d[3];
      var st = 10;
      if (flg & 4)
        st += (d[10] | d[11] << 8) + 2;
      for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])
        ;
      return st + (flg & 2);
    };
    var gzl = function(d) {
      var l = d.length;
      return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;
    };
    var gzhl = function(o) {
      return 10 + (o.filename ? o.filename.length + 1 : 0);
    };
    var zlh = function(c, o) {
      var lv = o.level, fl2 = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;
      c[0] = 120, c[1] = fl2 << 6 | (o.dictionary && 32);
      c[1] |= 31 - (c[0] << 8 | c[1]) % 31;
      if (o.dictionary) {
        var h = adler();
        h.p(o.dictionary);
        wbytes(c, 2, h.d());
      }
    };
    var zls = function(d, dict) {
      if ((d[0] & 15) != 8 || d[0] >> 4 > 7 || (d[0] << 8 | d[1]) % 31)
        err2(6, "invalid zlib data");
      if ((d[1] >> 5 & 1) == +!dict)
        err2(6, "invalid zlib data: " + (d[1] & 32 ? "need" : "unexpected") + " dictionary");
      return (d[1] >> 3 & 4) + 2;
    };
    function StrmOpt(opts, cb) {
      if (typeof opts == "function")
        cb = opts, opts = {};
      this.ondata = cb;
      return opts;
    }
    var Deflate2 = /* @__PURE__ */ (function() {
      function Deflate3(opts, cb) {
        if (typeof opts == "function")
          cb = opts, opts = {};
        this.ondata = cb;
        this.o = opts || {};
        this.s = { l: 0, i: 32768, w: 32768, z: 32768 };
        this.b = new u8(98304);
        if (this.o.dictionary) {
          var dict = this.o.dictionary.subarray(-32768);
          this.b.set(dict, 32768 - dict.length);
          this.s.i = 32768 - dict.length;
        }
      }
      Deflate3.prototype.p = function(c, f2) {
        this.ondata(dopt(c, this.o, 0, 0, this.s), f2);
      };
      Deflate3.prototype.push = function(chunk, final) {
        if (!this.ondata)
          err2(5);
        if (this.s.l)
          err2(4);
        var endLen = chunk.length + this.s.z;
        if (endLen > this.b.length) {
          if (endLen > 2 * this.b.length - 32768) {
            var newBuf = new u8(endLen & -32768);
            newBuf.set(this.b.subarray(0, this.s.z));
            this.b = newBuf;
          }
          var split = this.b.length - this.s.z;
          this.b.set(chunk.subarray(0, split), this.s.z);
          this.s.z = this.b.length;
          this.p(this.b, false);
          this.b.set(this.b.subarray(-32768));
          this.b.set(chunk.subarray(split), 32768);
          this.s.z = chunk.length - split + 32768;
          this.s.i = 32766, this.s.w = 32768;
        } else {
          this.b.set(chunk, this.s.z);
          this.s.z += chunk.length;
        }
        this.s.l = final & 1;
        if (this.s.z > this.s.w + 8191 || final) {
          this.p(this.b, final || false);
          this.s.w = this.s.i, this.s.i -= 2;
        }
      };
      Deflate3.prototype.flush = function() {
        if (!this.ondata)
          err2(5);
        if (this.s.l)
          err2(4);
        this.p(this.b, false);
        this.s.w = this.s.i, this.s.i -= 2;
      };
      return Deflate3;
    })();
    exports.Deflate = Deflate2;
    var AsyncDeflate = /* @__PURE__ */ (function() {
      function AsyncDeflate2(opts, cb) {
        astrmify([
          bDflt,
          function() {
            return [astrm, Deflate2];
          }
        ], this, StrmOpt.call(this, opts, cb), function(ev) {
          var strm = new Deflate2(ev.data);
          onmessage = astrm(strm);
        }, 6, 1);
      }
      return AsyncDeflate2;
    })();
    exports.AsyncDeflate = AsyncDeflate;
    function deflate2(data, opts, cb) {
      if (!cb)
        cb = opts, opts = {};
      if (typeof cb != "function")
        err2(7);
      return cbify(data, opts, [
        bDflt
      ], function(ev) {
        return pbf(deflateSync(ev.data[0], ev.data[1]));
      }, 0, cb);
    }
    exports.deflate = deflate2;
    function deflateSync(data, opts) {
      return dopt(data, opts || {}, 0, 0);
    }
    exports.deflateSync = deflateSync;
    var Inflate2 = /* @__PURE__ */ (function() {
      function Inflate3(opts, cb) {
        if (typeof opts == "function")
          cb = opts, opts = {};
        this.ondata = cb;
        var dict = opts && opts.dictionary && opts.dictionary.subarray(-32768);
        this.s = { i: 0, b: dict ? dict.length : 0 };
        this.o = new u8(32768);
        this.p = new u8(0);
        if (dict)
          this.o.set(dict);
      }
      Inflate3.prototype.e = function(c) {
        if (!this.ondata)
          err2(5);
        if (this.d)
          err2(4);
        if (!this.p.length)
          this.p = c;
        else if (c.length) {
          var n = new u8(this.p.length + c.length);
          n.set(this.p), n.set(c, this.p.length), this.p = n;
        }
      };
      Inflate3.prototype.c = function(final) {
        this.s.i = +(this.d = final || false);
        var bts = this.s.b;
        var dt = inflt(this.p, this.s, this.o);
        this.ondata(slc(dt, bts, this.s.b), this.d);
        this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;
        this.p = slc(this.p, this.s.p / 8 | 0), this.s.p &= 7;
      };
      Inflate3.prototype.push = function(chunk, final) {
        this.e(chunk), this.c(final);
      };
      return Inflate3;
    })();
    exports.Inflate = Inflate2;
    var AsyncInflate = /* @__PURE__ */ (function() {
      function AsyncInflate2(opts, cb) {
        astrmify([
          bInflt,
          function() {
            return [astrm, Inflate2];
          }
        ], this, StrmOpt.call(this, opts, cb), function(ev) {
          var strm = new Inflate2(ev.data);
          onmessage = astrm(strm);
        }, 7, 0);
      }
      return AsyncInflate2;
    })();
    exports.AsyncInflate = AsyncInflate;
    function inflate2(data, opts, cb) {
      if (!cb)
        cb = opts, opts = {};
      if (typeof cb != "function")
        err2(7);
      return cbify(data, opts, [
        bInflt
      ], function(ev) {
        return pbf(inflateSync(ev.data[0], gopt(ev.data[1])));
      }, 1, cb);
    }
    exports.inflate = inflate2;
    function inflateSync(data, opts) {
      return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);
    }
    exports.inflateSync = inflateSync;
    var Gzip = /* @__PURE__ */ (function() {
      function Gzip2(opts, cb) {
        this.c = crc2();
        this.l = 0;
        this.v = 1;
        Deflate2.call(this, opts, cb);
      }
      Gzip2.prototype.push = function(chunk, final) {
        this.c.p(chunk);
        this.l += chunk.length;
        Deflate2.prototype.push.call(this, chunk, final);
      };
      Gzip2.prototype.p = function(c, f2) {
        var raw = dopt(c, this.o, this.v && gzhl(this.o), f2 && 8, this.s);
        if (this.v)
          gzh(raw, this.o), this.v = 0;
        if (f2)
          wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);
        this.ondata(raw, f2);
      };
      Gzip2.prototype.flush = function() {
        Deflate2.prototype.flush.call(this);
      };
      return Gzip2;
    })();
    exports.Gzip = Gzip;
    exports.Compress = Gzip;
    var AsyncGzip = /* @__PURE__ */ (function() {
      function AsyncGzip2(opts, cb) {
        astrmify([
          bDflt,
          gze,
          function() {
            return [astrm, Deflate2, Gzip];
          }
        ], this, StrmOpt.call(this, opts, cb), function(ev) {
          var strm = new Gzip(ev.data);
          onmessage = astrm(strm);
        }, 8, 1);
      }
      return AsyncGzip2;
    })();
    exports.AsyncGzip = AsyncGzip;
    exports.AsyncCompress = AsyncGzip;
    function gzip2(data, opts, cb) {
      if (!cb)
        cb = opts, opts = {};
      if (typeof cb != "function")
        err2(7);
      return cbify(data, opts, [
        bDflt,
        gze,
        function() {
          return [gzipSync];
        }
      ], function(ev) {
        return pbf(gzipSync(ev.data[0], ev.data[1]));
      }, 2, cb);
    }
    exports.gzip = gzip2;
    exports.compress = gzip2;
    function gzipSync(data, opts) {
      if (!opts)
        opts = {};
      var c = crc2(), l = data.length;
      c.p(data);
      var d = dopt(data, opts, gzhl(opts), 8), s = d.length;
      return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;
    }
    exports.gzipSync = gzipSync;
    exports.compressSync = gzipSync;
    var Gunzip = /* @__PURE__ */ (function() {
      function Gunzip2(opts, cb) {
        this.v = 1;
        this.r = 0;
        Inflate2.call(this, opts, cb);
      }
      Gunzip2.prototype.push = function(chunk, final) {
        Inflate2.prototype.e.call(this, chunk);
        this.r += chunk.length;
        if (this.v) {
          var p = this.p.subarray(this.v - 1);
          var s = p.length > 3 ? gzs(p) : 4;
          if (s > p.length) {
            if (!final)
              return;
          } else if (this.v > 1 && this.onmember) {
            this.onmember(this.r - p.length);
          }
          this.p = p.subarray(s), this.v = 0;
        }
        Inflate2.prototype.c.call(this, final);
        if (this.s.f && !this.s.l && !final) {
          this.v = shft(this.s.p) + 9;
          this.s = { i: 0 };
          this.o = new u8(0);
          this.push(new u8(0), final);
        }
      };
      return Gunzip2;
    })();
    exports.Gunzip = Gunzip;
    var AsyncGunzip = /* @__PURE__ */ (function() {
      function AsyncGunzip2(opts, cb) {
        var _this = this;
        astrmify([
          bInflt,
          guze,
          function() {
            return [astrm, Inflate2, Gunzip];
          }
        ], this, StrmOpt.call(this, opts, cb), function(ev) {
          var strm = new Gunzip(ev.data);
          strm.onmember = function(offset) {
            return postMessage(offset);
          };
          onmessage = astrm(strm);
        }, 9, 0, function(offset) {
          return _this.onmember && _this.onmember(offset);
        });
      }
      return AsyncGunzip2;
    })();
    exports.AsyncGunzip = AsyncGunzip;
    function gunzip(data, opts, cb) {
      if (!cb)
        cb = opts, opts = {};
      if (typeof cb != "function")
        err2(7);
      return cbify(data, opts, [
        bInflt,
        guze,
        function() {
          return [gunzipSync];
        }
      ], function(ev) {
        return pbf(gunzipSync(ev.data[0], ev.data[1]));
      }, 3, cb);
    }
    exports.gunzip = gunzip;
    function gunzipSync(data, opts) {
      var st = gzs(data);
      if (st + 8 > data.length)
        err2(6, "invalid gzip data");
      return inflt(data.subarray(st, -8), { i: 2 }, opts && opts.out || new u8(gzl(data)), opts && opts.dictionary);
    }
    exports.gunzipSync = gunzipSync;
    var Zlib = /* @__PURE__ */ (function() {
      function Zlib2(opts, cb) {
        this.c = adler();
        this.v = 1;
        Deflate2.call(this, opts, cb);
      }
      Zlib2.prototype.push = function(chunk, final) {
        this.c.p(chunk);
        Deflate2.prototype.push.call(this, chunk, final);
      };
      Zlib2.prototype.p = function(c, f2) {
        var raw = dopt(c, this.o, this.v && (this.o.dictionary ? 6 : 2), f2 && 4, this.s);
        if (this.v)
          zlh(raw, this.o), this.v = 0;
        if (f2)
          wbytes(raw, raw.length - 4, this.c.d());
        this.ondata(raw, f2);
      };
      Zlib2.prototype.flush = function() {
        Deflate2.prototype.flush.call(this);
      };
      return Zlib2;
    })();
    exports.Zlib = Zlib;
    var AsyncZlib = /* @__PURE__ */ (function() {
      function AsyncZlib2(opts, cb) {
        astrmify([
          bDflt,
          zle,
          function() {
            return [astrm, Deflate2, Zlib];
          }
        ], this, StrmOpt.call(this, opts, cb), function(ev) {
          var strm = new Zlib(ev.data);
          onmessage = astrm(strm);
        }, 10, 1);
      }
      return AsyncZlib2;
    })();
    exports.AsyncZlib = AsyncZlib;
    function zlib(data, opts, cb) {
      if (!cb)
        cb = opts, opts = {};
      if (typeof cb != "function")
        err2(7);
      return cbify(data, opts, [
        bDflt,
        zle,
        function() {
          return [zlibSync];
        }
      ], function(ev) {
        return pbf(zlibSync(ev.data[0], ev.data[1]));
      }, 4, cb);
    }
    exports.zlib = zlib;
    function zlibSync(data, opts) {
      if (!opts)
        opts = {};
      var a2 = adler();
      a2.p(data);
      var d = dopt(data, opts, opts.dictionary ? 6 : 2, 4);
      return zlh(d, opts), wbytes(d, d.length - 4, a2.d()), d;
    }
    exports.zlibSync = zlibSync;
    var Unzlib = /* @__PURE__ */ (function() {
      function Unzlib2(opts, cb) {
        Inflate2.call(this, opts, cb);
        this.v = opts && opts.dictionary ? 2 : 1;
      }
      Unzlib2.prototype.push = function(chunk, final) {
        Inflate2.prototype.e.call(this, chunk);
        if (this.v) {
          if (this.p.length < 6 && !final)
            return;
          this.p = this.p.subarray(zls(this.p, this.v - 1)), this.v = 0;
        }
        if (final) {
          if (this.p.length < 4)
            err2(6, "invalid zlib data");
          this.p = this.p.subarray(0, -4);
        }
        Inflate2.prototype.c.call(this, final);
      };
      return Unzlib2;
    })();
    exports.Unzlib = Unzlib;
    var AsyncUnzlib = /* @__PURE__ */ (function() {
      function AsyncUnzlib2(opts, cb) {
        astrmify([
          bInflt,
          zule,
          function() {
            return [astrm, Inflate2, Unzlib];
          }
        ], this, StrmOpt.call(this, opts, cb), function(ev) {
          var strm = new Unzlib(ev.data);
          onmessage = astrm(strm);
        }, 11, 0);
      }
      return AsyncUnzlib2;
    })();
    exports.AsyncUnzlib = AsyncUnzlib;
    function unzlib(data, opts, cb) {
      if (!cb)
        cb = opts, opts = {};
      if (typeof cb != "function")
        err2(7);
      return cbify(data, opts, [
        bInflt,
        zule,
        function() {
          return [unzlibSync];
        }
      ], function(ev) {
        return pbf(unzlibSync(ev.data[0], gopt(ev.data[1])));
      }, 5, cb);
    }
    exports.unzlib = unzlib;
    function unzlibSync(data, opts) {
      return inflt(data.subarray(zls(data, opts && opts.dictionary), -4), { i: 2 }, opts && opts.out, opts && opts.dictionary);
    }
    exports.unzlibSync = unzlibSync;
    var Decompress = /* @__PURE__ */ (function() {
      function Decompress2(opts, cb) {
        this.o = StrmOpt.call(this, opts, cb) || {};
        this.G = Gunzip;
        this.I = Inflate2;
        this.Z = Unzlib;
      }
      Decompress2.prototype.i = function() {
        var _this = this;
        this.s.ondata = function(dat, final) {
          _this.ondata(dat, final);
        };
      };
      Decompress2.prototype.push = function(chunk, final) {
        if (!this.ondata)
          err2(5);
        if (!this.s) {
          if (this.p && this.p.length) {
            var n = new u8(this.p.length + chunk.length);
            n.set(this.p), n.set(chunk, this.p.length);
          } else
            this.p = chunk;
          if (this.p.length > 2) {
            this.s = this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8 ? new this.G(this.o) : (this.p[0] & 15) != 8 || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(this.o) : new this.Z(this.o);
            this.i();
            this.s.push(this.p, final);
            this.p = null;
          }
        } else
          this.s.push(chunk, final);
      };
      return Decompress2;
    })();
    exports.Decompress = Decompress;
    var AsyncDecompress = /* @__PURE__ */ (function() {
      function AsyncDecompress2(opts, cb) {
        Decompress.call(this, opts, cb);
        this.queuedSize = 0;
        this.G = AsyncGunzip;
        this.I = AsyncInflate;
        this.Z = AsyncUnzlib;
      }
      AsyncDecompress2.prototype.i = function() {
        var _this = this;
        this.s.ondata = function(err3, dat, final) {
          _this.ondata(err3, dat, final);
        };
        this.s.ondrain = function(size) {
          _this.queuedSize -= size;
          if (_this.ondrain)
            _this.ondrain(size);
        };
      };
      AsyncDecompress2.prototype.push = function(chunk, final) {
        this.queuedSize += chunk.length;
        Decompress.prototype.push.call(this, chunk, final);
      };
      return AsyncDecompress2;
    })();
    exports.AsyncDecompress = AsyncDecompress;
    function decompress(data, opts, cb) {
      if (!cb)
        cb = opts, opts = {};
      if (typeof cb != "function")
        err2(7);
      return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzip(data, opts, cb) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflate2(data, opts, cb) : unzlib(data, opts, cb);
    }
    exports.decompress = decompress;
    function decompressSync(data, opts) {
      return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzipSync(data, opts) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflateSync(data, opts) : unzlibSync(data, opts);
    }
    exports.decompressSync = decompressSync;
    var fltn = function(d, p, t, o) {
      for (var k in d) {
        var val = d[k], n = p + k, op = o;
        if (Array.isArray(val))
          op = mrg(o, val[1]), val = val[0];
        if (val instanceof u8)
          t[n] = [val, op];
        else {
          t[n += "/"] = [new u8(0), op];
          fltn(val, n, t, o);
        }
      }
    };
    var te = typeof TextEncoder != "undefined" && /* @__PURE__ */ new TextEncoder();
    var td = typeof TextDecoder != "undefined" && /* @__PURE__ */ new TextDecoder();
    var tds = 0;
    try {
      td.decode(et, { stream: true });
      tds = 1;
    } catch (e2) {
    }
    var dutf8 = function(d) {
      for (var r = "", i2 = 0; ; ) {
        var c = d[i2++];
        var eb = (c > 127) + (c > 223) + (c > 239);
        if (i2 + eb > d.length)
          return { s: r, r: slc(d, i2 - 1) };
        if (!eb)
          r += String.fromCharCode(c);
        else if (eb == 3) {
          c = ((c & 15) << 18 | (d[i2++] & 63) << 12 | (d[i2++] & 63) << 6 | d[i2++] & 63) - 65536, r += String.fromCharCode(55296 | c >> 10, 56320 | c & 1023);
        } else if (eb & 1)
          r += String.fromCharCode((c & 31) << 6 | d[i2++] & 63);
        else
          r += String.fromCharCode((c & 15) << 12 | (d[i2++] & 63) << 6 | d[i2++] & 63);
      }
    };
    var DecodeUTF8 = /* @__PURE__ */ (function() {
      function DecodeUTF82(cb) {
        this.ondata = cb;
        if (tds)
          this.t = new TextDecoder();
        else
          this.p = et;
      }
      DecodeUTF82.prototype.push = function(chunk, final) {
        if (!this.ondata)
          err2(5);
        final = !!final;
        if (this.t) {
          this.ondata(this.t.decode(chunk, { stream: true }), final);
          if (final) {
            if (this.t.decode().length)
              err2(8);
            this.t = null;
          }
          return;
        }
        if (!this.p)
          err2(4);
        var dat = new u8(this.p.length + chunk.length);
        dat.set(this.p);
        dat.set(chunk, this.p.length);
        var _a3 = dutf8(dat), s = _a3.s, r = _a3.r;
        if (final) {
          if (r.length)
            err2(8);
          this.p = null;
        } else
          this.p = r;
        this.ondata(s, final);
      };
      return DecodeUTF82;
    })();
    exports.DecodeUTF8 = DecodeUTF8;
    var EncodeUTF8 = /* @__PURE__ */ (function() {
      function EncodeUTF82(cb) {
        this.ondata = cb;
      }
      EncodeUTF82.prototype.push = function(chunk, final) {
        if (!this.ondata)
          err2(5);
        if (this.d)
          err2(4);
        this.ondata(strToU8(chunk), this.d = final || false);
      };
      return EncodeUTF82;
    })();
    exports.EncodeUTF8 = EncodeUTF8;
    function strToU8(str, latin1) {
      if (latin1) {
        var ar_1 = new u8(str.length);
        for (var i2 = 0; i2 < str.length; ++i2)
          ar_1[i2] = str.charCodeAt(i2);
        return ar_1;
      }
      if (te)
        return te.encode(str);
      var l = str.length;
      var ar = new u8(str.length + (str.length >> 1));
      var ai = 0;
      var w = function(v) {
        ar[ai++] = v;
      };
      for (var i2 = 0; i2 < l; ++i2) {
        if (ai + 5 > ar.length) {
          var n = new u8(ai + 8 + (l - i2 << 1));
          n.set(ar);
          ar = n;
        }
        var c = str.charCodeAt(i2);
        if (c < 128 || latin1)
          w(c);
        else if (c < 2048)
          w(192 | c >> 6), w(128 | c & 63);
        else if (c > 55295 && c < 57344)
          c = 65536 + (c & 1023 << 10) | str.charCodeAt(++i2) & 1023, w(240 | c >> 18), w(128 | c >> 12 & 63), w(128 | c >> 6 & 63), w(128 | c & 63);
        else
          w(224 | c >> 12), w(128 | c >> 6 & 63), w(128 | c & 63);
      }
      return slc(ar, 0, ai);
    }
    exports.strToU8 = strToU8;
    function strFromU8(dat, latin1) {
      if (latin1) {
        var r = "";
        for (var i2 = 0; i2 < dat.length; i2 += 16384)
          r += String.fromCharCode.apply(null, dat.subarray(i2, i2 + 16384));
        return r;
      } else if (td) {
        return td.decode(dat);
      } else {
        var _a3 = dutf8(dat), s = _a3.s, r = _a3.r;
        if (r.length)
          err2(8);
        return s;
      }
    }
    exports.strFromU8 = strFromU8;
    var dbf = function(l) {
      return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0;
    };
    var slzh = function(d, b) {
      return b + 30 + b2(d, b + 26) + b2(d, b + 28);
    };
    var zh = function(d, b, z2) {
      var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);
      var _a3 = z2 && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = _a3[0], su = _a3[1], off = _a3[2];
      return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];
    };
    var z64e = function(d, b) {
      for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))
        ;
      return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];
    };
    var exfl = function(ex) {
      var le = 0;
      if (ex) {
        for (var k in ex) {
          var l = ex[k].length;
          if (l > 65535)
            err2(9);
          le += l + 4;
        }
      }
      return le;
    };
    var wzh = function(d, b, f2, fn, u2, c, ce, co) {
      var fl2 = fn.length, ex = f2.extra, col = co && co.length;
      var exl = exfl(ex);
      wbytes(d, b, ce != null ? 33639248 : 67324752), b += 4;
      if (ce != null)
        d[b++] = 20, d[b++] = f2.os;
      d[b] = 20, b += 2;
      d[b++] = f2.flag << 1 | (c < 0 && 8), d[b++] = u2 && 8;
      d[b++] = f2.compression & 255, d[b++] = f2.compression >> 8;
      var dt = new Date(f2.mtime == null ? Date.now() : f2.mtime), y = dt.getFullYear() - 1980;
      if (y < 0 || y > 119)
        err2(10);
      wbytes(d, b, y << 25 | dt.getMonth() + 1 << 21 | dt.getDate() << 16 | dt.getHours() << 11 | dt.getMinutes() << 5 | dt.getSeconds() >> 1), b += 4;
      if (c != -1) {
        wbytes(d, b, f2.crc);
        wbytes(d, b + 4, c < 0 ? -c - 2 : c);
        wbytes(d, b + 8, f2.size);
      }
      wbytes(d, b + 12, fl2);
      wbytes(d, b + 14, exl), b += 16;
      if (ce != null) {
        wbytes(d, b, col);
        wbytes(d, b + 6, f2.attrs);
        wbytes(d, b + 10, ce), b += 14;
      }
      d.set(fn, b);
      b += fl2;
      if (exl) {
        for (var k in ex) {
          var exf = ex[k], l = exf.length;
          wbytes(d, b, +k);
          wbytes(d, b + 2, l);
          d.set(exf, b + 4), b += 4 + l;
        }
      }
      if (col)
        d.set(co, b), b += col;
      return b;
    };
    var wzf = function(o, b, c, d, e2) {
      wbytes(o, b, 101010256);
      wbytes(o, b + 8, c);
      wbytes(o, b + 10, c);
      wbytes(o, b + 12, d);
      wbytes(o, b + 16, e2);
    };
    var ZipPassThrough = /* @__PURE__ */ (function() {
      function ZipPassThrough2(filename) {
        this.filename = filename;
        this.c = crc2();
        this.size = 0;
        this.compression = 0;
      }
      ZipPassThrough2.prototype.process = function(chunk, final) {
        this.ondata(null, chunk, final);
      };
      ZipPassThrough2.prototype.push = function(chunk, final) {
        if (!this.ondata)
          err2(5);
        this.c.p(chunk);
        this.size += chunk.length;
        if (final)
          this.crc = this.c.d();
        this.process(chunk, final || false);
      };
      return ZipPassThrough2;
    })();
    exports.ZipPassThrough = ZipPassThrough;
    var ZipDeflate = /* @__PURE__ */ (function() {
      function ZipDeflate2(filename, opts) {
        var _this = this;
        if (!opts)
          opts = {};
        ZipPassThrough.call(this, filename);
        this.d = new Deflate2(opts, function(dat, final) {
          _this.ondata(null, dat, final);
        });
        this.compression = 8;
        this.flag = dbf(opts.level);
      }
      ZipDeflate2.prototype.process = function(chunk, final) {
        try {
          this.d.push(chunk, final);
        } catch (e2) {
          this.ondata(e2, null, final);
        }
      };
      ZipDeflate2.prototype.push = function(chunk, final) {
        ZipPassThrough.prototype.push.call(this, chunk, final);
      };
      return ZipDeflate2;
    })();
    exports.ZipDeflate = ZipDeflate;
    var AsyncZipDeflate = /* @__PURE__ */ (function() {
      function AsyncZipDeflate2(filename, opts) {
        var _this = this;
        if (!opts)
          opts = {};
        ZipPassThrough.call(this, filename);
        this.d = new AsyncDeflate(opts, function(err3, dat, final) {
          _this.ondata(err3, dat, final);
        });
        this.compression = 8;
        this.flag = dbf(opts.level);
        this.terminate = this.d.terminate;
      }
      AsyncZipDeflate2.prototype.process = function(chunk, final) {
        this.d.push(chunk, final);
      };
      AsyncZipDeflate2.prototype.push = function(chunk, final) {
        ZipPassThrough.prototype.push.call(this, chunk, final);
      };
      return AsyncZipDeflate2;
    })();
    exports.AsyncZipDeflate = AsyncZipDeflate;
    var Zip = /* @__PURE__ */ (function() {
      function Zip2(cb) {
        this.ondata = cb;
        this.u = [];
        this.d = 1;
      }
      Zip2.prototype.add = function(file) {
        var _this = this;
        if (!this.ondata)
          err2(5);
        if (this.d & 2)
          this.ondata(err2(4 + (this.d & 1) * 8, 0, 1), null, false);
        else {
          var f2 = strToU8(file.filename), fl_1 = f2.length;
          var com = file.comment, o = com && strToU8(com);
          var u2 = fl_1 != file.filename.length || o && com.length != o.length;
          var hl_1 = fl_1 + exfl(file.extra) + 30;
          if (fl_1 > 65535)
            this.ondata(err2(11, 0, 1), null, false);
          var header = new u8(hl_1);
          wzh(header, 0, file, f2, u2, -1);
          var chks_1 = [header];
          var pAll_1 = function() {
            for (var _i = 0, chks_2 = chks_1; _i < chks_2.length; _i++) {
              var chk = chks_2[_i];
              _this.ondata(null, chk, false);
            }
            chks_1 = [];
          };
          var tr_1 = this.d;
          this.d = 0;
          var ind_1 = this.u.length;
          var uf_1 = mrg(file, {
            f: f2,
            u: u2,
            o,
            t: function() {
              if (file.terminate)
                file.terminate();
            },
            r: function() {
              pAll_1();
              if (tr_1) {
                var nxt = _this.u[ind_1 + 1];
                if (nxt)
                  nxt.r();
                else
                  _this.d = 1;
              }
              tr_1 = 1;
            }
          });
          var cl_1 = 0;
          file.ondata = function(err3, dat, final) {
            if (err3) {
              _this.ondata(err3, dat, final);
              _this.terminate();
            } else {
              cl_1 += dat.length;
              chks_1.push(dat);
              if (final) {
                var dd = new u8(16);
                wbytes(dd, 0, 134695760);
                wbytes(dd, 4, file.crc);
                wbytes(dd, 8, cl_1);
                wbytes(dd, 12, file.size);
                chks_1.push(dd);
                uf_1.c = cl_1, uf_1.b = hl_1 + cl_1 + 16, uf_1.crc = file.crc, uf_1.size = file.size;
                if (tr_1)
                  uf_1.r();
                tr_1 = 1;
              } else if (tr_1)
                pAll_1();
            }
          };
          this.u.push(uf_1);
        }
      };
      Zip2.prototype.end = function() {
        var _this = this;
        if (this.d & 2) {
          this.ondata(err2(4 + (this.d & 1) * 8, 0, 1), null, true);
          return;
        }
        if (this.d)
          this.e();
        else
          this.u.push({
            r: function() {
              if (!(_this.d & 1))
                return;
              _this.u.splice(-1, 1);
              _this.e();
            },
            t: function() {
            }
          });
        this.d = 3;
      };
      Zip2.prototype.e = function() {
        var bt = 0, l = 0, tl = 0;
        for (var _i = 0, _a3 = this.u; _i < _a3.length; _i++) {
          var f2 = _a3[_i];
          tl += 46 + f2.f.length + exfl(f2.extra) + (f2.o ? f2.o.length : 0);
        }
        var out = new u8(tl + 22);
        for (var _b2 = 0, _c = this.u; _b2 < _c.length; _b2++) {
          var f2 = _c[_b2];
          wzh(out, bt, f2, f2.f, f2.u, -f2.c - 2, l, f2.o);
          bt += 46 + f2.f.length + exfl(f2.extra) + (f2.o ? f2.o.length : 0), l += f2.b;
        }
        wzf(out, bt, this.u.length, tl, l);
        this.ondata(null, out, true);
        this.d = 2;
      };
      Zip2.prototype.terminate = function() {
        for (var _i = 0, _a3 = this.u; _i < _a3.length; _i++) {
          var f2 = _a3[_i];
          f2.t();
        }
        this.d = 2;
      };
      return Zip2;
    })();
    exports.Zip = Zip;
    function zip(data, opts, cb) {
      if (!cb)
        cb = opts, opts = {};
      if (typeof cb != "function")
        err2(7);
      var r = {};
      fltn(data, "", r, opts);
      var k = Object.keys(r);
      var lft = k.length, o = 0, tot = 0;
      var slft = lft, files = new Array(lft);
      var term = [];
      var tAll = function() {
        for (var i3 = 0; i3 < term.length; ++i3)
          term[i3]();
      };
      var cbd = function(a2, b) {
        mt(function() {
          cb(a2, b);
        });
      };
      mt(function() {
        cbd = cb;
      });
      var cbf = function() {
        var out = new u8(tot + 22), oe = o, cdl = tot - o;
        tot = 0;
        for (var i3 = 0; i3 < slft; ++i3) {
          var f2 = files[i3];
          try {
            var l = f2.c.length;
            wzh(out, tot, f2, f2.f, f2.u, l);
            var badd = 30 + f2.f.length + exfl(f2.extra);
            var loc = tot + badd;
            out.set(f2.c, loc);
            wzh(out, o, f2, f2.f, f2.u, l, tot, f2.m), o += 16 + badd + (f2.m ? f2.m.length : 0), tot = loc + l;
          } catch (e2) {
            return cbd(e2, null);
          }
        }
        wzf(out, o, files.length, cdl, oe);
        cbd(null, out);
      };
      if (!lft)
        cbf();
      var _loop_1 = function(i3) {
        var fn = k[i3];
        var _a3 = r[fn], file = _a3[0], p = _a3[1];
        var c = crc2(), size = file.length;
        c.p(file);
        var f2 = strToU8(fn), s = f2.length;
        var com = p.comment, m = com && strToU8(com), ms = m && m.length;
        var exl = exfl(p.extra);
        var compression = p.level == 0 ? 0 : 8;
        var cbl = function(e2, d) {
          if (e2) {
            tAll();
            cbd(e2, null);
          } else {
            var l = d.length;
            files[i3] = mrg(p, {
              size,
              crc: c.d(),
              c: d,
              f: f2,
              m,
              u: s != fn.length || m && com.length != ms,
              compression
            });
            o += 30 + s + exl + l;
            tot += 76 + 2 * (s + exl) + (ms || 0) + l;
            if (!--lft)
              cbf();
          }
        };
        if (s > 65535)
          cbl(err2(11, 0, 1), null);
        if (!compression)
          cbl(null, file);
        else if (size < 16e4) {
          try {
            cbl(null, deflateSync(file, p));
          } catch (e2) {
            cbl(e2, null);
          }
        } else
          term.push(deflate2(file, p, cbl));
      };
      for (var i2 = 0; i2 < slft; ++i2) {
        _loop_1(i2);
      }
      return tAll;
    }
    exports.zip = zip;
    function zipSync(data, opts) {
      if (!opts)
        opts = {};
      var r = {};
      var files = [];
      fltn(data, "", r, opts);
      var o = 0;
      var tot = 0;
      for (var fn in r) {
        var _a3 = r[fn], file = _a3[0], p = _a3[1];
        var compression = p.level == 0 ? 0 : 8;
        var f2 = strToU8(fn), s = f2.length;
        var com = p.comment, m = com && strToU8(com), ms = m && m.length;
        var exl = exfl(p.extra);
        if (s > 65535)
          err2(11);
        var d = compression ? deflateSync(file, p) : file, l = d.length;
        var c = crc2();
        c.p(file);
        files.push(mrg(p, {
          size: file.length,
          crc: c.d(),
          c: d,
          f: f2,
          m,
          u: s != fn.length || m && com.length != ms,
          o,
          compression
        }));
        o += 30 + s + exl + l;
        tot += 76 + 2 * (s + exl) + (ms || 0) + l;
      }
      var out = new u8(tot + 22), oe = o, cdl = tot - o;
      for (var i2 = 0; i2 < files.length; ++i2) {
        var f2 = files[i2];
        wzh(out, f2.o, f2, f2.f, f2.u, f2.c.length);
        var badd = 30 + f2.f.length + exfl(f2.extra);
        out.set(f2.c, f2.o + badd);
        wzh(out, o, f2, f2.f, f2.u, f2.c.length, f2.o, f2.m), o += 16 + badd + (f2.m ? f2.m.length : 0);
      }
      wzf(out, o, files.length, cdl, oe);
      return out;
    }
    exports.zipSync = zipSync;
    var UnzipPassThrough = /* @__PURE__ */ (function() {
      function UnzipPassThrough2() {
      }
      UnzipPassThrough2.prototype.push = function(data, final) {
        this.ondata(null, data, final);
      };
      UnzipPassThrough2.compression = 0;
      return UnzipPassThrough2;
    })();
    exports.UnzipPassThrough = UnzipPassThrough;
    var UnzipInflate = /* @__PURE__ */ (function() {
      function UnzipInflate2() {
        var _this = this;
        this.i = new Inflate2(function(dat, final) {
          _this.ondata(null, dat, final);
        });
      }
      UnzipInflate2.prototype.push = function(data, final) {
        try {
          this.i.push(data, final);
        } catch (e2) {
          this.ondata(e2, null, final);
        }
      };
      UnzipInflate2.compression = 8;
      return UnzipInflate2;
    })();
    exports.UnzipInflate = UnzipInflate;
    var AsyncUnzipInflate = /* @__PURE__ */ (function() {
      function AsyncUnzipInflate2(_, sz) {
        var _this = this;
        if (sz < 32e4) {
          this.i = new Inflate2(function(dat, final) {
            _this.ondata(null, dat, final);
          });
        } else {
          this.i = new AsyncInflate(function(err3, dat, final) {
            _this.ondata(err3, dat, final);
          });
          this.terminate = this.i.terminate;
        }
      }
      AsyncUnzipInflate2.prototype.push = function(data, final) {
        if (this.i.terminate)
          data = slc(data, 0);
        this.i.push(data, final);
      };
      AsyncUnzipInflate2.compression = 8;
      return AsyncUnzipInflate2;
    })();
    exports.AsyncUnzipInflate = AsyncUnzipInflate;
    var Unzip = /* @__PURE__ */ (function() {
      function Unzip2(cb) {
        this.onfile = cb;
        this.k = [];
        this.o = {
          0: UnzipPassThrough
        };
        this.p = et;
      }
      Unzip2.prototype.push = function(chunk, final) {
        var _this = this;
        if (!this.onfile)
          err2(5);
        if (!this.p)
          err2(4);
        if (this.c > 0) {
          var len = Math.min(this.c, chunk.length);
          var toAdd = chunk.subarray(0, len);
          this.c -= len;
          if (this.d)
            this.d.push(toAdd, !this.c);
          else
            this.k[0].push(toAdd);
          chunk = chunk.subarray(len);
          if (chunk.length)
            return this.push(chunk, final);
        } else {
          var f2 = 0, i2 = 0, is = void 0, buf = void 0;
          if (!this.p.length)
            buf = chunk;
          else if (!chunk.length)
            buf = this.p;
          else {
            buf = new u8(this.p.length + chunk.length);
            buf.set(this.p), buf.set(chunk, this.p.length);
          }
          var l = buf.length, oc = this.c, add = oc && this.d;
          var _loop_2 = function() {
            var _a3;
            var sig = b4(buf, i2);
            if (sig == 67324752) {
              f2 = 1, is = i2;
              this_1.d = null;
              this_1.c = 0;
              var bf = b2(buf, i2 + 6), cmp_1 = b2(buf, i2 + 8), u2 = bf & 2048, dd = bf & 8, fnl = b2(buf, i2 + 26), es = b2(buf, i2 + 28);
              if (l > i2 + 30 + fnl + es) {
                var chks_3 = [];
                this_1.k.unshift(chks_3);
                f2 = 2;
                var sc_1 = b4(buf, i2 + 18), su_1 = b4(buf, i2 + 22);
                var fn_1 = strFromU8(buf.subarray(i2 + 30, i2 += 30 + fnl), !u2);
                if (sc_1 == 4294967295) {
                  _a3 = dd ? [-2] : z64e(buf, i2), sc_1 = _a3[0], su_1 = _a3[1];
                } else if (dd)
                  sc_1 = -1;
                i2 += es;
                this_1.c = sc_1;
                var d_1;
                var file_1 = {
                  name: fn_1,
                  compression: cmp_1,
                  start: function() {
                    if (!file_1.ondata)
                      err2(5);
                    if (!sc_1)
                      file_1.ondata(null, et, true);
                    else {
                      var ctr = _this.o[cmp_1];
                      if (!ctr)
                        file_1.ondata(err2(14, "unknown compression type " + cmp_1, 1), null, false);
                      d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);
                      d_1.ondata = function(err3, dat3, final2) {
                        file_1.ondata(err3, dat3, final2);
                      };
                      for (var _i = 0, chks_4 = chks_3; _i < chks_4.length; _i++) {
                        var dat2 = chks_4[_i];
                        d_1.push(dat2, false);
                      }
                      if (_this.k[0] == chks_3 && _this.c)
                        _this.d = d_1;
                      else
                        d_1.push(et, true);
                    }
                  },
                  terminate: function() {
                    if (d_1 && d_1.terminate)
                      d_1.terminate();
                  }
                };
                if (sc_1 >= 0)
                  file_1.size = sc_1, file_1.originalSize = su_1;
                this_1.onfile(file_1);
              }
              return "break";
            } else if (oc) {
              if (sig == 134695760) {
                is = i2 += 12 + (oc == -2 && 8), f2 = 3, this_1.c = 0;
                return "break";
              } else if (sig == 33639248) {
                is = i2 -= 4, f2 = 3, this_1.c = 0;
                return "break";
              }
            }
          };
          var this_1 = this;
          for (; i2 < l - 4; ++i2) {
            var state_1 = _loop_2();
            if (state_1 === "break")
              break;
          }
          this.p = et;
          if (oc < 0) {
            var dat = f2 ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 134695760 && 4)) : buf.subarray(0, i2);
            if (add)
              add.push(dat, !!f2);
            else
              this.k[+(f2 == 2)].push(dat);
          }
          if (f2 & 2)
            return this.push(buf.subarray(i2), final);
          this.p = buf.subarray(i2);
        }
        if (final) {
          if (this.c)
            err2(13);
          this.p = null;
        }
      };
      Unzip2.prototype.register = function(decoder) {
        this.o[decoder.compression] = decoder;
      };
      return Unzip2;
    })();
    exports.Unzip = Unzip;
    var mt = typeof queueMicrotask == "function" ? queueMicrotask : typeof setTimeout == "function" ? setTimeout : function(fn) {
      fn();
    };
    function unzip(data, opts, cb) {
      if (!cb)
        cb = opts, opts = {};
      if (typeof cb != "function")
        err2(7);
      var term = [];
      var tAll = function() {
        for (var i3 = 0; i3 < term.length; ++i3)
          term[i3]();
      };
      var files = {};
      var cbd = function(a2, b) {
        mt(function() {
          cb(a2, b);
        });
      };
      mt(function() {
        cbd = cb;
      });
      var e2 = data.length - 22;
      for (; b4(data, e2) != 101010256; --e2) {
        if (!e2 || data.length - e2 > 65558) {
          cbd(err2(13, 0, 1), null);
          return tAll;
        }
      }
      ;
      var lft = b2(data, e2 + 8);
      if (lft) {
        var c = lft;
        var o = b4(data, e2 + 16);
        var z2 = o == 4294967295 || c == 65535;
        if (z2) {
          var ze = b4(data, e2 - 12);
          z2 = b4(data, ze) == 101075792;
          if (z2) {
            c = lft = b4(data, ze + 32);
            o = b4(data, ze + 48);
          }
        }
        var fltr = opts && opts.filter;
        var _loop_3 = function(i3) {
          var _a3 = zh(data, o, z2), c_1 = _a3[0], sc = _a3[1], su = _a3[2], fn = _a3[3], no = _a3[4], off = _a3[5], b = slzh(data, off);
          o = no;
          var cbl = function(e3, d) {
            if (e3) {
              tAll();
              cbd(e3, null);
            } else {
              if (d)
                files[fn] = d;
              if (!--lft)
                cbd(null, files);
            }
          };
          if (!fltr || fltr({
            name: fn,
            size: sc,
            originalSize: su,
            compression: c_1
          })) {
            if (!c_1)
              cbl(null, slc(data, b, b + sc));
            else if (c_1 == 8) {
              var infl = data.subarray(b, b + sc);
              if (su < 524288 || sc > 0.8 * su) {
                try {
                  cbl(null, inflateSync(infl, { out: new u8(su) }));
                } catch (e3) {
                  cbl(e3, null);
                }
              } else
                term.push(inflate2(infl, { size: su }, cbl));
            } else
              cbl(err2(14, "unknown compression type " + c_1, 1), null);
          } else
            cbl(null, null);
        };
        for (var i2 = 0; i2 < c; ++i2) {
          _loop_3(i2);
        }
      } else
        cbd(null, {});
      return tAll;
    }
    exports.unzip = unzip;
    function unzipSync(data, opts) {
      var files = {};
      var e2 = data.length - 22;
      for (; b4(data, e2) != 101010256; --e2) {
        if (!e2 || data.length - e2 > 65558)
          err2(13);
      }
      ;
      var c = b2(data, e2 + 8);
      if (!c)
        return {};
      var o = b4(data, e2 + 16);
      var z2 = o == 4294967295 || c == 65535;
      if (z2) {
        var ze = b4(data, e2 - 12);
        z2 = b4(data, ze) == 101075792;
        if (z2) {
          c = b4(data, ze + 32);
          o = b4(data, ze + 48);
        }
      }
      var fltr = opts && opts.filter;
      for (var i2 = 0; i2 < c; ++i2) {
        var _a3 = zh(data, o, z2), c_2 = _a3[0], sc = _a3[1], su = _a3[2], fn = _a3[3], no = _a3[4], off = _a3[5], b = slzh(data, off);
        o = no;
        if (!fltr || fltr({
          name: fn,
          size: sc,
          originalSize: su,
          compression: c_2
        })) {
          if (!c_2)
            files[fn] = slc(data, b, b + sc);
          else if (c_2 == 8)
            files[fn] = inflateSync(data.subarray(b, b + sc), { out: new u8(su) });
          else
            err2(14, "unknown compression type " + c_2);
        }
      }
      return files;
    }
    exports.unzipSync = unzipSync;
  }
});

// node_modules/iobuffer/lib-esm/text.js
function decode(bytes, encoding = "utf8") {
  const decoder = new TextDecoder(encoding);
  return decoder.decode(bytes);
}
function encode(str) {
  return encoder.encode(str);
}
var encoder;
var init_text = __esm({
  "node_modules/iobuffer/lib-esm/text.js"() {
    "use strict";
    encoder = new TextEncoder();
  }
});

// node_modules/iobuffer/lib-esm/IOBuffer.js
var defaultByteLength, hostBigEndian, typedArrays, IOBuffer;
var init_IOBuffer = __esm({
  "node_modules/iobuffer/lib-esm/IOBuffer.js"() {
    "use strict";
    init_text();
    defaultByteLength = 1024 * 8;
    hostBigEndian = (() => {
      const array = new Uint8Array(4);
      const view = new Uint32Array(array.buffer);
      return !((view[0] = 1) & array[0]);
    })();
    typedArrays = {
      int8: globalThis.Int8Array,
      uint8: globalThis.Uint8Array,
      int16: globalThis.Int16Array,
      uint16: globalThis.Uint16Array,
      int32: globalThis.Int32Array,
      uint32: globalThis.Uint32Array,
      uint64: globalThis.BigUint64Array,
      int64: globalThis.BigInt64Array,
      float32: globalThis.Float32Array,
      float64: globalThis.Float64Array
    };
    IOBuffer = class _IOBuffer {
      /**
       * Reference to the internal ArrayBuffer object.
       */
      buffer;
      /**
       * Byte length of the internal ArrayBuffer.
       */
      byteLength;
      /**
       * Byte offset of the internal ArrayBuffer.
       */
      byteOffset;
      /**
       * Byte length of the internal ArrayBuffer.
       */
      length;
      /**
       * The current offset of the buffer's pointer.
       */
      offset;
      lastWrittenByte;
      littleEndian;
      _data;
      _mark;
      _marks;
      /**
       * Create a new IOBuffer.
       * @param data - The data to construct the IOBuffer with.
       * If data is a number, it will be the new buffer's length<br>
       * If data is `undefined`, the buffer will be initialized with a default length of 8Kb<br>
       * If data is an ArrayBuffer, SharedArrayBuffer, an ArrayBufferView (Typed Array), an IOBuffer instance,
       * or a Node.js Buffer, a view will be created over the underlying ArrayBuffer.
       * @param options - An object for the options.
       * @returns A new IOBuffer instance.
       */
      constructor(data = defaultByteLength, options = {}) {
        let dataIsGiven = false;
        if (typeof data === "number") {
          data = new ArrayBuffer(data);
        } else {
          dataIsGiven = true;
          this.lastWrittenByte = data.byteLength;
        }
        const offset = options.offset ? options.offset >>> 0 : 0;
        const byteLength = data.byteLength - offset;
        let dvOffset = offset;
        if (ArrayBuffer.isView(data) || data instanceof _IOBuffer) {
          if (data.byteLength !== data.buffer.byteLength) {
            dvOffset = data.byteOffset + offset;
          }
          data = data.buffer;
        }
        if (dataIsGiven) {
          this.lastWrittenByte = byteLength;
        } else {
          this.lastWrittenByte = 0;
        }
        this.buffer = data;
        this.length = byteLength;
        this.byteLength = byteLength;
        this.byteOffset = dvOffset;
        this.offset = 0;
        this.littleEndian = true;
        this._data = new DataView(this.buffer, dvOffset, byteLength);
        this._mark = 0;
        this._marks = [];
      }
      /**
       * Checks if the memory allocated to the buffer is sufficient to store more
       * bytes after the offset.
       * @param byteLength - The needed memory in bytes.
       * @returns `true` if there is sufficient space and `false` otherwise.
       */
      available(byteLength = 1) {
        return this.offset + byteLength <= this.length;
      }
      /**
       * Check if little-endian mode is used for reading and writing multi-byte
       * values.
       * @returns `true` if little-endian mode is used, `false` otherwise.
       */
      isLittleEndian() {
        return this.littleEndian;
      }
      /**
       * Set little-endian mode for reading and writing multi-byte values.
       * @returns This.
       */
      setLittleEndian() {
        this.littleEndian = true;
        return this;
      }
      /**
       * Check if big-endian mode is used for reading and writing multi-byte values.
       * @returns `true` if big-endian mode is used, `false` otherwise.
       */
      isBigEndian() {
        return !this.littleEndian;
      }
      /**
       * Switches to big-endian mode for reading and writing multi-byte values.
       * @returns This.
       */
      setBigEndian() {
        this.littleEndian = false;
        return this;
      }
      /**
       * Move the pointer n bytes forward.
       * @param n - Number of bytes to skip.
       * @returns This.
       */
      skip(n = 1) {
        this.offset += n;
        return this;
      }
      /**
       * Move the pointer n bytes backward.
       * @param n - Number of bytes to move back.
       * @returns This.
       */
      back(n = 1) {
        this.offset -= n;
        return this;
      }
      /**
       * Move the pointer to the given offset.
       * @param offset - The offset to move to.
       * @returns This.
       */
      seek(offset) {
        this.offset = offset;
        return this;
      }
      /**
       * Store the current pointer offset.
       * @see {@link IOBuffer#reset}
       * @returns This.
       */
      mark() {
        this._mark = this.offset;
        return this;
      }
      /**
       * Move the pointer back to the last pointer offset set by mark.
       * @see {@link IOBuffer#mark}
       * @returns This.
       */
      reset() {
        this.offset = this._mark;
        return this;
      }
      /**
       * Push the current pointer offset to the mark stack.
       * @see {@link IOBuffer#popMark}
       * @returns This.
       */
      pushMark() {
        this._marks.push(this.offset);
        return this;
      }
      /**
       * Pop the last pointer offset from the mark stack, and set the current
       * pointer offset to the popped value.
       * @see {@link IOBuffer#pushMark}
       * @returns This.
       */
      popMark() {
        const offset = this._marks.pop();
        if (offset === void 0) {
          throw new Error("Mark stack empty");
        }
        this.seek(offset);
        return this;
      }
      /**
       * Move the pointer offset back to 0.
       * @returns This.
       */
      rewind() {
        this.offset = 0;
        return this;
      }
      /**
       * Make sure the buffer has sufficient memory to write a given byteLength at
       * the current pointer offset.
       * If the buffer's memory is insufficient, this method will create a new
       * buffer (a copy) with a length that is twice (byteLength + current offset).
       * @param byteLength - The needed memory in bytes.
       * @returns This.
       */
      ensureAvailable(byteLength = 1) {
        if (!this.available(byteLength)) {
          const lengthNeeded = this.offset + byteLength;
          const newLength = lengthNeeded * 2;
          const newArray = new Uint8Array(newLength);
          newArray.set(new Uint8Array(this.buffer));
          this.buffer = newArray.buffer;
          this.length = newLength;
          this.byteLength = newLength;
          this._data = new DataView(this.buffer);
        }
        return this;
      }
      /**
       * Read a byte and return false if the byte's value is 0, or true otherwise.
       * Moves pointer forward by one byte.
       * @returns The read boolean.
       */
      readBoolean() {
        return this.readUint8() !== 0;
      }
      /**
       * Read a signed 8-bit integer and move pointer forward by 1 byte.
       * @returns The read byte.
       */
      readInt8() {
        return this._data.getInt8(this.offset++);
      }
      /**
       * Read an unsigned 8-bit integer and move pointer forward by 1 byte.
       * @returns The read byte.
       */
      readUint8() {
        return this._data.getUint8(this.offset++);
      }
      /**
       * Alias for {@link IOBuffer#readUint8}.
       * @returns The read byte.
       */
      readByte() {
        return this.readUint8();
      }
      /**
       * Read `n` bytes and move pointer forward by `n` bytes.
       * @param n - Number of bytes to read.
       * @returns The read bytes.
       */
      readBytes(n = 1) {
        return this.readArray(n, "uint8");
      }
      /**
       * Creates an array of corresponding to the type `type` and size `size`.
       * For example type `uint8` will create a `Uint8Array`.
       * @param size - size of the resulting array
       * @param type - number type of elements to read
       * @returns The read array.
       */
      readArray(size, type) {
        const bytes = typedArrays[type].BYTES_PER_ELEMENT * size;
        const offset = this.byteOffset + this.offset;
        const slice = this.buffer.slice(offset, offset + bytes);
        if (this.littleEndian === hostBigEndian && type !== "uint8" && type !== "int8") {
          const slice2 = new Uint8Array(this.buffer.slice(offset, offset + bytes));
          slice2.reverse();
          const returnArray2 = new typedArrays[type](slice2.buffer);
          this.offset += bytes;
          returnArray2.reverse();
          return returnArray2;
        }
        const returnArray = new typedArrays[type](slice);
        this.offset += bytes;
        return returnArray;
      }
      /**
       * Read a 16-bit signed integer and move pointer forward by 2 bytes.
       * @returns The read value.
       */
      readInt16() {
        const value = this._data.getInt16(this.offset, this.littleEndian);
        this.offset += 2;
        return value;
      }
      /**
       * Read a 16-bit unsigned integer and move pointer forward by 2 bytes.
       * @returns The read value.
       */
      readUint16() {
        const value = this._data.getUint16(this.offset, this.littleEndian);
        this.offset += 2;
        return value;
      }
      /**
       * Read a 32-bit signed integer and move pointer forward by 4 bytes.
       * @returns The read value.
       */
      readInt32() {
        const value = this._data.getInt32(this.offset, this.littleEndian);
        this.offset += 4;
        return value;
      }
      /**
       * Read a 32-bit unsigned integer and move pointer forward by 4 bytes.
       * @returns The read value.
       */
      readUint32() {
        const value = this._data.getUint32(this.offset, this.littleEndian);
        this.offset += 4;
        return value;
      }
      /**
       * Read a 32-bit floating number and move pointer forward by 4 bytes.
       * @returns The read value.
       */
      readFloat32() {
        const value = this._data.getFloat32(this.offset, this.littleEndian);
        this.offset += 4;
        return value;
      }
      /**
       * Read a 64-bit floating number and move pointer forward by 8 bytes.
       * @returns The read value.
       */
      readFloat64() {
        const value = this._data.getFloat64(this.offset, this.littleEndian);
        this.offset += 8;
        return value;
      }
      /**
       * Read a 64-bit signed integer number and move pointer forward by 8 bytes.
       * @returns The read value.
       */
      readBigInt64() {
        const value = this._data.getBigInt64(this.offset, this.littleEndian);
        this.offset += 8;
        return value;
      }
      /**
       * Read a 64-bit unsigned integer number and move pointer forward by 8 bytes.
       * @returns The read value.
       */
      readBigUint64() {
        const value = this._data.getBigUint64(this.offset, this.littleEndian);
        this.offset += 8;
        return value;
      }
      /**
       * Read a 1-byte ASCII character and move pointer forward by 1 byte.
       * @returns The read character.
       */
      readChar() {
        return String.fromCharCode(this.readInt8());
      }
      /**
       * Read `n` 1-byte ASCII characters and move pointer forward by `n` bytes.
       * @param n - Number of characters to read.
       * @returns The read characters.
       */
      readChars(n = 1) {
        let result = "";
        for (let i = 0; i < n; i++) {
          result += this.readChar();
        }
        return result;
      }
      /**
       * Read the next `n` bytes, return a UTF-8 decoded string and move pointer
       * forward by `n` bytes.
       * @param n - Number of bytes to read.
       * @returns The decoded string.
       */
      readUtf8(n = 1) {
        return decode(this.readBytes(n));
      }
      /**
       * Read the next `n` bytes, return a string decoded with `encoding` and move pointer
       * forward by `n` bytes.
       * If no encoding is passed, the function is equivalent to @see {@link IOBuffer#readUtf8}
       * @param n - Number of bytes to read.
       * @param encoding - The encoding to use. Default is 'utf8'.
       * @returns The decoded string.
       */
      decodeText(n = 1, encoding = "utf8") {
        return decode(this.readBytes(n), encoding);
      }
      /**
       * Write 0xff if the passed value is truthy, 0x00 otherwise and move pointer
       * forward by 1 byte.
       * @param value - The value to write.
       * @returns This.
       */
      writeBoolean(value) {
        this.writeUint8(value ? 255 : 0);
        return this;
      }
      /**
       * Write `value` as an 8-bit signed integer and move pointer forward by 1 byte.
       * @param value - The value to write.
       * @returns This.
       */
      writeInt8(value) {
        this.ensureAvailable(1);
        this._data.setInt8(this.offset++, value);
        this._updateLastWrittenByte();
        return this;
      }
      /**
       * Write `value` as an 8-bit unsigned integer and move pointer forward by 1
       * byte.
       * @param value - The value to write.
       * @returns This.
       */
      writeUint8(value) {
        this.ensureAvailable(1);
        this._data.setUint8(this.offset++, value);
        this._updateLastWrittenByte();
        return this;
      }
      /**
       * An alias for {@link IOBuffer#writeUint8}.
       * @param value - The value to write.
       * @returns This.
       */
      writeByte(value) {
        return this.writeUint8(value);
      }
      /**
       * Write all elements of `bytes` as uint8 values and move pointer forward by
       * `bytes.length` bytes.
       * @param bytes - The array of bytes to write.
       * @returns This.
       */
      writeBytes(bytes) {
        this.ensureAvailable(bytes.length);
        for (let i = 0; i < bytes.length; i++) {
          this._data.setUint8(this.offset++, bytes[i]);
        }
        this._updateLastWrittenByte();
        return this;
      }
      /**
       * Write `value` as a 16-bit signed integer and move pointer forward by 2
       * bytes.
       * @param value - The value to write.
       * @returns This.
       */
      writeInt16(value) {
        this.ensureAvailable(2);
        this._data.setInt16(this.offset, value, this.littleEndian);
        this.offset += 2;
        this._updateLastWrittenByte();
        return this;
      }
      /**
       * Write `value` as a 16-bit unsigned integer and move pointer forward by 2
       * bytes.
       * @param value - The value to write.
       * @returns This.
       */
      writeUint16(value) {
        this.ensureAvailable(2);
        this._data.setUint16(this.offset, value, this.littleEndian);
        this.offset += 2;
        this._updateLastWrittenByte();
        return this;
      }
      /**
       * Write `value` as a 32-bit signed integer and move pointer forward by 4
       * bytes.
       * @param value - The value to write.
       * @returns This.
       */
      writeInt32(value) {
        this.ensureAvailable(4);
        this._data.setInt32(this.offset, value, this.littleEndian);
        this.offset += 4;
        this._updateLastWrittenByte();
        return this;
      }
      /**
       * Write `value` as a 32-bit unsigned integer and move pointer forward by 4
       * bytes.
       * @param value - The value to write.
       * @returns This.
       */
      writeUint32(value) {
        this.ensureAvailable(4);
        this._data.setUint32(this.offset, value, this.littleEndian);
        this.offset += 4;
        this._updateLastWrittenByte();
        return this;
      }
      /**
       * Write `value` as a 32-bit floating number and move pointer forward by 4
       * bytes.
       * @param value - The value to write.
       * @returns This.
       */
      writeFloat32(value) {
        this.ensureAvailable(4);
        this._data.setFloat32(this.offset, value, this.littleEndian);
        this.offset += 4;
        this._updateLastWrittenByte();
        return this;
      }
      /**
       * Write `value` as a 64-bit floating number and move pointer forward by 8
       * bytes.
       * @param value - The value to write.
       * @returns This.
       */
      writeFloat64(value) {
        this.ensureAvailable(8);
        this._data.setFloat64(this.offset, value, this.littleEndian);
        this.offset += 8;
        this._updateLastWrittenByte();
        return this;
      }
      /**
       * Write `value` as a 64-bit signed bigint and move pointer forward by 8
       * bytes.
       * @param value - The value to write.
       * @returns This.
       */
      writeBigInt64(value) {
        this.ensureAvailable(8);
        this._data.setBigInt64(this.offset, value, this.littleEndian);
        this.offset += 8;
        this._updateLastWrittenByte();
        return this;
      }
      /**
       * Write `value` as a 64-bit unsigned bigint and move pointer forward by 8
       * bytes.
       * @param value - The value to write.
       * @returns This.
       */
      writeBigUint64(value) {
        this.ensureAvailable(8);
        this._data.setBigUint64(this.offset, value, this.littleEndian);
        this.offset += 8;
        this._updateLastWrittenByte();
        return this;
      }
      /**
       * Write the charCode of `str`'s first character as an 8-bit unsigned integer
       * and move pointer forward by 1 byte.
       * @param str - The character to write.
       * @returns This.
       */
      writeChar(str) {
        return this.writeUint8(str.charCodeAt(0));
      }
      /**
       * Write the charCodes of all `str`'s characters as 8-bit unsigned integers
       * and move pointer forward by `str.length` bytes.
       * @param str - The characters to write.
       * @returns This.
       */
      writeChars(str) {
        for (let i = 0; i < str.length; i++) {
          this.writeUint8(str.charCodeAt(i));
        }
        return this;
      }
      /**
       * UTF-8 encode and write `str` to the current pointer offset and move pointer
       * forward according to the encoded length.
       * @param str - The string to write.
       * @returns This.
       */
      writeUtf8(str) {
        return this.writeBytes(encode(str));
      }
      /**
       * Export a Uint8Array view of the internal buffer.
       * The view starts at the byte offset and its length
       * is calculated to stop at the last written byte or the original length.
       * @returns A new Uint8Array view.
       */
      toArray() {
        return new Uint8Array(this.buffer, this.byteOffset, this.lastWrittenByte);
      }
      /**
       *  Get the total number of bytes written so far, regardless of the current offset.
       * @returns - Total number of bytes.
       */
      getWrittenByteLength() {
        return this.lastWrittenByte - this.byteOffset;
      }
      /**
       * Update the last written byte offset
       * @private
       */
      _updateLastWrittenByte() {
        if (this.offset > this.lastWrittenByte) {
          this.lastWrittenByte = this.offset;
        }
      }
    };
  }
});

// node_modules/pako/dist/pako.esm.mjs
function zero$1(buf) {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED$2;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  this.heap = new Uint16Array(2 * L_CODES + 1);
  zero(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new Uint16Array(2 * L_CODES + 1);
  zero(this.depth);
  this.sym_buf = 0;
  this.lit_bufsize = 0;
  this.sym_next = 0;
  this.sym_end = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
function ZStream() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
function Deflate$1(options) {
  this.options = common.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, options || {});
  let opt = this.options;
  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = deflate_1$2.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );
  if (status !== Z_OK$2) {
    throw new Error(messages[status]);
  }
  if (opt.header) {
    deflate_1$2.deflateSetHeader(this.strm, opt.header);
  }
  if (opt.dictionary) {
    let dict;
    if (typeof opt.dictionary === "string") {
      dict = strings.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }
    status = deflate_1$2.deflateSetDictionary(this.strm, dict);
    if (status !== Z_OK$2) {
      throw new Error(messages[status]);
    }
    this._dict_set = true;
  }
}
function deflate$1(input, options) {
  const deflator = new Deflate$1(options);
  deflator.push(input, true);
  if (deflator.err) {
    throw deflator.msg || messages[deflator.err];
  }
  return deflator.result;
}
function deflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return deflate$1(input, options);
}
function gzip$1(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate$1(input, options);
}
function InflateState() {
  this.strm = null;
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new Uint16Array(320);
  this.work = new Uint16Array(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
function GZheader() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
function Inflate$1(options) {
  this.options = common.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, options || {});
  const opt = this.options;
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = inflate_1$2.inflateInit2(
    this.strm,
    opt.windowBits
  );
  if (status !== Z_OK) {
    throw new Error(messages[status]);
  }
  this.header = new gzheader();
  inflate_1$2.inflateGetHeader(this.strm, this.header);
  if (opt.dictionary) {
    if (typeof opt.dictionary === "string") {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString2.call(opt.dictionary) === "[object ArrayBuffer]") {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(messages[status]);
      }
    }
  }
}
function inflate$1(input, options) {
  const inflator = new Inflate$1(options);
  inflator.push(input);
  if (inflator.err) throw inflator.msg || messages[inflator.err];
  return inflator.result;
}
function inflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return inflate$1(input, options);
}
var Z_FIXED$1, Z_BINARY, Z_TEXT, Z_UNKNOWN$1, STORED_BLOCK, STATIC_TREES, DYN_TREES, MIN_MATCH$1, MAX_MATCH$1, LENGTH_CODES$1, LITERALS$1, L_CODES$1, D_CODES$1, BL_CODES$1, HEAP_SIZE$1, MAX_BITS$1, Buf_size, MAX_BL_BITS, END_BLOCK, REP_3_6, REPZ_3_10, REPZ_11_138, extra_lbits, extra_dbits, extra_blbits, bl_order, DIST_CODE_LEN, static_ltree, static_dtree, _dist_code, _length_code, base_length, base_dist, static_l_desc, static_d_desc, static_bl_desc, d_code, put_short, send_bits, send_code, bi_reverse, bi_flush, gen_bitlen, gen_codes, tr_static_init, init_block, bi_windup, smaller, pqdownheap, compress_block, build_tree, scan_tree, send_tree, build_bl_tree, send_all_trees, detect_data_type, static_init_done, _tr_init$1, _tr_stored_block$1, _tr_align$1, _tr_flush_block$1, _tr_tally$1, _tr_init_1, _tr_stored_block_1, _tr_flush_block_1, _tr_tally_1, _tr_align_1, trees, adler32, adler32_1, makeTable, crcTable, crc32, crc32_1, messages, constants$2, _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align, Z_NO_FLUSH$2, Z_PARTIAL_FLUSH, Z_FULL_FLUSH$1, Z_FINISH$3, Z_BLOCK$1, Z_OK$3, Z_STREAM_END$3, Z_STREAM_ERROR$2, Z_DATA_ERROR$2, Z_BUF_ERROR$1, Z_DEFAULT_COMPRESSION$1, Z_FILTERED, Z_HUFFMAN_ONLY, Z_RLE, Z_FIXED, Z_DEFAULT_STRATEGY$1, Z_UNKNOWN, Z_DEFLATED$2, MAX_MEM_LEVEL, MAX_WBITS$1, DEF_MEM_LEVEL, LENGTH_CODES, LITERALS, L_CODES, D_CODES, BL_CODES, HEAP_SIZE, MAX_BITS, MIN_MATCH, MAX_MATCH, MIN_LOOKAHEAD, PRESET_DICT, INIT_STATE, GZIP_STATE, EXTRA_STATE, NAME_STATE, COMMENT_STATE, HCRC_STATE, BUSY_STATE, FINISH_STATE, BS_NEED_MORE, BS_BLOCK_DONE, BS_FINISH_STARTED, BS_FINISH_DONE, OS_CODE, err, rank, zero, slide_hash, HASH_ZLIB, HASH, flush_pending, flush_block_only, put_byte, putShortMSB, read_buf, longest_match, fill_window, deflate_stored, deflate_fast, deflate_slow, deflate_rle, deflate_huff, configuration_table, lm_init, deflateStateCheck, deflateResetKeep, deflateReset, deflateSetHeader, deflateInit2, deflateInit, deflate$2, deflateEnd, deflateSetDictionary, deflateInit_1, deflateInit2_1, deflateReset_1, deflateResetKeep_1, deflateSetHeader_1, deflate_2$1, deflateEnd_1, deflateSetDictionary_1, deflateInfo, deflate_1$2, _has, assign, flattenChunks, common, STR_APPLY_UIA_OK, _utf8len, string2buf, buf2binstring, buf2string, utf8border, strings, zstream, toString$1, Z_NO_FLUSH$1, Z_SYNC_FLUSH, Z_FULL_FLUSH, Z_FINISH$2, Z_OK$2, Z_STREAM_END$2, Z_DEFAULT_COMPRESSION, Z_DEFAULT_STRATEGY, Z_DEFLATED$1, Deflate_1$1, deflate_2, deflateRaw_1$1, gzip_1$1, constants$1, deflate_1$1, BAD$1, TYPE$1, inffast, MAXBITS, ENOUGH_LENS$1, ENOUGH_DISTS$1, CODES$1, LENS$1, DISTS$1, lbase, lext, dbase, dext, inflate_table, inftrees, CODES, LENS, DISTS, Z_FINISH$1, Z_BLOCK, Z_TREES, Z_OK$1, Z_STREAM_END$1, Z_NEED_DICT$1, Z_STREAM_ERROR$1, Z_DATA_ERROR$1, Z_MEM_ERROR$1, Z_BUF_ERROR, Z_DEFLATED, HEAD, FLAGS, TIME, OS, EXLEN, EXTRA, NAME, COMMENT, HCRC, DICTID, DICT, TYPE, TYPEDO, STORED, COPY_, COPY, TABLE, LENLENS, CODELENS, LEN_, LEN, LENEXT, DIST, DISTEXT, MATCH, LIT, CHECK, LENGTH, DONE, BAD, MEM, SYNC, ENOUGH_LENS, ENOUGH_DISTS, MAX_WBITS, DEF_WBITS, zswap32, inflateStateCheck, inflateResetKeep, inflateReset, inflateReset2, inflateInit2, inflateInit, virgin, lenfix, distfix, fixedtables, updatewindow, inflate$2, inflateEnd, inflateGetHeader, inflateSetDictionary, inflateReset_1, inflateReset2_1, inflateResetKeep_1, inflateInit_1, inflateInit2_1, inflate_2$1, inflateEnd_1, inflateGetHeader_1, inflateSetDictionary_1, inflateInfo, inflate_1$2, gzheader, toString2, Z_NO_FLUSH, Z_FINISH, Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR, Inflate_1$1, inflate_2, inflateRaw_1$1, ungzip$1, constants, inflate_1$1, Deflate, deflate, deflateRaw, gzip, Inflate, inflate, inflateRaw, ungzip, deflate_1, Inflate_1, inflate_1;
var init_pako_esm = __esm({
  "node_modules/pako/dist/pako.esm.mjs"() {
    "use strict";
    Z_FIXED$1 = 4;
    Z_BINARY = 0;
    Z_TEXT = 1;
    Z_UNKNOWN$1 = 2;
    STORED_BLOCK = 0;
    STATIC_TREES = 1;
    DYN_TREES = 2;
    MIN_MATCH$1 = 3;
    MAX_MATCH$1 = 258;
    LENGTH_CODES$1 = 29;
    LITERALS$1 = 256;
    L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
    D_CODES$1 = 30;
    BL_CODES$1 = 19;
    HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
    MAX_BITS$1 = 15;
    Buf_size = 16;
    MAX_BL_BITS = 7;
    END_BLOCK = 256;
    REP_3_6 = 16;
    REPZ_3_10 = 17;
    REPZ_11_138 = 18;
    extra_lbits = /* extra bits for each length code */
    new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]);
    extra_dbits = /* extra bits for each distance code */
    new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
    extra_blbits = /* extra bits for each bit length code */
    new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]);
    bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    DIST_CODE_LEN = 512;
    static_ltree = new Array((L_CODES$1 + 2) * 2);
    zero$1(static_ltree);
    static_dtree = new Array(D_CODES$1 * 2);
    zero$1(static_dtree);
    _dist_code = new Array(DIST_CODE_LEN);
    zero$1(_dist_code);
    _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
    zero$1(_length_code);
    base_length = new Array(LENGTH_CODES$1);
    zero$1(base_length);
    base_dist = new Array(D_CODES$1);
    zero$1(base_dist);
    d_code = (dist) => {
      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    };
    put_short = (s, w) => {
      s.pending_buf[s.pending++] = w & 255;
      s.pending_buf[s.pending++] = w >>> 8 & 255;
    };
    send_bits = (s, value, length) => {
      if (s.bi_valid > Buf_size - length) {
        s.bi_buf |= value << s.bi_valid & 65535;
        put_short(s, s.bi_buf);
        s.bi_buf = value >> Buf_size - s.bi_valid;
        s.bi_valid += length - Buf_size;
      } else {
        s.bi_buf |= value << s.bi_valid & 65535;
        s.bi_valid += length;
      }
    };
    send_code = (s, c, tree) => {
      send_bits(
        s,
        tree[c * 2],
        tree[c * 2 + 1]
        /*.Len*/
      );
    };
    bi_reverse = (code, len) => {
      let res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    };
    bi_flush = (s) => {
      if (s.bi_valid === 16) {
        put_short(s, s.bi_buf);
        s.bi_buf = 0;
        s.bi_valid = 0;
      } else if (s.bi_valid >= 8) {
        s.pending_buf[s.pending++] = s.bi_buf & 255;
        s.bi_buf >>= 8;
        s.bi_valid -= 8;
      }
    };
    gen_bitlen = (s, desc) => {
      const tree = desc.dyn_tree;
      const max_code = desc.max_code;
      const stree = desc.stat_desc.static_tree;
      const has_stree = desc.stat_desc.has_stree;
      const extra = desc.stat_desc.extra_bits;
      const base = desc.stat_desc.extra_base;
      const max_length = desc.stat_desc.max_length;
      let h;
      let n, m;
      let bits;
      let xbits;
      let f2;
      let overflow2 = 0;
      for (bits = 0; bits <= MAX_BITS$1; bits++) {
        s.bl_count[bits] = 0;
      }
      tree[s.heap[s.heap_max] * 2 + 1] = 0;
      for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {
        n = s.heap[h];
        bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow2++;
        }
        tree[n * 2 + 1] = bits;
        if (n > max_code) {
          continue;
        }
        s.bl_count[bits]++;
        xbits = 0;
        if (n >= base) {
          xbits = extra[n - base];
        }
        f2 = tree[n * 2];
        s.opt_len += f2 * (bits + xbits);
        if (has_stree) {
          s.static_len += f2 * (stree[n * 2 + 1] + xbits);
        }
      }
      if (overflow2 === 0) {
        return;
      }
      do {
        bits = max_length - 1;
        while (s.bl_count[bits] === 0) {
          bits--;
        }
        s.bl_count[bits]--;
        s.bl_count[bits + 1] += 2;
        s.bl_count[max_length]--;
        overflow2 -= 2;
      } while (overflow2 > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n = s.bl_count[bits];
        while (n !== 0) {
          m = s.heap[--h];
          if (m > max_code) {
            continue;
          }
          if (tree[m * 2 + 1] !== bits) {
            s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
            tree[m * 2 + 1] = bits;
          }
          n--;
        }
      }
    };
    gen_codes = (tree, max_code, bl_count) => {
      const next_code = new Array(MAX_BITS$1 + 1);
      let code = 0;
      let bits;
      let n;
      for (bits = 1; bits <= MAX_BITS$1; bits++) {
        code = code + bl_count[bits - 1] << 1;
        next_code[bits] = code;
      }
      for (n = 0; n <= max_code; n++) {
        let len = tree[n * 2 + 1];
        if (len === 0) {
          continue;
        }
        tree[n * 2] = bi_reverse(next_code[len]++, len);
      }
    };
    tr_static_init = () => {
      let n;
      let bits;
      let length;
      let code;
      let dist;
      const bl_count = new Array(MAX_BITS$1 + 1);
      length = 0;
      for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
        base_length[code] = length;
        for (n = 0; n < 1 << extra_lbits[code]; n++) {
          _length_code[length++] = code;
        }
      }
      _length_code[length - 1] = code;
      dist = 0;
      for (code = 0; code < 16; code++) {
        base_dist[code] = dist;
        for (n = 0; n < 1 << extra_dbits[code]; n++) {
          _dist_code[dist++] = code;
        }
      }
      dist >>= 7;
      for (; code < D_CODES$1; code++) {
        base_dist[code] = dist << 7;
        for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
          _dist_code[256 + dist++] = code;
        }
      }
      for (bits = 0; bits <= MAX_BITS$1; bits++) {
        bl_count[bits] = 0;
      }
      n = 0;
      while (n <= 143) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      while (n <= 255) {
        static_ltree[n * 2 + 1] = 9;
        n++;
        bl_count[9]++;
      }
      while (n <= 279) {
        static_ltree[n * 2 + 1] = 7;
        n++;
        bl_count[7]++;
      }
      while (n <= 287) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
      for (n = 0; n < D_CODES$1; n++) {
        static_dtree[n * 2 + 1] = 5;
        static_dtree[n * 2] = bi_reverse(n, 5);
      }
      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
    };
    init_block = (s) => {
      let n;
      for (n = 0; n < L_CODES$1; n++) {
        s.dyn_ltree[n * 2] = 0;
      }
      for (n = 0; n < D_CODES$1; n++) {
        s.dyn_dtree[n * 2] = 0;
      }
      for (n = 0; n < BL_CODES$1; n++) {
        s.bl_tree[n * 2] = 0;
      }
      s.dyn_ltree[END_BLOCK * 2] = 1;
      s.opt_len = s.static_len = 0;
      s.sym_next = s.matches = 0;
    };
    bi_windup = (s) => {
      if (s.bi_valid > 8) {
        put_short(s, s.bi_buf);
      } else if (s.bi_valid > 0) {
        s.pending_buf[s.pending++] = s.bi_buf;
      }
      s.bi_buf = 0;
      s.bi_valid = 0;
    };
    smaller = (tree, n, m, depth) => {
      const _n2 = n * 2;
      const _m2 = m * 2;
      return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
    };
    pqdownheap = (s, tree, k) => {
      const v = s.heap[k];
      let j = k << 1;
      while (j <= s.heap_len) {
        if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
          j++;
        }
        if (smaller(tree, v, s.heap[j], s.depth)) {
          break;
        }
        s.heap[k] = s.heap[j];
        k = j;
        j <<= 1;
      }
      s.heap[k] = v;
    };
    compress_block = (s, ltree, dtree) => {
      let dist;
      let lc;
      let sx = 0;
      let code;
      let extra;
      if (s.sym_next !== 0) {
        do {
          dist = s.pending_buf[s.sym_buf + sx++] & 255;
          dist += (s.pending_buf[s.sym_buf + sx++] & 255) << 8;
          lc = s.pending_buf[s.sym_buf + sx++];
          if (dist === 0) {
            send_code(s, lc, ltree);
          } else {
            code = _length_code[lc];
            send_code(s, code + LITERALS$1 + 1, ltree);
            extra = extra_lbits[code];
            if (extra !== 0) {
              lc -= base_length[code];
              send_bits(s, lc, extra);
            }
            dist--;
            code = d_code(dist);
            send_code(s, code, dtree);
            extra = extra_dbits[code];
            if (extra !== 0) {
              dist -= base_dist[code];
              send_bits(s, dist, extra);
            }
          }
        } while (sx < s.sym_next);
      }
      send_code(s, END_BLOCK, ltree);
    };
    build_tree = (s, desc) => {
      const tree = desc.dyn_tree;
      const stree = desc.stat_desc.static_tree;
      const has_stree = desc.stat_desc.has_stree;
      const elems = desc.stat_desc.elems;
      let n, m;
      let max_code = -1;
      let node;
      s.heap_len = 0;
      s.heap_max = HEAP_SIZE$1;
      for (n = 0; n < elems; n++) {
        if (tree[n * 2] !== 0) {
          s.heap[++s.heap_len] = max_code = n;
          s.depth[n] = 0;
        } else {
          tree[n * 2 + 1] = 0;
        }
      }
      while (s.heap_len < 2) {
        node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s.depth[node] = 0;
        s.opt_len--;
        if (has_stree) {
          s.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n = s.heap_len >> 1; n >= 1; n--) {
        pqdownheap(s, tree, n);
      }
      node = elems;
      do {
        n = s.heap[
          1
          /*SMALLEST*/
        ];
        s.heap[
          1
          /*SMALLEST*/
        ] = s.heap[s.heap_len--];
        pqdownheap(
          s,
          tree,
          1
          /*SMALLEST*/
        );
        m = s.heap[
          1
          /*SMALLEST*/
        ];
        s.heap[--s.heap_max] = n;
        s.heap[--s.heap_max] = m;
        tree[node * 2] = tree[n * 2] + tree[m * 2];
        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
        tree[n * 2 + 1] = tree[m * 2 + 1] = node;
        s.heap[
          1
          /*SMALLEST*/
        ] = node++;
        pqdownheap(
          s,
          tree,
          1
          /*SMALLEST*/
        );
      } while (s.heap_len >= 2);
      s.heap[--s.heap_max] = s.heap[
        1
        /*SMALLEST*/
      ];
      gen_bitlen(s, desc);
      gen_codes(tree, max_code, s.bl_count);
    };
    scan_tree = (s, tree, max_code) => {
      let n;
      let prevlen = -1;
      let curlen;
      let nextlen = tree[0 * 2 + 1];
      let count = 0;
      let max_count = 7;
      let min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 65535;
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          s.bl_tree[curlen * 2] += count;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s.bl_tree[curlen * 2]++;
          }
          s.bl_tree[REP_3_6 * 2]++;
        } else if (count <= 10) {
          s.bl_tree[REPZ_3_10 * 2]++;
        } else {
          s.bl_tree[REPZ_11_138 * 2]++;
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    };
    send_tree = (s, tree, max_code) => {
      let n;
      let prevlen = -1;
      let curlen;
      let nextlen = tree[0 * 2 + 1];
      let count = 0;
      let max_count = 7;
      let min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          do {
            send_code(s, curlen, s.bl_tree);
          } while (--count !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code(s, curlen, s.bl_tree);
            count--;
          }
          send_code(s, REP_3_6, s.bl_tree);
          send_bits(s, count - 3, 2);
        } else if (count <= 10) {
          send_code(s, REPZ_3_10, s.bl_tree);
          send_bits(s, count - 3, 3);
        } else {
          send_code(s, REPZ_11_138, s.bl_tree);
          send_bits(s, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    };
    build_bl_tree = (s) => {
      let max_blindex;
      scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
      scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
      build_tree(s, s.bl_desc);
      for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
        if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    };
    send_all_trees = (s, lcodes, dcodes, blcodes) => {
      let rank2;
      send_bits(s, lcodes - 257, 5);
      send_bits(s, dcodes - 1, 5);
      send_bits(s, blcodes - 4, 4);
      for (rank2 = 0; rank2 < blcodes; rank2++) {
        send_bits(s, s.bl_tree[bl_order[rank2] * 2 + 1], 3);
      }
      send_tree(s, s.dyn_ltree, lcodes - 1);
      send_tree(s, s.dyn_dtree, dcodes - 1);
    };
    detect_data_type = (s) => {
      let block_mask = 4093624447;
      let n;
      for (n = 0; n <= 31; n++, block_mask >>>= 1) {
        if (block_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
          return Z_BINARY;
        }
      }
      if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
        return Z_TEXT;
      }
      for (n = 32; n < LITERALS$1; n++) {
        if (s.dyn_ltree[n * 2] !== 0) {
          return Z_TEXT;
        }
      }
      return Z_BINARY;
    };
    static_init_done = false;
    _tr_init$1 = (s) => {
      if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
      }
      s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
      s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
      s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
      s.bi_buf = 0;
      s.bi_valid = 0;
      init_block(s);
    };
    _tr_stored_block$1 = (s, buf, stored_len, last) => {
      send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
      bi_windup(s);
      put_short(s, stored_len);
      put_short(s, ~stored_len);
      if (stored_len) {
        s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
      }
      s.pending += stored_len;
    };
    _tr_align$1 = (s) => {
      send_bits(s, STATIC_TREES << 1, 3);
      send_code(s, END_BLOCK, static_ltree);
      bi_flush(s);
    };
    _tr_flush_block$1 = (s, buf, stored_len, last) => {
      let opt_lenb, static_lenb;
      let max_blindex = 0;
      if (s.level > 0) {
        if (s.strm.data_type === Z_UNKNOWN$1) {
          s.strm.data_type = detect_data_type(s);
        }
        build_tree(s, s.l_desc);
        build_tree(s, s.d_desc);
        max_blindex = build_bl_tree(s);
        opt_lenb = s.opt_len + 3 + 7 >>> 3;
        static_lenb = s.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if (stored_len + 4 <= opt_lenb && buf !== -1) {
        _tr_stored_block$1(s, buf, stored_len, last);
      } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
        send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
        compress_block(s, static_ltree, static_dtree);
      } else {
        send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s, s.dyn_ltree, s.dyn_dtree);
      }
      init_block(s);
      if (last) {
        bi_windup(s);
      }
    };
    _tr_tally$1 = (s, dist, lc) => {
      s.pending_buf[s.sym_buf + s.sym_next++] = dist;
      s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;
      s.pending_buf[s.sym_buf + s.sym_next++] = lc;
      if (dist === 0) {
        s.dyn_ltree[lc * 2]++;
      } else {
        s.matches++;
        dist--;
        s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
        s.dyn_dtree[d_code(dist) * 2]++;
      }
      return s.sym_next === s.sym_end;
    };
    _tr_init_1 = _tr_init$1;
    _tr_stored_block_1 = _tr_stored_block$1;
    _tr_flush_block_1 = _tr_flush_block$1;
    _tr_tally_1 = _tr_tally$1;
    _tr_align_1 = _tr_align$1;
    trees = {
      _tr_init: _tr_init_1,
      _tr_stored_block: _tr_stored_block_1,
      _tr_flush_block: _tr_flush_block_1,
      _tr_tally: _tr_tally_1,
      _tr_align: _tr_align_1
    };
    adler32 = (adler, buf, len, pos) => {
      let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
      while (len !== 0) {
        n = len > 2e3 ? 2e3 : len;
        len -= n;
        do {
          s1 = s1 + buf[pos++] | 0;
          s2 = s2 + s1 | 0;
        } while (--n);
        s1 %= 65521;
        s2 %= 65521;
      }
      return s1 | s2 << 16 | 0;
    };
    adler32_1 = adler32;
    makeTable = () => {
      let c, table = [];
      for (var n = 0; n < 256; n++) {
        c = n;
        for (var k = 0; k < 8; k++) {
          c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
        }
        table[n] = c;
      }
      return table;
    };
    crcTable = new Uint32Array(makeTable());
    crc32 = (crc2, buf, len, pos) => {
      const t = crcTable;
      const end = pos + len;
      crc2 ^= -1;
      for (let i = pos; i < end; i++) {
        crc2 = crc2 >>> 8 ^ t[(crc2 ^ buf[i]) & 255];
      }
      return crc2 ^ -1;
    };
    crc32_1 = crc32;
    messages = {
      2: "need dictionary",
      /* Z_NEED_DICT       2  */
      1: "stream end",
      /* Z_STREAM_END      1  */
      0: "",
      /* Z_OK              0  */
      "-1": "file error",
      /* Z_ERRNO         (-1) */
      "-2": "stream error",
      /* Z_STREAM_ERROR  (-2) */
      "-3": "data error",
      /* Z_DATA_ERROR    (-3) */
      "-4": "insufficient memory",
      /* Z_MEM_ERROR     (-4) */
      "-5": "buffer error",
      /* Z_BUF_ERROR     (-5) */
      "-6": "incompatible version"
      /* Z_VERSION_ERROR (-6) */
    };
    constants$2 = {
      /* Allowed flush values; see deflate() and inflate() below for details */
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      /* Return codes for the compression/decompression functions. Negative values
      * are errors, positive values are used for special but normal events.
      */
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      Z_MEM_ERROR: -4,
      Z_BUF_ERROR: -5,
      //Z_VERSION_ERROR: -6,
      /* compression levels */
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      /* Possible values of the data_type field (though see inflate()) */
      Z_BINARY: 0,
      Z_TEXT: 1,
      //Z_ASCII:                1, // = Z_TEXT (deprecated)
      Z_UNKNOWN: 2,
      /* The deflate compression method */
      Z_DEFLATED: 8
      //Z_NULL:                 null // Use -1 or null inline, depending on var type
    };
    ({ _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees);
    ({
      Z_NO_FLUSH: Z_NO_FLUSH$2,
      Z_PARTIAL_FLUSH,
      Z_FULL_FLUSH: Z_FULL_FLUSH$1,
      Z_FINISH: Z_FINISH$3,
      Z_BLOCK: Z_BLOCK$1,
      Z_OK: Z_OK$3,
      Z_STREAM_END: Z_STREAM_END$3,
      Z_STREAM_ERROR: Z_STREAM_ERROR$2,
      Z_DATA_ERROR: Z_DATA_ERROR$2,
      Z_BUF_ERROR: Z_BUF_ERROR$1,
      Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
      Z_FILTERED,
      Z_HUFFMAN_ONLY,
      Z_RLE,
      Z_FIXED,
      Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
      Z_UNKNOWN,
      Z_DEFLATED: Z_DEFLATED$2
    } = constants$2);
    MAX_MEM_LEVEL = 9;
    MAX_WBITS$1 = 15;
    DEF_MEM_LEVEL = 8;
    LENGTH_CODES = 29;
    LITERALS = 256;
    L_CODES = LITERALS + 1 + LENGTH_CODES;
    D_CODES = 30;
    BL_CODES = 19;
    HEAP_SIZE = 2 * L_CODES + 1;
    MAX_BITS = 15;
    MIN_MATCH = 3;
    MAX_MATCH = 258;
    MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
    PRESET_DICT = 32;
    INIT_STATE = 42;
    GZIP_STATE = 57;
    EXTRA_STATE = 69;
    NAME_STATE = 73;
    COMMENT_STATE = 91;
    HCRC_STATE = 103;
    BUSY_STATE = 113;
    FINISH_STATE = 666;
    BS_NEED_MORE = 1;
    BS_BLOCK_DONE = 2;
    BS_FINISH_STARTED = 3;
    BS_FINISH_DONE = 4;
    OS_CODE = 3;
    err = (strm, errorCode) => {
      strm.msg = messages[errorCode];
      return errorCode;
    };
    rank = (f2) => {
      return f2 * 2 - (f2 > 4 ? 9 : 0);
    };
    zero = (buf) => {
      let len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    };
    slide_hash = (s) => {
      let n, m;
      let p;
      let wsize = s.w_size;
      n = s.hash_size;
      p = n;
      do {
        m = s.head[--p];
        s.head[p] = m >= wsize ? m - wsize : 0;
      } while (--n);
      n = wsize;
      p = n;
      do {
        m = s.prev[--p];
        s.prev[p] = m >= wsize ? m - wsize : 0;
      } while (--n);
    };
    HASH_ZLIB = (s, prev, data) => (prev << s.hash_shift ^ data) & s.hash_mask;
    HASH = HASH_ZLIB;
    flush_pending = (strm) => {
      const s = strm.state;
      let len = s.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
      strm.next_out += len;
      s.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s.pending -= len;
      if (s.pending === 0) {
        s.pending_out = 0;
      }
    };
    flush_block_only = (s, last) => {
      _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
      s.block_start = s.strstart;
      flush_pending(s.strm);
    };
    put_byte = (s, b) => {
      s.pending_buf[s.pending++] = b;
    };
    putShortMSB = (s, b) => {
      s.pending_buf[s.pending++] = b >>> 8 & 255;
      s.pending_buf[s.pending++] = b & 255;
    };
    read_buf = (strm, buf, start, size) => {
      let len = strm.avail_in;
      if (len > size) {
        len = size;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len;
      buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
      if (strm.state.wrap === 1) {
        strm.adler = adler32_1(strm.adler, buf, len, start);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc32_1(strm.adler, buf, len, start);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    };
    longest_match = (s, cur_match) => {
      let chain_length = s.max_chain_length;
      let scan = s.strstart;
      let match;
      let len;
      let best_len = s.prev_length;
      let nice_match = s.nice_match;
      const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
      const _win = s.window;
      const wmask = s.w_mask;
      const prev = s.prev;
      const strend = s.strstart + MAX_MATCH;
      let scan_end1 = _win[scan + best_len - 1];
      let scan_end = _win[scan + best_len];
      if (s.prev_length >= s.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s.lookahead) {
        nice_match = s.lookahead;
      }
      do {
        match = cur_match;
        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
          continue;
        }
        scan += 2;
        match++;
        do {
        } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len > best_len) {
          s.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s.lookahead) {
        return best_len;
      }
      return s.lookahead;
    };
    fill_window = (s) => {
      const _w_size = s.w_size;
      let n, more, str;
      do {
        more = s.window_size - s.lookahead - s.strstart;
        if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
          s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
          s.match_start -= _w_size;
          s.strstart -= _w_size;
          s.block_start -= _w_size;
          if (s.insert > s.strstart) {
            s.insert = s.strstart;
          }
          slide_hash(s);
          more += _w_size;
        }
        if (s.strm.avail_in === 0) {
          break;
        }
        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
        s.lookahead += n;
        if (s.lookahead + s.insert >= MIN_MATCH) {
          str = s.strstart - s.insert;
          s.ins_h = s.window[str];
          s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
          while (s.insert) {
            s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
            s.prev[str & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str;
            str++;
            s.insert--;
            if (s.lookahead + s.insert < MIN_MATCH) {
              break;
            }
          }
        }
      } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
    };
    deflate_stored = (s, flush) => {
      let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;
      let len, left, have, last = 0;
      let used = s.strm.avail_in;
      do {
        len = 65535;
        have = s.bi_valid + 42 >> 3;
        if (s.strm.avail_out < have) {
          break;
        }
        have = s.strm.avail_out - have;
        left = s.strstart - s.block_start;
        if (len > left + s.strm.avail_in) {
          len = left + s.strm.avail_in;
        }
        if (len > have) {
          len = have;
        }
        if (len < min_block && (len === 0 && flush !== Z_FINISH$3 || flush === Z_NO_FLUSH$2 || len !== left + s.strm.avail_in)) {
          break;
        }
        last = flush === Z_FINISH$3 && len === left + s.strm.avail_in ? 1 : 0;
        _tr_stored_block(s, 0, 0, last);
        s.pending_buf[s.pending - 4] = len;
        s.pending_buf[s.pending - 3] = len >> 8;
        s.pending_buf[s.pending - 2] = ~len;
        s.pending_buf[s.pending - 1] = ~len >> 8;
        flush_pending(s.strm);
        if (left) {
          if (left > len) {
            left = len;
          }
          s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
          s.strm.next_out += left;
          s.strm.avail_out -= left;
          s.strm.total_out += left;
          s.block_start += left;
          len -= left;
        }
        if (len) {
          read_buf(s.strm, s.strm.output, s.strm.next_out, len);
          s.strm.next_out += len;
          s.strm.avail_out -= len;
          s.strm.total_out += len;
        }
      } while (last === 0);
      used -= s.strm.avail_in;
      if (used) {
        if (used >= s.w_size) {
          s.matches = 2;
          s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
          s.strstart = s.w_size;
          s.insert = s.strstart;
        } else {
          if (s.window_size - s.strstart <= used) {
            s.strstart -= s.w_size;
            s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
            if (s.matches < 2) {
              s.matches++;
            }
            if (s.insert > s.strstart) {
              s.insert = s.strstart;
            }
          }
          s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
          s.strstart += used;
          s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
        }
        s.block_start = s.strstart;
      }
      if (s.high_water < s.strstart) {
        s.high_water = s.strstart;
      }
      if (last) {
        return BS_FINISH_DONE;
      }
      if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 && s.strm.avail_in === 0 && s.strstart === s.block_start) {
        return BS_BLOCK_DONE;
      }
      have = s.window_size - s.strstart;
      if (s.strm.avail_in > have && s.block_start >= s.w_size) {
        s.block_start -= s.w_size;
        s.strstart -= s.w_size;
        s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
        if (s.matches < 2) {
          s.matches++;
        }
        have += s.w_size;
        if (s.insert > s.strstart) {
          s.insert = s.strstart;
        }
      }
      if (have > s.strm.avail_in) {
        have = s.strm.avail_in;
      }
      if (have) {
        read_buf(s.strm, s.window, s.strstart, have);
        s.strstart += have;
        s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
      }
      if (s.high_water < s.strstart) {
        s.high_water = s.strstart;
      }
      have = s.bi_valid + 42 >> 3;
      have = s.pending_buf_size - have > 65535 ? 65535 : s.pending_buf_size - have;
      min_block = have > s.w_size ? s.w_size : have;
      left = s.strstart - s.block_start;
      if (left >= min_block || (left || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 && s.strm.avail_in === 0 && left <= have) {
        len = left > have ? have : left;
        last = flush === Z_FINISH$3 && s.strm.avail_in === 0 && len === left ? 1 : 0;
        _tr_stored_block(s, s.block_start, len, last);
        s.block_start += len;
        flush_pending(s.strm);
      }
      return last ? BS_FINISH_STARTED : BS_NEED_MORE;
    };
    deflate_fast = (s, flush) => {
      let hash_head;
      let bflush;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
            s.match_length--;
            do {
              s.strstart++;
              s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            } while (--s.match_length !== 0);
            s.strstart++;
          } else {
            s.strstart += s.match_length;
            s.match_length = 0;
            s.ins_h = s.window[s.strstart];
            s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
          }
        } else {
          bflush = _tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH$3) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.sym_next) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    deflate_slow = (s, flush) => {
      let hash_head;
      let bflush;
      let max_insert;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        s.prev_length = s.match_length;
        s.prev_match = s.match_start;
        s.match_length = MIN_MATCH - 1;
        if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
          if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
            s.match_length = MIN_MATCH - 1;
          }
        }
        if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
          max_insert = s.strstart + s.lookahead - MIN_MATCH;
          bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
          s.lookahead -= s.prev_length - 1;
          s.prev_length -= 2;
          do {
            if (++s.strstart <= max_insert) {
              s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            }
          } while (--s.prev_length !== 0);
          s.match_available = 0;
          s.match_length = MIN_MATCH - 1;
          s.strstart++;
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        } else if (s.match_available) {
          bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
          if (bflush) {
            flush_block_only(s, false);
          }
          s.strstart++;
          s.lookahead--;
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        } else {
          s.match_available = 1;
          s.strstart++;
          s.lookahead--;
        }
      }
      if (s.match_available) {
        bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
        s.match_available = 0;
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH$3) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.sym_next) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    deflate_rle = (s, flush) => {
      let bflush;
      let prev;
      let scan, strend;
      const _win = s.window;
      for (; ; ) {
        if (s.lookahead <= MAX_MATCH) {
          fill_window(s);
          if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.match_length = 0;
        if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
          scan = s.strstart - 1;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s.strstart + MAX_MATCH;
            do {
            } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
            s.match_length = MAX_MATCH - (strend - scan);
            if (s.match_length > s.lookahead) {
              s.match_length = s.lookahead;
            }
          }
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          s.strstart += s.match_length;
          s.match_length = 0;
        } else {
          bflush = _tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH$3) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.sym_next) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    deflate_huff = (s, flush) => {
      let bflush;
      for (; ; ) {
        if (s.lookahead === 0) {
          fill_window(s);
          if (s.lookahead === 0) {
            if (flush === Z_NO_FLUSH$2) {
              return BS_NEED_MORE;
            }
            break;
          }
        }
        s.match_length = 0;
        bflush = _tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH$3) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.sym_next) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    configuration_table = [
      /*      good lazy nice chain */
      new Config(0, 0, 0, 0, deflate_stored),
      /* 0 store only */
      new Config(4, 4, 8, 4, deflate_fast),
      /* 1 max speed, no lazy matches */
      new Config(4, 5, 16, 8, deflate_fast),
      /* 2 */
      new Config(4, 6, 32, 32, deflate_fast),
      /* 3 */
      new Config(4, 4, 16, 16, deflate_slow),
      /* 4 lazy matches */
      new Config(8, 16, 32, 32, deflate_slow),
      /* 5 */
      new Config(8, 16, 128, 128, deflate_slow),
      /* 6 */
      new Config(8, 32, 128, 256, deflate_slow),
      /* 7 */
      new Config(32, 128, 258, 1024, deflate_slow),
      /* 8 */
      new Config(32, 258, 258, 4096, deflate_slow)
      /* 9 max compression */
    ];
    lm_init = (s) => {
      s.window_size = 2 * s.w_size;
      zero(s.head);
      s.max_lazy_match = configuration_table[s.level].max_lazy;
      s.good_match = configuration_table[s.level].good_length;
      s.nice_match = configuration_table[s.level].nice_length;
      s.max_chain_length = configuration_table[s.level].max_chain;
      s.strstart = 0;
      s.block_start = 0;
      s.lookahead = 0;
      s.insert = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      s.ins_h = 0;
    };
    deflateStateCheck = (strm) => {
      if (!strm) {
        return 1;
      }
      const s = strm.state;
      if (!s || s.strm !== strm || s.status !== INIT_STATE && //#ifdef GZIP
      s.status !== GZIP_STATE && //#endif
      s.status !== EXTRA_STATE && s.status !== NAME_STATE && s.status !== COMMENT_STATE && s.status !== HCRC_STATE && s.status !== BUSY_STATE && s.status !== FINISH_STATE) {
        return 1;
      }
      return 0;
    };
    deflateResetKeep = (strm) => {
      if (deflateStateCheck(strm)) {
        return err(strm, Z_STREAM_ERROR$2);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN;
      const s = strm.state;
      s.pending = 0;
      s.pending_out = 0;
      if (s.wrap < 0) {
        s.wrap = -s.wrap;
      }
      s.status = //#ifdef GZIP
      s.wrap === 2 ? GZIP_STATE : (
        //#endif
        s.wrap ? INIT_STATE : BUSY_STATE
      );
      strm.adler = s.wrap === 2 ? 0 : 1;
      s.last_flush = -2;
      _tr_init(s);
      return Z_OK$3;
    };
    deflateReset = (strm) => {
      const ret = deflateResetKeep(strm);
      if (ret === Z_OK$3) {
        lm_init(strm.state);
      }
      return ret;
    };
    deflateSetHeader = (strm, head) => {
      if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
        return Z_STREAM_ERROR$2;
      }
      strm.state.gzhead = head;
      return Z_OK$3;
    };
    deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
      if (!strm) {
        return Z_STREAM_ERROR$2;
      }
      let wrap = 1;
      if (level === Z_DEFAULT_COMPRESSION$1) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap = 2;
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap !== 1) {
        return err(strm, Z_STREAM_ERROR$2);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      const s = new DeflateState();
      strm.state = s;
      s.strm = strm;
      s.status = INIT_STATE;
      s.wrap = wrap;
      s.gzhead = null;
      s.w_bits = windowBits;
      s.w_size = 1 << s.w_bits;
      s.w_mask = s.w_size - 1;
      s.hash_bits = memLevel + 7;
      s.hash_size = 1 << s.hash_bits;
      s.hash_mask = s.hash_size - 1;
      s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
      s.window = new Uint8Array(s.w_size * 2);
      s.head = new Uint16Array(s.hash_size);
      s.prev = new Uint16Array(s.w_size);
      s.lit_bufsize = 1 << memLevel + 6;
      s.pending_buf_size = s.lit_bufsize * 4;
      s.pending_buf = new Uint8Array(s.pending_buf_size);
      s.sym_buf = s.lit_bufsize;
      s.sym_end = (s.lit_bufsize - 1) * 3;
      s.level = level;
      s.strategy = strategy;
      s.method = method;
      return deflateReset(strm);
    };
    deflateInit = (strm, level) => {
      return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
    };
    deflate$2 = (strm, flush) => {
      if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) {
        return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
      }
      const s = strm.state;
      if (!strm.output || strm.avail_in !== 0 && !strm.input || s.status === FINISH_STATE && flush !== Z_FINISH$3) {
        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
      }
      const old_flush = s.last_flush;
      s.last_flush = flush;
      if (s.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$3) {
        return err(strm, Z_BUF_ERROR$1);
      }
      if (s.status === FINISH_STATE && strm.avail_in !== 0) {
        return err(strm, Z_BUF_ERROR$1);
      }
      if (s.status === INIT_STATE && s.wrap === 0) {
        s.status = BUSY_STATE;
      }
      if (s.status === INIT_STATE) {
        let header = Z_DEFLATED$2 + (s.w_bits - 8 << 4) << 8;
        let level_flags = -1;
        if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
          level_flags = 0;
        } else if (s.level < 6) {
          level_flags = 1;
        } else if (s.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }
        header |= level_flags << 6;
        if (s.strstart !== 0) {
          header |= PRESET_DICT;
        }
        header += 31 - header % 31;
        putShortMSB(s, header);
        if (s.strstart !== 0) {
          putShortMSB(s, strm.adler >>> 16);
          putShortMSB(s, strm.adler & 65535);
        }
        strm.adler = 1;
        s.status = BUSY_STATE;
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
      }
      if (s.status === GZIP_STATE) {
        strm.adler = 0;
        put_byte(s, 31);
        put_byte(s, 139);
        put_byte(s, 8);
        if (!s.gzhead) {
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          put_byte(s, OS_CODE);
          s.status = BUSY_STATE;
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
        } else {
          put_byte(
            s,
            (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
          );
          put_byte(s, s.gzhead.time & 255);
          put_byte(s, s.gzhead.time >> 8 & 255);
          put_byte(s, s.gzhead.time >> 16 & 255);
          put_byte(s, s.gzhead.time >> 24 & 255);
          put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          put_byte(s, s.gzhead.os & 255);
          if (s.gzhead.extra && s.gzhead.extra.length) {
            put_byte(s, s.gzhead.extra.length & 255);
            put_byte(s, s.gzhead.extra.length >> 8 & 255);
          }
          if (s.gzhead.hcrc) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
          }
          s.gzindex = 0;
          s.status = EXTRA_STATE;
        }
      }
      if (s.status === EXTRA_STATE) {
        if (s.gzhead.extra) {
          let beg = s.pending;
          let left = (s.gzhead.extra.length & 65535) - s.gzindex;
          while (s.pending + left > s.pending_buf_size) {
            let copy = s.pending_buf_size - s.pending;
            s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending);
            s.pending = s.pending_buf_size;
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            s.gzindex += copy;
            flush_pending(strm);
            if (s.pending !== 0) {
              s.last_flush = -1;
              return Z_OK$3;
            }
            beg = 0;
            left -= copy;
          }
          let gzhead_extra = new Uint8Array(s.gzhead.extra);
          s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
          s.pending += left;
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          s.gzindex = 0;
        }
        s.status = NAME_STATE;
      }
      if (s.status === NAME_STATE) {
        if (s.gzhead.name) {
          let beg = s.pending;
          let val;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              if (s.pending !== 0) {
                s.last_flush = -1;
                return Z_OK$3;
              }
              beg = 0;
            }
            if (s.gzindex < s.gzhead.name.length) {
              val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          s.gzindex = 0;
        }
        s.status = COMMENT_STATE;
      }
      if (s.status === COMMENT_STATE) {
        if (s.gzhead.comment) {
          let beg = s.pending;
          let val;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              if (s.pending !== 0) {
                s.last_flush = -1;
                return Z_OK$3;
              }
              beg = 0;
            }
            if (s.gzindex < s.gzhead.comment.length) {
              val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
        }
        s.status = HCRC_STATE;
      }
      if (s.status === HCRC_STATE) {
        if (s.gzhead.hcrc) {
          if (s.pending + 2 > s.pending_buf_size) {
            flush_pending(strm);
            if (s.pending !== 0) {
              s.last_flush = -1;
              return Z_OK$3;
            }
          }
          put_byte(s, strm.adler & 255);
          put_byte(s, strm.adler >> 8 & 255);
          strm.adler = 0;
        }
        s.status = BUSY_STATE;
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
      }
      if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE) {
        let bstate = s.level === 0 ? deflate_stored(s, flush) : s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
          s.status = FINISH_STATE;
        }
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === 0) {
            s.last_flush = -1;
          }
          return Z_OK$3;
        }
        if (bstate === BS_BLOCK_DONE) {
          if (flush === Z_PARTIAL_FLUSH) {
            _tr_align(s);
          } else if (flush !== Z_BLOCK$1) {
            _tr_stored_block(s, 0, 0, false);
            if (flush === Z_FULL_FLUSH$1) {
              zero(s.head);
              if (s.lookahead === 0) {
                s.strstart = 0;
                s.block_start = 0;
                s.insert = 0;
              }
            }
          }
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
        }
      }
      if (flush !== Z_FINISH$3) {
        return Z_OK$3;
      }
      if (s.wrap <= 0) {
        return Z_STREAM_END$3;
      }
      if (s.wrap === 2) {
        put_byte(s, strm.adler & 255);
        put_byte(s, strm.adler >> 8 & 255);
        put_byte(s, strm.adler >> 16 & 255);
        put_byte(s, strm.adler >> 24 & 255);
        put_byte(s, strm.total_in & 255);
        put_byte(s, strm.total_in >> 8 & 255);
        put_byte(s, strm.total_in >> 16 & 255);
        put_byte(s, strm.total_in >> 24 & 255);
      } else {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 65535);
      }
      flush_pending(strm);
      if (s.wrap > 0) {
        s.wrap = -s.wrap;
      }
      return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
    };
    deflateEnd = (strm) => {
      if (deflateStateCheck(strm)) {
        return Z_STREAM_ERROR$2;
      }
      const status = strm.state.status;
      strm.state = null;
      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
    };
    deflateSetDictionary = (strm, dictionary) => {
      let dictLength = dictionary.length;
      if (deflateStateCheck(strm)) {
        return Z_STREAM_ERROR$2;
      }
      const s = strm.state;
      const wrap = s.wrap;
      if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
        return Z_STREAM_ERROR$2;
      }
      if (wrap === 1) {
        strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
      }
      s.wrap = 0;
      if (dictLength >= s.w_size) {
        if (wrap === 0) {
          zero(s.head);
          s.strstart = 0;
          s.block_start = 0;
          s.insert = 0;
        }
        let tmpDict = new Uint8Array(s.w_size);
        tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
        dictionary = tmpDict;
        dictLength = s.w_size;
      }
      const avail = strm.avail_in;
      const next = strm.next_in;
      const input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window(s);
      while (s.lookahead >= MIN_MATCH) {
        let str = s.strstart;
        let n = s.lookahead - (MIN_MATCH - 1);
        do {
          s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
        } while (--n);
        s.strstart = str;
        s.lookahead = MIN_MATCH - 1;
        fill_window(s);
      }
      s.strstart += s.lookahead;
      s.block_start = s.strstart;
      s.insert = s.lookahead;
      s.lookahead = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s.wrap = wrap;
      return Z_OK$3;
    };
    deflateInit_1 = deflateInit;
    deflateInit2_1 = deflateInit2;
    deflateReset_1 = deflateReset;
    deflateResetKeep_1 = deflateResetKeep;
    deflateSetHeader_1 = deflateSetHeader;
    deflate_2$1 = deflate$2;
    deflateEnd_1 = deflateEnd;
    deflateSetDictionary_1 = deflateSetDictionary;
    deflateInfo = "pako deflate (from Nodeca project)";
    deflate_1$2 = {
      deflateInit: deflateInit_1,
      deflateInit2: deflateInit2_1,
      deflateReset: deflateReset_1,
      deflateResetKeep: deflateResetKeep_1,
      deflateSetHeader: deflateSetHeader_1,
      deflate: deflate_2$1,
      deflateEnd: deflateEnd_1,
      deflateSetDictionary: deflateSetDictionary_1,
      deflateInfo
    };
    _has = (obj, key) => {
      return Object.prototype.hasOwnProperty.call(obj, key);
    };
    assign = function(obj) {
      const sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        const source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be non-object");
        }
        for (const p in source) {
          if (_has(source, p)) {
            obj[p] = source[p];
          }
        }
      }
      return obj;
    };
    flattenChunks = (chunks) => {
      let len = 0;
      for (let i = 0, l = chunks.length; i < l; i++) {
        len += chunks[i].length;
      }
      const result = new Uint8Array(len);
      for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
        let chunk = chunks[i];
        result.set(chunk, pos);
        pos += chunk.length;
      }
      return result;
    };
    common = {
      assign,
      flattenChunks
    };
    STR_APPLY_UIA_OK = true;
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      STR_APPLY_UIA_OK = false;
    }
    _utf8len = new Uint8Array(256);
    for (let q = 0; q < 256; q++) {
      _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
    }
    _utf8len[254] = _utf8len[254] = 1;
    string2buf = (str) => {
      if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
        return new TextEncoder().encode(str);
      }
      let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
      }
      buf = new Uint8Array(buf_len);
      for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        if (c < 128) {
          buf[i++] = c;
        } else if (c < 2048) {
          buf[i++] = 192 | c >>> 6;
          buf[i++] = 128 | c & 63;
        } else if (c < 65536) {
          buf[i++] = 224 | c >>> 12;
          buf[i++] = 128 | c >>> 6 & 63;
          buf[i++] = 128 | c & 63;
        } else {
          buf[i++] = 240 | c >>> 18;
          buf[i++] = 128 | c >>> 12 & 63;
          buf[i++] = 128 | c >>> 6 & 63;
          buf[i++] = 128 | c & 63;
        }
      }
      return buf;
    };
    buf2binstring = (buf, len) => {
      if (len < 65534) {
        if (buf.subarray && STR_APPLY_UIA_OK) {
          return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
        }
      }
      let result = "";
      for (let i = 0; i < len; i++) {
        result += String.fromCharCode(buf[i]);
      }
      return result;
    };
    buf2string = (buf, max) => {
      const len = max || buf.length;
      if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
        return new TextDecoder().decode(buf.subarray(0, max));
      }
      let i, out;
      const utf16buf = new Array(len * 2);
      for (out = 0, i = 0; i < len; ) {
        let c = buf[i++];
        if (c < 128) {
          utf16buf[out++] = c;
          continue;
        }
        let c_len = _utf8len[c];
        if (c_len > 4) {
          utf16buf[out++] = 65533;
          i += c_len - 1;
          continue;
        }
        c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
        while (c_len > 1 && i < len) {
          c = c << 6 | buf[i++] & 63;
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 65533;
          continue;
        }
        if (c < 65536) {
          utf16buf[out++] = c;
        } else {
          c -= 65536;
          utf16buf[out++] = 55296 | c >> 10 & 1023;
          utf16buf[out++] = 56320 | c & 1023;
        }
      }
      return buf2binstring(utf16buf, out);
    };
    utf8border = (buf, max) => {
      max = max || buf.length;
      if (max > buf.length) {
        max = buf.length;
      }
      let pos = max - 1;
      while (pos >= 0 && (buf[pos] & 192) === 128) {
        pos--;
      }
      if (pos < 0) {
        return max;
      }
      if (pos === 0) {
        return max;
      }
      return pos + _utf8len[buf[pos]] > max ? pos : max;
    };
    strings = {
      string2buf,
      buf2string,
      utf8border
    };
    zstream = ZStream;
    toString$1 = Object.prototype.toString;
    ({
      Z_NO_FLUSH: Z_NO_FLUSH$1,
      Z_SYNC_FLUSH,
      Z_FULL_FLUSH,
      Z_FINISH: Z_FINISH$2,
      Z_OK: Z_OK$2,
      Z_STREAM_END: Z_STREAM_END$2,
      Z_DEFAULT_COMPRESSION,
      Z_DEFAULT_STRATEGY,
      Z_DEFLATED: Z_DEFLATED$1
    } = constants$2);
    Deflate$1.prototype.push = function(data, flush_mode) {
      const strm = this.strm;
      const chunkSize = this.options.chunkSize;
      let status, _flush_mode;
      if (this.ended) {
        return false;
      }
      if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
      else _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
      if (typeof data === "string") {
        strm.input = strings.string2buf(data);
      } else if (toString$1.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      for (; ; ) {
        if (strm.avail_out === 0) {
          strm.output = new Uint8Array(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
          this.onData(strm.output.subarray(0, strm.next_out));
          strm.avail_out = 0;
          continue;
        }
        status = deflate_1$2.deflate(strm, _flush_mode);
        if (status === Z_STREAM_END$2) {
          if (strm.next_out > 0) {
            this.onData(strm.output.subarray(0, strm.next_out));
          }
          status = deflate_1$2.deflateEnd(this.strm);
          this.onEnd(status);
          this.ended = true;
          return status === Z_OK$2;
        }
        if (strm.avail_out === 0) {
          this.onData(strm.output);
          continue;
        }
        if (_flush_mode > 0 && strm.next_out > 0) {
          this.onData(strm.output.subarray(0, strm.next_out));
          strm.avail_out = 0;
          continue;
        }
        if (strm.avail_in === 0) break;
      }
      return true;
    };
    Deflate$1.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Deflate$1.prototype.onEnd = function(status) {
      if (status === Z_OK$2) {
        this.result = common.flattenChunks(this.chunks);
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    Deflate_1$1 = Deflate$1;
    deflate_2 = deflate$1;
    deflateRaw_1$1 = deflateRaw$1;
    gzip_1$1 = gzip$1;
    constants$1 = constants$2;
    deflate_1$1 = {
      Deflate: Deflate_1$1,
      deflate: deflate_2,
      deflateRaw: deflateRaw_1$1,
      gzip: gzip_1$1,
      constants: constants$1
    };
    BAD$1 = 16209;
    TYPE$1 = 16191;
    inffast = function inflate_fast(strm, start) {
      let _in;
      let last;
      let _out;
      let beg;
      let end;
      let dmax;
      let wsize;
      let whave;
      let wnext;
      let s_window;
      let hold;
      let bits;
      let lcode;
      let dcode;
      let lmask;
      let dmask;
      let here;
      let op;
      let len;
      let dist;
      let from;
      let from_source;
      let input, output;
      const state = strm.state;
      _in = strm.next_in;
      input = strm.input;
      last = _in + (strm.avail_in - 5);
      _out = strm.next_out;
      output = strm.output;
      beg = _out - (start - strm.avail_out);
      end = _out + (strm.avail_out - 257);
      dmax = state.dmax;
      wsize = state.wsize;
      whave = state.whave;
      wnext = state.wnext;
      s_window = state.window;
      hold = state.hold;
      bits = state.bits;
      lcode = state.lencode;
      dcode = state.distcode;
      lmask = (1 << state.lenbits) - 1;
      dmask = (1 << state.distbits) - 1;
      top:
        do {
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = lcode[hold & lmask];
          dolen:
            for (; ; ) {
              op = here >>> 24;
              hold >>>= op;
              bits -= op;
              op = here >>> 16 & 255;
              if (op === 0) {
                output[_out++] = here & 65535;
              } else if (op & 16) {
                len = here & 65535;
                op &= 15;
                if (op) {
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  len += hold & (1 << op) - 1;
                  hold >>>= op;
                  bits -= op;
                }
                if (bits < 15) {
                  hold += input[_in++] << bits;
                  bits += 8;
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                here = dcode[hold & dmask];
                dodist:
                  for (; ; ) {
                    op = here >>> 24;
                    hold >>>= op;
                    bits -= op;
                    op = here >>> 16 & 255;
                    if (op & 16) {
                      dist = here & 65535;
                      op &= 15;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                        }
                      }
                      dist += hold & (1 << op) - 1;
                      if (dist > dmax) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD$1;
                        break top;
                      }
                      hold >>>= op;
                      bits -= op;
                      op = _out - beg;
                      if (dist > op) {
                        op = dist - op;
                        if (op > whave) {
                          if (state.sane) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD$1;
                            break top;
                          }
                        }
                        from = 0;
                        from_source = s_window;
                        if (wnext === 0) {
                          from += wsize - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        } else if (wnext < op) {
                          from += wsize + wnext - op;
                          op -= wnext;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = 0;
                            if (wnext < len) {
                              op = wnext;
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist;
                              from_source = output;
                            }
                          }
                        } else {
                          from += wnext - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                        while (len > 2) {
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          len -= 3;
                        }
                        if (len) {
                          output[_out++] = from_source[from++];
                          if (len > 1) {
                            output[_out++] = from_source[from++];
                          }
                        }
                      } else {
                        from = _out - dist;
                        do {
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          len -= 3;
                        } while (len > 2);
                        if (len) {
                          output[_out++] = output[from++];
                          if (len > 1) {
                            output[_out++] = output[from++];
                          }
                        }
                      }
                    } else if ((op & 64) === 0) {
                      here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                      continue dodist;
                    } else {
                      strm.msg = "invalid distance code";
                      state.mode = BAD$1;
                      break top;
                    }
                    break;
                  }
              } else if ((op & 64) === 0) {
                here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                continue dolen;
              } else if (op & 32) {
                state.mode = TYPE$1;
                break top;
              } else {
                strm.msg = "invalid literal/length code";
                state.mode = BAD$1;
                break top;
              }
              break;
            }
        } while (_in < last && _out < end);
      len = bits >> 3;
      _in -= len;
      bits -= len << 3;
      hold &= (1 << bits) - 1;
      strm.next_in = _in;
      strm.next_out = _out;
      strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
      strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
      state.hold = hold;
      state.bits = bits;
      return;
    };
    MAXBITS = 15;
    ENOUGH_LENS$1 = 852;
    ENOUGH_DISTS$1 = 592;
    CODES$1 = 0;
    LENS$1 = 1;
    DISTS$1 = 2;
    lbase = new Uint16Array([
      /* Length codes 257..285 base */
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      13,
      15,
      17,
      19,
      23,
      27,
      31,
      35,
      43,
      51,
      59,
      67,
      83,
      99,
      115,
      131,
      163,
      195,
      227,
      258,
      0,
      0
    ]);
    lext = new Uint8Array([
      /* Length codes 257..285 extra */
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      16,
      72,
      78
    ]);
    dbase = new Uint16Array([
      /* Distance codes 0..29 base */
      1,
      2,
      3,
      4,
      5,
      7,
      9,
      13,
      17,
      25,
      33,
      49,
      65,
      97,
      129,
      193,
      257,
      385,
      513,
      769,
      1025,
      1537,
      2049,
      3073,
      4097,
      6145,
      8193,
      12289,
      16385,
      24577,
      0,
      0
    ]);
    dext = new Uint8Array([
      /* Distance codes 0..29 extra */
      16,
      16,
      16,
      16,
      17,
      17,
      18,
      18,
      19,
      19,
      20,
      20,
      21,
      21,
      22,
      22,
      23,
      23,
      24,
      24,
      25,
      25,
      26,
      26,
      27,
      27,
      28,
      28,
      29,
      29,
      64,
      64
    ]);
    inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) => {
      const bits = opts.bits;
      let len = 0;
      let sym = 0;
      let min = 0, max = 0;
      let root = 0;
      let curr = 0;
      let drop = 0;
      let left = 0;
      let used = 0;
      let huff = 0;
      let incr;
      let fill;
      let low;
      let mask;
      let next;
      let base = null;
      let match;
      const count = new Uint16Array(MAXBITS + 1);
      const offs = new Uint16Array(MAXBITS + 1);
      let extra = null;
      let here_bits, here_op, here_val;
      for (len = 0; len <= MAXBITS; len++) {
        count[len] = 0;
      }
      for (sym = 0; sym < codes; sym++) {
        count[lens[lens_index + sym]]++;
      }
      root = bits;
      for (max = MAXBITS; max >= 1; max--) {
        if (count[max] !== 0) {
          break;
        }
      }
      if (root > max) {
        root = max;
      }
      if (max === 0) {
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts.bits = 1;
        return 0;
      }
      for (min = 1; min < max; min++) {
        if (count[min] !== 0) {
          break;
        }
      }
      if (root < min) {
        root = min;
      }
      left = 1;
      for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
        left -= count[len];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type === CODES$1 || max !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len = 1; len < MAXBITS; len++) {
        offs[len + 1] = offs[len] + count[len];
      }
      for (sym = 0; sym < codes; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type === CODES$1) {
        base = extra = work;
        match = 20;
      } else if (type === LENS$1) {
        base = lbase;
        extra = lext;
        match = 257;
      } else {
        base = dbase;
        extra = dext;
        match = 0;
      }
      huff = 0;
      sym = 0;
      len = min;
      next = table_index;
      curr = root;
      drop = 0;
      low = -1;
      used = 1 << root;
      mask = used - 1;
      if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
        return 1;
      }
      for (; ; ) {
        here_bits = len - drop;
        if (work[sym] + 1 < match) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] >= match) {
          here_op = extra[work[sym] - match];
          here_val = base[work[sym] - match];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << len - drop;
        fill = 1 << curr;
        min = fill;
        do {
          fill -= incr;
          table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
        } while (fill !== 0);
        incr = 1 << len - 1;
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count[len] === 0) {
          if (len === max) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
          if (drop === 0) {
            drop = root;
          }
          next += min;
          curr = len - drop;
          left = 1 << curr;
          while (curr + drop < max) {
            left -= count[curr + drop];
            if (left <= 0) {
              break;
            }
            curr++;
            left <<= 1;
          }
          used += 1 << curr;
          if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
            return 1;
          }
          low = huff & mask;
          table[low] = root << 24 | curr << 16 | next - table_index | 0;
        }
      }
      if (huff !== 0) {
        table[next + huff] = len - drop << 24 | 64 << 16 | 0;
      }
      opts.bits = root;
      return 0;
    };
    inftrees = inflate_table;
    CODES = 0;
    LENS = 1;
    DISTS = 2;
    ({
      Z_FINISH: Z_FINISH$1,
      Z_BLOCK,
      Z_TREES,
      Z_OK: Z_OK$1,
      Z_STREAM_END: Z_STREAM_END$1,
      Z_NEED_DICT: Z_NEED_DICT$1,
      Z_STREAM_ERROR: Z_STREAM_ERROR$1,
      Z_DATA_ERROR: Z_DATA_ERROR$1,
      Z_MEM_ERROR: Z_MEM_ERROR$1,
      Z_BUF_ERROR,
      Z_DEFLATED
    } = constants$2);
    HEAD = 16180;
    FLAGS = 16181;
    TIME = 16182;
    OS = 16183;
    EXLEN = 16184;
    EXTRA = 16185;
    NAME = 16186;
    COMMENT = 16187;
    HCRC = 16188;
    DICTID = 16189;
    DICT = 16190;
    TYPE = 16191;
    TYPEDO = 16192;
    STORED = 16193;
    COPY_ = 16194;
    COPY = 16195;
    TABLE = 16196;
    LENLENS = 16197;
    CODELENS = 16198;
    LEN_ = 16199;
    LEN = 16200;
    LENEXT = 16201;
    DIST = 16202;
    DISTEXT = 16203;
    MATCH = 16204;
    LIT = 16205;
    CHECK = 16206;
    LENGTH = 16207;
    DONE = 16208;
    BAD = 16209;
    MEM = 16210;
    SYNC = 16211;
    ENOUGH_LENS = 852;
    ENOUGH_DISTS = 592;
    MAX_WBITS = 15;
    DEF_WBITS = MAX_WBITS;
    zswap32 = (q) => {
      return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
    };
    inflateStateCheck = (strm) => {
      if (!strm) {
        return 1;
      }
      const state = strm.state;
      if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) {
        return 1;
      }
      return 0;
    };
    inflateResetKeep = (strm) => {
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR$1;
      }
      const state = strm.state;
      strm.total_in = strm.total_out = state.total = 0;
      strm.msg = "";
      if (state.wrap) {
        strm.adler = state.wrap & 1;
      }
      state.mode = HEAD;
      state.last = 0;
      state.havedict = 0;
      state.flags = -1;
      state.dmax = 32768;
      state.head = null;
      state.hold = 0;
      state.bits = 0;
      state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
      state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
      state.sane = 1;
      state.back = -1;
      return Z_OK$1;
    };
    inflateReset = (strm) => {
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR$1;
      }
      const state = strm.state;
      state.wsize = 0;
      state.whave = 0;
      state.wnext = 0;
      return inflateResetKeep(strm);
    };
    inflateReset2 = (strm, windowBits) => {
      let wrap;
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR$1;
      }
      const state = strm.state;
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else {
        wrap = (windowBits >> 4) + 5;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR$1;
      }
      if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
      }
      state.wrap = wrap;
      state.wbits = windowBits;
      return inflateReset(strm);
    };
    inflateInit2 = (strm, windowBits) => {
      if (!strm) {
        return Z_STREAM_ERROR$1;
      }
      const state = new InflateState();
      strm.state = state;
      state.strm = strm;
      state.window = null;
      state.mode = HEAD;
      const ret = inflateReset2(strm, windowBits);
      if (ret !== Z_OK$1) {
        strm.state = null;
      }
      return ret;
    };
    inflateInit = (strm) => {
      return inflateInit2(strm, DEF_WBITS);
    };
    virgin = true;
    fixedtables = (state) => {
      if (virgin) {
        lenfix = new Int32Array(512);
        distfix = new Int32Array(32);
        let sym = 0;
        while (sym < 144) {
          state.lens[sym++] = 8;
        }
        while (sym < 256) {
          state.lens[sym++] = 9;
        }
        while (sym < 280) {
          state.lens[sym++] = 7;
        }
        while (sym < 288) {
          state.lens[sym++] = 8;
        }
        inftrees(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
        sym = 0;
        while (sym < 32) {
          state.lens[sym++] = 5;
        }
        inftrees(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
        virgin = false;
      }
      state.lencode = lenfix;
      state.lenbits = 9;
      state.distcode = distfix;
      state.distbits = 5;
    };
    updatewindow = (strm, src, end, copy) => {
      let dist;
      const state = strm.state;
      if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new Uint8Array(state.wsize);
      }
      if (copy >= state.wsize) {
        state.window.set(src.subarray(end - state.wsize, end), 0);
        state.wnext = 0;
        state.whave = state.wsize;
      } else {
        dist = state.wsize - state.wnext;
        if (dist > copy) {
          dist = copy;
        }
        state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
        copy -= dist;
        if (copy) {
          state.window.set(src.subarray(end - copy, end), 0);
          state.wnext = copy;
          state.whave = state.wsize;
        } else {
          state.wnext += dist;
          if (state.wnext === state.wsize) {
            state.wnext = 0;
          }
          if (state.whave < state.wsize) {
            state.whave += dist;
          }
        }
      }
      return 0;
    };
    inflate$2 = (strm, flush) => {
      let state;
      let input, output;
      let next;
      let put;
      let have, left;
      let hold;
      let bits;
      let _in, _out;
      let copy;
      let from;
      let from_source;
      let here = 0;
      let here_bits, here_op, here_val;
      let last_bits, last_op, last_val;
      let len;
      let ret;
      const hbuf = new Uint8Array(4);
      let opts;
      let n;
      const order = (
        /* permutation of code lengths */
        new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
      );
      if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
        return Z_STREAM_ERROR$1;
      }
      state = strm.state;
      if (state.mode === TYPE) {
        state.mode = TYPEDO;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state.hold;
      bits = state.bits;
      _in = have;
      _out = left;
      ret = Z_OK$1;
      inf_leave:
        for (; ; ) {
          switch (state.mode) {
            case HEAD:
              if (state.wrap === 0) {
                state.mode = TYPEDO;
                break;
              }
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.wrap & 2 && hold === 35615) {
                if (state.wbits === 0) {
                  state.wbits = 15;
                }
                state.check = 0;
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32_1(state.check, hbuf, 2, 0);
                hold = 0;
                bits = 0;
                state.mode = FLAGS;
                break;
              }
              if (state.head) {
                state.head.done = false;
              }
              if (!(state.wrap & 1) || /* check if zlib header allowed */
              (((hold & 255) << 8) + (hold >> 8)) % 31) {
                strm.msg = "incorrect header check";
                state.mode = BAD;
                break;
              }
              if ((hold & 15) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              hold >>>= 4;
              bits -= 4;
              len = (hold & 15) + 8;
              if (state.wbits === 0) {
                state.wbits = len;
              }
              if (len > 15 || len > state.wbits) {
                strm.msg = "invalid window size";
                state.mode = BAD;
                break;
              }
              state.dmax = 1 << state.wbits;
              state.flags = 0;
              strm.adler = state.check = 1;
              state.mode = hold & 512 ? DICTID : TYPE;
              hold = 0;
              bits = 0;
              break;
            case FLAGS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.flags = hold;
              if ((state.flags & 255) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              if (state.flags & 57344) {
                strm.msg = "unknown header flags set";
                state.mode = BAD;
                break;
              }
              if (state.head) {
                state.head.text = hold >> 8 & 1;
              }
              if (state.flags & 512 && state.wrap & 4) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32_1(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = TIME;
            /* falls through */
            case TIME:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.time = hold;
              }
              if (state.flags & 512 && state.wrap & 4) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                hbuf[2] = hold >>> 16 & 255;
                hbuf[3] = hold >>> 24 & 255;
                state.check = crc32_1(state.check, hbuf, 4, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = OS;
            /* falls through */
            case OS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.xflags = hold & 255;
                state.head.os = hold >> 8;
              }
              if (state.flags & 512 && state.wrap & 4) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32_1(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = EXLEN;
            /* falls through */
            case EXLEN:
              if (state.flags & 1024) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length = hold;
                if (state.head) {
                  state.head.extra_len = hold;
                }
                if (state.flags & 512 && state.wrap & 4) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32_1(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
              } else if (state.head) {
                state.head.extra = null;
              }
              state.mode = EXTRA;
            /* falls through */
            case EXTRA:
              if (state.flags & 1024) {
                copy = state.length;
                if (copy > have) {
                  copy = have;
                }
                if (copy) {
                  if (state.head) {
                    len = state.head.extra_len - state.length;
                    if (!state.head.extra) {
                      state.head.extra = new Uint8Array(state.head.extra_len);
                    }
                    state.head.extra.set(
                      input.subarray(
                        next,
                        // extra field is limited to 65536 bytes
                        // - no need for additional size check
                        next + copy
                      ),
                      /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                      len
                    );
                  }
                  if (state.flags & 512 && state.wrap & 4) {
                    state.check = crc32_1(state.check, input, copy, next);
                  }
                  have -= copy;
                  next += copy;
                  state.length -= copy;
                }
                if (state.length) {
                  break inf_leave;
                }
              }
              state.length = 0;
              state.mode = NAME;
            /* falls through */
            case NAME:
              if (state.flags & 2048) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.name += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512 && state.wrap & 4) {
                  state.check = crc32_1(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.name = null;
              }
              state.length = 0;
              state.mode = COMMENT;
            /* falls through */
            case COMMENT:
              if (state.flags & 4096) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.comment += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512 && state.wrap & 4) {
                  state.check = crc32_1(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.comment = null;
              }
              state.mode = HCRC;
            /* falls through */
            case HCRC:
              if (state.flags & 512) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (state.wrap & 4 && hold !== (state.check & 65535)) {
                  strm.msg = "header crc mismatch";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              if (state.head) {
                state.head.hcrc = state.flags >> 9 & 1;
                state.head.done = true;
              }
              strm.adler = state.check = 0;
              state.mode = TYPE;
              break;
            case DICTID:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              strm.adler = state.check = zswap32(hold);
              hold = 0;
              bits = 0;
              state.mode = DICT;
            /* falls through */
            case DICT:
              if (state.havedict === 0) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                return Z_NEED_DICT$1;
              }
              strm.adler = state.check = 1;
              state.mode = TYPE;
            /* falls through */
            case TYPE:
              if (flush === Z_BLOCK || flush === Z_TREES) {
                break inf_leave;
              }
            /* falls through */
            case TYPEDO:
              if (state.last) {
                hold >>>= bits & 7;
                bits -= bits & 7;
                state.mode = CHECK;
                break;
              }
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.last = hold & 1;
              hold >>>= 1;
              bits -= 1;
              switch (hold & 3) {
                case 0:
                  state.mode = STORED;
                  break;
                case 1:
                  fixedtables(state);
                  state.mode = LEN_;
                  if (flush === Z_TREES) {
                    hold >>>= 2;
                    bits -= 2;
                    break inf_leave;
                  }
                  break;
                case 2:
                  state.mode = TABLE;
                  break;
                case 3:
                  strm.msg = "invalid block type";
                  state.mode = BAD;
              }
              hold >>>= 2;
              bits -= 2;
              break;
            case STORED:
              hold >>>= bits & 7;
              bits -= bits & 7;
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                strm.msg = "invalid stored block lengths";
                state.mode = BAD;
                break;
              }
              state.length = hold & 65535;
              hold = 0;
              bits = 0;
              state.mode = COPY_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            /* falls through */
            case COPY_:
              state.mode = COPY;
            /* falls through */
            case COPY:
              copy = state.length;
              if (copy) {
                if (copy > have) {
                  copy = have;
                }
                if (copy > left) {
                  copy = left;
                }
                if (copy === 0) {
                  break inf_leave;
                }
                output.set(input.subarray(next, next + copy), put);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
                state.length -= copy;
                break;
              }
              state.mode = TYPE;
              break;
            case TABLE:
              while (bits < 14) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.nlen = (hold & 31) + 257;
              hold >>>= 5;
              bits -= 5;
              state.ndist = (hold & 31) + 1;
              hold >>>= 5;
              bits -= 5;
              state.ncode = (hold & 15) + 4;
              hold >>>= 4;
              bits -= 4;
              if (state.nlen > 286 || state.ndist > 30) {
                strm.msg = "too many length or distance symbols";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = LENLENS;
            /* falls through */
            case LENLENS:
              while (state.have < state.ncode) {
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.lens[order[state.have++]] = hold & 7;
                hold >>>= 3;
                bits -= 3;
              }
              while (state.have < 19) {
                state.lens[order[state.have++]] = 0;
              }
              state.lencode = state.lendyn;
              state.lenbits = 7;
              opts = { bits: state.lenbits };
              ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid code lengths set";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = CODELENS;
            /* falls through */
            case CODELENS:
              while (state.have < state.nlen + state.ndist) {
                for (; ; ) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_val < 16) {
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.lens[state.have++] = here_val;
                } else {
                  if (here_val === 16) {
                    n = here_bits + 2;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    if (state.have === 0) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD;
                      break;
                    }
                    len = state.lens[state.have - 1];
                    copy = 3 + (hold & 3);
                    hold >>>= 2;
                    bits -= 2;
                  } else if (here_val === 17) {
                    n = here_bits + 3;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 3 + (hold & 7);
                    hold >>>= 3;
                    bits -= 3;
                  } else {
                    n = here_bits + 7;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 11 + (hold & 127);
                    hold >>>= 7;
                    bits -= 7;
                  }
                  if (state.have + copy > state.nlen + state.ndist) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  while (copy--) {
                    state.lens[state.have++] = len;
                  }
                }
              }
              if (state.mode === BAD) {
                break;
              }
              if (state.lens[256] === 0) {
                strm.msg = "invalid code -- missing end-of-block";
                state.mode = BAD;
                break;
              }
              state.lenbits = 9;
              opts = { bits: state.lenbits };
              ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid literal/lengths set";
                state.mode = BAD;
                break;
              }
              state.distbits = 6;
              state.distcode = state.distdyn;
              opts = { bits: state.distbits };
              ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
              state.distbits = opts.bits;
              if (ret) {
                strm.msg = "invalid distances set";
                state.mode = BAD;
                break;
              }
              state.mode = LEN_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            /* falls through */
            case LEN_:
              state.mode = LEN;
            /* falls through */
            case LEN:
              if (have >= 6 && left >= 258) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                inffast(strm, _out);
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits = state.bits;
                if (state.mode === TYPE) {
                  state.back = -1;
                }
                break;
              }
              state.back = 0;
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_op && (here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              state.length = here_val;
              if (here_op === 0) {
                state.mode = LIT;
                break;
              }
              if (here_op & 32) {
                state.back = -1;
                state.mode = TYPE;
                break;
              }
              if (here_op & 64) {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break;
              }
              state.extra = here_op & 15;
              state.mode = LENEXT;
            /* falls through */
            case LENEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              state.was = state.length;
              state.mode = DIST;
            /* falls through */
            case DIST:
              for (; ; ) {
                here = state.distcode[hold & (1 << state.distbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              if (here_op & 64) {
                strm.msg = "invalid distance code";
                state.mode = BAD;
                break;
              }
              state.offset = here_val;
              state.extra = here_op & 15;
              state.mode = DISTEXT;
            /* falls through */
            case DISTEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.offset += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              if (state.offset > state.dmax) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
              state.mode = MATCH;
            /* falls through */
            case MATCH:
              if (left === 0) {
                break inf_leave;
              }
              copy = _out - left;
              if (state.offset > copy) {
                copy = state.offset - copy;
                if (copy > state.whave) {
                  if (state.sane) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break;
                  }
                }
                if (copy > state.wnext) {
                  copy -= state.wnext;
                  from = state.wsize - copy;
                } else {
                  from = state.wnext - copy;
                }
                if (copy > state.length) {
                  copy = state.length;
                }
                from_source = state.window;
              } else {
                from_source = output;
                from = put - state.offset;
                copy = state.length;
              }
              if (copy > left) {
                copy = left;
              }
              left -= copy;
              state.length -= copy;
              do {
                output[put++] = from_source[from++];
              } while (--copy);
              if (state.length === 0) {
                state.mode = LEN;
              }
              break;
            case LIT:
              if (left === 0) {
                break inf_leave;
              }
              output[put++] = state.length;
              left--;
              state.mode = LEN;
              break;
            case CHECK:
              if (state.wrap) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold |= input[next++] << bits;
                  bits += 8;
                }
                _out -= left;
                strm.total_out += _out;
                state.total += _out;
                if (state.wrap & 4 && _out) {
                  strm.adler = state.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
                  state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out);
                }
                _out = left;
                if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
                  strm.msg = "incorrect data check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = LENGTH;
            /* falls through */
            case LENGTH:
              if (state.wrap && state.flags) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
                  strm.msg = "incorrect length check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = DONE;
            /* falls through */
            case DONE:
              ret = Z_STREAM_END$1;
              break inf_leave;
            case BAD:
              ret = Z_DATA_ERROR$1;
              break inf_leave;
            case MEM:
              return Z_MEM_ERROR$1;
            case SYNC:
            /* falls through */
            default:
              return Z_STREAM_ERROR$1;
          }
        }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state.hold = hold;
      state.bits = bits;
      if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH$1)) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state.total += _out;
      if (state.wrap & 4 && _out) {
        strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
        state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out);
      }
      strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
      if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) {
        ret = Z_BUF_ERROR;
      }
      return ret;
    };
    inflateEnd = (strm) => {
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR$1;
      }
      let state = strm.state;
      if (state.window) {
        state.window = null;
      }
      strm.state = null;
      return Z_OK$1;
    };
    inflateGetHeader = (strm, head) => {
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR$1;
      }
      const state = strm.state;
      if ((state.wrap & 2) === 0) {
        return Z_STREAM_ERROR$1;
      }
      state.head = head;
      head.done = false;
      return Z_OK$1;
    };
    inflateSetDictionary = (strm, dictionary) => {
      const dictLength = dictionary.length;
      let state;
      let dictid;
      let ret;
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR$1;
      }
      state = strm.state;
      if (state.wrap !== 0 && state.mode !== DICT) {
        return Z_STREAM_ERROR$1;
      }
      if (state.mode === DICT) {
        dictid = 1;
        dictid = adler32_1(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) {
          return Z_DATA_ERROR$1;
        }
      }
      ret = updatewindow(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state.mode = MEM;
        return Z_MEM_ERROR$1;
      }
      state.havedict = 1;
      return Z_OK$1;
    };
    inflateReset_1 = inflateReset;
    inflateReset2_1 = inflateReset2;
    inflateResetKeep_1 = inflateResetKeep;
    inflateInit_1 = inflateInit;
    inflateInit2_1 = inflateInit2;
    inflate_2$1 = inflate$2;
    inflateEnd_1 = inflateEnd;
    inflateGetHeader_1 = inflateGetHeader;
    inflateSetDictionary_1 = inflateSetDictionary;
    inflateInfo = "pako inflate (from Nodeca project)";
    inflate_1$2 = {
      inflateReset: inflateReset_1,
      inflateReset2: inflateReset2_1,
      inflateResetKeep: inflateResetKeep_1,
      inflateInit: inflateInit_1,
      inflateInit2: inflateInit2_1,
      inflate: inflate_2$1,
      inflateEnd: inflateEnd_1,
      inflateGetHeader: inflateGetHeader_1,
      inflateSetDictionary: inflateSetDictionary_1,
      inflateInfo
    };
    gzheader = GZheader;
    toString2 = Object.prototype.toString;
    ({
      Z_NO_FLUSH,
      Z_FINISH,
      Z_OK,
      Z_STREAM_END,
      Z_NEED_DICT,
      Z_STREAM_ERROR,
      Z_DATA_ERROR,
      Z_MEM_ERROR
    } = constants$2);
    Inflate$1.prototype.push = function(data, flush_mode) {
      const strm = this.strm;
      const chunkSize = this.options.chunkSize;
      const dictionary = this.options.dictionary;
      let status, _flush_mode, last_avail_out;
      if (this.ended) return false;
      if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
      else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
      if (toString2.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      for (; ; ) {
        if (strm.avail_out === 0) {
          strm.output = new Uint8Array(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = inflate_1$2.inflate(strm, _flush_mode);
        if (status === Z_NEED_DICT && dictionary) {
          status = inflate_1$2.inflateSetDictionary(strm, dictionary);
          if (status === Z_OK) {
            status = inflate_1$2.inflate(strm, _flush_mode);
          } else if (status === Z_DATA_ERROR) {
            status = Z_NEED_DICT;
          }
        }
        while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
          inflate_1$2.inflateReset(strm);
          status = inflate_1$2.inflate(strm, _flush_mode);
        }
        switch (status) {
          case Z_STREAM_ERROR:
          case Z_DATA_ERROR:
          case Z_NEED_DICT:
          case Z_MEM_ERROR:
            this.onEnd(status);
            this.ended = true;
            return false;
        }
        last_avail_out = strm.avail_out;
        if (strm.next_out) {
          if (strm.avail_out === 0 || status === Z_STREAM_END) {
            if (this.options.to === "string") {
              let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
              let tail = strm.next_out - next_out_utf8;
              let utf8str = strings.buf2string(strm.output, next_out_utf8);
              strm.next_out = tail;
              strm.avail_out = chunkSize - tail;
              if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
              this.onData(utf8str);
            } else {
              this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
            }
          }
        }
        if (status === Z_OK && last_avail_out === 0) continue;
        if (status === Z_STREAM_END) {
          status = inflate_1$2.inflateEnd(this.strm);
          this.onEnd(status);
          this.ended = true;
          return true;
        }
        if (strm.avail_in === 0) break;
      }
      return true;
    };
    Inflate$1.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Inflate$1.prototype.onEnd = function(status) {
      if (status === Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = common.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    Inflate_1$1 = Inflate$1;
    inflate_2 = inflate$1;
    inflateRaw_1$1 = inflateRaw$1;
    ungzip$1 = inflate$1;
    constants = constants$2;
    inflate_1$1 = {
      Inflate: Inflate_1$1,
      inflate: inflate_2,
      inflateRaw: inflateRaw_1$1,
      ungzip: ungzip$1,
      constants
    };
    ({ Deflate, deflate, deflateRaw, gzip } = deflate_1$1);
    ({ Inflate, inflate, inflateRaw, ungzip } = inflate_1$1);
    deflate_1 = deflate;
    Inflate_1 = Inflate;
    inflate_1 = inflate;
  }
});

// node_modules/fast-png/lib-esm/helpers/crc.js
function updateCrc(currentCrc, data, length) {
  let c = currentCrc;
  for (let n = 0; n < length; n++) {
    c = crcTable2[(c ^ data[n]) & 255] ^ c >>> 8;
  }
  return c;
}
function crc(data, length) {
  return (updateCrc(initialCrc, data, length) ^ initialCrc) >>> 0;
}
function checkCrc(buffer, crcLength, chunkName) {
  const expectedCrc = buffer.readUint32();
  const actualCrc = crc(new Uint8Array(buffer.buffer, buffer.byteOffset + buffer.offset - crcLength - 4, crcLength), crcLength);
  if (actualCrc !== expectedCrc) {
    throw new Error(`CRC mismatch for chunk ${chunkName}. Expected ${expectedCrc}, found ${actualCrc}`);
  }
}
function writeCrc(buffer, length) {
  buffer.writeUint32(crc(new Uint8Array(buffer.buffer, buffer.byteOffset + buffer.offset - length, length), length));
}
var crcTable2, initialCrc;
var init_crc = __esm({
  "node_modules/fast-png/lib-esm/helpers/crc.js"() {
    "use strict";
    crcTable2 = [];
    for (let n = 0; n < 256; n++) {
      let c = n;
      for (let k = 0; k < 8; k++) {
        if (c & 1) {
          c = 3988292384 ^ c >>> 1;
        } else {
          c = c >>> 1;
        }
      }
      crcTable2[n] = c;
    }
    initialCrc = 4294967295;
  }
});

// node_modules/fast-png/lib-esm/helpers/unfilter.js
function unfilterNone(currentLine, newLine, bytesPerLine) {
  for (let i = 0; i < bytesPerLine; i++) {
    newLine[i] = currentLine[i];
  }
}
function unfilterSub(currentLine, newLine, bytesPerLine, bytesPerPixel) {
  let i = 0;
  for (; i < bytesPerPixel; i++) {
    newLine[i] = currentLine[i];
  }
  for (; i < bytesPerLine; i++) {
    newLine[i] = currentLine[i] + newLine[i - bytesPerPixel] & 255;
  }
}
function unfilterUp(currentLine, newLine, prevLine, bytesPerLine) {
  let i = 0;
  if (prevLine.length === 0) {
    for (; i < bytesPerLine; i++) {
      newLine[i] = currentLine[i];
    }
  } else {
    for (; i < bytesPerLine; i++) {
      newLine[i] = currentLine[i] + prevLine[i] & 255;
    }
  }
}
function unfilterAverage(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel) {
  let i = 0;
  if (prevLine.length === 0) {
    for (; i < bytesPerPixel; i++) {
      newLine[i] = currentLine[i];
    }
    for (; i < bytesPerLine; i++) {
      newLine[i] = currentLine[i] + (newLine[i - bytesPerPixel] >> 1) & 255;
    }
  } else {
    for (; i < bytesPerPixel; i++) {
      newLine[i] = currentLine[i] + (prevLine[i] >> 1) & 255;
    }
    for (; i < bytesPerLine; i++) {
      newLine[i] = currentLine[i] + (newLine[i - bytesPerPixel] + prevLine[i] >> 1) & 255;
    }
  }
}
function unfilterPaeth(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel) {
  let i = 0;
  if (prevLine.length === 0) {
    for (; i < bytesPerPixel; i++) {
      newLine[i] = currentLine[i];
    }
    for (; i < bytesPerLine; i++) {
      newLine[i] = currentLine[i] + newLine[i - bytesPerPixel] & 255;
    }
  } else {
    for (; i < bytesPerPixel; i++) {
      newLine[i] = currentLine[i] + prevLine[i] & 255;
    }
    for (; i < bytesPerLine; i++) {
      newLine[i] = currentLine[i] + paethPredictor(newLine[i - bytesPerPixel], prevLine[i], prevLine[i - bytesPerPixel]) & 255;
    }
  }
}
function paethPredictor(a2, b, c) {
  const p = a2 + b - c;
  const pa = Math.abs(p - a2);
  const pb = Math.abs(p - b);
  const pc = Math.abs(p - c);
  if (pa <= pb && pa <= pc)
    return a2;
  else if (pb <= pc)
    return b;
  else
    return c;
}
var init_unfilter = __esm({
  "node_modules/fast-png/lib-esm/helpers/unfilter.js"() {
    "use strict";
  }
});

// node_modules/fast-png/lib-esm/helpers/applyUnfilter.js
function applyUnfilter(filterType, currentLine, newLine, prevLine, passLineBytes, bytesPerPixel) {
  switch (filterType) {
    case 0:
      unfilterNone(currentLine, newLine, passLineBytes);
      break;
    case 1:
      unfilterSub(currentLine, newLine, passLineBytes, bytesPerPixel);
      break;
    case 2:
      unfilterUp(currentLine, newLine, prevLine, passLineBytes);
      break;
    case 3:
      unfilterAverage(currentLine, newLine, prevLine, passLineBytes, bytesPerPixel);
      break;
    case 4:
      unfilterPaeth(currentLine, newLine, prevLine, passLineBytes, bytesPerPixel);
      break;
    default:
      throw new Error(`Unsupported filter: ${filterType}`);
  }
}
var init_applyUnfilter = __esm({
  "node_modules/fast-png/lib-esm/helpers/applyUnfilter.js"() {
    "use strict";
    init_unfilter();
  }
});

// node_modules/fast-png/lib-esm/helpers/decodeInterlaceAdam7.js
function decodeInterlaceAdam7(params) {
  const { data, width, height, channels, depth } = params;
  const passes = [
    { x: 0, y: 0, xStep: 8, yStep: 8 },
    // Pass 1
    { x: 4, y: 0, xStep: 8, yStep: 8 },
    // Pass 2
    { x: 0, y: 4, xStep: 4, yStep: 8 },
    // Pass 3
    { x: 2, y: 0, xStep: 4, yStep: 4 },
    // Pass 4
    { x: 0, y: 2, xStep: 2, yStep: 4 },
    // Pass 5
    { x: 1, y: 0, xStep: 2, yStep: 2 },
    // Pass 6
    { x: 0, y: 1, xStep: 1, yStep: 2 }
    // Pass 7
  ];
  const bytesPerPixel = Math.ceil(depth / 8) * channels;
  const resultData = new Uint8Array(height * width * bytesPerPixel);
  let offset = 0;
  for (let passIndex = 0; passIndex < 7; passIndex++) {
    const pass = passes[passIndex];
    const passWidth = Math.ceil((width - pass.x) / pass.xStep);
    const passHeight = Math.ceil((height - pass.y) / pass.yStep);
    if (passWidth <= 0 || passHeight <= 0)
      continue;
    const passLineBytes = passWidth * bytesPerPixel;
    const prevLine = new Uint8Array(passLineBytes);
    for (let y = 0; y < passHeight; y++) {
      const filterType = data[offset++];
      const currentLine = data.subarray(offset, offset + passLineBytes);
      offset += passLineBytes;
      const newLine = new Uint8Array(passLineBytes);
      applyUnfilter(filterType, currentLine, newLine, prevLine, passLineBytes, bytesPerPixel);
      prevLine.set(newLine);
      for (let x = 0; x < passWidth; x++) {
        const outputX = pass.x + x * pass.xStep;
        const outputY = pass.y + y * pass.yStep;
        if (outputX >= width || outputY >= height)
          continue;
        for (let i = 0; i < bytesPerPixel; i++) {
          resultData[(outputY * width + outputX) * bytesPerPixel + i] = newLine[x * bytesPerPixel + i];
        }
      }
    }
  }
  if (depth === 16) {
    const uint16Data = new Uint16Array(resultData.buffer);
    if (osIsLittleEndian) {
      for (let k = 0; k < uint16Data.length; k++) {
        uint16Data[k] = swap16(uint16Data[k]);
      }
    }
    return uint16Data;
  } else {
    return resultData;
  }
}
function swap16(val) {
  return (val & 255) << 8 | val >> 8 & 255;
}
var uint16, uint8, osIsLittleEndian;
var init_decodeInterlaceAdam7 = __esm({
  "node_modules/fast-png/lib-esm/helpers/decodeInterlaceAdam7.js"() {
    "use strict";
    init_applyUnfilter();
    uint16 = new Uint16Array([255]);
    uint8 = new Uint8Array(uint16.buffer);
    osIsLittleEndian = uint8[0] === 255;
  }
});

// node_modules/fast-png/lib-esm/helpers/decodeInterlaceNull.js
function decodeInterlaceNull(params) {
  const { data, width, height, channels, depth } = params;
  const bytesPerPixel = Math.ceil(depth / 8) * channels;
  const bytesPerLine = Math.ceil(depth / 8 * channels * width);
  const newData = new Uint8Array(height * bytesPerLine);
  let prevLine = empty;
  let offset = 0;
  let currentLine;
  let newLine;
  for (let i = 0; i < height; i++) {
    currentLine = data.subarray(offset + 1, offset + 1 + bytesPerLine);
    newLine = newData.subarray(i * bytesPerLine, (i + 1) * bytesPerLine);
    switch (data[offset]) {
      case 0:
        unfilterNone(currentLine, newLine, bytesPerLine);
        break;
      case 1:
        unfilterSub(currentLine, newLine, bytesPerLine, bytesPerPixel);
        break;
      case 2:
        unfilterUp(currentLine, newLine, prevLine, bytesPerLine);
        break;
      case 3:
        unfilterAverage(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel);
        break;
      case 4:
        unfilterPaeth(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel);
        break;
      default:
        throw new Error(`Unsupported filter: ${data[offset]}`);
    }
    prevLine = newLine;
    offset += bytesPerLine + 1;
  }
  if (depth === 16) {
    const uint16Data = new Uint16Array(newData.buffer);
    if (osIsLittleEndian2) {
      for (let k = 0; k < uint16Data.length; k++) {
        uint16Data[k] = swap162(uint16Data[k]);
      }
    }
    return uint16Data;
  } else {
    return newData;
  }
}
function swap162(val) {
  return (val & 255) << 8 | val >> 8 & 255;
}
var uint162, uint82, osIsLittleEndian2, empty;
var init_decodeInterlaceNull = __esm({
  "node_modules/fast-png/lib-esm/helpers/decodeInterlaceNull.js"() {
    "use strict";
    init_unfilter();
    uint162 = new Uint16Array([255]);
    uint82 = new Uint8Array(uint162.buffer);
    osIsLittleEndian2 = uint82[0] === 255;
    empty = new Uint8Array(0);
  }
});

// node_modules/fast-png/lib-esm/helpers/signature.js
function writeSignature(buffer) {
  buffer.writeBytes(pngSignature);
}
function checkSignature(buffer) {
  if (!hasPngSignature(buffer.readBytes(pngSignature.length))) {
    throw new Error("wrong PNG signature");
  }
}
function hasPngSignature(array) {
  if (array.length < pngSignature.length) {
    return false;
  }
  for (let i = 0; i < pngSignature.length; i++) {
    if (array[i] !== pngSignature[i]) {
      return false;
    }
  }
  return true;
}
var pngSignature;
var init_signature = __esm({
  "node_modules/fast-png/lib-esm/helpers/signature.js"() {
    "use strict";
    pngSignature = Uint8Array.of(137, 80, 78, 71, 13, 10, 26, 10);
  }
});

// node_modules/fast-png/lib-esm/helpers/text.js
function validateKeyword(keyword) {
  validateLatin1(keyword);
  if (keyword.length === 0 || keyword.length > 79) {
    throw new Error("keyword length must be between 1 and 79");
  }
}
function validateLatin1(text) {
  if (!latin1Regex.test(text)) {
    throw new Error("invalid latin1 text");
  }
}
function decodetEXt(text, buffer, length) {
  const keyword = readKeyword(buffer);
  text[keyword] = readLatin1(buffer, length - keyword.length - 1);
}
function encodetEXt(buffer, keyword, text) {
  validateKeyword(keyword);
  validateLatin1(text);
  const length = keyword.length + 1 + text.length;
  buffer.writeUint32(length);
  buffer.writeChars(textChunkName);
  buffer.writeChars(keyword);
  buffer.writeByte(NULL);
  buffer.writeChars(text);
  writeCrc(buffer, length + 4);
}
function readKeyword(buffer) {
  buffer.mark();
  while (buffer.readByte() !== NULL) {
  }
  const end = buffer.offset;
  buffer.reset();
  const keyword = latin1Decoder.decode(buffer.readBytes(end - buffer.offset - 1));
  buffer.skip(1);
  validateKeyword(keyword);
  return keyword;
}
function readLatin1(buffer, length) {
  return latin1Decoder.decode(buffer.readBytes(length));
}
var textChunkName, NULL, latin1Decoder, latin1Regex;
var init_text2 = __esm({
  "node_modules/fast-png/lib-esm/helpers/text.js"() {
    "use strict";
    init_crc();
    textChunkName = "tEXt";
    NULL = 0;
    latin1Decoder = new TextDecoder("latin1");
    latin1Regex = /^[\u0000-\u00FF]*$/;
  }
});

// node_modules/fast-png/lib-esm/internalTypes.js
var ColorType, CompressionMethod, FilterMethod, InterlaceMethod, DisposeOpType, BlendOpType;
var init_internalTypes = __esm({
  "node_modules/fast-png/lib-esm/internalTypes.js"() {
    "use strict";
    ColorType = {
      UNKNOWN: -1,
      GREYSCALE: 0,
      TRUECOLOUR: 2,
      INDEXED_COLOUR: 3,
      GREYSCALE_ALPHA: 4,
      TRUECOLOUR_ALPHA: 6
    };
    CompressionMethod = {
      UNKNOWN: -1,
      DEFLATE: 0
    };
    FilterMethod = {
      UNKNOWN: -1,
      ADAPTIVE: 0
    };
    InterlaceMethod = {
      UNKNOWN: -1,
      NO_INTERLACE: 0,
      ADAM7: 1
    };
    DisposeOpType = {
      NONE: 0,
      BACKGROUND: 1,
      PREVIOUS: 2
    };
    BlendOpType = {
      SOURCE: 0,
      OVER: 1
    };
  }
});

// node_modules/fast-png/lib-esm/PngDecoder.js
function checkBitDepth(value) {
  if (value !== 1 && value !== 2 && value !== 4 && value !== 8 && value !== 16) {
    throw new Error(`invalid bit depth: ${value}`);
  }
  return value;
}
var PngDecoder;
var init_PngDecoder = __esm({
  "node_modules/fast-png/lib-esm/PngDecoder.js"() {
    "use strict";
    init_IOBuffer();
    init_pako_esm();
    init_crc();
    init_decodeInterlaceAdam7();
    init_decodeInterlaceNull();
    init_signature();
    init_text2();
    init_internalTypes();
    PngDecoder = class extends IOBuffer {
      _checkCrc;
      _inflator;
      _png;
      _apng;
      _end;
      _hasPalette;
      _palette;
      _hasTransparency;
      _transparency;
      _compressionMethod;
      _filterMethod;
      _interlaceMethod;
      _colorType;
      _isAnimated;
      _numberOfFrames;
      _numberOfPlays;
      _frames;
      _writingDataChunks;
      constructor(data, options = {}) {
        super(data);
        const { checkCrc: checkCrc2 = false } = options;
        this._checkCrc = checkCrc2;
        this._inflator = new Inflate_1();
        this._png = {
          width: -1,
          height: -1,
          channels: -1,
          data: new Uint8Array(0),
          depth: 1,
          text: {}
        };
        this._apng = {
          width: -1,
          height: -1,
          channels: -1,
          depth: 1,
          numberOfFrames: 1,
          numberOfPlays: 0,
          text: {},
          frames: []
        };
        this._end = false;
        this._hasPalette = false;
        this._palette = [];
        this._hasTransparency = false;
        this._transparency = new Uint16Array(0);
        this._compressionMethod = CompressionMethod.UNKNOWN;
        this._filterMethod = FilterMethod.UNKNOWN;
        this._interlaceMethod = InterlaceMethod.UNKNOWN;
        this._colorType = ColorType.UNKNOWN;
        this._isAnimated = false;
        this._numberOfFrames = 1;
        this._numberOfPlays = 0;
        this._frames = [];
        this._writingDataChunks = false;
        this.setBigEndian();
      }
      decode() {
        checkSignature(this);
        while (!this._end) {
          const length = this.readUint32();
          const type = this.readChars(4);
          this.decodeChunk(length, type);
        }
        this.decodeImage();
        return this._png;
      }
      decodeApng() {
        checkSignature(this);
        while (!this._end) {
          const length = this.readUint32();
          const type = this.readChars(4);
          this.decodeApngChunk(length, type);
        }
        this.decodeApngImage();
        return this._apng;
      }
      // https://www.w3.org/TR/PNG/#5Chunk-layout
      decodeChunk(length, type) {
        const offset = this.offset;
        switch (type) {
          // 11.2 Critical chunks
          case "IHDR":
            this.decodeIHDR();
            break;
          case "PLTE":
            this.decodePLTE(length);
            break;
          case "IDAT":
            this.decodeIDAT(length);
            break;
          case "IEND":
            this._end = true;
            break;
          // 11.3 Ancillary chunks
          case "tRNS":
            this.decodetRNS(length);
            break;
          case "iCCP":
            this.decodeiCCP(length);
            break;
          case textChunkName:
            decodetEXt(this._png.text, this, length);
            break;
          case "pHYs":
            this.decodepHYs();
            break;
          default:
            this.skip(length);
            break;
        }
        if (this.offset - offset !== length) {
          throw new Error(`Length mismatch while decoding chunk ${type}`);
        }
        if (this._checkCrc) {
          checkCrc(this, length + 4, type);
        } else {
          this.skip(4);
        }
      }
      decodeApngChunk(length, type) {
        const offset = this.offset;
        if (type !== "fdAT" && type !== "IDAT" && this._writingDataChunks) {
          this.pushDataToFrame();
        }
        switch (type) {
          case "acTL":
            this.decodeACTL();
            break;
          case "fcTL":
            this.decodeFCTL();
            break;
          case "fdAT":
            this.decodeFDAT(length);
            break;
          default:
            this.decodeChunk(length, type);
            this.offset = offset + length;
            break;
        }
        if (this.offset - offset !== length) {
          throw new Error(`Length mismatch while decoding chunk ${type}`);
        }
        if (this._checkCrc) {
          checkCrc(this, length + 4, type);
        } else {
          this.skip(4);
        }
      }
      // https://www.w3.org/TR/PNG/#11IHDR
      decodeIHDR() {
        const image2 = this._png;
        image2.width = this.readUint32();
        image2.height = this.readUint32();
        image2.depth = checkBitDepth(this.readUint8());
        const colorType = this.readUint8();
        this._colorType = colorType;
        let channels;
        switch (colorType) {
          case ColorType.GREYSCALE:
            channels = 1;
            break;
          case ColorType.TRUECOLOUR:
            channels = 3;
            break;
          case ColorType.INDEXED_COLOUR:
            channels = 1;
            break;
          case ColorType.GREYSCALE_ALPHA:
            channels = 2;
            break;
          case ColorType.TRUECOLOUR_ALPHA:
            channels = 4;
            break;
          // Kept for exhaustiveness.
          // eslint-disable-next-line unicorn/no-useless-switch-case
          case ColorType.UNKNOWN:
          default:
            throw new Error(`Unknown color type: ${colorType}`);
        }
        this._png.channels = channels;
        this._compressionMethod = this.readUint8();
        if (this._compressionMethod !== CompressionMethod.DEFLATE) {
          throw new Error(`Unsupported compression method: ${this._compressionMethod}`);
        }
        this._filterMethod = this.readUint8();
        this._interlaceMethod = this.readUint8();
      }
      decodeACTL() {
        this._numberOfFrames = this.readUint32();
        this._numberOfPlays = this.readUint32();
        this._isAnimated = true;
      }
      decodeFCTL() {
        const image2 = {
          sequenceNumber: this.readUint32(),
          width: this.readUint32(),
          height: this.readUint32(),
          xOffset: this.readUint32(),
          yOffset: this.readUint32(),
          delayNumber: this.readUint16(),
          delayDenominator: this.readUint16(),
          disposeOp: this.readUint8(),
          blendOp: this.readUint8(),
          data: new Uint8Array(0)
        };
        this._frames.push(image2);
      }
      // https://www.w3.org/TR/PNG/#11PLTE
      decodePLTE(length) {
        if (length % 3 !== 0) {
          throw new RangeError(`PLTE field length must be a multiple of 3. Got ${length}`);
        }
        const l = length / 3;
        this._hasPalette = true;
        const palette = [];
        this._palette = palette;
        for (let i = 0; i < l; i++) {
          palette.push([this.readUint8(), this.readUint8(), this.readUint8()]);
        }
      }
      // https://www.w3.org/TR/PNG/#11IDAT
      decodeIDAT(length) {
        this._writingDataChunks = true;
        const dataLength = length;
        const dataOffset = this.offset + this.byteOffset;
        this._inflator.push(new Uint8Array(this.buffer, dataOffset, dataLength));
        if (this._inflator.err) {
          throw new Error(`Error while decompressing the data: ${this._inflator.err}`);
        }
        this.skip(length);
      }
      decodeFDAT(length) {
        this._writingDataChunks = true;
        let dataLength = length;
        let dataOffset = this.offset + this.byteOffset;
        dataOffset += 4;
        dataLength -= 4;
        this._inflator.push(new Uint8Array(this.buffer, dataOffset, dataLength));
        if (this._inflator.err) {
          throw new Error(`Error while decompressing the data: ${this._inflator.err}`);
        }
        this.skip(length);
      }
      // https://www.w3.org/TR/PNG/#11tRNS
      decodetRNS(length) {
        switch (this._colorType) {
          case ColorType.GREYSCALE:
          case ColorType.TRUECOLOUR: {
            if (length % 2 !== 0) {
              throw new RangeError(`tRNS chunk length must be a multiple of 2. Got ${length}`);
            }
            if (length / 2 > this._png.width * this._png.height) {
              throw new Error(`tRNS chunk contains more alpha values than there are pixels (${length / 2} vs ${this._png.width * this._png.height})`);
            }
            this._hasTransparency = true;
            this._transparency = new Uint16Array(length / 2);
            for (let i = 0; i < length / 2; i++) {
              this._transparency[i] = this.readUint16();
            }
            break;
          }
          case ColorType.INDEXED_COLOUR: {
            if (length > this._palette.length) {
              throw new Error(`tRNS chunk contains more alpha values than there are palette colors (${length} vs ${this._palette.length})`);
            }
            let i = 0;
            for (; i < length; i++) {
              const alpha = this.readByte();
              this._palette[i].push(alpha);
            }
            for (; i < this._palette.length; i++) {
              this._palette[i].push(255);
            }
            break;
          }
          // Kept for exhaustiveness.
          /* eslint-disable unicorn/no-useless-switch-case */
          case ColorType.UNKNOWN:
          case ColorType.GREYSCALE_ALPHA:
          case ColorType.TRUECOLOUR_ALPHA:
          default: {
            throw new Error(`tRNS chunk is not supported for color type ${this._colorType}`);
          }
        }
      }
      // https://www.w3.org/TR/PNG/#11iCCP
      decodeiCCP(length) {
        const name = readKeyword(this);
        const compressionMethod = this.readUint8();
        if (compressionMethod !== CompressionMethod.DEFLATE) {
          throw new Error(`Unsupported iCCP compression method: ${compressionMethod}`);
        }
        const compressedProfile = this.readBytes(length - name.length - 2);
        this._png.iccEmbeddedProfile = {
          name,
          profile: inflate_1(compressedProfile)
        };
      }
      // https://www.w3.org/TR/PNG/#11pHYs
      decodepHYs() {
        const ppuX = this.readUint32();
        const ppuY = this.readUint32();
        const unitSpecifier = this.readByte();
        this._png.resolution = { x: ppuX, y: ppuY, unit: unitSpecifier };
      }
      decodeApngImage() {
        this._apng.width = this._png.width;
        this._apng.height = this._png.height;
        this._apng.channels = this._png.channels;
        this._apng.depth = this._png.depth;
        this._apng.numberOfFrames = this._numberOfFrames;
        this._apng.numberOfPlays = this._numberOfPlays;
        this._apng.text = this._png.text;
        this._apng.resolution = this._png.resolution;
        for (let i = 0; i < this._numberOfFrames; i++) {
          const newFrame = {
            sequenceNumber: this._frames[i].sequenceNumber,
            delayNumber: this._frames[i].delayNumber,
            delayDenominator: this._frames[i].delayDenominator,
            data: this._apng.depth === 8 ? new Uint8Array(this._apng.width * this._apng.height * this._apng.channels) : new Uint16Array(this._apng.width * this._apng.height * this._apng.channels)
          };
          const frame = this._frames.at(i);
          if (frame) {
            frame.data = decodeInterlaceNull({
              data: frame.data,
              width: frame.width,
              height: frame.height,
              channels: this._apng.channels,
              depth: this._apng.depth
            });
            if (this._hasPalette) {
              this._apng.palette = this._palette;
            }
            if (this._hasTransparency) {
              this._apng.transparency = this._transparency;
            }
            if (i === 0 || frame.xOffset === 0 && frame.yOffset === 0 && frame.width === this._png.width && frame.height === this._png.height) {
              newFrame.data = frame.data;
            } else {
              const prevFrame = this._apng.frames.at(i - 1);
              this.disposeFrame(frame, prevFrame, newFrame);
              this.addFrameDataToCanvas(newFrame, frame);
            }
            this._apng.frames.push(newFrame);
          }
        }
        return this._apng;
      }
      disposeFrame(frame, prevFrame, imageFrame) {
        switch (frame.disposeOp) {
          case DisposeOpType.NONE:
            break;
          case DisposeOpType.BACKGROUND:
            for (let row = 0; row < this._png.height; row++) {
              for (let col = 0; col < this._png.width; col++) {
                const index = (row * frame.width + col) * this._png.channels;
                for (let channel = 0; channel < this._png.channels; channel++) {
                  imageFrame.data[index + channel] = 0;
                }
              }
            }
            break;
          case DisposeOpType.PREVIOUS:
            imageFrame.data.set(prevFrame.data);
            break;
          default:
            throw new Error("Unknown disposeOp");
        }
      }
      addFrameDataToCanvas(imageFrame, frame) {
        const maxValue = 1 << this._png.depth;
        const calculatePixelIndices = (row, col) => {
          const index = ((row + frame.yOffset) * this._png.width + frame.xOffset + col) * this._png.channels;
          const frameIndex = (row * frame.width + col) * this._png.channels;
          return { index, frameIndex };
        };
        switch (frame.blendOp) {
          case BlendOpType.SOURCE:
            for (let row = 0; row < frame.height; row++) {
              for (let col = 0; col < frame.width; col++) {
                const { index, frameIndex } = calculatePixelIndices(row, col);
                for (let channel = 0; channel < this._png.channels; channel++) {
                  imageFrame.data[index + channel] = frame.data[frameIndex + channel];
                }
              }
            }
            break;
          // https://www.w3.org/TR/png-3/#13Alpha-channel-processing
          case BlendOpType.OVER:
            for (let row = 0; row < frame.height; row++) {
              for (let col = 0; col < frame.width; col++) {
                const { index, frameIndex } = calculatePixelIndices(row, col);
                for (let channel = 0; channel < this._png.channels; channel++) {
                  const sourceAlpha = frame.data[frameIndex + this._png.channels - 1] / maxValue;
                  const foregroundValue = channel % (this._png.channels - 1) === 0 ? 1 : frame.data[frameIndex + channel];
                  const value = Math.floor(sourceAlpha * foregroundValue + (1 - sourceAlpha) * imageFrame.data[index + channel]);
                  imageFrame.data[index + channel] += value;
                }
              }
            }
            break;
          default:
            throw new Error("Unknown blendOp");
        }
      }
      decodeImage() {
        if (this._inflator.err) {
          throw new Error(`Error while decompressing the data: ${this._inflator.err}`);
        }
        const data = this._isAnimated ? (this._frames?.at(0)).data : this._inflator.result;
        if (this._filterMethod !== FilterMethod.ADAPTIVE) {
          throw new Error(`Filter method ${this._filterMethod} not supported`);
        }
        if (this._interlaceMethod === InterlaceMethod.NO_INTERLACE) {
          this._png.data = decodeInterlaceNull({
            data,
            width: this._png.width,
            height: this._png.height,
            channels: this._png.channels,
            depth: this._png.depth
          });
        } else if (this._interlaceMethod === InterlaceMethod.ADAM7) {
          this._png.data = decodeInterlaceAdam7({
            data,
            width: this._png.width,
            height: this._png.height,
            channels: this._png.channels,
            depth: this._png.depth
          });
        } else {
          throw new Error(`Interlace method ${this._interlaceMethod} not supported`);
        }
        if (this._hasPalette) {
          this._png.palette = this._palette;
        }
        if (this._hasTransparency) {
          this._png.transparency = this._transparency;
        }
      }
      pushDataToFrame() {
        const result = this._inflator.result;
        const lastFrame = this._frames.at(-1);
        if (lastFrame) {
          lastFrame.data = result;
        } else {
          this._frames.push({
            sequenceNumber: 0,
            width: this._png.width,
            height: this._png.height,
            xOffset: 0,
            yOffset: 0,
            delayNumber: 0,
            delayDenominator: 0,
            disposeOp: DisposeOpType.NONE,
            blendOp: BlendOpType.SOURCE,
            data: result
          });
        }
        this._inflator = new Inflate_1();
        this._writingDataChunks = false;
      }
    };
  }
});

// node_modules/fast-png/lib-esm/PngEncoder.js
function checkInteger(value, name) {
  if (Number.isInteger(value) && value > 0) {
    return value;
  }
  throw new TypeError(`${name} must be a positive integer`);
}
function getColorType(data, palette) {
  const { channels = 4, depth = 8 } = data;
  if (channels !== 4 && channels !== 3 && channels !== 2 && channels !== 1) {
    throw new RangeError(`unsupported number of channels: ${channels}`);
  }
  const returnValue = {
    channels,
    depth,
    colorType: ColorType.UNKNOWN
  };
  switch (channels) {
    case 4:
      returnValue.colorType = ColorType.TRUECOLOUR_ALPHA;
      break;
    case 3:
      returnValue.colorType = ColorType.TRUECOLOUR;
      break;
    case 1:
      if (palette) {
        returnValue.colorType = ColorType.INDEXED_COLOUR;
      } else {
        returnValue.colorType = ColorType.GREYSCALE;
      }
      break;
    case 2:
      returnValue.colorType = ColorType.GREYSCALE_ALPHA;
      break;
    default:
      throw new Error("unsupported number of channels");
  }
  return returnValue;
}
function writeDataBytes(data, newData, slotsPerLine, offset) {
  for (let j = 0; j < slotsPerLine; j++) {
    newData.writeByte(data[offset++]);
  }
  return offset;
}
function writeDataInterlaced(imageData, data, newData, offset) {
  const passes = [
    { x: 0, y: 0, xStep: 8, yStep: 8 },
    { x: 4, y: 0, xStep: 8, yStep: 8 },
    { x: 0, y: 4, xStep: 4, yStep: 8 },
    { x: 2, y: 0, xStep: 4, yStep: 4 },
    { x: 0, y: 2, xStep: 2, yStep: 4 },
    { x: 1, y: 0, xStep: 2, yStep: 2 },
    { x: 0, y: 1, xStep: 1, yStep: 2 }
  ];
  const { width, height, channels, depth } = imageData;
  let pixelSize = 0;
  if (depth === 16) {
    pixelSize = channels * depth / 8 / 2;
  } else {
    pixelSize = channels * depth / 8;
  }
  for (let passIndex = 0; passIndex < 7; passIndex++) {
    const pass = passes[passIndex];
    const passWidth = Math.floor((width - pass.x + pass.xStep - 1) / pass.xStep);
    const passHeight = Math.floor((height - pass.y + pass.yStep - 1) / pass.yStep);
    if (passWidth <= 0 || passHeight <= 0)
      continue;
    const passLineBytes = passWidth * pixelSize;
    for (let y = 0; y < passHeight; y++) {
      const imageY = pass.y + y * pass.yStep;
      const rawScanline = depth <= 8 ? new Uint8Array(passLineBytes) : new Uint16Array(passLineBytes);
      let rawOffset = 0;
      for (let x = 0; x < passWidth; x++) {
        const imageX = pass.x + x * pass.xStep;
        if (imageX < width && imageY < height) {
          const srcPos = (imageY * width + imageX) * pixelSize;
          for (let i = 0; i < pixelSize; i++) {
            rawScanline[rawOffset++] = data[srcPos + i];
          }
        }
      }
      newData.writeByte(0);
      if (depth === 8) {
        newData.writeBytes(rawScanline);
      } else if (depth === 16) {
        for (const value of rawScanline) {
          newData.writeByte(value >> 8 & 255);
          newData.writeByte(value & 255);
        }
      }
    }
  }
  return offset;
}
function writeDataUint16(data, newData, slotsPerLine, offset) {
  for (let j = 0; j < slotsPerLine; j++) {
    newData.writeUint16(data[offset++]);
  }
  return offset;
}
var defaultZlibOptions, PngEncoder;
var init_PngEncoder = __esm({
  "node_modules/fast-png/lib-esm/PngEncoder.js"() {
    "use strict";
    init_IOBuffer();
    init_pako_esm();
    init_crc();
    init_signature();
    init_text2();
    init_internalTypes();
    defaultZlibOptions = {
      level: 3
    };
    PngEncoder = class extends IOBuffer {
      _png;
      _zlibOptions;
      _colorType;
      _interlaceMethod;
      constructor(data, options = {}) {
        super();
        this._colorType = ColorType.UNKNOWN;
        this._zlibOptions = __spreadValues(__spreadValues({}, defaultZlibOptions), options.zlib);
        this._png = this._checkData(data);
        this._interlaceMethod = (options.interlace === "Adam7" ? InterlaceMethod.ADAM7 : InterlaceMethod.NO_INTERLACE) ?? InterlaceMethod.NO_INTERLACE;
        this.setBigEndian();
      }
      encode() {
        writeSignature(this);
        this.encodeIHDR();
        if (this._png.palette) {
          this.encodePLTE();
          if (this._png.palette[0].length === 4) {
            this.encodeTRNS();
          }
        }
        this.encodeData();
        if (this._png.text) {
          for (const [keyword, text] of Object.entries(this._png.text)) {
            encodetEXt(this, keyword, text);
          }
        }
        this.encodeIEND();
        return this.toArray();
      }
      // https://www.w3.org/TR/PNG/#11IHDR
      encodeIHDR() {
        this.writeUint32(13);
        this.writeChars("IHDR");
        this.writeUint32(this._png.width);
        this.writeUint32(this._png.height);
        this.writeByte(this._png.depth);
        this.writeByte(this._colorType);
        this.writeByte(CompressionMethod.DEFLATE);
        this.writeByte(FilterMethod.ADAPTIVE);
        this.writeByte(this._interlaceMethod);
        writeCrc(this, 17);
      }
      // https://www.w3.org/TR/PNG/#11IEND
      encodeIEND() {
        this.writeUint32(0);
        this.writeChars("IEND");
        writeCrc(this, 4);
      }
      encodePLTE() {
        const paletteLength = this._png.palette?.length * 3;
        this.writeUint32(paletteLength);
        this.writeChars("PLTE");
        for (const color2 of this._png.palette) {
          this.writeByte(color2[0]);
          this.writeByte(color2[1]);
          this.writeByte(color2[2]);
        }
        writeCrc(this, 4 + paletteLength);
      }
      encodeTRNS() {
        const alpha = this._png.palette.filter((color2) => {
          return color2.at(-1) !== 255;
        });
        this.writeUint32(alpha.length);
        this.writeChars("tRNS");
        for (const el of alpha) {
          this.writeByte(el.at(-1));
        }
        writeCrc(this, 4 + alpha.length);
      }
      // https://www.w3.org/TR/PNG/#11IDAT
      encodeIDAT(data) {
        this.writeUint32(data.length);
        this.writeChars("IDAT");
        this.writeBytes(data);
        writeCrc(this, data.length + 4);
      }
      encodeData() {
        const { width, height, channels, depth, data } = this._png;
        const slotsPerLine = depth <= 8 ? Math.ceil(width * depth / 8) * channels : Math.ceil(width * depth / 8 * channels / 2);
        const newData = new IOBuffer().setBigEndian();
        let offset = 0;
        if (this._interlaceMethod === InterlaceMethod.NO_INTERLACE) {
          for (let i = 0; i < height; i++) {
            newData.writeByte(0);
            if (depth === 16) {
              offset = writeDataUint16(data, newData, slotsPerLine, offset);
            } else {
              offset = writeDataBytes(data, newData, slotsPerLine, offset);
            }
          }
        } else if (this._interlaceMethod === InterlaceMethod.ADAM7) {
          offset = writeDataInterlaced(this._png, data, newData, offset);
        }
        const buffer = newData.toArray();
        const compressed = deflate_1(buffer, this._zlibOptions);
        this.encodeIDAT(compressed);
      }
      _checkData(data) {
        const { colorType, channels, depth } = getColorType(data, data.palette);
        const png = {
          width: checkInteger(data.width, "width"),
          height: checkInteger(data.height, "height"),
          channels,
          data: data.data,
          depth,
          text: data.text,
          palette: data.palette
        };
        this._colorType = colorType;
        const expectedSize = depth < 8 ? Math.ceil(png.width * depth / 8) * png.height * channels : png.width * png.height * channels;
        if (png.data.length !== expectedSize) {
          throw new RangeError(`wrong data size. Found ${png.data.length}, expected ${expectedSize}`);
        }
        return png;
      }
    };
  }
});

// node_modules/fast-png/lib-esm/types.js
var ResolutionUnitSpecifier;
var init_types = __esm({
  "node_modules/fast-png/lib-esm/types.js"() {
    "use strict";
    (function(ResolutionUnitSpecifier2) {
      ResolutionUnitSpecifier2[ResolutionUnitSpecifier2["UNKNOWN"] = 0] = "UNKNOWN";
      ResolutionUnitSpecifier2[ResolutionUnitSpecifier2["METRE"] = 1] = "METRE";
    })(ResolutionUnitSpecifier || (ResolutionUnitSpecifier = {}));
  }
});

// node_modules/fast-png/lib-esm/convertIndexedToRgb.js
function convertIndexedToRgb(decodedImage) {
  const palette = decodedImage.palette;
  const depth = decodedImage.depth;
  if (!palette) {
    throw new Error("Color palette is undefined.");
  }
  checkDataSize(decodedImage);
  const indexSize = decodedImage.width * decodedImage.height;
  const resSize = indexSize * palette[0].length;
  const res = new Uint8Array(resSize);
  let indexPos = 0;
  let offset = 0;
  const indexes = new Uint8Array(indexSize);
  let bit = 255;
  switch (depth) {
    case 1:
      bit = 128;
      break;
    case 2:
      bit = 192;
      break;
    case 4:
      bit = 240;
      break;
    case 8:
      bit = 255;
      break;
    default:
      throw new Error("Incorrect depth value");
  }
  for (const byte of decodedImage.data) {
    let bit2 = bit;
    let shift = 8;
    while (bit2) {
      shift -= depth;
      indexes[indexPos++] = (byte & bit2) >> shift;
      bit2 = bit2 >> depth;
      if (indexPos % decodedImage.width === 0) {
        break;
      }
    }
  }
  if (decodedImage.palette) {
    for (const index of indexes) {
      const color2 = decodedImage.palette.at(index);
      if (!color2) {
        throw new Error("Incorrect index of palette color");
      }
      res.set(color2, offset);
      offset += color2.length;
    }
  }
  return res;
}
function checkDataSize(image2) {
  const expectedSize = image2.depth < 8 ? Math.ceil(image2.width * image2.depth / 8) * image2.height * image2.channels : image2.width * image2.height * image2.channels;
  if (image2.data.length !== expectedSize) {
    throw new RangeError(`wrong data size. Found ${image2.data.length}, expected ${expectedSize}`);
  }
}
var init_convertIndexedToRgb = __esm({
  "node_modules/fast-png/lib-esm/convertIndexedToRgb.js"() {
    "use strict";
  }
});

// node_modules/fast-png/lib-esm/index.js
var lib_esm_exports = {};
__export(lib_esm_exports, {
  ResolutionUnitSpecifier: () => ResolutionUnitSpecifier,
  convertIndexedToRgb: () => convertIndexedToRgb,
  decode: () => decodePng,
  decodeApng: () => decodeApng,
  encode: () => encodePng,
  hasPngSignature: () => hasPngSignature
});
function decodePng(data, options) {
  const decoder = new PngDecoder(data, options);
  return decoder.decode();
}
function encodePng(png, options) {
  const encoder2 = new PngEncoder(png, options);
  return encoder2.encode();
}
function decodeApng(data, options) {
  const decoder = new PngDecoder(data, options);
  return decoder.decodeApng();
}
var init_lib_esm = __esm({
  "node_modules/fast-png/lib-esm/index.js"() {
    "use strict";
    init_PngDecoder();
    init_PngEncoder();
    init_signature();
    init_types();
    init_convertIndexedToRgb();
  }
});

// node_modules/html2canvas/dist/html2canvas.esm.js
var html2canvas_esm_exports = {};
__export(html2canvas_esm_exports, {
  default: () => html2canvas_esm_default
});
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f2, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f2) throw new TypeError("Generator is already executing.");
    while (_) try {
      if (f2 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e2) {
      op = [6, e2];
      y = 0;
    } finally {
      f2 = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __spreadArray(to, from, pack2) {
  if (pack2 || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || from);
}
function hue2rgb(t1, t2, hue) {
  if (hue < 0) {
    hue += 1;
  }
  if (hue >= 1) {
    hue -= 1;
  }
  if (hue < 1 / 6) {
    return (t2 - t1) * hue * 6 + t1;
  } else if (hue < 1 / 2) {
    return t2;
  } else if (hue < 2 / 3) {
    return (t2 - t1) * 6 * (2 / 3 - hue) + t1;
  } else {
    return t1;
  }
}
function isSupportedImage(value) {
  return !(value.type === 20 && value.value === "none") && (value.type !== 18 || !!SUPPORTED_IMAGE_FUNCTIONS[value.name]);
}
var extendStatics, __assign, Bounds, parseBounds, parseDocumentSize, toCodePoints$1, fromCodePoint$1, chars$2, lookup$2, i$2, chars$1$1, lookup$1$1, i$1$1, decode$1, polyUint16Array$1, polyUint32Array$1, UTRIE2_SHIFT_2$1, UTRIE2_SHIFT_1$1, UTRIE2_INDEX_SHIFT$1, UTRIE2_SHIFT_1_2$1, UTRIE2_LSCP_INDEX_2_OFFSET$1, UTRIE2_DATA_BLOCK_LENGTH$1, UTRIE2_DATA_MASK$1, UTRIE2_LSCP_INDEX_2_LENGTH$1, UTRIE2_INDEX_2_BMP_LENGTH$1, UTRIE2_UTF8_2B_INDEX_2_OFFSET$1, UTRIE2_UTF8_2B_INDEX_2_LENGTH$1, UTRIE2_INDEX_1_OFFSET$1, UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1, UTRIE2_INDEX_2_BLOCK_LENGTH$1, UTRIE2_INDEX_2_MASK$1, slice16$1, slice32$1, createTrieFromBase64$1, Trie$1, chars$3, lookup$3, i$3, base64$1, LETTER_NUMBER_MODIFIER, BK, CR$1, LF$1, CM, NL, WJ, ZW, GL, SP, ZWJ$1, B2, BA, BB, HY, CB, CL, CP, EX, IN, NS, OP, QU, IS, NU, PO, PR, SY, AI, AL, CJ, EB, EM, H2, H3, HL, ID, JL, JV, JT, RI$1, SA, XX, ea_OP, BREAK_MANDATORY, BREAK_NOT_ALLOWED$1, BREAK_ALLOWED$1, UnicodeTrie$1, ALPHABETICS, HARD_LINE_BREAKS, SPACE$1, PREFIX_POSTFIX, LINE_BREAKS, KOREAN_SYLLABLE_BLOCK, HYPHEN, codePointsToCharacterClasses, isAdjacentWithSpaceIgnored, previousNonSpaceClassType, _lineBreakAtIndex, cssFormattedClasses, Break, LineBreaker, FLAG_UNRESTRICTED, FLAG_ID, FLAG_INTEGER, FLAG_NUMBER, LINE_FEED, SOLIDUS, REVERSE_SOLIDUS, CHARACTER_TABULATION, SPACE, QUOTATION_MARK, EQUALS_SIGN, NUMBER_SIGN, DOLLAR_SIGN, PERCENTAGE_SIGN, APOSTROPHE, LEFT_PARENTHESIS, RIGHT_PARENTHESIS, LOW_LINE, HYPHEN_MINUS, EXCLAMATION_MARK, LESS_THAN_SIGN, GREATER_THAN_SIGN, COMMERCIAL_AT, LEFT_SQUARE_BRACKET, RIGHT_SQUARE_BRACKET, CIRCUMFLEX_ACCENT, LEFT_CURLY_BRACKET, QUESTION_MARK, RIGHT_CURLY_BRACKET, VERTICAL_LINE, TILDE, CONTROL, REPLACEMENT_CHARACTER, ASTERISK, PLUS_SIGN, COMMA, COLON, SEMICOLON, FULL_STOP, NULL2, BACKSPACE, LINE_TABULATION, SHIFT_OUT, INFORMATION_SEPARATOR_ONE, DELETE, EOF, ZERO, a, e, f, u, z, A, E, F, U, Z, isDigit, isSurrogateCodePoint, isHex, isLowerCaseLetter, isUpperCaseLetter, isLetter, isNonASCIICodePoint, isWhiteSpace, isNameStartCodePoint, isNameCodePoint, isNonPrintableCodePoint, isValidEscape, isIdentifierStart, isNumberStart, stringToNumber, LEFT_PARENTHESIS_TOKEN, RIGHT_PARENTHESIS_TOKEN, COMMA_TOKEN, SUFFIX_MATCH_TOKEN, PREFIX_MATCH_TOKEN, COLUMN_TOKEN, DASH_MATCH_TOKEN, INCLUDE_MATCH_TOKEN, LEFT_CURLY_BRACKET_TOKEN, RIGHT_CURLY_BRACKET_TOKEN, SUBSTRING_MATCH_TOKEN, BAD_URL_TOKEN, BAD_STRING_TOKEN, CDO_TOKEN, CDC_TOKEN, COLON_TOKEN, SEMICOLON_TOKEN, LEFT_SQUARE_BRACKET_TOKEN, RIGHT_SQUARE_BRACKET_TOKEN, WHITESPACE_TOKEN, EOF_TOKEN, Tokenizer, Parser, isDimensionToken, isNumberToken, isIdentToken, isStringToken, isIdentWithValue, nonWhiteSpace, nonFunctionArgSeparator, parseFunctionArgs, isEndingTokenFor, isLength, isLengthPercentage, parseLengthPercentageTuple, ZERO_LENGTH, FIFTY_PERCENT, HUNDRED_PERCENT, getAbsoluteValueForTuple, getAbsoluteValue, DEG, GRAD, RAD, TURN, angle, isAngle, parseNamedSide, deg, color$1, isTransparent, asString, pack, getTokenColorValue, rgb, hsl, SUPPORTED_COLOR_FUNCTIONS, parseColor, COLORS, backgroundClip, backgroundColor, parseColorStop, processColorStops, getAngleFromCorner, calculateGradientDirection, distance, findCorner, calculateRadius, linearGradient, prefixLinearGradient, webkitGradient, CLOSEST_SIDE, FARTHEST_SIDE, CLOSEST_CORNER, FARTHEST_CORNER, CIRCLE, ELLIPSE, COVER, CONTAIN, radialGradient, prefixRadialGradient, isLinearGradient, isRadialGradient, image, SUPPORTED_IMAGE_FUNCTIONS, backgroundImage, backgroundOrigin, backgroundPosition, backgroundRepeat, parseBackgroundRepeat, BACKGROUND_SIZE, backgroundSize, isBackgroundSizeInfoToken, borderColorForSide, borderTopColor, borderRightColor, borderBottomColor, borderLeftColor, borderRadiusForSide, borderTopLeftRadius, borderTopRightRadius, borderBottomRightRadius, borderBottomLeftRadius, borderStyleForSide, borderTopStyle, borderRightStyle, borderBottomStyle, borderLeftStyle, borderWidthForSide, borderTopWidth, borderRightWidth, borderBottomWidth, borderLeftWidth, color, direction, display, parseDisplayValue, float, letterSpacing, LINE_BREAK, lineBreak, lineHeight, computeLineHeight, listStyleImage, listStylePosition, listStyleType, marginForSide, marginTop, marginRight, marginBottom, marginLeft, overflow, overflowWrap, paddingForSide, paddingTop, paddingRight, paddingBottom, paddingLeft, textAlign, position, textShadow, textTransform, transform$1, matrix, matrix3d, SUPPORTED_TRANSFORM_FUNCTIONS, DEFAULT_VALUE, DEFAULT, transformOrigin, visibility, WORD_BREAK, wordBreak, zIndex, time, opacity, textDecorationColor, textDecorationLine, fontFamily, fontSize, fontWeight, fontVariant, fontStyle, contains, content, counterIncrement, counterReset, duration, quotes, getQuote, boxShadow, paintOrder, webkitTextStrokeColor, webkitTextStrokeWidth, CSSParsedDeclaration, CSSParsedPseudoDeclaration, CSSParsedCounterDeclaration, parse, elementDebuggerAttribute, getElementDebugType, isDebugging, ElementContainer, base64, chars$1, lookup$1, i$1, decode2, polyUint16Array, polyUint32Array, UTRIE2_SHIFT_2, UTRIE2_SHIFT_1, UTRIE2_INDEX_SHIFT, UTRIE2_SHIFT_1_2, UTRIE2_LSCP_INDEX_2_OFFSET, UTRIE2_DATA_BLOCK_LENGTH, UTRIE2_DATA_MASK, UTRIE2_LSCP_INDEX_2_LENGTH, UTRIE2_INDEX_2_BMP_LENGTH, UTRIE2_UTF8_2B_INDEX_2_OFFSET, UTRIE2_UTF8_2B_INDEX_2_LENGTH, UTRIE2_INDEX_1_OFFSET, UTRIE2_OMITTED_BMP_INDEX_1_LENGTH, UTRIE2_INDEX_2_BLOCK_LENGTH, UTRIE2_INDEX_2_MASK, slice16, slice32, createTrieFromBase64, Trie, chars, lookup, i, Prepend, CR, LF, Control, Extend, SpacingMark, L, V, T, LV, LVT, ZWJ, Extended_Pictographic, RI, toCodePoints, fromCodePoint, UnicodeTrie, BREAK_NOT_ALLOWED, BREAK_ALLOWED, codePointToClass, _graphemeBreakAtIndex, GraphemeBreaker, splitGraphemes, testRangeBounds, testIOSLineBreak, testCORS, testResponseType, testSVG, isGreenPixel, testForeignObject, createForeignObjectSVG, loadSerializedSVG$1, FEATURES, TextBounds, parseTextBounds, getWrapperBounds, createRange, segmentGraphemes, segmentWords, breakText, wordSeparators, breakWords, TextContainer, transform, CAPITALIZE, capitalize, ImageElementContainer, CanvasElementContainer, SVGElementContainer, LIElementContainer, OLElementContainer, CHECKBOX_BORDER_RADIUS, RADIO_BORDER_RADIUS, reformatInputBounds, getInputValue, CHECKBOX, RADIO, PASSWORD, INPUT_COLOR, InputElementContainer, SelectElementContainer, TextareaElementContainer, IFrameElementContainer, LIST_OWNERS, parseNodeTree, createContainer, parseTree, createsRealStackingContext, createsStackingContext, isTextNode, isElementNode, isHTMLElementNode, isSVGElementNode, isLIElement, isOLElement, isInputElement, isHTMLElement, isSVGElement, isBodyElement, isCanvasElement, isVideoElement, isImageElement, isIFrameElement, isStyleElement, isScriptElement, isTextareaElement, isSelectElement, isSlotElement, isCustomElement, CounterState, ROMAN_UPPER, ARMENIAN, HEBREW, GEORGIAN, createAdditiveCounter, createCounterStyleWithSymbolResolver, createCounterStyleFromRange, createCounterStyleFromSymbols, CJK_ZEROS, CJK_TEN_COEFFICIENTS, CJK_TEN_HIGH_COEFFICIENTS, CJK_HUNDRED_COEFFICIENTS, createCJKCounter, CHINESE_INFORMAL_MULTIPLIERS, CHINESE_FORMAL_MULTIPLIERS, JAPANESE_NEGATIVE, KOREAN_NEGATIVE, createCounterText, IGNORE_ATTRIBUTE, DocumentCloner, PseudoElementType, createIFrameContainer, imageReady, imagesReady, iframeLoader, ignoredStyleProperties, copyCSSStyles, serializeDoctype, restoreOwnerScroll, restoreNodeScroll, PSEUDO_BEFORE, PSEUDO_AFTER, PSEUDO_HIDE_ELEMENT_CLASS_BEFORE, PSEUDO_HIDE_ELEMENT_CLASS_AFTER, PSEUDO_HIDE_ELEMENT_STYLE, createPseudoHideStyles, createStyles, CacheStorage, Cache, INLINE_SVG, INLINE_BASE64, INLINE_IMG, isRenderable, isInlineImage, isInlineBase64Image, isBlobImage, isSVG, Vector, lerp, BezierCurve, isBezierCurve, BoundCurves, CORNER, getCurvePoints, calculateBorderBoxPath, calculateContentBoxPath, calculatePaddingBoxPath, TransformEffect, ClipEffect, OpacityEffect, isTransformEffect, isClipEffect, isOpacityEffect, equalPath, transformPath, StackingContext, ElementPaint, parseStackTree, processListItems, parseStackingContexts, parsePathForBorder, parsePathForBorderDoubleOuter, parsePathForBorderDoubleInner, parsePathForBorderStroke, createStrokePathFromCurves, createPathFromCurves, paddingBox, contentBox, calculateBackgroundPositioningArea, calculateBackgroundPaintingArea, calculateBackgroundRendering, isAuto, hasIntrinsicValue, calculateBackgroundSize, getBackgroundValueForIndex, calculateBackgroundRepeatPath, SMALL_IMAGE, SAMPLE_TEXT, FontMetrics, Renderer, MASK_OFFSET, CanvasRenderer, isTextInputElement, calculateBackgroundCurvedPaintingArea, canvasTextAlign, iOSBrokenFonts, fixIOSSystemFonts, ForeignObjectRenderer, loadSerializedSVG, Logger, Context, html2canvas, renderElement, parseBackgroundColor, html2canvas_esm_default;
var init_html2canvas_esm = __esm({
  "node_modules/html2canvas/dist/html2canvas.esm.js"() {
    "use strict";
    extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    __assign = function() {
      __assign = Object.assign || function __assign2(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Bounds = /** @class */
    (function() {
      function Bounds2(left, top, width, height) {
        this.left = left;
        this.top = top;
        this.width = width;
        this.height = height;
      }
      Bounds2.prototype.add = function(x, y, w, h) {
        return new Bounds2(this.left + x, this.top + y, this.width + w, this.height + h);
      };
      Bounds2.fromClientRect = function(context, clientRect) {
        return new Bounds2(clientRect.left + context.windowBounds.left, clientRect.top + context.windowBounds.top, clientRect.width, clientRect.height);
      };
      Bounds2.fromDOMRectList = function(context, domRectList) {
        var domRect = Array.from(domRectList).find(function(rect) {
          return rect.width !== 0;
        });
        return domRect ? new Bounds2(domRect.left + context.windowBounds.left, domRect.top + context.windowBounds.top, domRect.width, domRect.height) : Bounds2.EMPTY;
      };
      Bounds2.EMPTY = new Bounds2(0, 0, 0, 0);
      return Bounds2;
    })();
    parseBounds = function(context, node) {
      return Bounds.fromClientRect(context, node.getBoundingClientRect());
    };
    parseDocumentSize = function(document2) {
      var body = document2.body;
      var documentElement = document2.documentElement;
      if (!body || !documentElement) {
        throw new Error("Unable to get document size");
      }
      var width = Math.max(Math.max(body.scrollWidth, documentElement.scrollWidth), Math.max(body.offsetWidth, documentElement.offsetWidth), Math.max(body.clientWidth, documentElement.clientWidth));
      var height = Math.max(Math.max(body.scrollHeight, documentElement.scrollHeight), Math.max(body.offsetHeight, documentElement.offsetHeight), Math.max(body.clientHeight, documentElement.clientHeight));
      return new Bounds(0, 0, width, height);
    };
    toCodePoints$1 = function(str) {
      var codePoints = [];
      var i = 0;
      var length = str.length;
      while (i < length) {
        var value = str.charCodeAt(i++);
        if (value >= 55296 && value <= 56319 && i < length) {
          var extra = str.charCodeAt(i++);
          if ((extra & 64512) === 56320) {
            codePoints.push(((value & 1023) << 10) + (extra & 1023) + 65536);
          } else {
            codePoints.push(value);
            i--;
          }
        } else {
          codePoints.push(value);
        }
      }
      return codePoints;
    };
    fromCodePoint$1 = function() {
      var codePoints = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        codePoints[_i] = arguments[_i];
      }
      if (String.fromCodePoint) {
        return String.fromCodePoint.apply(String, codePoints);
      }
      var length = codePoints.length;
      if (!length) {
        return "";
      }
      var codeUnits = [];
      var index = -1;
      var result = "";
      while (++index < length) {
        var codePoint = codePoints[index];
        if (codePoint <= 65535) {
          codeUnits.push(codePoint);
        } else {
          codePoint -= 65536;
          codeUnits.push((codePoint >> 10) + 55296, codePoint % 1024 + 56320);
        }
        if (index + 1 === length || codeUnits.length > 16384) {
          result += String.fromCharCode.apply(String, codeUnits);
          codeUnits.length = 0;
        }
      }
      return result;
    };
    chars$2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    lookup$2 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
    for (i$2 = 0; i$2 < chars$2.length; i$2++) {
      lookup$2[chars$2.charCodeAt(i$2)] = i$2;
    }
    chars$1$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    lookup$1$1 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
    for (i$1$1 = 0; i$1$1 < chars$1$1.length; i$1$1++) {
      lookup$1$1[chars$1$1.charCodeAt(i$1$1)] = i$1$1;
    }
    decode$1 = function(base642) {
      var bufferLength = base642.length * 0.75, len = base642.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
      if (base642[base642.length - 1] === "=") {
        bufferLength--;
        if (base642[base642.length - 2] === "=") {
          bufferLength--;
        }
      }
      var buffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && typeof Uint8Array.prototype.slice !== "undefined" ? new ArrayBuffer(bufferLength) : new Array(bufferLength);
      var bytes = Array.isArray(buffer) ? buffer : new Uint8Array(buffer);
      for (i = 0; i < len; i += 4) {
        encoded1 = lookup$1$1[base642.charCodeAt(i)];
        encoded2 = lookup$1$1[base642.charCodeAt(i + 1)];
        encoded3 = lookup$1$1[base642.charCodeAt(i + 2)];
        encoded4 = lookup$1$1[base642.charCodeAt(i + 3)];
        bytes[p++] = encoded1 << 2 | encoded2 >> 4;
        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
      }
      return buffer;
    };
    polyUint16Array$1 = function(buffer) {
      var length = buffer.length;
      var bytes = [];
      for (var i = 0; i < length; i += 2) {
        bytes.push(buffer[i + 1] << 8 | buffer[i]);
      }
      return bytes;
    };
    polyUint32Array$1 = function(buffer) {
      var length = buffer.length;
      var bytes = [];
      for (var i = 0; i < length; i += 4) {
        bytes.push(buffer[i + 3] << 24 | buffer[i + 2] << 16 | buffer[i + 1] << 8 | buffer[i]);
      }
      return bytes;
    };
    UTRIE2_SHIFT_2$1 = 5;
    UTRIE2_SHIFT_1$1 = 6 + 5;
    UTRIE2_INDEX_SHIFT$1 = 2;
    UTRIE2_SHIFT_1_2$1 = UTRIE2_SHIFT_1$1 - UTRIE2_SHIFT_2$1;
    UTRIE2_LSCP_INDEX_2_OFFSET$1 = 65536 >> UTRIE2_SHIFT_2$1;
    UTRIE2_DATA_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_2$1;
    UTRIE2_DATA_MASK$1 = UTRIE2_DATA_BLOCK_LENGTH$1 - 1;
    UTRIE2_LSCP_INDEX_2_LENGTH$1 = 1024 >> UTRIE2_SHIFT_2$1;
    UTRIE2_INDEX_2_BMP_LENGTH$1 = UTRIE2_LSCP_INDEX_2_OFFSET$1 + UTRIE2_LSCP_INDEX_2_LENGTH$1;
    UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 = UTRIE2_INDEX_2_BMP_LENGTH$1;
    UTRIE2_UTF8_2B_INDEX_2_LENGTH$1 = 2048 >> 6;
    UTRIE2_INDEX_1_OFFSET$1 = UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 + UTRIE2_UTF8_2B_INDEX_2_LENGTH$1;
    UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 = 65536 >> UTRIE2_SHIFT_1$1;
    UTRIE2_INDEX_2_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_1_2$1;
    UTRIE2_INDEX_2_MASK$1 = UTRIE2_INDEX_2_BLOCK_LENGTH$1 - 1;
    slice16$1 = function(view, start, end) {
      if (view.slice) {
        return view.slice(start, end);
      }
      return new Uint16Array(Array.prototype.slice.call(view, start, end));
    };
    slice32$1 = function(view, start, end) {
      if (view.slice) {
        return view.slice(start, end);
      }
      return new Uint32Array(Array.prototype.slice.call(view, start, end));
    };
    createTrieFromBase64$1 = function(base642, _byteLength) {
      var buffer = decode$1(base642);
      var view32 = Array.isArray(buffer) ? polyUint32Array$1(buffer) : new Uint32Array(buffer);
      var view16 = Array.isArray(buffer) ? polyUint16Array$1(buffer) : new Uint16Array(buffer);
      var headerLength = 24;
      var index = slice16$1(view16, headerLength / 2, view32[4] / 2);
      var data = view32[5] === 2 ? slice16$1(view16, (headerLength + view32[4]) / 2) : slice32$1(view32, Math.ceil((headerLength + view32[4]) / 4));
      return new Trie$1(view32[0], view32[1], view32[2], view32[3], index, data);
    };
    Trie$1 = /** @class */
    (function() {
      function Trie2(initialValue, errorValue, highStart, highValueIndex, index, data) {
        this.initialValue = initialValue;
        this.errorValue = errorValue;
        this.highStart = highStart;
        this.highValueIndex = highValueIndex;
        this.index = index;
        this.data = data;
      }
      Trie2.prototype.get = function(codePoint) {
        var ix;
        if (codePoint >= 0) {
          if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
            ix = this.index[codePoint >> UTRIE2_SHIFT_2$1];
            ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
            return this.data[ix];
          }
          if (codePoint <= 65535) {
            ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET$1 + (codePoint - 55296 >> UTRIE2_SHIFT_2$1)];
            ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
            return this.data[ix];
          }
          if (codePoint < this.highStart) {
            ix = UTRIE2_INDEX_1_OFFSET$1 - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 + (codePoint >> UTRIE2_SHIFT_1$1);
            ix = this.index[ix];
            ix += codePoint >> UTRIE2_SHIFT_2$1 & UTRIE2_INDEX_2_MASK$1;
            ix = this.index[ix];
            ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
            return this.data[ix];
          }
          if (codePoint <= 1114111) {
            return this.data[this.highValueIndex];
          }
        }
        return this.errorValue;
      };
      return Trie2;
    })();
    chars$3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    lookup$3 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
    for (i$3 = 0; i$3 < chars$3.length; i$3++) {
      lookup$3[chars$3.charCodeAt(i$3)] = i$3;
    }
    base64$1 = "KwAAAAAAAAAACA4AUD0AADAgAAACAAAAAAAIABAAGABAAEgAUABYAGAAaABgAGgAYgBqAF8AZwBgAGgAcQB5AHUAfQCFAI0AlQCdAKIAqgCyALoAYABoAGAAaABgAGgAwgDKAGAAaADGAM4A0wDbAOEA6QDxAPkAAQEJAQ8BFwF1AH0AHAEkASwBNAE6AUIBQQFJAVEBWQFhAWgBcAF4ATAAgAGGAY4BlQGXAZ8BpwGvAbUBvQHFAc0B0wHbAeMB6wHxAfkBAQIJAvEBEQIZAiECKQIxAjgCQAJGAk4CVgJeAmQCbAJ0AnwCgQKJApECmQKgAqgCsAK4ArwCxAIwAMwC0wLbAjAA4wLrAvMC+AIAAwcDDwMwABcDHQMlAy0DNQN1AD0DQQNJA0kDSQNRA1EDVwNZA1kDdQB1AGEDdQBpA20DdQN1AHsDdQCBA4kDkQN1AHUAmQOhA3UAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AKYDrgN1AHUAtgO+A8YDzgPWAxcD3gPjA+sD8wN1AHUA+wMDBAkEdQANBBUEHQQlBCoEFwMyBDgEYABABBcDSARQBFgEYARoBDAAcAQzAXgEgASIBJAEdQCXBHUAnwSnBK4EtgS6BMIEyAR1AHUAdQB1AHUAdQCVANAEYABgAGAAYABgAGAAYABgANgEYADcBOQEYADsBPQE/AQEBQwFFAUcBSQFLAU0BWQEPAVEBUsFUwVbBWAAYgVgAGoFcgV6BYIFigWRBWAAmQWfBaYFYABgAGAAYABgAKoFYACxBbAFuQW6BcEFwQXHBcEFwQXPBdMF2wXjBeoF8gX6BQIGCgYSBhoGIgYqBjIGOgZgAD4GRgZMBmAAUwZaBmAAYABgAGAAYABgAGAAYABgAGAAYABgAGIGYABpBnAGYABgAGAAYABgAGAAYABgAGAAYAB4Bn8GhQZgAGAAYAB1AHcDFQSLBmAAYABgAJMGdQA9A3UAmwajBqsGqwaVALMGuwbDBjAAywbSBtIG1QbSBtIG0gbSBtIG0gbdBuMG6wbzBvsGAwcLBxMHAwcbByMHJwcsBywHMQcsB9IGOAdAB0gHTgfSBkgHVgfSBtIG0gbSBtIG0gbSBtIG0gbSBiwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdgAGAALAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdbB2MHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB2kH0gZwB64EdQB1AHUAdQB1AHUAdQB1AHUHfQdgAIUHjQd1AHUAlQedB2AAYAClB6sHYACzB7YHvgfGB3UAzgfWBzMB3gfmB1EB7gf1B/0HlQENAQUIDQh1ABUIHQglCBcDLQg1CD0IRQhNCEEDUwh1AHUAdQBbCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIcAh3CHoIMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIgggwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAALAcsBywHLAcsBywHLAcsBywHLAcsB4oILAcsB44I0gaWCJ4Ipgh1AHUAqgiyCHUAdQB1AHUAdQB1AHUAdQB1AHUAtwh8AXUAvwh1AMUIyQjRCNkI4AjoCHUAdQB1AO4I9gj+CAYJDgkTCS0HGwkjCYIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiAAIAAAAFAAYABgAGIAXwBgAHEAdQBFAJUAogCyAKAAYABgAEIA4ABGANMA4QDxAMEBDwE1AFwBLAE6AQEBUQF4QkhCmEKoQrhCgAHIQsAB0MLAAcABwAHAAeDC6ABoAHDCwMMAAcABwAHAAdDDGMMAAcAB6MM4wwjDWMNow3jDaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAEjDqABWw6bDqABpg6gAaABoAHcDvwOPA+gAaABfA/8DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DpcPAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcAB9cPKwkyCToJMAB1AHUAdQBCCUoJTQl1AFUJXAljCWcJawkwADAAMAAwAHMJdQB2CX4JdQCECYoJjgmWCXUAngkwAGAAYABxAHUApgn3A64JtAl1ALkJdQDACTAAMAAwADAAdQB1AHUAdQB1AHUAdQB1AHUAowYNBMUIMAAwADAAMADICcsJ0wnZCRUE4QkwAOkJ8An4CTAAMAB1AAAKvwh1AAgKDwoXCh8KdQAwACcKLgp1ADYKqAmICT4KRgowADAAdQB1AE4KMAB1AFYKdQBeCnUAZQowADAAMAAwADAAMAAwADAAMAAVBHUAbQowADAAdQC5CXUKMAAwAHwBxAijBogEMgF9CoQKiASMCpQKmgqIBKIKqgquCogEDQG2Cr4KxgrLCjAAMADTCtsKCgHjCusK8Qr5CgELMAAwADAAMAB1AIsECQsRC3UANAEZCzAAMAAwADAAMAB1ACELKQswAHUANAExCzkLdQBBC0kLMABRC1kLMAAwADAAMAAwADAAdQBhCzAAMAAwAGAAYABpC3ELdwt/CzAAMACHC4sLkwubC58Lpwt1AK4Ltgt1APsDMAAwADAAMAAwADAAMAAwAL4LwwvLC9IL1wvdCzAAMADlC+kL8Qv5C/8LSQswADAAMAAwADAAMAAwADAAMAAHDDAAMAAwADAAMAAODBYMHgx1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1ACYMMAAwADAAdQB1AHUALgx1AHUAdQB1AHUAdQA2DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AD4MdQBGDHUAdQB1AHUAdQB1AEkMdQB1AHUAdQB1AFAMMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQBYDHUAdQB1AF8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUA+wMVBGcMMAAwAHwBbwx1AHcMfwyHDI8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAYABgAJcMMAAwADAAdQB1AJ8MlQClDDAAMACtDCwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB7UMLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AA0EMAC9DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAsBywHLAcsBywHLAcsBywHLQcwAMEMyAwsBywHLAcsBywHLAcsBywHLAcsBywHzAwwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1ANQM2QzhDDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMABgAGAAYABgAGAAYABgAOkMYADxDGAA+AwADQYNYABhCWAAYAAODTAAMAAwADAAFg1gAGAAHg37AzAAMAAwADAAYABgACYNYAAsDTQNPA1gAEMNPg1LDWAAYABgAGAAYABgAGAAYABgAGAAUg1aDYsGVglhDV0NcQBnDW0NdQ15DWAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAlQCBDZUAiA2PDZcNMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAnw2nDTAAMAAwADAAMAAwAHUArw23DTAAMAAwADAAMAAwADAAMAAwADAAMAB1AL8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQDHDTAAYABgAM8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA1w11ANwNMAAwAD0B5A0wADAAMAAwADAAMADsDfQN/A0EDgwOFA4wABsOMAAwADAAMAAwADAAMAAwANIG0gbSBtIG0gbSBtIG0gYjDigOwQUuDsEFMw7SBjoO0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGQg5KDlIOVg7SBtIGXg5lDm0OdQ7SBtIGfQ6EDooOjQ6UDtIGmg6hDtIG0gaoDqwO0ga0DrwO0gZgAGAAYADEDmAAYAAkBtIGzA5gANIOYADaDokO0gbSBt8O5w7SBu8O0gb1DvwO0gZgAGAAxA7SBtIG0gbSBtIGYABgAGAAYAAED2AAsAUMD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHJA8sBywHLAcsBywHLAccDywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywPLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAc0D9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHPA/SBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gYUD0QPlQCVAJUAMAAwADAAMACVAJUAlQCVAJUAlQCVAEwPMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA//8EAAQABAAEAAQABAAEAAQABAANAAMAAQABAAIABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQACgATABcAHgAbABoAHgAXABYAEgAeABsAGAAPABgAHABLAEsASwBLAEsASwBLAEsASwBLABgAGAAeAB4AHgATAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABYAGwASAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWAA0AEQAeAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAFAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJABYAGgAbABsAGwAeAB0AHQAeAE8AFwAeAA0AHgAeABoAGwBPAE8ADgBQAB0AHQAdAE8ATwAXAE8ATwBPABYAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAFAATwBAAE8ATwBPAEAATwBQAFAATwBQAB4AHgAeAB4AHgAeAB0AHQAdAB0AHgAdAB4ADgBQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgBQAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAkACQAJAAkACQAJAAkABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAFAAHgAeAB4AKwArAFAAUABQAFAAGABQACsAKwArACsAHgAeAFAAHgBQAFAAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUAAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAYAA0AKwArAB4AHgAbACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAB4ABAAEAB4ABAAEABMABAArACsAKwArACsAKwArACsAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAKwArACsAKwBWAFYAVgBWAB4AHgArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AGgAaABoAGAAYAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQAEwAEACsAEwATAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABLAEsASwBLAEsASwBLAEsASwBLABoAGQAZAB4AUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABMAUAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABABQAFAABAAEAB4ABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUAAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAFAABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQAUABQAB4AHgAYABMAUAArACsABAAbABsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAFAABAAEAAQABAAEAFAABAAEAAQAUAAEAAQABAAEAAQAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArACsAHgArAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAUAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEAA0ADQBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUAArACsAKwBQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABABQACsAKwArACsAKwArACsAKwAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUAAaABoAUABQAFAAUABQAEwAHgAbAFAAHgAEACsAKwAEAAQABAArAFAAUABQAFAAUABQACsAKwArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQACsAUABQACsAKwAEACsABAAEAAQABAAEACsAKwArACsABAAEACsAKwAEAAQABAArACsAKwAEACsAKwArACsAKwArACsAUABQAFAAUAArAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLAAQABABQAFAAUAAEAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAArACsAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AGwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAKwArACsAKwArAAQABAAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAAQAUAArAFAAUABQAFAAUABQACsAKwArAFAAUABQACsAUABQAFAAUAArACsAKwBQAFAAKwBQACsAUABQACsAKwArAFAAUAArACsAKwBQAFAAUAArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArAAQABAAEAAQABAArACsAKwAEAAQABAArAAQABAAEAAQAKwArAFAAKwArACsAKwArACsABAArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAHgAeAB4AHgAeAB4AGwAeACsAKwArACsAKwAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAUABQAFAAKwArACsAKwArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwAOAFAAUABQAFAAUABQAFAAHgBQAAQABAAEAA4AUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAKwArAAQAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAKwArACsAKwArACsAUAArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAFAABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQABABQAB4AKwArACsAKwBQAFAAUAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQABoAUABQAFAAUABQAFAAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQACsAUAArACsAUABQAFAAUABQAFAAUAArACsAKwAEACsAKwArACsABAAEAAQABAAEAAQAKwAEACsABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArAAQABAAeACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAXAAqACoAKgAqACoAKgAqACsAKwArACsAGwBcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAeAEsASwBLAEsASwBLAEsASwBLAEsADQANACsAKwArACsAKwBcAFwAKwBcACsAXABcAFwAXABcACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAXAArAFwAXABcAFwAXABcAFwAXABcAFwAKgBcAFwAKgAqACoAKgAqACoAKgAqACoAXAArACsAXABcAFwAXABcACsAXAArACoAKgAqACoAKgAqACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwBcAFwAXABcAFAADgAOAA4ADgAeAA4ADgAJAA4ADgANAAkAEwATABMAEwATAAkAHgATAB4AHgAeAAQABAAeAB4AHgAeAB4AHgBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQAFAADQAEAB4ABAAeAAQAFgARABYAEQAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAAQABAAEAAQADQAEAAQAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAA0ADQAeAB4AHgAeAB4AHgAEAB4AHgAeAB4AHgAeACsAHgAeAA4ADgANAA4AHgAeAB4AHgAeAAkACQArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgBcAEsASwBLAEsASwBLAEsASwBLAEsADQANAB4AHgAeAB4AXABcAFwAXABcAFwAKgAqACoAKgBcAFwAXABcACoAKgAqAFwAKgAqACoAXABcACoAKgAqACoAKgAqACoAXABcAFwAKgAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqAFwAKgBLAEsASwBLAEsASwBLAEsASwBLACoAKgAqACoAKgAqAFAAUABQAFAAUABQACsAUAArACsAKwArACsAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAKwBQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsABAAEAAQAHgANAB4AHgAeAB4AHgAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUAArACsADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWABEAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQANAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAANAA0AKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUAArAAQABAArACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqAA0ADQAVAFwADQAeAA0AGwBcACoAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwAeAB4AEwATAA0ADQAOAB4AEwATAB4ABAAEAAQACQArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAHgArACsAKwATABMASwBLAEsASwBLAEsASwBLAEsASwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAXABcAFwAXABcACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAXAArACsAKwAqACoAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsAHgAeAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKwAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKwArAAQASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACoAKgAqACoAKgAqACoAXAAqACoAKgAqACoAKgArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABABQAFAAUABQAFAAUABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwANAA0AHgANAA0ADQANAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwAeAB4AHgAeAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArAA0ADQANAA0ADQBLAEsASwBLAEsASwBLAEsASwBLACsAKwArAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUAAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAAQAUABQAFAAUABQAFAABABQAFAABAAEAAQAUAArACsAKwArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQACsAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAFAAUABQACsAHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQACsAKwAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQACsAHgAeAB4AHgAeAB4AHgAOAB4AKwANAA0ADQANAA0ADQANAAkADQANAA0ACAAEAAsABAAEAA0ACQANAA0ADAAdAB0AHgAXABcAFgAXABcAFwAWABcAHQAdAB4AHgAUABQAFAANAAEAAQAEAAQABAAEAAQACQAaABoAGgAaABoAGgAaABoAHgAXABcAHQAVABUAHgAeAB4AHgAeAB4AGAAWABEAFQAVABUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ADQAeAA0ADQANAA0AHgANAA0ADQAHAB4AHgAeAB4AKwAEAAQABAAEAAQABAAEAAQABAAEAFAAUAArACsATwBQAFAAUABQAFAAHgAeAB4AFgARAE8AUABPAE8ATwBPAFAAUABQAFAAUAAeAB4AHgAWABEAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArABsAGwAbABsAGwAbABsAGgAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGgAbABsAGwAbABoAGwAbABoAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAHgAeAFAAGgAeAB0AHgBQAB4AGgAeAB4AHgAeAB4AHgAeAB4AHgBPAB4AUAAbAB4AHgBQAFAAUABQAFAAHgAeAB4AHQAdAB4AUAAeAFAAHgBQAB4AUABPAFAAUAAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgBQAFAAUABQAE8ATwBQAFAAUABQAFAATwBQAFAATwBQAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAUABQAFAATwBPAE8ATwBPAE8ATwBPAE8ATwBQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABPAB4AHgArACsAKwArAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHQAdAB4AHgAeAB0AHQAeAB4AHQAeAB4AHgAdAB4AHQAbABsAHgAdAB4AHgAeAB4AHQAeAB4AHQAdAB0AHQAeAB4AHQAeAB0AHgAdAB0AHQAdAB0AHQAeAB0AHgAeAB4AHgAeAB0AHQAdAB0AHgAeAB4AHgAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHgAeAB0AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAeAB0AHQAdAB0AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAdAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAWABEAHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAWABEAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AHQAdAB0AHgAeAB0AHgAeAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlAB4AHQAdAB4AHgAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AJQAlAB0AHQAlAB4AJQAlACUAIAAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAdAB0AHQAeAB0AJQAdAB0AHgAdAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAdAB0AHQAdACUAHgAlACUAJQAdACUAJQAdAB0AHQAlACUAHQAdACUAHQAdACUAJQAlAB4AHQAeAB4AHgAeAB0AHQAlAB0AHQAdAB0AHQAdACUAJQAlACUAJQAdACUAJQAgACUAHQAdACUAJQAlACUAJQAlACUAJQAeAB4AHgAlACUAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AFwAXABcAFwAXABcAHgATABMAJQAeAB4AHgAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARABYAEQAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAEAAQABAAeAB4AKwArACsAKwArABMADQANAA0AUAATAA0AUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUAANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAA0ADQANAA0ADQANAA0ADQAeAA0AFgANAB4AHgAXABcAHgAeABcAFwAWABEAFgARABYAEQAWABEADQANAA0ADQATAFAADQANAB4ADQANAB4AHgAeAB4AHgAMAAwADQANAA0AHgANAA0AFgANAA0ADQANAA0ADQANAA0AHgANAB4ADQANAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArAA0AEQARACUAJQBHAFcAVwAWABEAFgARABYAEQAWABEAFgARACUAJQAWABEAFgARABYAEQAWABEAFQAWABEAEQAlAFcAVwBXAFcAVwBXAFcAVwBXAAQABAAEAAQABAAEACUAVwBXAFcAVwA2ACUAJQBXAFcAVwBHAEcAJQAlACUAKwBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBRAFcAUQBXAFEAVwBXAFcAVwBXAFcAUQBXAFcAVwBXAFcAVwBRAFEAKwArAAQABAAVABUARwBHAFcAFQBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBRAFcAVwBXAFcAVwBXAFEAUQBXAFcAVwBXABUAUQBHAEcAVwArACsAKwArACsAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwAlACUAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACsAKwArACsAKwArACsAKwArACsAKwArAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBPAE8ATwBPAE8ATwBPAE8AJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADQATAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABLAEsASwBLAEsASwBLAEsASwBLAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAABAAEAAQABAAeAAQABAAEAAQABAAEAAQABAAEAAQAHgBQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAeAA0ADQANAA0ADQArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAAQAUABQAFAABABQAFAAUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAeAB4AHgAeAAQAKwArACsAUABQAFAAUABQAFAAHgAeABoAHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADgAOABMAEwArACsAKwArACsAKwArACsABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwANAA0ASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUAAeAB4AHgBQAA4AUABQAAQAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArAB4AWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYACsAKwArAAQAHgAeAB4AHgAeAB4ADQANAA0AHgAeAB4AHgArAFAASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArAB4AHgBcAFwAXABcAFwAKgBcAFwAXABcAFwAXABcAFwAXABcAEsASwBLAEsASwBLAEsASwBLAEsAXABcAFwAXABcACsAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAFAAUABQAAQAUABQAFAAUABQAFAAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAHgANAA0ADQBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAXAAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAKgAqACoAXABcACoAKgBcAFwAXABcAFwAKgAqAFwAKgBcACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcACoAKgBQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAA0ADQBQAFAAUAAEAAQAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQADQAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAVABVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBUAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVACsAKwArACsAKwArACsAKwArACsAKwArAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAKwArACsAKwBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAKwArACsAKwAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAKwArACsAKwArAFYABABWAFYAVgBWAFYAVgBWAFYAVgBWAB4AVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgArAFYAVgBWAFYAVgArAFYAKwBWAFYAKwBWAFYAKwBWAFYAVgBWAFYAVgBWAFYAVgBWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAEQAWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAaAB4AKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAGAARABEAGAAYABMAEwAWABEAFAArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACUAJQAlACUAJQAWABEAFgARABYAEQAWABEAFgARABYAEQAlACUAFgARACUAJQAlACUAJQAlACUAEQAlABEAKwAVABUAEwATACUAFgARABYAEQAWABEAJQAlACUAJQAlACUAJQAlACsAJQAbABoAJQArACsAKwArAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAcAKwATACUAJQAbABoAJQAlABYAEQAlACUAEQAlABEAJQBXAFcAVwBXAFcAVwBXAFcAVwBXABUAFQAlACUAJQATACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXABYAJQARACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAWACUAEQAlABYAEQARABYAEQARABUAVwBRAFEAUQBRAFEAUQBRAFEAUQBRAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcARwArACsAVwBXAFcAVwBXAFcAKwArAFcAVwBXAFcAVwBXACsAKwBXAFcAVwBXAFcAVwArACsAVwBXAFcAKwArACsAGgAbACUAJQAlABsAGwArAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAAQAB0AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsADQANAA0AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAA0AUABQAFAAUAArACsAKwArAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwArAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwBQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAUABQAFAAUABQAAQABAAEACsABAAEACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAKwBQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAA0ADQANAA0ADQANAA0ADQAeACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAArACsAKwArAFAAUABQAFAAUAANAA0ADQANAA0ADQAUACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsADQANAA0ADQANAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArAAQABAANACsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAB4AHgAeAB4AHgArACsAKwArACsAKwAEAAQABAAEAAQABAAEAA0ADQAeAB4AHgAeAB4AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsASwBLAEsASwBLAEsASwBLAEsASwANAA0ADQANAFAABAAEAFAAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAeAA4AUAArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAADQANAB4ADQAEAAQABAAEAB4ABAAEAEsASwBLAEsASwBLAEsASwBLAEsAUAAOAFAADQANAA0AKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAANAA0AHgANAA0AHgAEACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAA0AKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsABAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsABAAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAUAArACsAKwArACsAKwAEACsAKwArACsAKwBQAFAAUABQAFAABAAEACsAKwAEAAQABAAEAAQABAAEACsAKwArAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAQABABQAFAAUABQAA0ADQANAA0AHgBLAEsASwBLAEsASwBLAEsASwBLAA0ADQArAB4ABABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUAAeAFAAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABAAEAAQADgANAA0AEwATAB4AHgAeAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAFAAUABQAFAABAAEACsAKwAEAA0ADQAeAFAAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKwArACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBcAFwADQANAA0AKgBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAKwArAFAAKwArAFAAUABQAFAAUABQAFAAUAArAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQAKwAEAAQAKwArAAQABAAEAAQAUAAEAFAABAAEAA0ADQANACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABABQAA4AUAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAFAABAAEAAQABAAOAB4ADQANAA0ADQAOAB4ABAArACsAKwArACsAKwArACsAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAA0ADQANAFAADgAOAA4ADQANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAAQABAAEAFAADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAOABMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAArACsAKwAEACsABAAEACsABAAEAAQABAAEAAQABABQAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAaABoAGgAaAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABIAEgAQwBDAEMAUABQAFAAUABDAFAAUABQAEgAQwBIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABDAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAJAAkACQAJAAkACQAJABYAEQArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwANAA0AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAANACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAA0ADQANAB4AHgAeAB4AHgAeAFAAUABQAFAADQAeACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAA0AHgAeACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAARwBHABUARwAJACsAKwArACsAKwArACsAKwArACsAKwAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUQBRAFEAKwArACsAKwArACsAKwArACsAKwArACsAKwBRAFEAUQBRACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAHgAEAAQADQAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQABAAEAAQABAAeAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQAHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAKwArAFAAKwArAFAAUAArACsAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUAArAFAAUABQAFAAUABQAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAHgAeAFAAUABQAFAAUAArAFAAKwArACsAUABQAFAAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeACsAKwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4ABAAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAHgAeAA0ADQANAA0AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArAAQABAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwBQAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArABsAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAB4AHgAeAB4ABAAEAAQABAAEAAQABABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArABYAFgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAGgBQAFAAUAAaAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUAArACsAKwArACsAKwBQACsAKwArACsAUAArAFAAKwBQACsAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUAArAFAAKwBQACsAUAArAFAAUAArAFAAKwArAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAKwBQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8AJQAlACUAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB4AHgAeACUAJQAlAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAlACUAJQAlACUAHgAlACUAJQAlACUAIAAgACAAJQAlACAAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACEAIQAhACEAIQAlACUAIAAgACUAJQAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAIAAlACUAJQAlACAAIAAgACUAIAAgACAAJQAlACUAJQAlACUAJQAgACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAlAB4AJQAeACUAJQAlACUAJQAgACUAJQAlACUAHgAlAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACAAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABcAFwAXABUAFQAVAB4AHgAeAB4AJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAgACUAJQAgACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAIAAgACUAJQAgACAAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACAAIAAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACAAIAAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAA==";
    LETTER_NUMBER_MODIFIER = 50;
    BK = 1;
    CR$1 = 2;
    LF$1 = 3;
    CM = 4;
    NL = 5;
    WJ = 7;
    ZW = 8;
    GL = 9;
    SP = 10;
    ZWJ$1 = 11;
    B2 = 12;
    BA = 13;
    BB = 14;
    HY = 15;
    CB = 16;
    CL = 17;
    CP = 18;
    EX = 19;
    IN = 20;
    NS = 21;
    OP = 22;
    QU = 23;
    IS = 24;
    NU = 25;
    PO = 26;
    PR = 27;
    SY = 28;
    AI = 29;
    AL = 30;
    CJ = 31;
    EB = 32;
    EM = 33;
    H2 = 34;
    H3 = 35;
    HL = 36;
    ID = 37;
    JL = 38;
    JV = 39;
    JT = 40;
    RI$1 = 41;
    SA = 42;
    XX = 43;
    ea_OP = [9001, 65288];
    BREAK_MANDATORY = "!";
    BREAK_NOT_ALLOWED$1 = "\xD7";
    BREAK_ALLOWED$1 = "\xF7";
    UnicodeTrie$1 = createTrieFromBase64$1(base64$1);
    ALPHABETICS = [AL, HL];
    HARD_LINE_BREAKS = [BK, CR$1, LF$1, NL];
    SPACE$1 = [SP, ZW];
    PREFIX_POSTFIX = [PR, PO];
    LINE_BREAKS = HARD_LINE_BREAKS.concat(SPACE$1);
    KOREAN_SYLLABLE_BLOCK = [JL, JV, JT, H2, H3];
    HYPHEN = [HY, BA];
    codePointsToCharacterClasses = function(codePoints, lineBreak2) {
      if (lineBreak2 === void 0) {
        lineBreak2 = "strict";
      }
      var types = [];
      var indices = [];
      var categories = [];
      codePoints.forEach(function(codePoint, index) {
        var classType = UnicodeTrie$1.get(codePoint);
        if (classType > LETTER_NUMBER_MODIFIER) {
          categories.push(true);
          classType -= LETTER_NUMBER_MODIFIER;
        } else {
          categories.push(false);
        }
        if (["normal", "auto", "loose"].indexOf(lineBreak2) !== -1) {
          if ([8208, 8211, 12316, 12448].indexOf(codePoint) !== -1) {
            indices.push(index);
            return types.push(CB);
          }
        }
        if (classType === CM || classType === ZWJ$1) {
          if (index === 0) {
            indices.push(index);
            return types.push(AL);
          }
          var prev = types[index - 1];
          if (LINE_BREAKS.indexOf(prev) === -1) {
            indices.push(indices[index - 1]);
            return types.push(prev);
          }
          indices.push(index);
          return types.push(AL);
        }
        indices.push(index);
        if (classType === CJ) {
          return types.push(lineBreak2 === "strict" ? NS : ID);
        }
        if (classType === SA) {
          return types.push(AL);
        }
        if (classType === AI) {
          return types.push(AL);
        }
        if (classType === XX) {
          if (codePoint >= 131072 && codePoint <= 196605 || codePoint >= 196608 && codePoint <= 262141) {
            return types.push(ID);
          } else {
            return types.push(AL);
          }
        }
        types.push(classType);
      });
      return [indices, types, categories];
    };
    isAdjacentWithSpaceIgnored = function(a2, b, currentIndex, classTypes) {
      var current = classTypes[currentIndex];
      if (Array.isArray(a2) ? a2.indexOf(current) !== -1 : a2 === current) {
        var i = currentIndex;
        while (i <= classTypes.length) {
          i++;
          var next = classTypes[i];
          if (next === b) {
            return true;
          }
          if (next !== SP) {
            break;
          }
        }
      }
      if (current === SP) {
        var i = currentIndex;
        while (i > 0) {
          i--;
          var prev = classTypes[i];
          if (Array.isArray(a2) ? a2.indexOf(prev) !== -1 : a2 === prev) {
            var n = currentIndex;
            while (n <= classTypes.length) {
              n++;
              var next = classTypes[n];
              if (next === b) {
                return true;
              }
              if (next !== SP) {
                break;
              }
            }
          }
          if (prev !== SP) {
            break;
          }
        }
      }
      return false;
    };
    previousNonSpaceClassType = function(currentIndex, classTypes) {
      var i = currentIndex;
      while (i >= 0) {
        var type = classTypes[i];
        if (type === SP) {
          i--;
        } else {
          return type;
        }
      }
      return 0;
    };
    _lineBreakAtIndex = function(codePoints, classTypes, indicies, index, forbiddenBreaks) {
      if (indicies[index] === 0) {
        return BREAK_NOT_ALLOWED$1;
      }
      var currentIndex = index - 1;
      if (Array.isArray(forbiddenBreaks) && forbiddenBreaks[currentIndex] === true) {
        return BREAK_NOT_ALLOWED$1;
      }
      var beforeIndex = currentIndex - 1;
      var afterIndex = currentIndex + 1;
      var current = classTypes[currentIndex];
      var before = beforeIndex >= 0 ? classTypes[beforeIndex] : 0;
      var next = classTypes[afterIndex];
      if (current === CR$1 && next === LF$1) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (HARD_LINE_BREAKS.indexOf(current) !== -1) {
        return BREAK_MANDATORY;
      }
      if (HARD_LINE_BREAKS.indexOf(next) !== -1) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (SPACE$1.indexOf(next) !== -1) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (previousNonSpaceClassType(currentIndex, classTypes) === ZW) {
        return BREAK_ALLOWED$1;
      }
      if (UnicodeTrie$1.get(codePoints[currentIndex]) === ZWJ$1) {
        return BREAK_NOT_ALLOWED$1;
      }
      if ((current === EB || current === EM) && UnicodeTrie$1.get(codePoints[afterIndex]) === ZWJ$1) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (current === WJ || next === WJ) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (current === GL) {
        return BREAK_NOT_ALLOWED$1;
      }
      if ([SP, BA, HY].indexOf(current) === -1 && next === GL) {
        return BREAK_NOT_ALLOWED$1;
      }
      if ([CL, CP, EX, IS, SY].indexOf(next) !== -1) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (previousNonSpaceClassType(currentIndex, classTypes) === OP) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (isAdjacentWithSpaceIgnored(QU, OP, currentIndex, classTypes)) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (isAdjacentWithSpaceIgnored([CL, CP], NS, currentIndex, classTypes)) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (isAdjacentWithSpaceIgnored(B2, B2, currentIndex, classTypes)) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (current === SP) {
        return BREAK_ALLOWED$1;
      }
      if (current === QU || next === QU) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (next === CB || current === CB) {
        return BREAK_ALLOWED$1;
      }
      if ([BA, HY, NS].indexOf(next) !== -1 || current === BB) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (before === HL && HYPHEN.indexOf(current) !== -1) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (current === SY && next === HL) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (next === IN) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (ALPHABETICS.indexOf(next) !== -1 && current === NU || ALPHABETICS.indexOf(current) !== -1 && next === NU) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (current === PR && [ID, EB, EM].indexOf(next) !== -1 || [ID, EB, EM].indexOf(current) !== -1 && next === PO) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (ALPHABETICS.indexOf(current) !== -1 && PREFIX_POSTFIX.indexOf(next) !== -1 || PREFIX_POSTFIX.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (
        // (PR | PO) × ( OP | HY )? NU
        [PR, PO].indexOf(current) !== -1 && (next === NU || [OP, HY].indexOf(next) !== -1 && classTypes[afterIndex + 1] === NU) || // ( OP | HY ) × NU
        [OP, HY].indexOf(current) !== -1 && next === NU || // NU ×	(NU | SY | IS)
        current === NU && [NU, SY, IS].indexOf(next) !== -1
      ) {
        return BREAK_NOT_ALLOWED$1;
      }
      if ([NU, SY, IS, CL, CP].indexOf(next) !== -1) {
        var prevIndex = currentIndex;
        while (prevIndex >= 0) {
          var type = classTypes[prevIndex];
          if (type === NU) {
            return BREAK_NOT_ALLOWED$1;
          } else if ([SY, IS].indexOf(type) !== -1) {
            prevIndex--;
          } else {
            break;
          }
        }
      }
      if ([PR, PO].indexOf(next) !== -1) {
        var prevIndex = [CL, CP].indexOf(current) !== -1 ? beforeIndex : currentIndex;
        while (prevIndex >= 0) {
          var type = classTypes[prevIndex];
          if (type === NU) {
            return BREAK_NOT_ALLOWED$1;
          } else if ([SY, IS].indexOf(type) !== -1) {
            prevIndex--;
          } else {
            break;
          }
        }
      }
      if (JL === current && [JL, JV, H2, H3].indexOf(next) !== -1 || [JV, H2].indexOf(current) !== -1 && [JV, JT].indexOf(next) !== -1 || [JT, H3].indexOf(current) !== -1 && next === JT) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (KOREAN_SYLLABLE_BLOCK.indexOf(current) !== -1 && [IN, PO].indexOf(next) !== -1 || KOREAN_SYLLABLE_BLOCK.indexOf(next) !== -1 && current === PR) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (ALPHABETICS.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (current === IS && ALPHABETICS.indexOf(next) !== -1) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (ALPHABETICS.concat(NU).indexOf(current) !== -1 && next === OP && ea_OP.indexOf(codePoints[afterIndex]) === -1 || ALPHABETICS.concat(NU).indexOf(next) !== -1 && current === CP) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (current === RI$1 && next === RI$1) {
        var i = indicies[currentIndex];
        var count = 1;
        while (i > 0) {
          i--;
          if (classTypes[i] === RI$1) {
            count++;
          } else {
            break;
          }
        }
        if (count % 2 !== 0) {
          return BREAK_NOT_ALLOWED$1;
        }
      }
      if (current === EB && next === EM) {
        return BREAK_NOT_ALLOWED$1;
      }
      return BREAK_ALLOWED$1;
    };
    cssFormattedClasses = function(codePoints, options) {
      if (!options) {
        options = { lineBreak: "normal", wordBreak: "normal" };
      }
      var _a2 = codePointsToCharacterClasses(codePoints, options.lineBreak), indicies = _a2[0], classTypes = _a2[1], isLetterNumber = _a2[2];
      if (options.wordBreak === "break-all" || options.wordBreak === "break-word") {
        classTypes = classTypes.map(function(type) {
          return [NU, AL, SA].indexOf(type) !== -1 ? ID : type;
        });
      }
      var forbiddenBreakpoints = options.wordBreak === "keep-all" ? isLetterNumber.map(function(letterNumber, i) {
        return letterNumber && codePoints[i] >= 19968 && codePoints[i] <= 40959;
      }) : void 0;
      return [indicies, classTypes, forbiddenBreakpoints];
    };
    Break = /** @class */
    (function() {
      function Break2(codePoints, lineBreak2, start, end) {
        this.codePoints = codePoints;
        this.required = lineBreak2 === BREAK_MANDATORY;
        this.start = start;
        this.end = end;
      }
      Break2.prototype.slice = function() {
        return fromCodePoint$1.apply(void 0, this.codePoints.slice(this.start, this.end));
      };
      return Break2;
    })();
    LineBreaker = function(str, options) {
      var codePoints = toCodePoints$1(str);
      var _a2 = cssFormattedClasses(codePoints, options), indicies = _a2[0], classTypes = _a2[1], forbiddenBreakpoints = _a2[2];
      var length = codePoints.length;
      var lastEnd = 0;
      var nextIndex = 0;
      return {
        next: function() {
          if (nextIndex >= length) {
            return { done: true, value: null };
          }
          var lineBreak2 = BREAK_NOT_ALLOWED$1;
          while (nextIndex < length && (lineBreak2 = _lineBreakAtIndex(codePoints, classTypes, indicies, ++nextIndex, forbiddenBreakpoints)) === BREAK_NOT_ALLOWED$1) {
          }
          if (lineBreak2 !== BREAK_NOT_ALLOWED$1 || nextIndex === length) {
            var value = new Break(codePoints, lineBreak2, lastEnd, nextIndex);
            lastEnd = nextIndex;
            return { value, done: false };
          }
          return { done: true, value: null };
        }
      };
    };
    FLAG_UNRESTRICTED = 1 << 0;
    FLAG_ID = 1 << 1;
    FLAG_INTEGER = 1 << 2;
    FLAG_NUMBER = 1 << 3;
    LINE_FEED = 10;
    SOLIDUS = 47;
    REVERSE_SOLIDUS = 92;
    CHARACTER_TABULATION = 9;
    SPACE = 32;
    QUOTATION_MARK = 34;
    EQUALS_SIGN = 61;
    NUMBER_SIGN = 35;
    DOLLAR_SIGN = 36;
    PERCENTAGE_SIGN = 37;
    APOSTROPHE = 39;
    LEFT_PARENTHESIS = 40;
    RIGHT_PARENTHESIS = 41;
    LOW_LINE = 95;
    HYPHEN_MINUS = 45;
    EXCLAMATION_MARK = 33;
    LESS_THAN_SIGN = 60;
    GREATER_THAN_SIGN = 62;
    COMMERCIAL_AT = 64;
    LEFT_SQUARE_BRACKET = 91;
    RIGHT_SQUARE_BRACKET = 93;
    CIRCUMFLEX_ACCENT = 61;
    LEFT_CURLY_BRACKET = 123;
    QUESTION_MARK = 63;
    RIGHT_CURLY_BRACKET = 125;
    VERTICAL_LINE = 124;
    TILDE = 126;
    CONTROL = 128;
    REPLACEMENT_CHARACTER = 65533;
    ASTERISK = 42;
    PLUS_SIGN = 43;
    COMMA = 44;
    COLON = 58;
    SEMICOLON = 59;
    FULL_STOP = 46;
    NULL2 = 0;
    BACKSPACE = 8;
    LINE_TABULATION = 11;
    SHIFT_OUT = 14;
    INFORMATION_SEPARATOR_ONE = 31;
    DELETE = 127;
    EOF = -1;
    ZERO = 48;
    a = 97;
    e = 101;
    f = 102;
    u = 117;
    z = 122;
    A = 65;
    E = 69;
    F = 70;
    U = 85;
    Z = 90;
    isDigit = function(codePoint) {
      return codePoint >= ZERO && codePoint <= 57;
    };
    isSurrogateCodePoint = function(codePoint) {
      return codePoint >= 55296 && codePoint <= 57343;
    };
    isHex = function(codePoint) {
      return isDigit(codePoint) || codePoint >= A && codePoint <= F || codePoint >= a && codePoint <= f;
    };
    isLowerCaseLetter = function(codePoint) {
      return codePoint >= a && codePoint <= z;
    };
    isUpperCaseLetter = function(codePoint) {
      return codePoint >= A && codePoint <= Z;
    };
    isLetter = function(codePoint) {
      return isLowerCaseLetter(codePoint) || isUpperCaseLetter(codePoint);
    };
    isNonASCIICodePoint = function(codePoint) {
      return codePoint >= CONTROL;
    };
    isWhiteSpace = function(codePoint) {
      return codePoint === LINE_FEED || codePoint === CHARACTER_TABULATION || codePoint === SPACE;
    };
    isNameStartCodePoint = function(codePoint) {
      return isLetter(codePoint) || isNonASCIICodePoint(codePoint) || codePoint === LOW_LINE;
    };
    isNameCodePoint = function(codePoint) {
      return isNameStartCodePoint(codePoint) || isDigit(codePoint) || codePoint === HYPHEN_MINUS;
    };
    isNonPrintableCodePoint = function(codePoint) {
      return codePoint >= NULL2 && codePoint <= BACKSPACE || codePoint === LINE_TABULATION || codePoint >= SHIFT_OUT && codePoint <= INFORMATION_SEPARATOR_ONE || codePoint === DELETE;
    };
    isValidEscape = function(c1, c2) {
      if (c1 !== REVERSE_SOLIDUS) {
        return false;
      }
      return c2 !== LINE_FEED;
    };
    isIdentifierStart = function(c1, c2, c3) {
      if (c1 === HYPHEN_MINUS) {
        return isNameStartCodePoint(c2) || isValidEscape(c2, c3);
      } else if (isNameStartCodePoint(c1)) {
        return true;
      } else if (c1 === REVERSE_SOLIDUS && isValidEscape(c1, c2)) {
        return true;
      }
      return false;
    };
    isNumberStart = function(c1, c2, c3) {
      if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
        if (isDigit(c2)) {
          return true;
        }
        return c2 === FULL_STOP && isDigit(c3);
      }
      if (c1 === FULL_STOP) {
        return isDigit(c2);
      }
      return isDigit(c1);
    };
    stringToNumber = function(codePoints) {
      var c = 0;
      var sign = 1;
      if (codePoints[c] === PLUS_SIGN || codePoints[c] === HYPHEN_MINUS) {
        if (codePoints[c] === HYPHEN_MINUS) {
          sign = -1;
        }
        c++;
      }
      var integers = [];
      while (isDigit(codePoints[c])) {
        integers.push(codePoints[c++]);
      }
      var int = integers.length ? parseInt(fromCodePoint$1.apply(void 0, integers), 10) : 0;
      if (codePoints[c] === FULL_STOP) {
        c++;
      }
      var fraction = [];
      while (isDigit(codePoints[c])) {
        fraction.push(codePoints[c++]);
      }
      var fracd = fraction.length;
      var frac = fracd ? parseInt(fromCodePoint$1.apply(void 0, fraction), 10) : 0;
      if (codePoints[c] === E || codePoints[c] === e) {
        c++;
      }
      var expsign = 1;
      if (codePoints[c] === PLUS_SIGN || codePoints[c] === HYPHEN_MINUS) {
        if (codePoints[c] === HYPHEN_MINUS) {
          expsign = -1;
        }
        c++;
      }
      var exponent = [];
      while (isDigit(codePoints[c])) {
        exponent.push(codePoints[c++]);
      }
      var exp = exponent.length ? parseInt(fromCodePoint$1.apply(void 0, exponent), 10) : 0;
      return sign * (int + frac * Math.pow(10, -fracd)) * Math.pow(10, expsign * exp);
    };
    LEFT_PARENTHESIS_TOKEN = {
      type: 2
      /* LEFT_PARENTHESIS_TOKEN */
    };
    RIGHT_PARENTHESIS_TOKEN = {
      type: 3
      /* RIGHT_PARENTHESIS_TOKEN */
    };
    COMMA_TOKEN = {
      type: 4
      /* COMMA_TOKEN */
    };
    SUFFIX_MATCH_TOKEN = {
      type: 13
      /* SUFFIX_MATCH_TOKEN */
    };
    PREFIX_MATCH_TOKEN = {
      type: 8
      /* PREFIX_MATCH_TOKEN */
    };
    COLUMN_TOKEN = {
      type: 21
      /* COLUMN_TOKEN */
    };
    DASH_MATCH_TOKEN = {
      type: 9
      /* DASH_MATCH_TOKEN */
    };
    INCLUDE_MATCH_TOKEN = {
      type: 10
      /* INCLUDE_MATCH_TOKEN */
    };
    LEFT_CURLY_BRACKET_TOKEN = {
      type: 11
      /* LEFT_CURLY_BRACKET_TOKEN */
    };
    RIGHT_CURLY_BRACKET_TOKEN = {
      type: 12
      /* RIGHT_CURLY_BRACKET_TOKEN */
    };
    SUBSTRING_MATCH_TOKEN = {
      type: 14
      /* SUBSTRING_MATCH_TOKEN */
    };
    BAD_URL_TOKEN = {
      type: 23
      /* BAD_URL_TOKEN */
    };
    BAD_STRING_TOKEN = {
      type: 1
      /* BAD_STRING_TOKEN */
    };
    CDO_TOKEN = {
      type: 25
      /* CDO_TOKEN */
    };
    CDC_TOKEN = {
      type: 24
      /* CDC_TOKEN */
    };
    COLON_TOKEN = {
      type: 26
      /* COLON_TOKEN */
    };
    SEMICOLON_TOKEN = {
      type: 27
      /* SEMICOLON_TOKEN */
    };
    LEFT_SQUARE_BRACKET_TOKEN = {
      type: 28
      /* LEFT_SQUARE_BRACKET_TOKEN */
    };
    RIGHT_SQUARE_BRACKET_TOKEN = {
      type: 29
      /* RIGHT_SQUARE_BRACKET_TOKEN */
    };
    WHITESPACE_TOKEN = {
      type: 31
      /* WHITESPACE_TOKEN */
    };
    EOF_TOKEN = {
      type: 32
      /* EOF_TOKEN */
    };
    Tokenizer = /** @class */
    (function() {
      function Tokenizer2() {
        this._value = [];
      }
      Tokenizer2.prototype.write = function(chunk) {
        this._value = this._value.concat(toCodePoints$1(chunk));
      };
      Tokenizer2.prototype.read = function() {
        var tokens = [];
        var token = this.consumeToken();
        while (token !== EOF_TOKEN) {
          tokens.push(token);
          token = this.consumeToken();
        }
        return tokens;
      };
      Tokenizer2.prototype.consumeToken = function() {
        var codePoint = this.consumeCodePoint();
        switch (codePoint) {
          case QUOTATION_MARK:
            return this.consumeStringToken(QUOTATION_MARK);
          case NUMBER_SIGN:
            var c1 = this.peekCodePoint(0);
            var c2 = this.peekCodePoint(1);
            var c3 = this.peekCodePoint(2);
            if (isNameCodePoint(c1) || isValidEscape(c2, c3)) {
              var flags = isIdentifierStart(c1, c2, c3) ? FLAG_ID : FLAG_UNRESTRICTED;
              var value = this.consumeName();
              return { type: 5, value, flags };
            }
            break;
          case DOLLAR_SIGN:
            if (this.peekCodePoint(0) === EQUALS_SIGN) {
              this.consumeCodePoint();
              return SUFFIX_MATCH_TOKEN;
            }
            break;
          case APOSTROPHE:
            return this.consumeStringToken(APOSTROPHE);
          case LEFT_PARENTHESIS:
            return LEFT_PARENTHESIS_TOKEN;
          case RIGHT_PARENTHESIS:
            return RIGHT_PARENTHESIS_TOKEN;
          case ASTERISK:
            if (this.peekCodePoint(0) === EQUALS_SIGN) {
              this.consumeCodePoint();
              return SUBSTRING_MATCH_TOKEN;
            }
            break;
          case PLUS_SIGN:
            if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
              this.reconsumeCodePoint(codePoint);
              return this.consumeNumericToken();
            }
            break;
          case COMMA:
            return COMMA_TOKEN;
          case HYPHEN_MINUS:
            var e1 = codePoint;
            var e2 = this.peekCodePoint(0);
            var e3 = this.peekCodePoint(1);
            if (isNumberStart(e1, e2, e3)) {
              this.reconsumeCodePoint(codePoint);
              return this.consumeNumericToken();
            }
            if (isIdentifierStart(e1, e2, e3)) {
              this.reconsumeCodePoint(codePoint);
              return this.consumeIdentLikeToken();
            }
            if (e2 === HYPHEN_MINUS && e3 === GREATER_THAN_SIGN) {
              this.consumeCodePoint();
              this.consumeCodePoint();
              return CDC_TOKEN;
            }
            break;
          case FULL_STOP:
            if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
              this.reconsumeCodePoint(codePoint);
              return this.consumeNumericToken();
            }
            break;
          case SOLIDUS:
            if (this.peekCodePoint(0) === ASTERISK) {
              this.consumeCodePoint();
              while (true) {
                var c = this.consumeCodePoint();
                if (c === ASTERISK) {
                  c = this.consumeCodePoint();
                  if (c === SOLIDUS) {
                    return this.consumeToken();
                  }
                }
                if (c === EOF) {
                  return this.consumeToken();
                }
              }
            }
            break;
          case COLON:
            return COLON_TOKEN;
          case SEMICOLON:
            return SEMICOLON_TOKEN;
          case LESS_THAN_SIGN:
            if (this.peekCodePoint(0) === EXCLAMATION_MARK && this.peekCodePoint(1) === HYPHEN_MINUS && this.peekCodePoint(2) === HYPHEN_MINUS) {
              this.consumeCodePoint();
              this.consumeCodePoint();
              return CDO_TOKEN;
            }
            break;
          case COMMERCIAL_AT:
            var a1 = this.peekCodePoint(0);
            var a2 = this.peekCodePoint(1);
            var a3 = this.peekCodePoint(2);
            if (isIdentifierStart(a1, a2, a3)) {
              var value = this.consumeName();
              return { type: 7, value };
            }
            break;
          case LEFT_SQUARE_BRACKET:
            return LEFT_SQUARE_BRACKET_TOKEN;
          case REVERSE_SOLIDUS:
            if (isValidEscape(codePoint, this.peekCodePoint(0))) {
              this.reconsumeCodePoint(codePoint);
              return this.consumeIdentLikeToken();
            }
            break;
          case RIGHT_SQUARE_BRACKET:
            return RIGHT_SQUARE_BRACKET_TOKEN;
          case CIRCUMFLEX_ACCENT:
            if (this.peekCodePoint(0) === EQUALS_SIGN) {
              this.consumeCodePoint();
              return PREFIX_MATCH_TOKEN;
            }
            break;
          case LEFT_CURLY_BRACKET:
            return LEFT_CURLY_BRACKET_TOKEN;
          case RIGHT_CURLY_BRACKET:
            return RIGHT_CURLY_BRACKET_TOKEN;
          case u:
          case U:
            var u1 = this.peekCodePoint(0);
            var u2 = this.peekCodePoint(1);
            if (u1 === PLUS_SIGN && (isHex(u2) || u2 === QUESTION_MARK)) {
              this.consumeCodePoint();
              this.consumeUnicodeRangeToken();
            }
            this.reconsumeCodePoint(codePoint);
            return this.consumeIdentLikeToken();
          case VERTICAL_LINE:
            if (this.peekCodePoint(0) === EQUALS_SIGN) {
              this.consumeCodePoint();
              return DASH_MATCH_TOKEN;
            }
            if (this.peekCodePoint(0) === VERTICAL_LINE) {
              this.consumeCodePoint();
              return COLUMN_TOKEN;
            }
            break;
          case TILDE:
            if (this.peekCodePoint(0) === EQUALS_SIGN) {
              this.consumeCodePoint();
              return INCLUDE_MATCH_TOKEN;
            }
            break;
          case EOF:
            return EOF_TOKEN;
        }
        if (isWhiteSpace(codePoint)) {
          this.consumeWhiteSpace();
          return WHITESPACE_TOKEN;
        }
        if (isDigit(codePoint)) {
          this.reconsumeCodePoint(codePoint);
          return this.consumeNumericToken();
        }
        if (isNameStartCodePoint(codePoint)) {
          this.reconsumeCodePoint(codePoint);
          return this.consumeIdentLikeToken();
        }
        return { type: 6, value: fromCodePoint$1(codePoint) };
      };
      Tokenizer2.prototype.consumeCodePoint = function() {
        var value = this._value.shift();
        return typeof value === "undefined" ? -1 : value;
      };
      Tokenizer2.prototype.reconsumeCodePoint = function(codePoint) {
        this._value.unshift(codePoint);
      };
      Tokenizer2.prototype.peekCodePoint = function(delta) {
        if (delta >= this._value.length) {
          return -1;
        }
        return this._value[delta];
      };
      Tokenizer2.prototype.consumeUnicodeRangeToken = function() {
        var digits = [];
        var codePoint = this.consumeCodePoint();
        while (isHex(codePoint) && digits.length < 6) {
          digits.push(codePoint);
          codePoint = this.consumeCodePoint();
        }
        var questionMarks = false;
        while (codePoint === QUESTION_MARK && digits.length < 6) {
          digits.push(codePoint);
          codePoint = this.consumeCodePoint();
          questionMarks = true;
        }
        if (questionMarks) {
          var start_1 = parseInt(fromCodePoint$1.apply(void 0, digits.map(function(digit) {
            return digit === QUESTION_MARK ? ZERO : digit;
          })), 16);
          var end = parseInt(fromCodePoint$1.apply(void 0, digits.map(function(digit) {
            return digit === QUESTION_MARK ? F : digit;
          })), 16);
          return { type: 30, start: start_1, end };
        }
        var start = parseInt(fromCodePoint$1.apply(void 0, digits), 16);
        if (this.peekCodePoint(0) === HYPHEN_MINUS && isHex(this.peekCodePoint(1))) {
          this.consumeCodePoint();
          codePoint = this.consumeCodePoint();
          var endDigits = [];
          while (isHex(codePoint) && endDigits.length < 6) {
            endDigits.push(codePoint);
            codePoint = this.consumeCodePoint();
          }
          var end = parseInt(fromCodePoint$1.apply(void 0, endDigits), 16);
          return { type: 30, start, end };
        } else {
          return { type: 30, start, end: start };
        }
      };
      Tokenizer2.prototype.consumeIdentLikeToken = function() {
        var value = this.consumeName();
        if (value.toLowerCase() === "url" && this.peekCodePoint(0) === LEFT_PARENTHESIS) {
          this.consumeCodePoint();
          return this.consumeUrlToken();
        } else if (this.peekCodePoint(0) === LEFT_PARENTHESIS) {
          this.consumeCodePoint();
          return { type: 19, value };
        }
        return { type: 20, value };
      };
      Tokenizer2.prototype.consumeUrlToken = function() {
        var value = [];
        this.consumeWhiteSpace();
        if (this.peekCodePoint(0) === EOF) {
          return { type: 22, value: "" };
        }
        var next = this.peekCodePoint(0);
        if (next === APOSTROPHE || next === QUOTATION_MARK) {
          var stringToken = this.consumeStringToken(this.consumeCodePoint());
          if (stringToken.type === 0) {
            this.consumeWhiteSpace();
            if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
              this.consumeCodePoint();
              return { type: 22, value: stringToken.value };
            }
          }
          this.consumeBadUrlRemnants();
          return BAD_URL_TOKEN;
        }
        while (true) {
          var codePoint = this.consumeCodePoint();
          if (codePoint === EOF || codePoint === RIGHT_PARENTHESIS) {
            return { type: 22, value: fromCodePoint$1.apply(void 0, value) };
          } else if (isWhiteSpace(codePoint)) {
            this.consumeWhiteSpace();
            if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
              this.consumeCodePoint();
              return { type: 22, value: fromCodePoint$1.apply(void 0, value) };
            }
            this.consumeBadUrlRemnants();
            return BAD_URL_TOKEN;
          } else if (codePoint === QUOTATION_MARK || codePoint === APOSTROPHE || codePoint === LEFT_PARENTHESIS || isNonPrintableCodePoint(codePoint)) {
            this.consumeBadUrlRemnants();
            return BAD_URL_TOKEN;
          } else if (codePoint === REVERSE_SOLIDUS) {
            if (isValidEscape(codePoint, this.peekCodePoint(0))) {
              value.push(this.consumeEscapedCodePoint());
            } else {
              this.consumeBadUrlRemnants();
              return BAD_URL_TOKEN;
            }
          } else {
            value.push(codePoint);
          }
        }
      };
      Tokenizer2.prototype.consumeWhiteSpace = function() {
        while (isWhiteSpace(this.peekCodePoint(0))) {
          this.consumeCodePoint();
        }
      };
      Tokenizer2.prototype.consumeBadUrlRemnants = function() {
        while (true) {
          var codePoint = this.consumeCodePoint();
          if (codePoint === RIGHT_PARENTHESIS || codePoint === EOF) {
            return;
          }
          if (isValidEscape(codePoint, this.peekCodePoint(0))) {
            this.consumeEscapedCodePoint();
          }
        }
      };
      Tokenizer2.prototype.consumeStringSlice = function(count) {
        var SLICE_STACK_SIZE = 5e4;
        var value = "";
        while (count > 0) {
          var amount = Math.min(SLICE_STACK_SIZE, count);
          value += fromCodePoint$1.apply(void 0, this._value.splice(0, amount));
          count -= amount;
        }
        this._value.shift();
        return value;
      };
      Tokenizer2.prototype.consumeStringToken = function(endingCodePoint) {
        var value = "";
        var i = 0;
        do {
          var codePoint = this._value[i];
          if (codePoint === EOF || codePoint === void 0 || codePoint === endingCodePoint) {
            value += this.consumeStringSlice(i);
            return { type: 0, value };
          }
          if (codePoint === LINE_FEED) {
            this._value.splice(0, i);
            return BAD_STRING_TOKEN;
          }
          if (codePoint === REVERSE_SOLIDUS) {
            var next = this._value[i + 1];
            if (next !== EOF && next !== void 0) {
              if (next === LINE_FEED) {
                value += this.consumeStringSlice(i);
                i = -1;
                this._value.shift();
              } else if (isValidEscape(codePoint, next)) {
                value += this.consumeStringSlice(i);
                value += fromCodePoint$1(this.consumeEscapedCodePoint());
                i = -1;
              }
            }
          }
          i++;
        } while (true);
      };
      Tokenizer2.prototype.consumeNumber = function() {
        var repr = [];
        var type = FLAG_INTEGER;
        var c1 = this.peekCodePoint(0);
        if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
          repr.push(this.consumeCodePoint());
        }
        while (isDigit(this.peekCodePoint(0))) {
          repr.push(this.consumeCodePoint());
        }
        c1 = this.peekCodePoint(0);
        var c2 = this.peekCodePoint(1);
        if (c1 === FULL_STOP && isDigit(c2)) {
          repr.push(this.consumeCodePoint(), this.consumeCodePoint());
          type = FLAG_NUMBER;
          while (isDigit(this.peekCodePoint(0))) {
            repr.push(this.consumeCodePoint());
          }
        }
        c1 = this.peekCodePoint(0);
        c2 = this.peekCodePoint(1);
        var c3 = this.peekCodePoint(2);
        if ((c1 === E || c1 === e) && ((c2 === PLUS_SIGN || c2 === HYPHEN_MINUS) && isDigit(c3) || isDigit(c2))) {
          repr.push(this.consumeCodePoint(), this.consumeCodePoint());
          type = FLAG_NUMBER;
          while (isDigit(this.peekCodePoint(0))) {
            repr.push(this.consumeCodePoint());
          }
        }
        return [stringToNumber(repr), type];
      };
      Tokenizer2.prototype.consumeNumericToken = function() {
        var _a2 = this.consumeNumber(), number = _a2[0], flags = _a2[1];
        var c1 = this.peekCodePoint(0);
        var c2 = this.peekCodePoint(1);
        var c3 = this.peekCodePoint(2);
        if (isIdentifierStart(c1, c2, c3)) {
          var unit = this.consumeName();
          return { type: 15, number, flags, unit };
        }
        if (c1 === PERCENTAGE_SIGN) {
          this.consumeCodePoint();
          return { type: 16, number, flags };
        }
        return { type: 17, number, flags };
      };
      Tokenizer2.prototype.consumeEscapedCodePoint = function() {
        var codePoint = this.consumeCodePoint();
        if (isHex(codePoint)) {
          var hex = fromCodePoint$1(codePoint);
          while (isHex(this.peekCodePoint(0)) && hex.length < 6) {
            hex += fromCodePoint$1(this.consumeCodePoint());
          }
          if (isWhiteSpace(this.peekCodePoint(0))) {
            this.consumeCodePoint();
          }
          var hexCodePoint = parseInt(hex, 16);
          if (hexCodePoint === 0 || isSurrogateCodePoint(hexCodePoint) || hexCodePoint > 1114111) {
            return REPLACEMENT_CHARACTER;
          }
          return hexCodePoint;
        }
        if (codePoint === EOF) {
          return REPLACEMENT_CHARACTER;
        }
        return codePoint;
      };
      Tokenizer2.prototype.consumeName = function() {
        var result = "";
        while (true) {
          var codePoint = this.consumeCodePoint();
          if (isNameCodePoint(codePoint)) {
            result += fromCodePoint$1(codePoint);
          } else if (isValidEscape(codePoint, this.peekCodePoint(0))) {
            result += fromCodePoint$1(this.consumeEscapedCodePoint());
          } else {
            this.reconsumeCodePoint(codePoint);
            return result;
          }
        }
      };
      return Tokenizer2;
    })();
    Parser = /** @class */
    (function() {
      function Parser2(tokens) {
        this._tokens = tokens;
      }
      Parser2.create = function(value) {
        var tokenizer = new Tokenizer();
        tokenizer.write(value);
        return new Parser2(tokenizer.read());
      };
      Parser2.parseValue = function(value) {
        return Parser2.create(value).parseComponentValue();
      };
      Parser2.parseValues = function(value) {
        return Parser2.create(value).parseComponentValues();
      };
      Parser2.prototype.parseComponentValue = function() {
        var token = this.consumeToken();
        while (token.type === 31) {
          token = this.consumeToken();
        }
        if (token.type === 32) {
          throw new SyntaxError("Error parsing CSS component value, unexpected EOF");
        }
        this.reconsumeToken(token);
        var value = this.consumeComponentValue();
        do {
          token = this.consumeToken();
        } while (token.type === 31);
        if (token.type === 32) {
          return value;
        }
        throw new SyntaxError("Error parsing CSS component value, multiple values found when expecting only one");
      };
      Parser2.prototype.parseComponentValues = function() {
        var values = [];
        while (true) {
          var value = this.consumeComponentValue();
          if (value.type === 32) {
            return values;
          }
          values.push(value);
          values.push();
        }
      };
      Parser2.prototype.consumeComponentValue = function() {
        var token = this.consumeToken();
        switch (token.type) {
          case 11:
          case 28:
          case 2:
            return this.consumeSimpleBlock(token.type);
          case 19:
            return this.consumeFunction(token);
        }
        return token;
      };
      Parser2.prototype.consumeSimpleBlock = function(type) {
        var block = { type, values: [] };
        var token = this.consumeToken();
        while (true) {
          if (token.type === 32 || isEndingTokenFor(token, type)) {
            return block;
          }
          this.reconsumeToken(token);
          block.values.push(this.consumeComponentValue());
          token = this.consumeToken();
        }
      };
      Parser2.prototype.consumeFunction = function(functionToken) {
        var cssFunction = {
          name: functionToken.value,
          values: [],
          type: 18
          /* FUNCTION */
        };
        while (true) {
          var token = this.consumeToken();
          if (token.type === 32 || token.type === 3) {
            return cssFunction;
          }
          this.reconsumeToken(token);
          cssFunction.values.push(this.consumeComponentValue());
        }
      };
      Parser2.prototype.consumeToken = function() {
        var token = this._tokens.shift();
        return typeof token === "undefined" ? EOF_TOKEN : token;
      };
      Parser2.prototype.reconsumeToken = function(token) {
        this._tokens.unshift(token);
      };
      return Parser2;
    })();
    isDimensionToken = function(token) {
      return token.type === 15;
    };
    isNumberToken = function(token) {
      return token.type === 17;
    };
    isIdentToken = function(token) {
      return token.type === 20;
    };
    isStringToken = function(token) {
      return token.type === 0;
    };
    isIdentWithValue = function(token, value) {
      return isIdentToken(token) && token.value === value;
    };
    nonWhiteSpace = function(token) {
      return token.type !== 31;
    };
    nonFunctionArgSeparator = function(token) {
      return token.type !== 31 && token.type !== 4;
    };
    parseFunctionArgs = function(tokens) {
      var args = [];
      var arg = [];
      tokens.forEach(function(token) {
        if (token.type === 4) {
          if (arg.length === 0) {
            throw new Error("Error parsing function args, zero tokens for arg");
          }
          args.push(arg);
          arg = [];
          return;
        }
        if (token.type !== 31) {
          arg.push(token);
        }
      });
      if (arg.length) {
        args.push(arg);
      }
      return args;
    };
    isEndingTokenFor = function(token, type) {
      if (type === 11 && token.type === 12) {
        return true;
      }
      if (type === 28 && token.type === 29) {
        return true;
      }
      return type === 2 && token.type === 3;
    };
    isLength = function(token) {
      return token.type === 17 || token.type === 15;
    };
    isLengthPercentage = function(token) {
      return token.type === 16 || isLength(token);
    };
    parseLengthPercentageTuple = function(tokens) {
      return tokens.length > 1 ? [tokens[0], tokens[1]] : [tokens[0]];
    };
    ZERO_LENGTH = {
      type: 17,
      number: 0,
      flags: FLAG_INTEGER
    };
    FIFTY_PERCENT = {
      type: 16,
      number: 50,
      flags: FLAG_INTEGER
    };
    HUNDRED_PERCENT = {
      type: 16,
      number: 100,
      flags: FLAG_INTEGER
    };
    getAbsoluteValueForTuple = function(tuple, width, height) {
      var x = tuple[0], y = tuple[1];
      return [getAbsoluteValue(x, width), getAbsoluteValue(typeof y !== "undefined" ? y : x, height)];
    };
    getAbsoluteValue = function(token, parent) {
      if (token.type === 16) {
        return token.number / 100 * parent;
      }
      if (isDimensionToken(token)) {
        switch (token.unit) {
          case "rem":
          case "em":
            return 16 * token.number;
          // TODO use correct font-size
          case "px":
          default:
            return token.number;
        }
      }
      return token.number;
    };
    DEG = "deg";
    GRAD = "grad";
    RAD = "rad";
    TURN = "turn";
    angle = {
      name: "angle",
      parse: function(_context, value) {
        if (value.type === 15) {
          switch (value.unit) {
            case DEG:
              return Math.PI * value.number / 180;
            case GRAD:
              return Math.PI / 200 * value.number;
            case RAD:
              return value.number;
            case TURN:
              return Math.PI * 2 * value.number;
          }
        }
        throw new Error("Unsupported angle type");
      }
    };
    isAngle = function(value) {
      if (value.type === 15) {
        if (value.unit === DEG || value.unit === GRAD || value.unit === RAD || value.unit === TURN) {
          return true;
        }
      }
      return false;
    };
    parseNamedSide = function(tokens) {
      var sideOrCorner = tokens.filter(isIdentToken).map(function(ident) {
        return ident.value;
      }).join(" ");
      switch (sideOrCorner) {
        case "to bottom right":
        case "to right bottom":
        case "left top":
        case "top left":
          return [ZERO_LENGTH, ZERO_LENGTH];
        case "to top":
        case "bottom":
          return deg(0);
        case "to bottom left":
        case "to left bottom":
        case "right top":
        case "top right":
          return [ZERO_LENGTH, HUNDRED_PERCENT];
        case "to right":
        case "left":
          return deg(90);
        case "to top left":
        case "to left top":
        case "right bottom":
        case "bottom right":
          return [HUNDRED_PERCENT, HUNDRED_PERCENT];
        case "to bottom":
        case "top":
          return deg(180);
        case "to top right":
        case "to right top":
        case "left bottom":
        case "bottom left":
          return [HUNDRED_PERCENT, ZERO_LENGTH];
        case "to left":
        case "right":
          return deg(270);
      }
      return 0;
    };
    deg = function(deg2) {
      return Math.PI * deg2 / 180;
    };
    color$1 = {
      name: "color",
      parse: function(context, value) {
        if (value.type === 18) {
          var colorFunction = SUPPORTED_COLOR_FUNCTIONS[value.name];
          if (typeof colorFunction === "undefined") {
            throw new Error('Attempting to parse an unsupported color function "' + value.name + '"');
          }
          return colorFunction(context, value.values);
        }
        if (value.type === 5) {
          if (value.value.length === 3) {
            var r = value.value.substring(0, 1);
            var g = value.value.substring(1, 2);
            var b = value.value.substring(2, 3);
            return pack(parseInt(r + r, 16), parseInt(g + g, 16), parseInt(b + b, 16), 1);
          }
          if (value.value.length === 4) {
            var r = value.value.substring(0, 1);
            var g = value.value.substring(1, 2);
            var b = value.value.substring(2, 3);
            var a2 = value.value.substring(3, 4);
            return pack(parseInt(r + r, 16), parseInt(g + g, 16), parseInt(b + b, 16), parseInt(a2 + a2, 16) / 255);
          }
          if (value.value.length === 6) {
            var r = value.value.substring(0, 2);
            var g = value.value.substring(2, 4);
            var b = value.value.substring(4, 6);
            return pack(parseInt(r, 16), parseInt(g, 16), parseInt(b, 16), 1);
          }
          if (value.value.length === 8) {
            var r = value.value.substring(0, 2);
            var g = value.value.substring(2, 4);
            var b = value.value.substring(4, 6);
            var a2 = value.value.substring(6, 8);
            return pack(parseInt(r, 16), parseInt(g, 16), parseInt(b, 16), parseInt(a2, 16) / 255);
          }
        }
        if (value.type === 20) {
          var namedColor = COLORS[value.value.toUpperCase()];
          if (typeof namedColor !== "undefined") {
            return namedColor;
          }
        }
        return COLORS.TRANSPARENT;
      }
    };
    isTransparent = function(color2) {
      return (255 & color2) === 0;
    };
    asString = function(color2) {
      var alpha = 255 & color2;
      var blue = 255 & color2 >> 8;
      var green = 255 & color2 >> 16;
      var red = 255 & color2 >> 24;
      return alpha < 255 ? "rgba(" + red + "," + green + "," + blue + "," + alpha / 255 + ")" : "rgb(" + red + "," + green + "," + blue + ")";
    };
    pack = function(r, g, b, a2) {
      return (r << 24 | g << 16 | b << 8 | Math.round(a2 * 255) << 0) >>> 0;
    };
    getTokenColorValue = function(token, i) {
      if (token.type === 17) {
        return token.number;
      }
      if (token.type === 16) {
        var max = i === 3 ? 1 : 255;
        return i === 3 ? token.number / 100 * max : Math.round(token.number / 100 * max);
      }
      return 0;
    };
    rgb = function(_context, args) {
      var tokens = args.filter(nonFunctionArgSeparator);
      if (tokens.length === 3) {
        var _a2 = tokens.map(getTokenColorValue), r = _a2[0], g = _a2[1], b = _a2[2];
        return pack(r, g, b, 1);
      }
      if (tokens.length === 4) {
        var _b = tokens.map(getTokenColorValue), r = _b[0], g = _b[1], b = _b[2], a2 = _b[3];
        return pack(r, g, b, a2);
      }
      return 0;
    };
    hsl = function(context, args) {
      var tokens = args.filter(nonFunctionArgSeparator);
      var hue = tokens[0], saturation = tokens[1], lightness = tokens[2], alpha = tokens[3];
      var h = (hue.type === 17 ? deg(hue.number) : angle.parse(context, hue)) / (Math.PI * 2);
      var s = isLengthPercentage(saturation) ? saturation.number / 100 : 0;
      var l = isLengthPercentage(lightness) ? lightness.number / 100 : 0;
      var a2 = typeof alpha !== "undefined" && isLengthPercentage(alpha) ? getAbsoluteValue(alpha, 1) : 1;
      if (s === 0) {
        return pack(l * 255, l * 255, l * 255, 1);
      }
      var t2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
      var t1 = l * 2 - t2;
      var r = hue2rgb(t1, t2, h + 1 / 3);
      var g = hue2rgb(t1, t2, h);
      var b = hue2rgb(t1, t2, h - 1 / 3);
      return pack(r * 255, g * 255, b * 255, a2);
    };
    SUPPORTED_COLOR_FUNCTIONS = {
      hsl,
      hsla: hsl,
      rgb,
      rgba: rgb
    };
    parseColor = function(context, value) {
      return color$1.parse(context, Parser.create(value).parseComponentValue());
    };
    COLORS = {
      ALICEBLUE: 4042850303,
      ANTIQUEWHITE: 4209760255,
      AQUA: 16777215,
      AQUAMARINE: 2147472639,
      AZURE: 4043309055,
      BEIGE: 4126530815,
      BISQUE: 4293182719,
      BLACK: 255,
      BLANCHEDALMOND: 4293643775,
      BLUE: 65535,
      BLUEVIOLET: 2318131967,
      BROWN: 2771004159,
      BURLYWOOD: 3736635391,
      CADETBLUE: 1604231423,
      CHARTREUSE: 2147418367,
      CHOCOLATE: 3530104575,
      CORAL: 4286533887,
      CORNFLOWERBLUE: 1687547391,
      CORNSILK: 4294499583,
      CRIMSON: 3692313855,
      CYAN: 16777215,
      DARKBLUE: 35839,
      DARKCYAN: 9145343,
      DARKGOLDENROD: 3095837695,
      DARKGRAY: 2846468607,
      DARKGREEN: 6553855,
      DARKGREY: 2846468607,
      DARKKHAKI: 3182914559,
      DARKMAGENTA: 2332068863,
      DARKOLIVEGREEN: 1433087999,
      DARKORANGE: 4287365375,
      DARKORCHID: 2570243327,
      DARKRED: 2332033279,
      DARKSALMON: 3918953215,
      DARKSEAGREEN: 2411499519,
      DARKSLATEBLUE: 1211993087,
      DARKSLATEGRAY: 793726975,
      DARKSLATEGREY: 793726975,
      DARKTURQUOISE: 13554175,
      DARKVIOLET: 2483082239,
      DEEPPINK: 4279538687,
      DEEPSKYBLUE: 12582911,
      DIMGRAY: 1768516095,
      DIMGREY: 1768516095,
      DODGERBLUE: 512819199,
      FIREBRICK: 2988581631,
      FLORALWHITE: 4294635775,
      FORESTGREEN: 579543807,
      FUCHSIA: 4278255615,
      GAINSBORO: 3705462015,
      GHOSTWHITE: 4177068031,
      GOLD: 4292280575,
      GOLDENROD: 3668254975,
      GRAY: 2155905279,
      GREEN: 8388863,
      GREENYELLOW: 2919182335,
      GREY: 2155905279,
      HONEYDEW: 4043305215,
      HOTPINK: 4285117695,
      INDIANRED: 3445382399,
      INDIGO: 1258324735,
      IVORY: 4294963455,
      KHAKI: 4041641215,
      LAVENDER: 3873897215,
      LAVENDERBLUSH: 4293981695,
      LAWNGREEN: 2096890111,
      LEMONCHIFFON: 4294626815,
      LIGHTBLUE: 2916673279,
      LIGHTCORAL: 4034953471,
      LIGHTCYAN: 3774873599,
      LIGHTGOLDENRODYELLOW: 4210742015,
      LIGHTGRAY: 3553874943,
      LIGHTGREEN: 2431553791,
      LIGHTGREY: 3553874943,
      LIGHTPINK: 4290167295,
      LIGHTSALMON: 4288707327,
      LIGHTSEAGREEN: 548580095,
      LIGHTSKYBLUE: 2278488831,
      LIGHTSLATEGRAY: 2005441023,
      LIGHTSLATEGREY: 2005441023,
      LIGHTSTEELBLUE: 2965692159,
      LIGHTYELLOW: 4294959359,
      LIME: 16711935,
      LIMEGREEN: 852308735,
      LINEN: 4210091775,
      MAGENTA: 4278255615,
      MAROON: 2147483903,
      MEDIUMAQUAMARINE: 1724754687,
      MEDIUMBLUE: 52735,
      MEDIUMORCHID: 3126187007,
      MEDIUMPURPLE: 2473647103,
      MEDIUMSEAGREEN: 1018393087,
      MEDIUMSLATEBLUE: 2070474495,
      MEDIUMSPRINGGREEN: 16423679,
      MEDIUMTURQUOISE: 1221709055,
      MEDIUMVIOLETRED: 3340076543,
      MIDNIGHTBLUE: 421097727,
      MINTCREAM: 4127193855,
      MISTYROSE: 4293190143,
      MOCCASIN: 4293178879,
      NAVAJOWHITE: 4292783615,
      NAVY: 33023,
      OLDLACE: 4260751103,
      OLIVE: 2155872511,
      OLIVEDRAB: 1804477439,
      ORANGE: 4289003775,
      ORANGERED: 4282712319,
      ORCHID: 3664828159,
      PALEGOLDENROD: 4008225535,
      PALEGREEN: 2566625535,
      PALETURQUOISE: 2951671551,
      PALEVIOLETRED: 3681588223,
      PAPAYAWHIP: 4293907967,
      PEACHPUFF: 4292524543,
      PERU: 3448061951,
      PINK: 4290825215,
      PLUM: 3718307327,
      POWDERBLUE: 2967529215,
      PURPLE: 2147516671,
      REBECCAPURPLE: 1714657791,
      RED: 4278190335,
      ROSYBROWN: 3163525119,
      ROYALBLUE: 1097458175,
      SADDLEBROWN: 2336560127,
      SALMON: 4202722047,
      SANDYBROWN: 4104413439,
      SEAGREEN: 780883967,
      SEASHELL: 4294307583,
      SIENNA: 2689740287,
      SILVER: 3233857791,
      SKYBLUE: 2278484991,
      SLATEBLUE: 1784335871,
      SLATEGRAY: 1887473919,
      SLATEGREY: 1887473919,
      SNOW: 4294638335,
      SPRINGGREEN: 16744447,
      STEELBLUE: 1182971135,
      TAN: 3535047935,
      TEAL: 8421631,
      THISTLE: 3636451583,
      TOMATO: 4284696575,
      TRANSPARENT: 0,
      TURQUOISE: 1088475391,
      VIOLET: 4001558271,
      WHEAT: 4125012991,
      WHITE: 4294967295,
      WHITESMOKE: 4126537215,
      YELLOW: 4294902015,
      YELLOWGREEN: 2597139199
    };
    backgroundClip = {
      name: "background-clip",
      initialValue: "border-box",
      prefix: false,
      type: 1,
      parse: function(_context, tokens) {
        return tokens.map(function(token) {
          if (isIdentToken(token)) {
            switch (token.value) {
              case "padding-box":
                return 1;
              case "content-box":
                return 2;
            }
          }
          return 0;
        });
      }
    };
    backgroundColor = {
      name: "background-color",
      initialValue: "transparent",
      prefix: false,
      type: 3,
      format: "color"
    };
    parseColorStop = function(context, args) {
      var color2 = color$1.parse(context, args[0]);
      var stop = args[1];
      return stop && isLengthPercentage(stop) ? { color: color2, stop } : { color: color2, stop: null };
    };
    processColorStops = function(stops, lineLength) {
      var first = stops[0];
      var last = stops[stops.length - 1];
      if (first.stop === null) {
        first.stop = ZERO_LENGTH;
      }
      if (last.stop === null) {
        last.stop = HUNDRED_PERCENT;
      }
      var processStops = [];
      var previous = 0;
      for (var i = 0; i < stops.length; i++) {
        var stop_1 = stops[i].stop;
        if (stop_1 !== null) {
          var absoluteValue = getAbsoluteValue(stop_1, lineLength);
          if (absoluteValue > previous) {
            processStops.push(absoluteValue);
          } else {
            processStops.push(previous);
          }
          previous = absoluteValue;
        } else {
          processStops.push(null);
        }
      }
      var gapBegin = null;
      for (var i = 0; i < processStops.length; i++) {
        var stop_2 = processStops[i];
        if (stop_2 === null) {
          if (gapBegin === null) {
            gapBegin = i;
          }
        } else if (gapBegin !== null) {
          var gapLength = i - gapBegin;
          var beforeGap = processStops[gapBegin - 1];
          var gapValue = (stop_2 - beforeGap) / (gapLength + 1);
          for (var g = 1; g <= gapLength; g++) {
            processStops[gapBegin + g - 1] = gapValue * g;
          }
          gapBegin = null;
        }
      }
      return stops.map(function(_a2, i2) {
        var color2 = _a2.color;
        return { color: color2, stop: Math.max(Math.min(1, processStops[i2] / lineLength), 0) };
      });
    };
    getAngleFromCorner = function(corner, width, height) {
      var centerX = width / 2;
      var centerY = height / 2;
      var x = getAbsoluteValue(corner[0], width) - centerX;
      var y = centerY - getAbsoluteValue(corner[1], height);
      return (Math.atan2(y, x) + Math.PI * 2) % (Math.PI * 2);
    };
    calculateGradientDirection = function(angle2, width, height) {
      var radian = typeof angle2 === "number" ? angle2 : getAngleFromCorner(angle2, width, height);
      var lineLength = Math.abs(width * Math.sin(radian)) + Math.abs(height * Math.cos(radian));
      var halfWidth = width / 2;
      var halfHeight = height / 2;
      var halfLineLength = lineLength / 2;
      var yDiff = Math.sin(radian - Math.PI / 2) * halfLineLength;
      var xDiff = Math.cos(radian - Math.PI / 2) * halfLineLength;
      return [lineLength, halfWidth - xDiff, halfWidth + xDiff, halfHeight - yDiff, halfHeight + yDiff];
    };
    distance = function(a2, b) {
      return Math.sqrt(a2 * a2 + b * b);
    };
    findCorner = function(width, height, x, y, closest) {
      var corners = [
        [0, 0],
        [0, height],
        [width, 0],
        [width, height]
      ];
      return corners.reduce(function(stat, corner) {
        var cx = corner[0], cy = corner[1];
        var d = distance(x - cx, y - cy);
        if (closest ? d < stat.optimumDistance : d > stat.optimumDistance) {
          return {
            optimumCorner: corner,
            optimumDistance: d
          };
        }
        return stat;
      }, {
        optimumDistance: closest ? Infinity : -Infinity,
        optimumCorner: null
      }).optimumCorner;
    };
    calculateRadius = function(gradient, x, y, width, height) {
      var rx = 0;
      var ry = 0;
      switch (gradient.size) {
        case 0:
          if (gradient.shape === 0) {
            rx = ry = Math.min(Math.abs(x), Math.abs(x - width), Math.abs(y), Math.abs(y - height));
          } else if (gradient.shape === 1) {
            rx = Math.min(Math.abs(x), Math.abs(x - width));
            ry = Math.min(Math.abs(y), Math.abs(y - height));
          }
          break;
        case 2:
          if (gradient.shape === 0) {
            rx = ry = Math.min(distance(x, y), distance(x, y - height), distance(x - width, y), distance(x - width, y - height));
          } else if (gradient.shape === 1) {
            var c = Math.min(Math.abs(y), Math.abs(y - height)) / Math.min(Math.abs(x), Math.abs(x - width));
            var _a2 = findCorner(width, height, x, y, true), cx = _a2[0], cy = _a2[1];
            rx = distance(cx - x, (cy - y) / c);
            ry = c * rx;
          }
          break;
        case 1:
          if (gradient.shape === 0) {
            rx = ry = Math.max(Math.abs(x), Math.abs(x - width), Math.abs(y), Math.abs(y - height));
          } else if (gradient.shape === 1) {
            rx = Math.max(Math.abs(x), Math.abs(x - width));
            ry = Math.max(Math.abs(y), Math.abs(y - height));
          }
          break;
        case 3:
          if (gradient.shape === 0) {
            rx = ry = Math.max(distance(x, y), distance(x, y - height), distance(x - width, y), distance(x - width, y - height));
          } else if (gradient.shape === 1) {
            var c = Math.max(Math.abs(y), Math.abs(y - height)) / Math.max(Math.abs(x), Math.abs(x - width));
            var _b = findCorner(width, height, x, y, false), cx = _b[0], cy = _b[1];
            rx = distance(cx - x, (cy - y) / c);
            ry = c * rx;
          }
          break;
      }
      if (Array.isArray(gradient.size)) {
        rx = getAbsoluteValue(gradient.size[0], width);
        ry = gradient.size.length === 2 ? getAbsoluteValue(gradient.size[1], height) : rx;
      }
      return [rx, ry];
    };
    linearGradient = function(context, tokens) {
      var angle$1 = deg(180);
      var stops = [];
      parseFunctionArgs(tokens).forEach(function(arg, i) {
        if (i === 0) {
          var firstToken = arg[0];
          if (firstToken.type === 20 && firstToken.value === "to") {
            angle$1 = parseNamedSide(arg);
            return;
          } else if (isAngle(firstToken)) {
            angle$1 = angle.parse(context, firstToken);
            return;
          }
        }
        var colorStop = parseColorStop(context, arg);
        stops.push(colorStop);
      });
      return {
        angle: angle$1,
        stops,
        type: 1
        /* LINEAR_GRADIENT */
      };
    };
    prefixLinearGradient = function(context, tokens) {
      var angle$1 = deg(180);
      var stops = [];
      parseFunctionArgs(tokens).forEach(function(arg, i) {
        if (i === 0) {
          var firstToken = arg[0];
          if (firstToken.type === 20 && ["top", "left", "right", "bottom"].indexOf(firstToken.value) !== -1) {
            angle$1 = parseNamedSide(arg);
            return;
          } else if (isAngle(firstToken)) {
            angle$1 = (angle.parse(context, firstToken) + deg(270)) % deg(360);
            return;
          }
        }
        var colorStop = parseColorStop(context, arg);
        stops.push(colorStop);
      });
      return {
        angle: angle$1,
        stops,
        type: 1
        /* LINEAR_GRADIENT */
      };
    };
    webkitGradient = function(context, tokens) {
      var angle2 = deg(180);
      var stops = [];
      var type = 1;
      var shape = 0;
      var size = 3;
      var position2 = [];
      parseFunctionArgs(tokens).forEach(function(arg, i) {
        var firstToken = arg[0];
        if (i === 0) {
          if (isIdentToken(firstToken) && firstToken.value === "linear") {
            type = 1;
            return;
          } else if (isIdentToken(firstToken) && firstToken.value === "radial") {
            type = 2;
            return;
          }
        }
        if (firstToken.type === 18) {
          if (firstToken.name === "from") {
            var color2 = color$1.parse(context, firstToken.values[0]);
            stops.push({ stop: ZERO_LENGTH, color: color2 });
          } else if (firstToken.name === "to") {
            var color2 = color$1.parse(context, firstToken.values[0]);
            stops.push({ stop: HUNDRED_PERCENT, color: color2 });
          } else if (firstToken.name === "color-stop") {
            var values = firstToken.values.filter(nonFunctionArgSeparator);
            if (values.length === 2) {
              var color2 = color$1.parse(context, values[1]);
              var stop_1 = values[0];
              if (isNumberToken(stop_1)) {
                stops.push({
                  stop: { type: 16, number: stop_1.number * 100, flags: stop_1.flags },
                  color: color2
                });
              }
            }
          }
        }
      });
      return type === 1 ? {
        angle: (angle2 + deg(180)) % deg(360),
        stops,
        type
      } : { size, shape, stops, position: position2, type };
    };
    CLOSEST_SIDE = "closest-side";
    FARTHEST_SIDE = "farthest-side";
    CLOSEST_CORNER = "closest-corner";
    FARTHEST_CORNER = "farthest-corner";
    CIRCLE = "circle";
    ELLIPSE = "ellipse";
    COVER = "cover";
    CONTAIN = "contain";
    radialGradient = function(context, tokens) {
      var shape = 0;
      var size = 3;
      var stops = [];
      var position2 = [];
      parseFunctionArgs(tokens).forEach(function(arg, i) {
        var isColorStop = true;
        if (i === 0) {
          var isAtPosition_1 = false;
          isColorStop = arg.reduce(function(acc, token) {
            if (isAtPosition_1) {
              if (isIdentToken(token)) {
                switch (token.value) {
                  case "center":
                    position2.push(FIFTY_PERCENT);
                    return acc;
                  case "top":
                  case "left":
                    position2.push(ZERO_LENGTH);
                    return acc;
                  case "right":
                  case "bottom":
                    position2.push(HUNDRED_PERCENT);
                    return acc;
                }
              } else if (isLengthPercentage(token) || isLength(token)) {
                position2.push(token);
              }
            } else if (isIdentToken(token)) {
              switch (token.value) {
                case CIRCLE:
                  shape = 0;
                  return false;
                case ELLIPSE:
                  shape = 1;
                  return false;
                case "at":
                  isAtPosition_1 = true;
                  return false;
                case CLOSEST_SIDE:
                  size = 0;
                  return false;
                case COVER:
                case FARTHEST_SIDE:
                  size = 1;
                  return false;
                case CONTAIN:
                case CLOSEST_CORNER:
                  size = 2;
                  return false;
                case FARTHEST_CORNER:
                  size = 3;
                  return false;
              }
            } else if (isLength(token) || isLengthPercentage(token)) {
              if (!Array.isArray(size)) {
                size = [];
              }
              size.push(token);
              return false;
            }
            return acc;
          }, isColorStop);
        }
        if (isColorStop) {
          var colorStop = parseColorStop(context, arg);
          stops.push(colorStop);
        }
      });
      return {
        size,
        shape,
        stops,
        position: position2,
        type: 2
        /* RADIAL_GRADIENT */
      };
    };
    prefixRadialGradient = function(context, tokens) {
      var shape = 0;
      var size = 3;
      var stops = [];
      var position2 = [];
      parseFunctionArgs(tokens).forEach(function(arg, i) {
        var isColorStop = true;
        if (i === 0) {
          isColorStop = arg.reduce(function(acc, token) {
            if (isIdentToken(token)) {
              switch (token.value) {
                case "center":
                  position2.push(FIFTY_PERCENT);
                  return false;
                case "top":
                case "left":
                  position2.push(ZERO_LENGTH);
                  return false;
                case "right":
                case "bottom":
                  position2.push(HUNDRED_PERCENT);
                  return false;
              }
            } else if (isLengthPercentage(token) || isLength(token)) {
              position2.push(token);
              return false;
            }
            return acc;
          }, isColorStop);
        } else if (i === 1) {
          isColorStop = arg.reduce(function(acc, token) {
            if (isIdentToken(token)) {
              switch (token.value) {
                case CIRCLE:
                  shape = 0;
                  return false;
                case ELLIPSE:
                  shape = 1;
                  return false;
                case CONTAIN:
                case CLOSEST_SIDE:
                  size = 0;
                  return false;
                case FARTHEST_SIDE:
                  size = 1;
                  return false;
                case CLOSEST_CORNER:
                  size = 2;
                  return false;
                case COVER:
                case FARTHEST_CORNER:
                  size = 3;
                  return false;
              }
            } else if (isLength(token) || isLengthPercentage(token)) {
              if (!Array.isArray(size)) {
                size = [];
              }
              size.push(token);
              return false;
            }
            return acc;
          }, isColorStop);
        }
        if (isColorStop) {
          var colorStop = parseColorStop(context, arg);
          stops.push(colorStop);
        }
      });
      return {
        size,
        shape,
        stops,
        position: position2,
        type: 2
        /* RADIAL_GRADIENT */
      };
    };
    isLinearGradient = function(background) {
      return background.type === 1;
    };
    isRadialGradient = function(background) {
      return background.type === 2;
    };
    image = {
      name: "image",
      parse: function(context, value) {
        if (value.type === 22) {
          var image_1 = {
            url: value.value,
            type: 0
            /* URL */
          };
          context.cache.addImage(value.value);
          return image_1;
        }
        if (value.type === 18) {
          var imageFunction = SUPPORTED_IMAGE_FUNCTIONS[value.name];
          if (typeof imageFunction === "undefined") {
            throw new Error('Attempting to parse an unsupported image function "' + value.name + '"');
          }
          return imageFunction(context, value.values);
        }
        throw new Error("Unsupported image type " + value.type);
      }
    };
    SUPPORTED_IMAGE_FUNCTIONS = {
      "linear-gradient": linearGradient,
      "-moz-linear-gradient": prefixLinearGradient,
      "-ms-linear-gradient": prefixLinearGradient,
      "-o-linear-gradient": prefixLinearGradient,
      "-webkit-linear-gradient": prefixLinearGradient,
      "radial-gradient": radialGradient,
      "-moz-radial-gradient": prefixRadialGradient,
      "-ms-radial-gradient": prefixRadialGradient,
      "-o-radial-gradient": prefixRadialGradient,
      "-webkit-radial-gradient": prefixRadialGradient,
      "-webkit-gradient": webkitGradient
    };
    backgroundImage = {
      name: "background-image",
      initialValue: "none",
      type: 1,
      prefix: false,
      parse: function(context, tokens) {
        if (tokens.length === 0) {
          return [];
        }
        var first = tokens[0];
        if (first.type === 20 && first.value === "none") {
          return [];
        }
        return tokens.filter(function(value) {
          return nonFunctionArgSeparator(value) && isSupportedImage(value);
        }).map(function(value) {
          return image.parse(context, value);
        });
      }
    };
    backgroundOrigin = {
      name: "background-origin",
      initialValue: "border-box",
      prefix: false,
      type: 1,
      parse: function(_context, tokens) {
        return tokens.map(function(token) {
          if (isIdentToken(token)) {
            switch (token.value) {
              case "padding-box":
                return 1;
              case "content-box":
                return 2;
            }
          }
          return 0;
        });
      }
    };
    backgroundPosition = {
      name: "background-position",
      initialValue: "0% 0%",
      type: 1,
      prefix: false,
      parse: function(_context, tokens) {
        return parseFunctionArgs(tokens).map(function(values) {
          return values.filter(isLengthPercentage);
        }).map(parseLengthPercentageTuple);
      }
    };
    backgroundRepeat = {
      name: "background-repeat",
      initialValue: "repeat",
      prefix: false,
      type: 1,
      parse: function(_context, tokens) {
        return parseFunctionArgs(tokens).map(function(values) {
          return values.filter(isIdentToken).map(function(token) {
            return token.value;
          }).join(" ");
        }).map(parseBackgroundRepeat);
      }
    };
    parseBackgroundRepeat = function(value) {
      switch (value) {
        case "no-repeat":
          return 1;
        case "repeat-x":
        case "repeat no-repeat":
          return 2;
        case "repeat-y":
        case "no-repeat repeat":
          return 3;
        case "repeat":
        default:
          return 0;
      }
    };
    (function(BACKGROUND_SIZE2) {
      BACKGROUND_SIZE2["AUTO"] = "auto";
      BACKGROUND_SIZE2["CONTAIN"] = "contain";
      BACKGROUND_SIZE2["COVER"] = "cover";
    })(BACKGROUND_SIZE || (BACKGROUND_SIZE = {}));
    backgroundSize = {
      name: "background-size",
      initialValue: "0",
      prefix: false,
      type: 1,
      parse: function(_context, tokens) {
        return parseFunctionArgs(tokens).map(function(values) {
          return values.filter(isBackgroundSizeInfoToken);
        });
      }
    };
    isBackgroundSizeInfoToken = function(value) {
      return isIdentToken(value) || isLengthPercentage(value);
    };
    borderColorForSide = function(side) {
      return {
        name: "border-" + side + "-color",
        initialValue: "transparent",
        prefix: false,
        type: 3,
        format: "color"
      };
    };
    borderTopColor = borderColorForSide("top");
    borderRightColor = borderColorForSide("right");
    borderBottomColor = borderColorForSide("bottom");
    borderLeftColor = borderColorForSide("left");
    borderRadiusForSide = function(side) {
      return {
        name: "border-radius-" + side,
        initialValue: "0 0",
        prefix: false,
        type: 1,
        parse: function(_context, tokens) {
          return parseLengthPercentageTuple(tokens.filter(isLengthPercentage));
        }
      };
    };
    borderTopLeftRadius = borderRadiusForSide("top-left");
    borderTopRightRadius = borderRadiusForSide("top-right");
    borderBottomRightRadius = borderRadiusForSide("bottom-right");
    borderBottomLeftRadius = borderRadiusForSide("bottom-left");
    borderStyleForSide = function(side) {
      return {
        name: "border-" + side + "-style",
        initialValue: "solid",
        prefix: false,
        type: 2,
        parse: function(_context, style) {
          switch (style) {
            case "none":
              return 0;
            case "dashed":
              return 2;
            case "dotted":
              return 3;
            case "double":
              return 4;
          }
          return 1;
        }
      };
    };
    borderTopStyle = borderStyleForSide("top");
    borderRightStyle = borderStyleForSide("right");
    borderBottomStyle = borderStyleForSide("bottom");
    borderLeftStyle = borderStyleForSide("left");
    borderWidthForSide = function(side) {
      return {
        name: "border-" + side + "-width",
        initialValue: "0",
        type: 0,
        prefix: false,
        parse: function(_context, token) {
          if (isDimensionToken(token)) {
            return token.number;
          }
          return 0;
        }
      };
    };
    borderTopWidth = borderWidthForSide("top");
    borderRightWidth = borderWidthForSide("right");
    borderBottomWidth = borderWidthForSide("bottom");
    borderLeftWidth = borderWidthForSide("left");
    color = {
      name: "color",
      initialValue: "transparent",
      prefix: false,
      type: 3,
      format: "color"
    };
    direction = {
      name: "direction",
      initialValue: "ltr",
      prefix: false,
      type: 2,
      parse: function(_context, direction2) {
        switch (direction2) {
          case "rtl":
            return 1;
          case "ltr":
          default:
            return 0;
        }
      }
    };
    display = {
      name: "display",
      initialValue: "inline-block",
      prefix: false,
      type: 1,
      parse: function(_context, tokens) {
        return tokens.filter(isIdentToken).reduce(
          function(bit, token) {
            return bit | parseDisplayValue(token.value);
          },
          0
          /* NONE */
        );
      }
    };
    parseDisplayValue = function(display2) {
      switch (display2) {
        case "block":
        case "-webkit-box":
          return 2;
        case "inline":
          return 4;
        case "run-in":
          return 8;
        case "flow":
          return 16;
        case "flow-root":
          return 32;
        case "table":
          return 64;
        case "flex":
        case "-webkit-flex":
          return 128;
        case "grid":
        case "-ms-grid":
          return 256;
        case "ruby":
          return 512;
        case "subgrid":
          return 1024;
        case "list-item":
          return 2048;
        case "table-row-group":
          return 4096;
        case "table-header-group":
          return 8192;
        case "table-footer-group":
          return 16384;
        case "table-row":
          return 32768;
        case "table-cell":
          return 65536;
        case "table-column-group":
          return 131072;
        case "table-column":
          return 262144;
        case "table-caption":
          return 524288;
        case "ruby-base":
          return 1048576;
        case "ruby-text":
          return 2097152;
        case "ruby-base-container":
          return 4194304;
        case "ruby-text-container":
          return 8388608;
        case "contents":
          return 16777216;
        case "inline-block":
          return 33554432;
        case "inline-list-item":
          return 67108864;
        case "inline-table":
          return 134217728;
        case "inline-flex":
          return 268435456;
        case "inline-grid":
          return 536870912;
      }
      return 0;
    };
    float = {
      name: "float",
      initialValue: "none",
      prefix: false,
      type: 2,
      parse: function(_context, float2) {
        switch (float2) {
          case "left":
            return 1;
          case "right":
            return 2;
          case "inline-start":
            return 3;
          case "inline-end":
            return 4;
        }
        return 0;
      }
    };
    letterSpacing = {
      name: "letter-spacing",
      initialValue: "0",
      prefix: false,
      type: 0,
      parse: function(_context, token) {
        if (token.type === 20 && token.value === "normal") {
          return 0;
        }
        if (token.type === 17) {
          return token.number;
        }
        if (token.type === 15) {
          return token.number;
        }
        return 0;
      }
    };
    (function(LINE_BREAK2) {
      LINE_BREAK2["NORMAL"] = "normal";
      LINE_BREAK2["STRICT"] = "strict";
    })(LINE_BREAK || (LINE_BREAK = {}));
    lineBreak = {
      name: "line-break",
      initialValue: "normal",
      prefix: false,
      type: 2,
      parse: function(_context, lineBreak2) {
        switch (lineBreak2) {
          case "strict":
            return LINE_BREAK.STRICT;
          case "normal":
          default:
            return LINE_BREAK.NORMAL;
        }
      }
    };
    lineHeight = {
      name: "line-height",
      initialValue: "normal",
      prefix: false,
      type: 4
      /* TOKEN_VALUE */
    };
    computeLineHeight = function(token, fontSize2) {
      if (isIdentToken(token) && token.value === "normal") {
        return 1.2 * fontSize2;
      } else if (token.type === 17) {
        return fontSize2 * token.number;
      } else if (isLengthPercentage(token)) {
        return getAbsoluteValue(token, fontSize2);
      }
      return fontSize2;
    };
    listStyleImage = {
      name: "list-style-image",
      initialValue: "none",
      type: 0,
      prefix: false,
      parse: function(context, token) {
        if (token.type === 20 && token.value === "none") {
          return null;
        }
        return image.parse(context, token);
      }
    };
    listStylePosition = {
      name: "list-style-position",
      initialValue: "outside",
      prefix: false,
      type: 2,
      parse: function(_context, position2) {
        switch (position2) {
          case "inside":
            return 0;
          case "outside":
          default:
            return 1;
        }
      }
    };
    listStyleType = {
      name: "list-style-type",
      initialValue: "none",
      prefix: false,
      type: 2,
      parse: function(_context, type) {
        switch (type) {
          case "disc":
            return 0;
          case "circle":
            return 1;
          case "square":
            return 2;
          case "decimal":
            return 3;
          case "cjk-decimal":
            return 4;
          case "decimal-leading-zero":
            return 5;
          case "lower-roman":
            return 6;
          case "upper-roman":
            return 7;
          case "lower-greek":
            return 8;
          case "lower-alpha":
            return 9;
          case "upper-alpha":
            return 10;
          case "arabic-indic":
            return 11;
          case "armenian":
            return 12;
          case "bengali":
            return 13;
          case "cambodian":
            return 14;
          case "cjk-earthly-branch":
            return 15;
          case "cjk-heavenly-stem":
            return 16;
          case "cjk-ideographic":
            return 17;
          case "devanagari":
            return 18;
          case "ethiopic-numeric":
            return 19;
          case "georgian":
            return 20;
          case "gujarati":
            return 21;
          case "gurmukhi":
            return 22;
          case "hebrew":
            return 22;
          case "hiragana":
            return 23;
          case "hiragana-iroha":
            return 24;
          case "japanese-formal":
            return 25;
          case "japanese-informal":
            return 26;
          case "kannada":
            return 27;
          case "katakana":
            return 28;
          case "katakana-iroha":
            return 29;
          case "khmer":
            return 30;
          case "korean-hangul-formal":
            return 31;
          case "korean-hanja-formal":
            return 32;
          case "korean-hanja-informal":
            return 33;
          case "lao":
            return 34;
          case "lower-armenian":
            return 35;
          case "malayalam":
            return 36;
          case "mongolian":
            return 37;
          case "myanmar":
            return 38;
          case "oriya":
            return 39;
          case "persian":
            return 40;
          case "simp-chinese-formal":
            return 41;
          case "simp-chinese-informal":
            return 42;
          case "tamil":
            return 43;
          case "telugu":
            return 44;
          case "thai":
            return 45;
          case "tibetan":
            return 46;
          case "trad-chinese-formal":
            return 47;
          case "trad-chinese-informal":
            return 48;
          case "upper-armenian":
            return 49;
          case "disclosure-open":
            return 50;
          case "disclosure-closed":
            return 51;
          case "none":
          default:
            return -1;
        }
      }
    };
    marginForSide = function(side) {
      return {
        name: "margin-" + side,
        initialValue: "0",
        prefix: false,
        type: 4
        /* TOKEN_VALUE */
      };
    };
    marginTop = marginForSide("top");
    marginRight = marginForSide("right");
    marginBottom = marginForSide("bottom");
    marginLeft = marginForSide("left");
    overflow = {
      name: "overflow",
      initialValue: "visible",
      prefix: false,
      type: 1,
      parse: function(_context, tokens) {
        return tokens.filter(isIdentToken).map(function(overflow2) {
          switch (overflow2.value) {
            case "hidden":
              return 1;
            case "scroll":
              return 2;
            case "clip":
              return 3;
            case "auto":
              return 4;
            case "visible":
            default:
              return 0;
          }
        });
      }
    };
    overflowWrap = {
      name: "overflow-wrap",
      initialValue: "normal",
      prefix: false,
      type: 2,
      parse: function(_context, overflow2) {
        switch (overflow2) {
          case "break-word":
            return "break-word";
          case "normal":
          default:
            return "normal";
        }
      }
    };
    paddingForSide = function(side) {
      return {
        name: "padding-" + side,
        initialValue: "0",
        prefix: false,
        type: 3,
        format: "length-percentage"
      };
    };
    paddingTop = paddingForSide("top");
    paddingRight = paddingForSide("right");
    paddingBottom = paddingForSide("bottom");
    paddingLeft = paddingForSide("left");
    textAlign = {
      name: "text-align",
      initialValue: "left",
      prefix: false,
      type: 2,
      parse: function(_context, textAlign2) {
        switch (textAlign2) {
          case "right":
            return 2;
          case "center":
          case "justify":
            return 1;
          case "left":
          default:
            return 0;
        }
      }
    };
    position = {
      name: "position",
      initialValue: "static",
      prefix: false,
      type: 2,
      parse: function(_context, position2) {
        switch (position2) {
          case "relative":
            return 1;
          case "absolute":
            return 2;
          case "fixed":
            return 3;
          case "sticky":
            return 4;
        }
        return 0;
      }
    };
    textShadow = {
      name: "text-shadow",
      initialValue: "none",
      type: 1,
      prefix: false,
      parse: function(context, tokens) {
        if (tokens.length === 1 && isIdentWithValue(tokens[0], "none")) {
          return [];
        }
        return parseFunctionArgs(tokens).map(function(values) {
          var shadow = {
            color: COLORS.TRANSPARENT,
            offsetX: ZERO_LENGTH,
            offsetY: ZERO_LENGTH,
            blur: ZERO_LENGTH
          };
          var c = 0;
          for (var i = 0; i < values.length; i++) {
            var token = values[i];
            if (isLength(token)) {
              if (c === 0) {
                shadow.offsetX = token;
              } else if (c === 1) {
                shadow.offsetY = token;
              } else {
                shadow.blur = token;
              }
              c++;
            } else {
              shadow.color = color$1.parse(context, token);
            }
          }
          return shadow;
        });
      }
    };
    textTransform = {
      name: "text-transform",
      initialValue: "none",
      prefix: false,
      type: 2,
      parse: function(_context, textTransform2) {
        switch (textTransform2) {
          case "uppercase":
            return 2;
          case "lowercase":
            return 1;
          case "capitalize":
            return 3;
        }
        return 0;
      }
    };
    transform$1 = {
      name: "transform",
      initialValue: "none",
      prefix: true,
      type: 0,
      parse: function(_context, token) {
        if (token.type === 20 && token.value === "none") {
          return null;
        }
        if (token.type === 18) {
          var transformFunction = SUPPORTED_TRANSFORM_FUNCTIONS[token.name];
          if (typeof transformFunction === "undefined") {
            throw new Error('Attempting to parse an unsupported transform function "' + token.name + '"');
          }
          return transformFunction(token.values);
        }
        return null;
      }
    };
    matrix = function(args) {
      var values = args.filter(function(arg) {
        return arg.type === 17;
      }).map(function(arg) {
        return arg.number;
      });
      return values.length === 6 ? values : null;
    };
    matrix3d = function(args) {
      var values = args.filter(function(arg) {
        return arg.type === 17;
      }).map(function(arg) {
        return arg.number;
      });
      var a1 = values[0], b1 = values[1];
      values[2];
      values[3];
      var a2 = values[4], b2 = values[5];
      values[6];
      values[7];
      values[8];
      values[9];
      values[10];
      values[11];
      var a4 = values[12], b4 = values[13];
      values[14];
      values[15];
      return values.length === 16 ? [a1, b1, a2, b2, a4, b4] : null;
    };
    SUPPORTED_TRANSFORM_FUNCTIONS = {
      matrix,
      matrix3d
    };
    DEFAULT_VALUE = {
      type: 16,
      number: 50,
      flags: FLAG_INTEGER
    };
    DEFAULT = [DEFAULT_VALUE, DEFAULT_VALUE];
    transformOrigin = {
      name: "transform-origin",
      initialValue: "50% 50%",
      prefix: true,
      type: 1,
      parse: function(_context, tokens) {
        var origins = tokens.filter(isLengthPercentage);
        if (origins.length !== 2) {
          return DEFAULT;
        }
        return [origins[0], origins[1]];
      }
    };
    visibility = {
      name: "visible",
      initialValue: "none",
      prefix: false,
      type: 2,
      parse: function(_context, visibility2) {
        switch (visibility2) {
          case "hidden":
            return 1;
          case "collapse":
            return 2;
          case "visible":
          default:
            return 0;
        }
      }
    };
    (function(WORD_BREAK2) {
      WORD_BREAK2["NORMAL"] = "normal";
      WORD_BREAK2["BREAK_ALL"] = "break-all";
      WORD_BREAK2["KEEP_ALL"] = "keep-all";
    })(WORD_BREAK || (WORD_BREAK = {}));
    wordBreak = {
      name: "word-break",
      initialValue: "normal",
      prefix: false,
      type: 2,
      parse: function(_context, wordBreak2) {
        switch (wordBreak2) {
          case "break-all":
            return WORD_BREAK.BREAK_ALL;
          case "keep-all":
            return WORD_BREAK.KEEP_ALL;
          case "normal":
          default:
            return WORD_BREAK.NORMAL;
        }
      }
    };
    zIndex = {
      name: "z-index",
      initialValue: "auto",
      prefix: false,
      type: 0,
      parse: function(_context, token) {
        if (token.type === 20) {
          return { auto: true, order: 0 };
        }
        if (isNumberToken(token)) {
          return { auto: false, order: token.number };
        }
        throw new Error("Invalid z-index number parsed");
      }
    };
    time = {
      name: "time",
      parse: function(_context, value) {
        if (value.type === 15) {
          switch (value.unit.toLowerCase()) {
            case "s":
              return 1e3 * value.number;
            case "ms":
              return value.number;
          }
        }
        throw new Error("Unsupported time type");
      }
    };
    opacity = {
      name: "opacity",
      initialValue: "1",
      type: 0,
      prefix: false,
      parse: function(_context, token) {
        if (isNumberToken(token)) {
          return token.number;
        }
        return 1;
      }
    };
    textDecorationColor = {
      name: "text-decoration-color",
      initialValue: "transparent",
      prefix: false,
      type: 3,
      format: "color"
    };
    textDecorationLine = {
      name: "text-decoration-line",
      initialValue: "none",
      prefix: false,
      type: 1,
      parse: function(_context, tokens) {
        return tokens.filter(isIdentToken).map(function(token) {
          switch (token.value) {
            case "underline":
              return 1;
            case "overline":
              return 2;
            case "line-through":
              return 3;
            case "none":
              return 4;
          }
          return 0;
        }).filter(function(line) {
          return line !== 0;
        });
      }
    };
    fontFamily = {
      name: "font-family",
      initialValue: "",
      prefix: false,
      type: 1,
      parse: function(_context, tokens) {
        var accumulator = [];
        var results = [];
        tokens.forEach(function(token) {
          switch (token.type) {
            case 20:
            case 0:
              accumulator.push(token.value);
              break;
            case 17:
              accumulator.push(token.number.toString());
              break;
            case 4:
              results.push(accumulator.join(" "));
              accumulator.length = 0;
              break;
          }
        });
        if (accumulator.length) {
          results.push(accumulator.join(" "));
        }
        return results.map(function(result) {
          return result.indexOf(" ") === -1 ? result : "'" + result + "'";
        });
      }
    };
    fontSize = {
      name: "font-size",
      initialValue: "0",
      prefix: false,
      type: 3,
      format: "length"
    };
    fontWeight = {
      name: "font-weight",
      initialValue: "normal",
      type: 0,
      prefix: false,
      parse: function(_context, token) {
        if (isNumberToken(token)) {
          return token.number;
        }
        if (isIdentToken(token)) {
          switch (token.value) {
            case "bold":
              return 700;
            case "normal":
            default:
              return 400;
          }
        }
        return 400;
      }
    };
    fontVariant = {
      name: "font-variant",
      initialValue: "none",
      type: 1,
      prefix: false,
      parse: function(_context, tokens) {
        return tokens.filter(isIdentToken).map(function(token) {
          return token.value;
        });
      }
    };
    fontStyle = {
      name: "font-style",
      initialValue: "normal",
      prefix: false,
      type: 2,
      parse: function(_context, overflow2) {
        switch (overflow2) {
          case "oblique":
            return "oblique";
          case "italic":
            return "italic";
          case "normal":
          default:
            return "normal";
        }
      }
    };
    contains = function(bit, value) {
      return (bit & value) !== 0;
    };
    content = {
      name: "content",
      initialValue: "none",
      type: 1,
      prefix: false,
      parse: function(_context, tokens) {
        if (tokens.length === 0) {
          return [];
        }
        var first = tokens[0];
        if (first.type === 20 && first.value === "none") {
          return [];
        }
        return tokens;
      }
    };
    counterIncrement = {
      name: "counter-increment",
      initialValue: "none",
      prefix: true,
      type: 1,
      parse: function(_context, tokens) {
        if (tokens.length === 0) {
          return null;
        }
        var first = tokens[0];
        if (first.type === 20 && first.value === "none") {
          return null;
        }
        var increments = [];
        var filtered = tokens.filter(nonWhiteSpace);
        for (var i = 0; i < filtered.length; i++) {
          var counter = filtered[i];
          var next = filtered[i + 1];
          if (counter.type === 20) {
            var increment = next && isNumberToken(next) ? next.number : 1;
            increments.push({ counter: counter.value, increment });
          }
        }
        return increments;
      }
    };
    counterReset = {
      name: "counter-reset",
      initialValue: "none",
      prefix: true,
      type: 1,
      parse: function(_context, tokens) {
        if (tokens.length === 0) {
          return [];
        }
        var resets = [];
        var filtered = tokens.filter(nonWhiteSpace);
        for (var i = 0; i < filtered.length; i++) {
          var counter = filtered[i];
          var next = filtered[i + 1];
          if (isIdentToken(counter) && counter.value !== "none") {
            var reset = next && isNumberToken(next) ? next.number : 0;
            resets.push({ counter: counter.value, reset });
          }
        }
        return resets;
      }
    };
    duration = {
      name: "duration",
      initialValue: "0s",
      prefix: false,
      type: 1,
      parse: function(context, tokens) {
        return tokens.filter(isDimensionToken).map(function(token) {
          return time.parse(context, token);
        });
      }
    };
    quotes = {
      name: "quotes",
      initialValue: "none",
      prefix: true,
      type: 1,
      parse: function(_context, tokens) {
        if (tokens.length === 0) {
          return null;
        }
        var first = tokens[0];
        if (first.type === 20 && first.value === "none") {
          return null;
        }
        var quotes2 = [];
        var filtered = tokens.filter(isStringToken);
        if (filtered.length % 2 !== 0) {
          return null;
        }
        for (var i = 0; i < filtered.length; i += 2) {
          var open_1 = filtered[i].value;
          var close_1 = filtered[i + 1].value;
          quotes2.push({ open: open_1, close: close_1 });
        }
        return quotes2;
      }
    };
    getQuote = function(quotes2, depth, open) {
      if (!quotes2) {
        return "";
      }
      var quote = quotes2[Math.min(depth, quotes2.length - 1)];
      if (!quote) {
        return "";
      }
      return open ? quote.open : quote.close;
    };
    boxShadow = {
      name: "box-shadow",
      initialValue: "none",
      type: 1,
      prefix: false,
      parse: function(context, tokens) {
        if (tokens.length === 1 && isIdentWithValue(tokens[0], "none")) {
          return [];
        }
        return parseFunctionArgs(tokens).map(function(values) {
          var shadow = {
            color: 255,
            offsetX: ZERO_LENGTH,
            offsetY: ZERO_LENGTH,
            blur: ZERO_LENGTH,
            spread: ZERO_LENGTH,
            inset: false
          };
          var c = 0;
          for (var i = 0; i < values.length; i++) {
            var token = values[i];
            if (isIdentWithValue(token, "inset")) {
              shadow.inset = true;
            } else if (isLength(token)) {
              if (c === 0) {
                shadow.offsetX = token;
              } else if (c === 1) {
                shadow.offsetY = token;
              } else if (c === 2) {
                shadow.blur = token;
              } else {
                shadow.spread = token;
              }
              c++;
            } else {
              shadow.color = color$1.parse(context, token);
            }
          }
          return shadow;
        });
      }
    };
    paintOrder = {
      name: "paint-order",
      initialValue: "normal",
      prefix: false,
      type: 1,
      parse: function(_context, tokens) {
        var DEFAULT_VALUE2 = [
          0,
          1,
          2
          /* MARKERS */
        ];
        var layers = [];
        tokens.filter(isIdentToken).forEach(function(token) {
          switch (token.value) {
            case "stroke":
              layers.push(
                1
                /* STROKE */
              );
              break;
            case "fill":
              layers.push(
                0
                /* FILL */
              );
              break;
            case "markers":
              layers.push(
                2
                /* MARKERS */
              );
              break;
          }
        });
        DEFAULT_VALUE2.forEach(function(value) {
          if (layers.indexOf(value) === -1) {
            layers.push(value);
          }
        });
        return layers;
      }
    };
    webkitTextStrokeColor = {
      name: "-webkit-text-stroke-color",
      initialValue: "currentcolor",
      prefix: false,
      type: 3,
      format: "color"
    };
    webkitTextStrokeWidth = {
      name: "-webkit-text-stroke-width",
      initialValue: "0",
      type: 0,
      prefix: false,
      parse: function(_context, token) {
        if (isDimensionToken(token)) {
          return token.number;
        }
        return 0;
      }
    };
    CSSParsedDeclaration = /** @class */
    (function() {
      function CSSParsedDeclaration2(context, declaration) {
        var _a2, _b;
        this.animationDuration = parse(context, duration, declaration.animationDuration);
        this.backgroundClip = parse(context, backgroundClip, declaration.backgroundClip);
        this.backgroundColor = parse(context, backgroundColor, declaration.backgroundColor);
        this.backgroundImage = parse(context, backgroundImage, declaration.backgroundImage);
        this.backgroundOrigin = parse(context, backgroundOrigin, declaration.backgroundOrigin);
        this.backgroundPosition = parse(context, backgroundPosition, declaration.backgroundPosition);
        this.backgroundRepeat = parse(context, backgroundRepeat, declaration.backgroundRepeat);
        this.backgroundSize = parse(context, backgroundSize, declaration.backgroundSize);
        this.borderTopColor = parse(context, borderTopColor, declaration.borderTopColor);
        this.borderRightColor = parse(context, borderRightColor, declaration.borderRightColor);
        this.borderBottomColor = parse(context, borderBottomColor, declaration.borderBottomColor);
        this.borderLeftColor = parse(context, borderLeftColor, declaration.borderLeftColor);
        this.borderTopLeftRadius = parse(context, borderTopLeftRadius, declaration.borderTopLeftRadius);
        this.borderTopRightRadius = parse(context, borderTopRightRadius, declaration.borderTopRightRadius);
        this.borderBottomRightRadius = parse(context, borderBottomRightRadius, declaration.borderBottomRightRadius);
        this.borderBottomLeftRadius = parse(context, borderBottomLeftRadius, declaration.borderBottomLeftRadius);
        this.borderTopStyle = parse(context, borderTopStyle, declaration.borderTopStyle);
        this.borderRightStyle = parse(context, borderRightStyle, declaration.borderRightStyle);
        this.borderBottomStyle = parse(context, borderBottomStyle, declaration.borderBottomStyle);
        this.borderLeftStyle = parse(context, borderLeftStyle, declaration.borderLeftStyle);
        this.borderTopWidth = parse(context, borderTopWidth, declaration.borderTopWidth);
        this.borderRightWidth = parse(context, borderRightWidth, declaration.borderRightWidth);
        this.borderBottomWidth = parse(context, borderBottomWidth, declaration.borderBottomWidth);
        this.borderLeftWidth = parse(context, borderLeftWidth, declaration.borderLeftWidth);
        this.boxShadow = parse(context, boxShadow, declaration.boxShadow);
        this.color = parse(context, color, declaration.color);
        this.direction = parse(context, direction, declaration.direction);
        this.display = parse(context, display, declaration.display);
        this.float = parse(context, float, declaration.cssFloat);
        this.fontFamily = parse(context, fontFamily, declaration.fontFamily);
        this.fontSize = parse(context, fontSize, declaration.fontSize);
        this.fontStyle = parse(context, fontStyle, declaration.fontStyle);
        this.fontVariant = parse(context, fontVariant, declaration.fontVariant);
        this.fontWeight = parse(context, fontWeight, declaration.fontWeight);
        this.letterSpacing = parse(context, letterSpacing, declaration.letterSpacing);
        this.lineBreak = parse(context, lineBreak, declaration.lineBreak);
        this.lineHeight = parse(context, lineHeight, declaration.lineHeight);
        this.listStyleImage = parse(context, listStyleImage, declaration.listStyleImage);
        this.listStylePosition = parse(context, listStylePosition, declaration.listStylePosition);
        this.listStyleType = parse(context, listStyleType, declaration.listStyleType);
        this.marginTop = parse(context, marginTop, declaration.marginTop);
        this.marginRight = parse(context, marginRight, declaration.marginRight);
        this.marginBottom = parse(context, marginBottom, declaration.marginBottom);
        this.marginLeft = parse(context, marginLeft, declaration.marginLeft);
        this.opacity = parse(context, opacity, declaration.opacity);
        var overflowTuple = parse(context, overflow, declaration.overflow);
        this.overflowX = overflowTuple[0];
        this.overflowY = overflowTuple[overflowTuple.length > 1 ? 1 : 0];
        this.overflowWrap = parse(context, overflowWrap, declaration.overflowWrap);
        this.paddingTop = parse(context, paddingTop, declaration.paddingTop);
        this.paddingRight = parse(context, paddingRight, declaration.paddingRight);
        this.paddingBottom = parse(context, paddingBottom, declaration.paddingBottom);
        this.paddingLeft = parse(context, paddingLeft, declaration.paddingLeft);
        this.paintOrder = parse(context, paintOrder, declaration.paintOrder);
        this.position = parse(context, position, declaration.position);
        this.textAlign = parse(context, textAlign, declaration.textAlign);
        this.textDecorationColor = parse(context, textDecorationColor, (_a2 = declaration.textDecorationColor) !== null && _a2 !== void 0 ? _a2 : declaration.color);
        this.textDecorationLine = parse(context, textDecorationLine, (_b = declaration.textDecorationLine) !== null && _b !== void 0 ? _b : declaration.textDecoration);
        this.textShadow = parse(context, textShadow, declaration.textShadow);
        this.textTransform = parse(context, textTransform, declaration.textTransform);
        this.transform = parse(context, transform$1, declaration.transform);
        this.transformOrigin = parse(context, transformOrigin, declaration.transformOrigin);
        this.visibility = parse(context, visibility, declaration.visibility);
        this.webkitTextStrokeColor = parse(context, webkitTextStrokeColor, declaration.webkitTextStrokeColor);
        this.webkitTextStrokeWidth = parse(context, webkitTextStrokeWidth, declaration.webkitTextStrokeWidth);
        this.wordBreak = parse(context, wordBreak, declaration.wordBreak);
        this.zIndex = parse(context, zIndex, declaration.zIndex);
      }
      CSSParsedDeclaration2.prototype.isVisible = function() {
        return this.display > 0 && this.opacity > 0 && this.visibility === 0;
      };
      CSSParsedDeclaration2.prototype.isTransparent = function() {
        return isTransparent(this.backgroundColor);
      };
      CSSParsedDeclaration2.prototype.isTransformed = function() {
        return this.transform !== null;
      };
      CSSParsedDeclaration2.prototype.isPositioned = function() {
        return this.position !== 0;
      };
      CSSParsedDeclaration2.prototype.isPositionedWithZIndex = function() {
        return this.isPositioned() && !this.zIndex.auto;
      };
      CSSParsedDeclaration2.prototype.isFloating = function() {
        return this.float !== 0;
      };
      CSSParsedDeclaration2.prototype.isInlineLevel = function() {
        return contains(
          this.display,
          4
          /* INLINE */
        ) || contains(
          this.display,
          33554432
          /* INLINE_BLOCK */
        ) || contains(
          this.display,
          268435456
          /* INLINE_FLEX */
        ) || contains(
          this.display,
          536870912
          /* INLINE_GRID */
        ) || contains(
          this.display,
          67108864
          /* INLINE_LIST_ITEM */
        ) || contains(
          this.display,
          134217728
          /* INLINE_TABLE */
        );
      };
      return CSSParsedDeclaration2;
    })();
    CSSParsedPseudoDeclaration = /** @class */
    /* @__PURE__ */ (function() {
      function CSSParsedPseudoDeclaration2(context, declaration) {
        this.content = parse(context, content, declaration.content);
        this.quotes = parse(context, quotes, declaration.quotes);
      }
      return CSSParsedPseudoDeclaration2;
    })();
    CSSParsedCounterDeclaration = /** @class */
    /* @__PURE__ */ (function() {
      function CSSParsedCounterDeclaration2(context, declaration) {
        this.counterIncrement = parse(context, counterIncrement, declaration.counterIncrement);
        this.counterReset = parse(context, counterReset, declaration.counterReset);
      }
      return CSSParsedCounterDeclaration2;
    })();
    parse = function(context, descriptor, style) {
      var tokenizer = new Tokenizer();
      var value = style !== null && typeof style !== "undefined" ? style.toString() : descriptor.initialValue;
      tokenizer.write(value);
      var parser = new Parser(tokenizer.read());
      switch (descriptor.type) {
        case 2:
          var token = parser.parseComponentValue();
          return descriptor.parse(context, isIdentToken(token) ? token.value : descriptor.initialValue);
        case 0:
          return descriptor.parse(context, parser.parseComponentValue());
        case 1:
          return descriptor.parse(context, parser.parseComponentValues());
        case 4:
          return parser.parseComponentValue();
        case 3:
          switch (descriptor.format) {
            case "angle":
              return angle.parse(context, parser.parseComponentValue());
            case "color":
              return color$1.parse(context, parser.parseComponentValue());
            case "image":
              return image.parse(context, parser.parseComponentValue());
            case "length":
              var length_1 = parser.parseComponentValue();
              return isLength(length_1) ? length_1 : ZERO_LENGTH;
            case "length-percentage":
              var value_1 = parser.parseComponentValue();
              return isLengthPercentage(value_1) ? value_1 : ZERO_LENGTH;
            case "time":
              return time.parse(context, parser.parseComponentValue());
          }
          break;
      }
    };
    elementDebuggerAttribute = "data-html2canvas-debug";
    getElementDebugType = function(element) {
      var attribute = element.getAttribute(elementDebuggerAttribute);
      switch (attribute) {
        case "all":
          return 1;
        case "clone":
          return 2;
        case "parse":
          return 3;
        case "render":
          return 4;
        default:
          return 0;
      }
    };
    isDebugging = function(element, type) {
      var elementType = getElementDebugType(element);
      return elementType === 1 || type === elementType;
    };
    ElementContainer = /** @class */
    /* @__PURE__ */ (function() {
      function ElementContainer2(context, element) {
        this.context = context;
        this.textNodes = [];
        this.elements = [];
        this.flags = 0;
        if (isDebugging(
          element,
          3
          /* PARSE */
        )) {
          debugger;
        }
        this.styles = new CSSParsedDeclaration(context, window.getComputedStyle(element, null));
        if (isHTMLElementNode(element)) {
          if (this.styles.animationDuration.some(function(duration2) {
            return duration2 > 0;
          })) {
            element.style.animationDuration = "0s";
          }
          if (this.styles.transform !== null) {
            element.style.transform = "none";
          }
        }
        this.bounds = parseBounds(this.context, element);
        if (isDebugging(
          element,
          4
          /* RENDER */
        )) {
          this.flags |= 16;
        }
      }
      return ElementContainer2;
    })();
    base64 = "AAAAAAAAAAAAEA4AGBkAAFAaAAACAAAAAAAIABAAGAAwADgACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAIABAAQABIAEQATAAIABAACAAQAAgAEAAIABAAVABcAAgAEAAIABAACAAQAGAAaABwAHgAgACIAI4AlgAIABAAmwCjAKgAsAC2AL4AvQDFAMoA0gBPAVYBWgEIAAgACACMANoAYgFkAWwBdAF8AX0BhQGNAZUBlgGeAaMBlQGWAasBswF8AbsBwwF0AcsBYwHTAQgA2wG/AOMBdAF8AekB8QF0AfkB+wHiAHQBfAEIAAMC5gQIAAsCEgIIAAgAFgIeAggAIgIpAggAMQI5AkACygEIAAgASAJQAlgCYAIIAAgACAAKBQoFCgUTBRMFGQUrBSsFCAAIAAgACAAIAAgACAAIAAgACABdAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABoAmgCrwGvAQgAbgJ2AggAHgEIAAgACADnAXsCCAAIAAgAgwIIAAgACAAIAAgACACKAggAkQKZAggAPADJAAgAoQKkAqwCsgK6AsICCADJAggA0AIIAAgACAAIANYC3gIIAAgACAAIAAgACABAAOYCCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAkASoB+QIEAAgACAA8AEMCCABCBQgACABJBVAFCAAIAAgACAAIAAgACAAIAAgACABTBVoFCAAIAFoFCABfBWUFCAAIAAgACAAIAAgAbQUIAAgACAAIAAgACABzBXsFfQWFBYoFigWKBZEFigWKBYoFmAWfBaYFrgWxBbkFCAAIAAgACAAIAAgACAAIAAgACAAIAMEFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAMgFCADQBQgACAAIAAgACAAIAAgACAAIAAgACAAIAO4CCAAIAAgAiQAIAAgACABAAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAD0AggACAD8AggACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIANYFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAMDvwAIAAgAJAIIAAgACAAIAAgACAAIAAgACwMTAwgACAB9BOsEGwMjAwgAKwMyAwsFYgE3A/MEPwMIAEUDTQNRAwgAWQOsAGEDCAAIAAgACAAIAAgACABpAzQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFIQUoBSwFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABtAwgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABMAEwACAAIAAgACAAIABgACAAIAAgACAC/AAgACAAyAQgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACAAIAAwAAgACAAIAAgACAAIAAgACAAIAAAARABIAAgACAAIABQASAAIAAgAIABwAEAAjgCIABsAqAC2AL0AigDQAtwC+IJIQqVAZUBWQqVAZUBlQGVAZUBlQGrC5UBlQGVAZUBlQGVAZUBlQGVAXsKlQGVAbAK6wsrDGUMpQzlDJUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAfAKAAuZA64AtwCJALoC6ADwAAgAuACgA/oEpgO6AqsD+AAIAAgAswMIAAgACAAIAIkAuwP5AfsBwwPLAwgACAAIAAgACADRA9kDCAAIAOED6QMIAAgACAAIAAgACADuA/YDCAAIAP4DyQAIAAgABgQIAAgAXQAOBAgACAAIAAgACAAIABMECAAIAAgACAAIAAgACAD8AAQBCAAIAAgAGgQiBCoECAExBAgAEAEIAAgACAAIAAgACAAIAAgACAAIAAgACAA4BAgACABABEYECAAIAAgATAQYAQgAVAQIAAgACAAIAAgACAAIAAgACAAIAFoECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAOQEIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAB+BAcACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAEABhgSMBAgACAAIAAgAlAQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAwAEAAQABAADAAMAAwADAAQABAAEAAQABAAEAAQABHATAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAdQMIAAgACAAIAAgACAAIAMkACAAIAAgAfQMIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACFA4kDCAAIAAgACAAIAOcBCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAIcDCAAIAAgACAAIAAgACAAIAAgACAAIAJEDCAAIAAgACADFAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABgBAgAZgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAbAQCBXIECAAIAHkECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABAAJwEQACjBKoEsgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAC6BMIECAAIAAgACAAIAAgACABmBAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAxwQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAGYECAAIAAgAzgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBd0FXwUIAOIF6gXxBYoF3gT5BQAGCAaKBYoFigWKBYoFigWKBYoFigWKBYoFigXWBIoFigWKBYoFigWKBYoFigWKBYsFEAaKBYoFigWKBYoFigWKBRQGCACKBYoFigWKBQgACAAIANEECAAIABgGigUgBggAJgYIAC4GMwaKBYoF0wQ3Bj4GigWKBYoFigWKBYoFigWKBYoFigWKBYoFigUIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWLBf///////wQABAAEAAQABAAEAAQABAAEAAQAAwAEAAQAAgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAQADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUAAAAFAAUAAAAFAAUAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAQAAAAUABQAFAAUABQAFAAAAAAAFAAUAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAFAAUAAQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAAABwAHAAcAAAAHAAcABwAFAAEAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAcABwAFAAUAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAQABAAAAAAAAAAAAAAAFAAUABQAFAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAHAAcAAAAHAAcAAAAAAAUABQAHAAUAAQAHAAEABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwABAAUABQAFAAUAAAAAAAAAAAAAAAEAAQABAAEAAQABAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABQANAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAABQAHAAUABQAFAAAAAAAAAAcABQAFAAUABQAFAAQABAAEAAQABAAEAAQABAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUAAAAFAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAUAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAcABwAFAAcABwAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUABwAHAAUABQAFAAUAAAAAAAcABwAAAAAABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAAAAAAAAAAABQAFAAAAAAAFAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAFAAUABQAFAAUAAAAFAAUABwAAAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABwAFAAUABQAFAAAAAAAHAAcAAAAAAAcABwAFAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAAAAAAAAAHAAcABwAAAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAUABQAFAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAHAAcABQAHAAcAAAAFAAcABwAAAAcABwAFAAUAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAFAAcABwAFAAUABQAAAAUAAAAHAAcABwAHAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAHAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUAAAAFAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAUAAAAFAAUAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABwAFAAUABQAFAAUABQAAAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABQAFAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAFAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAHAAUABQAFAAUABQAFAAUABwAHAAcABwAHAAcABwAHAAUABwAHAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABwAHAAcABwAFAAUABwAHAAcAAAAAAAAAAAAHAAcABQAHAAcABwAHAAcABwAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAUABQAFAAUABQAFAAUAAAAFAAAABQAAAAAABQAFAAUABQAFAAUABQAFAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAUABQAFAAUABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABwAFAAcABwAHAAcABwAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAUABQAFAAUABwAHAAUABQAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABQAFAAcABwAHAAUABwAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAcABQAFAAUABQAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAAAAAABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAAAAAAAAAFAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAUABQAHAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAFAAUABQAFAAcABwAFAAUABwAHAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAcABwAFAAUABwAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABQAAAAAABQAFAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAcABwAAAAAAAAAAAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAcABwAFAAcABwAAAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAFAAUABQAAAAUABQAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABwAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAHAAcABQAHAAUABQAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAAABwAHAAAAAAAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAFAAUABwAFAAcABwAFAAcABQAFAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAAAAAABwAHAAcABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAFAAcABwAFAAUABQAFAAUABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAUABQAFAAcABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABQAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAAAAAAFAAUABwAHAAcABwAFAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAHAAUABQAFAAUABQAFAAUABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAABQAAAAUABQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAHAAcAAAAFAAUAAAAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABQAFAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAABQAFAAUABQAFAAUABQAAAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAFAAUABQAFAAUADgAOAA4ADgAOAA4ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAMAAwADAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAAAAAAAAAAAAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAAAAAAAAAAAAsADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwACwAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAADgAOAA4AAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAAAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4AAAAOAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAAAAAAAAAAAA4AAAAOAAAAAAAAAAAADgAOAA4AAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAA=";
    chars$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    lookup$1 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
    for (i$1 = 0; i$1 < chars$1.length; i$1++) {
      lookup$1[chars$1.charCodeAt(i$1)] = i$1;
    }
    decode2 = function(base642) {
      var bufferLength = base642.length * 0.75, len = base642.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
      if (base642[base642.length - 1] === "=") {
        bufferLength--;
        if (base642[base642.length - 2] === "=") {
          bufferLength--;
        }
      }
      var buffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && typeof Uint8Array.prototype.slice !== "undefined" ? new ArrayBuffer(bufferLength) : new Array(bufferLength);
      var bytes = Array.isArray(buffer) ? buffer : new Uint8Array(buffer);
      for (i = 0; i < len; i += 4) {
        encoded1 = lookup$1[base642.charCodeAt(i)];
        encoded2 = lookup$1[base642.charCodeAt(i + 1)];
        encoded3 = lookup$1[base642.charCodeAt(i + 2)];
        encoded4 = lookup$1[base642.charCodeAt(i + 3)];
        bytes[p++] = encoded1 << 2 | encoded2 >> 4;
        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
      }
      return buffer;
    };
    polyUint16Array = function(buffer) {
      var length = buffer.length;
      var bytes = [];
      for (var i = 0; i < length; i += 2) {
        bytes.push(buffer[i + 1] << 8 | buffer[i]);
      }
      return bytes;
    };
    polyUint32Array = function(buffer) {
      var length = buffer.length;
      var bytes = [];
      for (var i = 0; i < length; i += 4) {
        bytes.push(buffer[i + 3] << 24 | buffer[i + 2] << 16 | buffer[i + 1] << 8 | buffer[i]);
      }
      return bytes;
    };
    UTRIE2_SHIFT_2 = 5;
    UTRIE2_SHIFT_1 = 6 + 5;
    UTRIE2_INDEX_SHIFT = 2;
    UTRIE2_SHIFT_1_2 = UTRIE2_SHIFT_1 - UTRIE2_SHIFT_2;
    UTRIE2_LSCP_INDEX_2_OFFSET = 65536 >> UTRIE2_SHIFT_2;
    UTRIE2_DATA_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_2;
    UTRIE2_DATA_MASK = UTRIE2_DATA_BLOCK_LENGTH - 1;
    UTRIE2_LSCP_INDEX_2_LENGTH = 1024 >> UTRIE2_SHIFT_2;
    UTRIE2_INDEX_2_BMP_LENGTH = UTRIE2_LSCP_INDEX_2_OFFSET + UTRIE2_LSCP_INDEX_2_LENGTH;
    UTRIE2_UTF8_2B_INDEX_2_OFFSET = UTRIE2_INDEX_2_BMP_LENGTH;
    UTRIE2_UTF8_2B_INDEX_2_LENGTH = 2048 >> 6;
    UTRIE2_INDEX_1_OFFSET = UTRIE2_UTF8_2B_INDEX_2_OFFSET + UTRIE2_UTF8_2B_INDEX_2_LENGTH;
    UTRIE2_OMITTED_BMP_INDEX_1_LENGTH = 65536 >> UTRIE2_SHIFT_1;
    UTRIE2_INDEX_2_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_1_2;
    UTRIE2_INDEX_2_MASK = UTRIE2_INDEX_2_BLOCK_LENGTH - 1;
    slice16 = function(view, start, end) {
      if (view.slice) {
        return view.slice(start, end);
      }
      return new Uint16Array(Array.prototype.slice.call(view, start, end));
    };
    slice32 = function(view, start, end) {
      if (view.slice) {
        return view.slice(start, end);
      }
      return new Uint32Array(Array.prototype.slice.call(view, start, end));
    };
    createTrieFromBase64 = function(base642, _byteLength) {
      var buffer = decode2(base642);
      var view32 = Array.isArray(buffer) ? polyUint32Array(buffer) : new Uint32Array(buffer);
      var view16 = Array.isArray(buffer) ? polyUint16Array(buffer) : new Uint16Array(buffer);
      var headerLength = 24;
      var index = slice16(view16, headerLength / 2, view32[4] / 2);
      var data = view32[5] === 2 ? slice16(view16, (headerLength + view32[4]) / 2) : slice32(view32, Math.ceil((headerLength + view32[4]) / 4));
      return new Trie(view32[0], view32[1], view32[2], view32[3], index, data);
    };
    Trie = /** @class */
    (function() {
      function Trie2(initialValue, errorValue, highStart, highValueIndex, index, data) {
        this.initialValue = initialValue;
        this.errorValue = errorValue;
        this.highStart = highStart;
        this.highValueIndex = highValueIndex;
        this.index = index;
        this.data = data;
      }
      Trie2.prototype.get = function(codePoint) {
        var ix;
        if (codePoint >= 0) {
          if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
            ix = this.index[codePoint >> UTRIE2_SHIFT_2];
            ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
            return this.data[ix];
          }
          if (codePoint <= 65535) {
            ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET + (codePoint - 55296 >> UTRIE2_SHIFT_2)];
            ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
            return this.data[ix];
          }
          if (codePoint < this.highStart) {
            ix = UTRIE2_INDEX_1_OFFSET - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH + (codePoint >> UTRIE2_SHIFT_1);
            ix = this.index[ix];
            ix += codePoint >> UTRIE2_SHIFT_2 & UTRIE2_INDEX_2_MASK;
            ix = this.index[ix];
            ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
            return this.data[ix];
          }
          if (codePoint <= 1114111) {
            return this.data[this.highValueIndex];
          }
        }
        return this.errorValue;
      };
      return Trie2;
    })();
    chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    lookup = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
    for (i = 0; i < chars.length; i++) {
      lookup[chars.charCodeAt(i)] = i;
    }
    Prepend = 1;
    CR = 2;
    LF = 3;
    Control = 4;
    Extend = 5;
    SpacingMark = 7;
    L = 8;
    V = 9;
    T = 10;
    LV = 11;
    LVT = 12;
    ZWJ = 13;
    Extended_Pictographic = 14;
    RI = 15;
    toCodePoints = function(str) {
      var codePoints = [];
      var i = 0;
      var length = str.length;
      while (i < length) {
        var value = str.charCodeAt(i++);
        if (value >= 55296 && value <= 56319 && i < length) {
          var extra = str.charCodeAt(i++);
          if ((extra & 64512) === 56320) {
            codePoints.push(((value & 1023) << 10) + (extra & 1023) + 65536);
          } else {
            codePoints.push(value);
            i--;
          }
        } else {
          codePoints.push(value);
        }
      }
      return codePoints;
    };
    fromCodePoint = function() {
      var codePoints = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        codePoints[_i] = arguments[_i];
      }
      if (String.fromCodePoint) {
        return String.fromCodePoint.apply(String, codePoints);
      }
      var length = codePoints.length;
      if (!length) {
        return "";
      }
      var codeUnits = [];
      var index = -1;
      var result = "";
      while (++index < length) {
        var codePoint = codePoints[index];
        if (codePoint <= 65535) {
          codeUnits.push(codePoint);
        } else {
          codePoint -= 65536;
          codeUnits.push((codePoint >> 10) + 55296, codePoint % 1024 + 56320);
        }
        if (index + 1 === length || codeUnits.length > 16384) {
          result += String.fromCharCode.apply(String, codeUnits);
          codeUnits.length = 0;
        }
      }
      return result;
    };
    UnicodeTrie = createTrieFromBase64(base64);
    BREAK_NOT_ALLOWED = "\xD7";
    BREAK_ALLOWED = "\xF7";
    codePointToClass = function(codePoint) {
      return UnicodeTrie.get(codePoint);
    };
    _graphemeBreakAtIndex = function(_codePoints, classTypes, index) {
      var prevIndex = index - 2;
      var prev = classTypes[prevIndex];
      var current = classTypes[index - 1];
      var next = classTypes[index];
      if (current === CR && next === LF) {
        return BREAK_NOT_ALLOWED;
      }
      if (current === CR || current === LF || current === Control) {
        return BREAK_ALLOWED;
      }
      if (next === CR || next === LF || next === Control) {
        return BREAK_ALLOWED;
      }
      if (current === L && [L, V, LV, LVT].indexOf(next) !== -1) {
        return BREAK_NOT_ALLOWED;
      }
      if ((current === LV || current === V) && (next === V || next === T)) {
        return BREAK_NOT_ALLOWED;
      }
      if ((current === LVT || current === T) && next === T) {
        return BREAK_NOT_ALLOWED;
      }
      if (next === ZWJ || next === Extend) {
        return BREAK_NOT_ALLOWED;
      }
      if (next === SpacingMark) {
        return BREAK_NOT_ALLOWED;
      }
      if (current === Prepend) {
        return BREAK_NOT_ALLOWED;
      }
      if (current === ZWJ && next === Extended_Pictographic) {
        while (prev === Extend) {
          prev = classTypes[--prevIndex];
        }
        if (prev === Extended_Pictographic) {
          return BREAK_NOT_ALLOWED;
        }
      }
      if (current === RI && next === RI) {
        var countRI = 0;
        while (prev === RI) {
          countRI++;
          prev = classTypes[--prevIndex];
        }
        if (countRI % 2 === 0) {
          return BREAK_NOT_ALLOWED;
        }
      }
      return BREAK_ALLOWED;
    };
    GraphemeBreaker = function(str) {
      var codePoints = toCodePoints(str);
      var length = codePoints.length;
      var index = 0;
      var lastEnd = 0;
      var classTypes = codePoints.map(codePointToClass);
      return {
        next: function() {
          if (index >= length) {
            return { done: true, value: null };
          }
          var graphemeBreak = BREAK_NOT_ALLOWED;
          while (index < length && (graphemeBreak = _graphemeBreakAtIndex(codePoints, classTypes, ++index)) === BREAK_NOT_ALLOWED) {
          }
          if (graphemeBreak !== BREAK_NOT_ALLOWED || index === length) {
            var value = fromCodePoint.apply(null, codePoints.slice(lastEnd, index));
            lastEnd = index;
            return { value, done: false };
          }
          return { done: true, value: null };
        }
      };
    };
    splitGraphemes = function(str) {
      var breaker = GraphemeBreaker(str);
      var graphemes = [];
      var bk;
      while (!(bk = breaker.next()).done) {
        if (bk.value) {
          graphemes.push(bk.value.slice());
        }
      }
      return graphemes;
    };
    testRangeBounds = function(document2) {
      var TEST_HEIGHT = 123;
      if (document2.createRange) {
        var range = document2.createRange();
        if (range.getBoundingClientRect) {
          var testElement = document2.createElement("boundtest");
          testElement.style.height = TEST_HEIGHT + "px";
          testElement.style.display = "block";
          document2.body.appendChild(testElement);
          range.selectNode(testElement);
          var rangeBounds = range.getBoundingClientRect();
          var rangeHeight = Math.round(rangeBounds.height);
          document2.body.removeChild(testElement);
          if (rangeHeight === TEST_HEIGHT) {
            return true;
          }
        }
      }
      return false;
    };
    testIOSLineBreak = function(document2) {
      var testElement = document2.createElement("boundtest");
      testElement.style.width = "50px";
      testElement.style.display = "block";
      testElement.style.fontSize = "12px";
      testElement.style.letterSpacing = "0px";
      testElement.style.wordSpacing = "0px";
      document2.body.appendChild(testElement);
      var range = document2.createRange();
      testElement.innerHTML = typeof "".repeat === "function" ? "&#128104;".repeat(10) : "";
      var node = testElement.firstChild;
      var textList = toCodePoints$1(node.data).map(function(i) {
        return fromCodePoint$1(i);
      });
      var offset = 0;
      var prev = {};
      var supports = textList.every(function(text, i) {
        range.setStart(node, offset);
        range.setEnd(node, offset + text.length);
        var rect = range.getBoundingClientRect();
        offset += text.length;
        var boundAhead = rect.x > prev.x || rect.y > prev.y;
        prev = rect;
        if (i === 0) {
          return true;
        }
        return boundAhead;
      });
      document2.body.removeChild(testElement);
      return supports;
    };
    testCORS = function() {
      return typeof new Image().crossOrigin !== "undefined";
    };
    testResponseType = function() {
      return typeof new XMLHttpRequest().responseType === "string";
    };
    testSVG = function(document2) {
      var img = new Image();
      var canvas = document2.createElement("canvas");
      var ctx = canvas.getContext("2d");
      if (!ctx) {
        return false;
      }
      img.src = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>";
      try {
        ctx.drawImage(img, 0, 0);
        canvas.toDataURL();
      } catch (e2) {
        return false;
      }
      return true;
    };
    isGreenPixel = function(data) {
      return data[0] === 0 && data[1] === 255 && data[2] === 0 && data[3] === 255;
    };
    testForeignObject = function(document2) {
      var canvas = document2.createElement("canvas");
      var size = 100;
      canvas.width = size;
      canvas.height = size;
      var ctx = canvas.getContext("2d");
      if (!ctx) {
        return Promise.reject(false);
      }
      ctx.fillStyle = "rgb(0, 255, 0)";
      ctx.fillRect(0, 0, size, size);
      var img = new Image();
      var greenImageSrc = canvas.toDataURL();
      img.src = greenImageSrc;
      var svg = createForeignObjectSVG(size, size, 0, 0, img);
      ctx.fillStyle = "red";
      ctx.fillRect(0, 0, size, size);
      return loadSerializedSVG$1(svg).then(function(img2) {
        ctx.drawImage(img2, 0, 0);
        var data = ctx.getImageData(0, 0, size, size).data;
        ctx.fillStyle = "red";
        ctx.fillRect(0, 0, size, size);
        var node = document2.createElement("div");
        node.style.backgroundImage = "url(" + greenImageSrc + ")";
        node.style.height = size + "px";
        return isGreenPixel(data) ? loadSerializedSVG$1(createForeignObjectSVG(size, size, 0, 0, node)) : Promise.reject(false);
      }).then(function(img2) {
        ctx.drawImage(img2, 0, 0);
        return isGreenPixel(ctx.getImageData(0, 0, size, size).data);
      }).catch(function() {
        return false;
      });
    };
    createForeignObjectSVG = function(width, height, x, y, node) {
      var xmlns = "http://www.w3.org/2000/svg";
      var svg = document.createElementNS(xmlns, "svg");
      var foreignObject = document.createElementNS(xmlns, "foreignObject");
      svg.setAttributeNS(null, "width", width.toString());
      svg.setAttributeNS(null, "height", height.toString());
      foreignObject.setAttributeNS(null, "width", "100%");
      foreignObject.setAttributeNS(null, "height", "100%");
      foreignObject.setAttributeNS(null, "x", x.toString());
      foreignObject.setAttributeNS(null, "y", y.toString());
      foreignObject.setAttributeNS(null, "externalResourcesRequired", "true");
      svg.appendChild(foreignObject);
      foreignObject.appendChild(node);
      return svg;
    };
    loadSerializedSVG$1 = function(svg) {
      return new Promise(function(resolve, reject) {
        var img = new Image();
        img.onload = function() {
          return resolve(img);
        };
        img.onerror = reject;
        img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg));
      });
    };
    FEATURES = {
      get SUPPORT_RANGE_BOUNDS() {
        var value = testRangeBounds(document);
        Object.defineProperty(FEATURES, "SUPPORT_RANGE_BOUNDS", { value });
        return value;
      },
      get SUPPORT_WORD_BREAKING() {
        var value = FEATURES.SUPPORT_RANGE_BOUNDS && testIOSLineBreak(document);
        Object.defineProperty(FEATURES, "SUPPORT_WORD_BREAKING", { value });
        return value;
      },
      get SUPPORT_SVG_DRAWING() {
        var value = testSVG(document);
        Object.defineProperty(FEATURES, "SUPPORT_SVG_DRAWING", { value });
        return value;
      },
      get SUPPORT_FOREIGNOBJECT_DRAWING() {
        var value = typeof Array.from === "function" && typeof window.fetch === "function" ? testForeignObject(document) : Promise.resolve(false);
        Object.defineProperty(FEATURES, "SUPPORT_FOREIGNOBJECT_DRAWING", { value });
        return value;
      },
      get SUPPORT_CORS_IMAGES() {
        var value = testCORS();
        Object.defineProperty(FEATURES, "SUPPORT_CORS_IMAGES", { value });
        return value;
      },
      get SUPPORT_RESPONSE_TYPE() {
        var value = testResponseType();
        Object.defineProperty(FEATURES, "SUPPORT_RESPONSE_TYPE", { value });
        return value;
      },
      get SUPPORT_CORS_XHR() {
        var value = "withCredentials" in new XMLHttpRequest();
        Object.defineProperty(FEATURES, "SUPPORT_CORS_XHR", { value });
        return value;
      },
      get SUPPORT_NATIVE_TEXT_SEGMENTATION() {
        var value = !!(typeof Intl !== "undefined" && Intl.Segmenter);
        Object.defineProperty(FEATURES, "SUPPORT_NATIVE_TEXT_SEGMENTATION", { value });
        return value;
      }
    };
    TextBounds = /** @class */
    /* @__PURE__ */ (function() {
      function TextBounds2(text, bounds) {
        this.text = text;
        this.bounds = bounds;
      }
      return TextBounds2;
    })();
    parseTextBounds = function(context, value, styles, node) {
      var textList = breakText(value, styles);
      var textBounds = [];
      var offset = 0;
      textList.forEach(function(text) {
        if (styles.textDecorationLine.length || text.trim().length > 0) {
          if (FEATURES.SUPPORT_RANGE_BOUNDS) {
            var clientRects = createRange(node, offset, text.length).getClientRects();
            if (clientRects.length > 1) {
              var subSegments = segmentGraphemes(text);
              var subOffset_1 = 0;
              subSegments.forEach(function(subSegment) {
                textBounds.push(new TextBounds(subSegment, Bounds.fromDOMRectList(context, createRange(node, subOffset_1 + offset, subSegment.length).getClientRects())));
                subOffset_1 += subSegment.length;
              });
            } else {
              textBounds.push(new TextBounds(text, Bounds.fromDOMRectList(context, clientRects)));
            }
          } else {
            var replacementNode = node.splitText(text.length);
            textBounds.push(new TextBounds(text, getWrapperBounds(context, node)));
            node = replacementNode;
          }
        } else if (!FEATURES.SUPPORT_RANGE_BOUNDS) {
          node = node.splitText(text.length);
        }
        offset += text.length;
      });
      return textBounds;
    };
    getWrapperBounds = function(context, node) {
      var ownerDocument = node.ownerDocument;
      if (ownerDocument) {
        var wrapper = ownerDocument.createElement("html2canvaswrapper");
        wrapper.appendChild(node.cloneNode(true));
        var parentNode = node.parentNode;
        if (parentNode) {
          parentNode.replaceChild(wrapper, node);
          var bounds = parseBounds(context, wrapper);
          if (wrapper.firstChild) {
            parentNode.replaceChild(wrapper.firstChild, wrapper);
          }
          return bounds;
        }
      }
      return Bounds.EMPTY;
    };
    createRange = function(node, offset, length) {
      var ownerDocument = node.ownerDocument;
      if (!ownerDocument) {
        throw new Error("Node has no owner document");
      }
      var range = ownerDocument.createRange();
      range.setStart(node, offset);
      range.setEnd(node, offset + length);
      return range;
    };
    segmentGraphemes = function(value) {
      if (FEATURES.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
        var segmenter = new Intl.Segmenter(void 0, { granularity: "grapheme" });
        return Array.from(segmenter.segment(value)).map(function(segment) {
          return segment.segment;
        });
      }
      return splitGraphemes(value);
    };
    segmentWords = function(value, styles) {
      if (FEATURES.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
        var segmenter = new Intl.Segmenter(void 0, {
          granularity: "word"
        });
        return Array.from(segmenter.segment(value)).map(function(segment) {
          return segment.segment;
        });
      }
      return breakWords(value, styles);
    };
    breakText = function(value, styles) {
      return styles.letterSpacing !== 0 ? segmentGraphemes(value) : segmentWords(value, styles);
    };
    wordSeparators = [32, 160, 4961, 65792, 65793, 4153, 4241];
    breakWords = function(str, styles) {
      var breaker = LineBreaker(str, {
        lineBreak: styles.lineBreak,
        wordBreak: styles.overflowWrap === "break-word" ? "break-word" : styles.wordBreak
      });
      var words = [];
      var bk;
      var _loop_1 = function() {
        if (bk.value) {
          var value = bk.value.slice();
          var codePoints = toCodePoints$1(value);
          var word_1 = "";
          codePoints.forEach(function(codePoint) {
            if (wordSeparators.indexOf(codePoint) === -1) {
              word_1 += fromCodePoint$1(codePoint);
            } else {
              if (word_1.length) {
                words.push(word_1);
              }
              words.push(fromCodePoint$1(codePoint));
              word_1 = "";
            }
          });
          if (word_1.length) {
            words.push(word_1);
          }
        }
      };
      while (!(bk = breaker.next()).done) {
        _loop_1();
      }
      return words;
    };
    TextContainer = /** @class */
    /* @__PURE__ */ (function() {
      function TextContainer2(context, node, styles) {
        this.text = transform(node.data, styles.textTransform);
        this.textBounds = parseTextBounds(context, this.text, styles, node);
      }
      return TextContainer2;
    })();
    transform = function(text, transform2) {
      switch (transform2) {
        case 1:
          return text.toLowerCase();
        case 3:
          return text.replace(CAPITALIZE, capitalize);
        case 2:
          return text.toUpperCase();
        default:
          return text;
      }
    };
    CAPITALIZE = /(^|\s|:|-|\(|\))([a-z])/g;
    capitalize = function(m, p1, p2) {
      if (m.length > 0) {
        return p1 + p2.toUpperCase();
      }
      return m;
    };
    ImageElementContainer = /** @class */
    (function(_super) {
      __extends(ImageElementContainer2, _super);
      function ImageElementContainer2(context, img) {
        var _this = _super.call(this, context, img) || this;
        _this.src = img.currentSrc || img.src;
        _this.intrinsicWidth = img.naturalWidth;
        _this.intrinsicHeight = img.naturalHeight;
        _this.context.cache.addImage(_this.src);
        return _this;
      }
      return ImageElementContainer2;
    })(ElementContainer);
    CanvasElementContainer = /** @class */
    (function(_super) {
      __extends(CanvasElementContainer2, _super);
      function CanvasElementContainer2(context, canvas) {
        var _this = _super.call(this, context, canvas) || this;
        _this.canvas = canvas;
        _this.intrinsicWidth = canvas.width;
        _this.intrinsicHeight = canvas.height;
        return _this;
      }
      return CanvasElementContainer2;
    })(ElementContainer);
    SVGElementContainer = /** @class */
    (function(_super) {
      __extends(SVGElementContainer2, _super);
      function SVGElementContainer2(context, img) {
        var _this = _super.call(this, context, img) || this;
        var s = new XMLSerializer();
        var bounds = parseBounds(context, img);
        img.setAttribute("width", bounds.width + "px");
        img.setAttribute("height", bounds.height + "px");
        _this.svg = "data:image/svg+xml," + encodeURIComponent(s.serializeToString(img));
        _this.intrinsicWidth = img.width.baseVal.value;
        _this.intrinsicHeight = img.height.baseVal.value;
        _this.context.cache.addImage(_this.svg);
        return _this;
      }
      return SVGElementContainer2;
    })(ElementContainer);
    LIElementContainer = /** @class */
    (function(_super) {
      __extends(LIElementContainer2, _super);
      function LIElementContainer2(context, element) {
        var _this = _super.call(this, context, element) || this;
        _this.value = element.value;
        return _this;
      }
      return LIElementContainer2;
    })(ElementContainer);
    OLElementContainer = /** @class */
    (function(_super) {
      __extends(OLElementContainer2, _super);
      function OLElementContainer2(context, element) {
        var _this = _super.call(this, context, element) || this;
        _this.start = element.start;
        _this.reversed = typeof element.reversed === "boolean" && element.reversed === true;
        return _this;
      }
      return OLElementContainer2;
    })(ElementContainer);
    CHECKBOX_BORDER_RADIUS = [
      {
        type: 15,
        flags: 0,
        unit: "px",
        number: 3
      }
    ];
    RADIO_BORDER_RADIUS = [
      {
        type: 16,
        flags: 0,
        number: 50
      }
    ];
    reformatInputBounds = function(bounds) {
      if (bounds.width > bounds.height) {
        return new Bounds(bounds.left + (bounds.width - bounds.height) / 2, bounds.top, bounds.height, bounds.height);
      } else if (bounds.width < bounds.height) {
        return new Bounds(bounds.left, bounds.top + (bounds.height - bounds.width) / 2, bounds.width, bounds.width);
      }
      return bounds;
    };
    getInputValue = function(node) {
      var value = node.type === PASSWORD ? new Array(node.value.length + 1).join("\u2022") : node.value;
      return value.length === 0 ? node.placeholder || "" : value;
    };
    CHECKBOX = "checkbox";
    RADIO = "radio";
    PASSWORD = "password";
    INPUT_COLOR = 707406591;
    InputElementContainer = /** @class */
    (function(_super) {
      __extends(InputElementContainer2, _super);
      function InputElementContainer2(context, input) {
        var _this = _super.call(this, context, input) || this;
        _this.type = input.type.toLowerCase();
        _this.checked = input.checked;
        _this.value = getInputValue(input);
        if (_this.type === CHECKBOX || _this.type === RADIO) {
          _this.styles.backgroundColor = 3739148031;
          _this.styles.borderTopColor = _this.styles.borderRightColor = _this.styles.borderBottomColor = _this.styles.borderLeftColor = 2779096575;
          _this.styles.borderTopWidth = _this.styles.borderRightWidth = _this.styles.borderBottomWidth = _this.styles.borderLeftWidth = 1;
          _this.styles.borderTopStyle = _this.styles.borderRightStyle = _this.styles.borderBottomStyle = _this.styles.borderLeftStyle = 1;
          _this.styles.backgroundClip = [
            0
            /* BORDER_BOX */
          ];
          _this.styles.backgroundOrigin = [
            0
            /* BORDER_BOX */
          ];
          _this.bounds = reformatInputBounds(_this.bounds);
        }
        switch (_this.type) {
          case CHECKBOX:
            _this.styles.borderTopRightRadius = _this.styles.borderTopLeftRadius = _this.styles.borderBottomRightRadius = _this.styles.borderBottomLeftRadius = CHECKBOX_BORDER_RADIUS;
            break;
          case RADIO:
            _this.styles.borderTopRightRadius = _this.styles.borderTopLeftRadius = _this.styles.borderBottomRightRadius = _this.styles.borderBottomLeftRadius = RADIO_BORDER_RADIUS;
            break;
        }
        return _this;
      }
      return InputElementContainer2;
    })(ElementContainer);
    SelectElementContainer = /** @class */
    (function(_super) {
      __extends(SelectElementContainer2, _super);
      function SelectElementContainer2(context, element) {
        var _this = _super.call(this, context, element) || this;
        var option = element.options[element.selectedIndex || 0];
        _this.value = option ? option.text || "" : "";
        return _this;
      }
      return SelectElementContainer2;
    })(ElementContainer);
    TextareaElementContainer = /** @class */
    (function(_super) {
      __extends(TextareaElementContainer2, _super);
      function TextareaElementContainer2(context, element) {
        var _this = _super.call(this, context, element) || this;
        _this.value = element.value;
        return _this;
      }
      return TextareaElementContainer2;
    })(ElementContainer);
    IFrameElementContainer = /** @class */
    (function(_super) {
      __extends(IFrameElementContainer2, _super);
      function IFrameElementContainer2(context, iframe) {
        var _this = _super.call(this, context, iframe) || this;
        _this.src = iframe.src;
        _this.width = parseInt(iframe.width, 10) || 0;
        _this.height = parseInt(iframe.height, 10) || 0;
        _this.backgroundColor = _this.styles.backgroundColor;
        try {
          if (iframe.contentWindow && iframe.contentWindow.document && iframe.contentWindow.document.documentElement) {
            _this.tree = parseTree(context, iframe.contentWindow.document.documentElement);
            var documentBackgroundColor = iframe.contentWindow.document.documentElement ? parseColor(context, getComputedStyle(iframe.contentWindow.document.documentElement).backgroundColor) : COLORS.TRANSPARENT;
            var bodyBackgroundColor = iframe.contentWindow.document.body ? parseColor(context, getComputedStyle(iframe.contentWindow.document.body).backgroundColor) : COLORS.TRANSPARENT;
            _this.backgroundColor = isTransparent(documentBackgroundColor) ? isTransparent(bodyBackgroundColor) ? _this.styles.backgroundColor : bodyBackgroundColor : documentBackgroundColor;
          }
        } catch (e2) {
        }
        return _this;
      }
      return IFrameElementContainer2;
    })(ElementContainer);
    LIST_OWNERS = ["OL", "UL", "MENU"];
    parseNodeTree = function(context, node, parent, root) {
      for (var childNode = node.firstChild, nextNode = void 0; childNode; childNode = nextNode) {
        nextNode = childNode.nextSibling;
        if (isTextNode(childNode) && childNode.data.trim().length > 0) {
          parent.textNodes.push(new TextContainer(context, childNode, parent.styles));
        } else if (isElementNode(childNode)) {
          if (isSlotElement(childNode) && childNode.assignedNodes) {
            childNode.assignedNodes().forEach(function(childNode2) {
              return parseNodeTree(context, childNode2, parent, root);
            });
          } else {
            var container = createContainer(context, childNode);
            if (container.styles.isVisible()) {
              if (createsRealStackingContext(childNode, container, root)) {
                container.flags |= 4;
              } else if (createsStackingContext(container.styles)) {
                container.flags |= 2;
              }
              if (LIST_OWNERS.indexOf(childNode.tagName) !== -1) {
                container.flags |= 8;
              }
              parent.elements.push(container);
              childNode.slot;
              if (childNode.shadowRoot) {
                parseNodeTree(context, childNode.shadowRoot, container, root);
              } else if (!isTextareaElement(childNode) && !isSVGElement(childNode) && !isSelectElement(childNode)) {
                parseNodeTree(context, childNode, container, root);
              }
            }
          }
        }
      }
    };
    createContainer = function(context, element) {
      if (isImageElement(element)) {
        return new ImageElementContainer(context, element);
      }
      if (isCanvasElement(element)) {
        return new CanvasElementContainer(context, element);
      }
      if (isSVGElement(element)) {
        return new SVGElementContainer(context, element);
      }
      if (isLIElement(element)) {
        return new LIElementContainer(context, element);
      }
      if (isOLElement(element)) {
        return new OLElementContainer(context, element);
      }
      if (isInputElement(element)) {
        return new InputElementContainer(context, element);
      }
      if (isSelectElement(element)) {
        return new SelectElementContainer(context, element);
      }
      if (isTextareaElement(element)) {
        return new TextareaElementContainer(context, element);
      }
      if (isIFrameElement(element)) {
        return new IFrameElementContainer(context, element);
      }
      return new ElementContainer(context, element);
    };
    parseTree = function(context, element) {
      var container = createContainer(context, element);
      container.flags |= 4;
      parseNodeTree(context, element, container, container);
      return container;
    };
    createsRealStackingContext = function(node, container, root) {
      return container.styles.isPositionedWithZIndex() || container.styles.opacity < 1 || container.styles.isTransformed() || isBodyElement(node) && root.styles.isTransparent();
    };
    createsStackingContext = function(styles) {
      return styles.isPositioned() || styles.isFloating();
    };
    isTextNode = function(node) {
      return node.nodeType === Node.TEXT_NODE;
    };
    isElementNode = function(node) {
      return node.nodeType === Node.ELEMENT_NODE;
    };
    isHTMLElementNode = function(node) {
      return isElementNode(node) && typeof node.style !== "undefined" && !isSVGElementNode(node);
    };
    isSVGElementNode = function(element) {
      return typeof element.className === "object";
    };
    isLIElement = function(node) {
      return node.tagName === "LI";
    };
    isOLElement = function(node) {
      return node.tagName === "OL";
    };
    isInputElement = function(node) {
      return node.tagName === "INPUT";
    };
    isHTMLElement = function(node) {
      return node.tagName === "HTML";
    };
    isSVGElement = function(node) {
      return node.tagName === "svg";
    };
    isBodyElement = function(node) {
      return node.tagName === "BODY";
    };
    isCanvasElement = function(node) {
      return node.tagName === "CANVAS";
    };
    isVideoElement = function(node) {
      return node.tagName === "VIDEO";
    };
    isImageElement = function(node) {
      return node.tagName === "IMG";
    };
    isIFrameElement = function(node) {
      return node.tagName === "IFRAME";
    };
    isStyleElement = function(node) {
      return node.tagName === "STYLE";
    };
    isScriptElement = function(node) {
      return node.tagName === "SCRIPT";
    };
    isTextareaElement = function(node) {
      return node.tagName === "TEXTAREA";
    };
    isSelectElement = function(node) {
      return node.tagName === "SELECT";
    };
    isSlotElement = function(node) {
      return node.tagName === "SLOT";
    };
    isCustomElement = function(node) {
      return node.tagName.indexOf("-") > 0;
    };
    CounterState = /** @class */
    (function() {
      function CounterState2() {
        this.counters = {};
      }
      CounterState2.prototype.getCounterValue = function(name) {
        var counter = this.counters[name];
        if (counter && counter.length) {
          return counter[counter.length - 1];
        }
        return 1;
      };
      CounterState2.prototype.getCounterValues = function(name) {
        var counter = this.counters[name];
        return counter ? counter : [];
      };
      CounterState2.prototype.pop = function(counters) {
        var _this = this;
        counters.forEach(function(counter) {
          return _this.counters[counter].pop();
        });
      };
      CounterState2.prototype.parse = function(style) {
        var _this = this;
        var counterIncrement2 = style.counterIncrement;
        var counterReset2 = style.counterReset;
        var canReset = true;
        if (counterIncrement2 !== null) {
          counterIncrement2.forEach(function(entry) {
            var counter = _this.counters[entry.counter];
            if (counter && entry.increment !== 0) {
              canReset = false;
              if (!counter.length) {
                counter.push(1);
              }
              counter[Math.max(0, counter.length - 1)] += entry.increment;
            }
          });
        }
        var counterNames = [];
        if (canReset) {
          counterReset2.forEach(function(entry) {
            var counter = _this.counters[entry.counter];
            counterNames.push(entry.counter);
            if (!counter) {
              counter = _this.counters[entry.counter] = [];
            }
            counter.push(entry.reset);
          });
        }
        return counterNames;
      };
      return CounterState2;
    })();
    ROMAN_UPPER = {
      integers: [1e3, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1],
      values: ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"]
    };
    ARMENIAN = {
      integers: [
        9e3,
        8e3,
        7e3,
        6e3,
        5e3,
        4e3,
        3e3,
        2e3,
        1e3,
        900,
        800,
        700,
        600,
        500,
        400,
        300,
        200,
        100,
        90,
        80,
        70,
        60,
        50,
        40,
        30,
        20,
        10,
        9,
        8,
        7,
        6,
        5,
        4,
        3,
        2,
        1
      ],
      values: [
        "\u0554",
        "\u0553",
        "\u0552",
        "\u0551",
        "\u0550",
        "\u054F",
        "\u054E",
        "\u054D",
        "\u054C",
        "\u054B",
        "\u054A",
        "\u0549",
        "\u0548",
        "\u0547",
        "\u0546",
        "\u0545",
        "\u0544",
        "\u0543",
        "\u0542",
        "\u0541",
        "\u0540",
        "\u053F",
        "\u053E",
        "\u053D",
        "\u053C",
        "\u053B",
        "\u053A",
        "\u0539",
        "\u0538",
        "\u0537",
        "\u0536",
        "\u0535",
        "\u0534",
        "\u0533",
        "\u0532",
        "\u0531"
      ]
    };
    HEBREW = {
      integers: [
        1e4,
        9e3,
        8e3,
        7e3,
        6e3,
        5e3,
        4e3,
        3e3,
        2e3,
        1e3,
        400,
        300,
        200,
        100,
        90,
        80,
        70,
        60,
        50,
        40,
        30,
        20,
        19,
        18,
        17,
        16,
        15,
        10,
        9,
        8,
        7,
        6,
        5,
        4,
        3,
        2,
        1
      ],
      values: [
        "\u05D9\u05F3",
        "\u05D8\u05F3",
        "\u05D7\u05F3",
        "\u05D6\u05F3",
        "\u05D5\u05F3",
        "\u05D4\u05F3",
        "\u05D3\u05F3",
        "\u05D2\u05F3",
        "\u05D1\u05F3",
        "\u05D0\u05F3",
        "\u05EA",
        "\u05E9",
        "\u05E8",
        "\u05E7",
        "\u05E6",
        "\u05E4",
        "\u05E2",
        "\u05E1",
        "\u05E0",
        "\u05DE",
        "\u05DC",
        "\u05DB",
        "\u05D9\u05D8",
        "\u05D9\u05D7",
        "\u05D9\u05D6",
        "\u05D8\u05D6",
        "\u05D8\u05D5",
        "\u05D9",
        "\u05D8",
        "\u05D7",
        "\u05D6",
        "\u05D5",
        "\u05D4",
        "\u05D3",
        "\u05D2",
        "\u05D1",
        "\u05D0"
      ]
    };
    GEORGIAN = {
      integers: [
        1e4,
        9e3,
        8e3,
        7e3,
        6e3,
        5e3,
        4e3,
        3e3,
        2e3,
        1e3,
        900,
        800,
        700,
        600,
        500,
        400,
        300,
        200,
        100,
        90,
        80,
        70,
        60,
        50,
        40,
        30,
        20,
        10,
        9,
        8,
        7,
        6,
        5,
        4,
        3,
        2,
        1
      ],
      values: [
        "\u10F5",
        "\u10F0",
        "\u10EF",
        "\u10F4",
        "\u10EE",
        "\u10ED",
        "\u10EC",
        "\u10EB",
        "\u10EA",
        "\u10E9",
        "\u10E8",
        "\u10E7",
        "\u10E6",
        "\u10E5",
        "\u10E4",
        "\u10F3",
        "\u10E2",
        "\u10E1",
        "\u10E0",
        "\u10DF",
        "\u10DE",
        "\u10DD",
        "\u10F2",
        "\u10DC",
        "\u10DB",
        "\u10DA",
        "\u10D9",
        "\u10D8",
        "\u10D7",
        "\u10F1",
        "\u10D6",
        "\u10D5",
        "\u10D4",
        "\u10D3",
        "\u10D2",
        "\u10D1",
        "\u10D0"
      ]
    };
    createAdditiveCounter = function(value, min, max, symbols, fallback, suffix) {
      if (value < min || value > max) {
        return createCounterText(value, fallback, suffix.length > 0);
      }
      return symbols.integers.reduce(function(string, integer, index) {
        while (value >= integer) {
          value -= integer;
          string += symbols.values[index];
        }
        return string;
      }, "") + suffix;
    };
    createCounterStyleWithSymbolResolver = function(value, codePointRangeLength, isNumeric, resolver) {
      var string = "";
      do {
        if (!isNumeric) {
          value--;
        }
        string = resolver(value) + string;
        value /= codePointRangeLength;
      } while (value * codePointRangeLength >= codePointRangeLength);
      return string;
    };
    createCounterStyleFromRange = function(value, codePointRangeStart, codePointRangeEnd, isNumeric, suffix) {
      var codePointRangeLength = codePointRangeEnd - codePointRangeStart + 1;
      return (value < 0 ? "-" : "") + (createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, isNumeric, function(codePoint) {
        return fromCodePoint$1(Math.floor(codePoint % codePointRangeLength) + codePointRangeStart);
      }) + suffix);
    };
    createCounterStyleFromSymbols = function(value, symbols, suffix) {
      if (suffix === void 0) {
        suffix = ". ";
      }
      var codePointRangeLength = symbols.length;
      return createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, false, function(codePoint) {
        return symbols[Math.floor(codePoint % codePointRangeLength)];
      }) + suffix;
    };
    CJK_ZEROS = 1 << 0;
    CJK_TEN_COEFFICIENTS = 1 << 1;
    CJK_TEN_HIGH_COEFFICIENTS = 1 << 2;
    CJK_HUNDRED_COEFFICIENTS = 1 << 3;
    createCJKCounter = function(value, numbers, multipliers, negativeSign, suffix, flags) {
      if (value < -9999 || value > 9999) {
        return createCounterText(value, 4, suffix.length > 0);
      }
      var tmp = Math.abs(value);
      var string = suffix;
      if (tmp === 0) {
        return numbers[0] + string;
      }
      for (var digit = 0; tmp > 0 && digit <= 4; digit++) {
        var coefficient = tmp % 10;
        if (coefficient === 0 && contains(flags, CJK_ZEROS) && string !== "") {
          string = numbers[coefficient] + string;
        } else if (coefficient > 1 || coefficient === 1 && digit === 0 || coefficient === 1 && digit === 1 && contains(flags, CJK_TEN_COEFFICIENTS) || coefficient === 1 && digit === 1 && contains(flags, CJK_TEN_HIGH_COEFFICIENTS) && value > 100 || coefficient === 1 && digit > 1 && contains(flags, CJK_HUNDRED_COEFFICIENTS)) {
          string = numbers[coefficient] + (digit > 0 ? multipliers[digit - 1] : "") + string;
        } else if (coefficient === 1 && digit > 0) {
          string = multipliers[digit - 1] + string;
        }
        tmp = Math.floor(tmp / 10);
      }
      return (value < 0 ? negativeSign : "") + string;
    };
    CHINESE_INFORMAL_MULTIPLIERS = "\u5341\u767E\u5343\u842C";
    CHINESE_FORMAL_MULTIPLIERS = "\u62FE\u4F70\u4EDF\u842C";
    JAPANESE_NEGATIVE = "\u30DE\u30A4\u30CA\u30B9";
    KOREAN_NEGATIVE = "\uB9C8\uC774\uB108\uC2A4";
    createCounterText = function(value, type, appendSuffix) {
      var defaultSuffix = appendSuffix ? ". " : "";
      var cjkSuffix = appendSuffix ? "\u3001" : "";
      var koreanSuffix = appendSuffix ? ", " : "";
      var spaceSuffix = appendSuffix ? " " : "";
      switch (type) {
        case 0:
          return "\u2022" + spaceSuffix;
        case 1:
          return "\u25E6" + spaceSuffix;
        case 2:
          return "\u25FE" + spaceSuffix;
        case 5:
          var string = createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
          return string.length < 4 ? "0" + string : string;
        case 4:
          return createCounterStyleFromSymbols(value, "\u3007\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", cjkSuffix);
        case 6:
          return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, 3, defaultSuffix).toLowerCase();
        case 7:
          return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, 3, defaultSuffix);
        case 8:
          return createCounterStyleFromRange(value, 945, 969, false, defaultSuffix);
        case 9:
          return createCounterStyleFromRange(value, 97, 122, false, defaultSuffix);
        case 10:
          return createCounterStyleFromRange(value, 65, 90, false, defaultSuffix);
        case 11:
          return createCounterStyleFromRange(value, 1632, 1641, true, defaultSuffix);
        case 12:
        case 49:
          return createAdditiveCounter(value, 1, 9999, ARMENIAN, 3, defaultSuffix);
        case 35:
          return createAdditiveCounter(value, 1, 9999, ARMENIAN, 3, defaultSuffix).toLowerCase();
        case 13:
          return createCounterStyleFromRange(value, 2534, 2543, true, defaultSuffix);
        case 14:
        case 30:
          return createCounterStyleFromRange(value, 6112, 6121, true, defaultSuffix);
        case 15:
          return createCounterStyleFromSymbols(value, "\u5B50\u4E11\u5BC5\u536F\u8FB0\u5DF3\u5348\u672A\u7533\u9149\u620C\u4EA5", cjkSuffix);
        case 16:
          return createCounterStyleFromSymbols(value, "\u7532\u4E59\u4E19\u4E01\u620A\u5DF1\u5E9A\u8F9B\u58EC\u7678", cjkSuffix);
        case 17:
        case 48:
          return createCJKCounter(value, "\u96F6\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", CHINESE_INFORMAL_MULTIPLIERS, "\u8CA0", cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
        case 47:
          return createCJKCounter(value, "\u96F6\u58F9\u8CB3\u53C3\u8086\u4F0D\u9678\u67D2\u634C\u7396", CHINESE_FORMAL_MULTIPLIERS, "\u8CA0", cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
        case 42:
          return createCJKCounter(value, "\u96F6\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", CHINESE_INFORMAL_MULTIPLIERS, "\u8D1F", cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
        case 41:
          return createCJKCounter(value, "\u96F6\u58F9\u8D30\u53C1\u8086\u4F0D\u9646\u67D2\u634C\u7396", CHINESE_FORMAL_MULTIPLIERS, "\u8D1F", cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
        case 26:
          return createCJKCounter(value, "\u3007\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", "\u5341\u767E\u5343\u4E07", JAPANESE_NEGATIVE, cjkSuffix, 0);
        case 25:
          return createCJKCounter(value, "\u96F6\u58F1\u5F10\u53C2\u56DB\u4F0D\u516D\u4E03\u516B\u4E5D", "\u62FE\u767E\u5343\u4E07", JAPANESE_NEGATIVE, cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
        case 31:
          return createCJKCounter(value, "\uC601\uC77C\uC774\uC0BC\uC0AC\uC624\uC721\uCE60\uD314\uAD6C", "\uC2ED\uBC31\uCC9C\uB9CC", KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
        case 33:
          return createCJKCounter(value, "\u96F6\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", "\u5341\u767E\u5343\u842C", KOREAN_NEGATIVE, koreanSuffix, 0);
        case 32:
          return createCJKCounter(value, "\u96F6\u58F9\u8CB3\u53C3\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", "\u62FE\u767E\u5343", KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
        case 18:
          return createCounterStyleFromRange(value, 2406, 2415, true, defaultSuffix);
        case 20:
          return createAdditiveCounter(value, 1, 19999, GEORGIAN, 3, defaultSuffix);
        case 21:
          return createCounterStyleFromRange(value, 2790, 2799, true, defaultSuffix);
        case 22:
          return createCounterStyleFromRange(value, 2662, 2671, true, defaultSuffix);
        case 22:
          return createAdditiveCounter(value, 1, 10999, HEBREW, 3, defaultSuffix);
        case 23:
          return createCounterStyleFromSymbols(value, "\u3042\u3044\u3046\u3048\u304A\u304B\u304D\u304F\u3051\u3053\u3055\u3057\u3059\u305B\u305D\u305F\u3061\u3064\u3066\u3068\u306A\u306B\u306C\u306D\u306E\u306F\u3072\u3075\u3078\u307B\u307E\u307F\u3080\u3081\u3082\u3084\u3086\u3088\u3089\u308A\u308B\u308C\u308D\u308F\u3090\u3091\u3092\u3093");
        case 24:
          return createCounterStyleFromSymbols(value, "\u3044\u308D\u306F\u306B\u307B\u3078\u3068\u3061\u308A\u306C\u308B\u3092\u308F\u304B\u3088\u305F\u308C\u305D\u3064\u306D\u306A\u3089\u3080\u3046\u3090\u306E\u304A\u304F\u3084\u307E\u3051\u3075\u3053\u3048\u3066\u3042\u3055\u304D\u3086\u3081\u307F\u3057\u3091\u3072\u3082\u305B\u3059");
        case 27:
          return createCounterStyleFromRange(value, 3302, 3311, true, defaultSuffix);
        case 28:
          return createCounterStyleFromSymbols(value, "\u30A2\u30A4\u30A6\u30A8\u30AA\u30AB\u30AD\u30AF\u30B1\u30B3\u30B5\u30B7\u30B9\u30BB\u30BD\u30BF\u30C1\u30C4\u30C6\u30C8\u30CA\u30CB\u30CC\u30CD\u30CE\u30CF\u30D2\u30D5\u30D8\u30DB\u30DE\u30DF\u30E0\u30E1\u30E2\u30E4\u30E6\u30E8\u30E9\u30EA\u30EB\u30EC\u30ED\u30EF\u30F0\u30F1\u30F2\u30F3", cjkSuffix);
        case 29:
          return createCounterStyleFromSymbols(value, "\u30A4\u30ED\u30CF\u30CB\u30DB\u30D8\u30C8\u30C1\u30EA\u30CC\u30EB\u30F2\u30EF\u30AB\u30E8\u30BF\u30EC\u30BD\u30C4\u30CD\u30CA\u30E9\u30E0\u30A6\u30F0\u30CE\u30AA\u30AF\u30E4\u30DE\u30B1\u30D5\u30B3\u30A8\u30C6\u30A2\u30B5\u30AD\u30E6\u30E1\u30DF\u30B7\u30F1\u30D2\u30E2\u30BB\u30B9", cjkSuffix);
        case 34:
          return createCounterStyleFromRange(value, 3792, 3801, true, defaultSuffix);
        case 37:
          return createCounterStyleFromRange(value, 6160, 6169, true, defaultSuffix);
        case 38:
          return createCounterStyleFromRange(value, 4160, 4169, true, defaultSuffix);
        case 39:
          return createCounterStyleFromRange(value, 2918, 2927, true, defaultSuffix);
        case 40:
          return createCounterStyleFromRange(value, 1776, 1785, true, defaultSuffix);
        case 43:
          return createCounterStyleFromRange(value, 3046, 3055, true, defaultSuffix);
        case 44:
          return createCounterStyleFromRange(value, 3174, 3183, true, defaultSuffix);
        case 45:
          return createCounterStyleFromRange(value, 3664, 3673, true, defaultSuffix);
        case 46:
          return createCounterStyleFromRange(value, 3872, 3881, true, defaultSuffix);
        case 3:
        default:
          return createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
      }
    };
    IGNORE_ATTRIBUTE = "data-html2canvas-ignore";
    DocumentCloner = /** @class */
    (function() {
      function DocumentCloner2(context, element, options) {
        this.context = context;
        this.options = options;
        this.scrolledElements = [];
        this.referenceElement = element;
        this.counters = new CounterState();
        this.quoteDepth = 0;
        if (!element.ownerDocument) {
          throw new Error("Cloned element does not have an owner document");
        }
        this.documentElement = this.cloneNode(element.ownerDocument.documentElement, false);
      }
      DocumentCloner2.prototype.toIFrame = function(ownerDocument, windowSize) {
        var _this = this;
        var iframe = createIFrameContainer(ownerDocument, windowSize);
        if (!iframe.contentWindow) {
          return Promise.reject("Unable to find iframe window");
        }
        var scrollX = ownerDocument.defaultView.pageXOffset;
        var scrollY = ownerDocument.defaultView.pageYOffset;
        var cloneWindow = iframe.contentWindow;
        var documentClone = cloneWindow.document;
        var iframeLoad = iframeLoader(iframe).then(function() {
          return __awaiter(_this, void 0, void 0, function() {
            var onclone, referenceElement;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  this.scrolledElements.forEach(restoreNodeScroll);
                  if (cloneWindow) {
                    cloneWindow.scrollTo(windowSize.left, windowSize.top);
                    if (/(iPad|iPhone|iPod)/g.test(navigator.userAgent) && (cloneWindow.scrollY !== windowSize.top || cloneWindow.scrollX !== windowSize.left)) {
                      this.context.logger.warn("Unable to restore scroll position for cloned document");
                      this.context.windowBounds = this.context.windowBounds.add(cloneWindow.scrollX - windowSize.left, cloneWindow.scrollY - windowSize.top, 0, 0);
                    }
                  }
                  onclone = this.options.onclone;
                  referenceElement = this.clonedReferenceElement;
                  if (typeof referenceElement === "undefined") {
                    return [2, Promise.reject("Error finding the " + this.referenceElement.nodeName + " in the cloned document")];
                  }
                  if (!(documentClone.fonts && documentClone.fonts.ready)) return [3, 2];
                  return [4, documentClone.fonts.ready];
                case 1:
                  _a2.sent();
                  _a2.label = 2;
                case 2:
                  if (!/(AppleWebKit)/g.test(navigator.userAgent)) return [3, 4];
                  return [4, imagesReady(documentClone)];
                case 3:
                  _a2.sent();
                  _a2.label = 4;
                case 4:
                  if (typeof onclone === "function") {
                    return [2, Promise.resolve().then(function() {
                      return onclone(documentClone, referenceElement);
                    }).then(function() {
                      return iframe;
                    })];
                  }
                  return [2, iframe];
              }
            });
          });
        });
        documentClone.open();
        documentClone.write(serializeDoctype(document.doctype) + "<html></html>");
        restoreOwnerScroll(this.referenceElement.ownerDocument, scrollX, scrollY);
        documentClone.replaceChild(documentClone.adoptNode(this.documentElement), documentClone.documentElement);
        documentClone.close();
        return iframeLoad;
      };
      DocumentCloner2.prototype.createElementClone = function(node) {
        if (isDebugging(
          node,
          2
          /* CLONE */
        )) {
          debugger;
        }
        if (isCanvasElement(node)) {
          return this.createCanvasClone(node);
        }
        if (isVideoElement(node)) {
          return this.createVideoClone(node);
        }
        if (isStyleElement(node)) {
          return this.createStyleClone(node);
        }
        var clone = node.cloneNode(false);
        if (isImageElement(clone)) {
          if (isImageElement(node) && node.currentSrc && node.currentSrc !== node.src) {
            clone.src = node.currentSrc;
            clone.srcset = "";
          }
          if (clone.loading === "lazy") {
            clone.loading = "eager";
          }
        }
        if (isCustomElement(clone)) {
          return this.createCustomElementClone(clone);
        }
        return clone;
      };
      DocumentCloner2.prototype.createCustomElementClone = function(node) {
        var clone = document.createElement("html2canvascustomelement");
        copyCSSStyles(node.style, clone);
        return clone;
      };
      DocumentCloner2.prototype.createStyleClone = function(node) {
        try {
          var sheet = node.sheet;
          if (sheet && sheet.cssRules) {
            var css = [].slice.call(sheet.cssRules, 0).reduce(function(css2, rule) {
              if (rule && typeof rule.cssText === "string") {
                return css2 + rule.cssText;
              }
              return css2;
            }, "");
            var style = node.cloneNode(false);
            style.textContent = css;
            return style;
          }
        } catch (e2) {
          this.context.logger.error("Unable to access cssRules property", e2);
          if (e2.name !== "SecurityError") {
            throw e2;
          }
        }
        return node.cloneNode(false);
      };
      DocumentCloner2.prototype.createCanvasClone = function(canvas) {
        var _a2;
        if (this.options.inlineImages && canvas.ownerDocument) {
          var img = canvas.ownerDocument.createElement("img");
          try {
            img.src = canvas.toDataURL();
            return img;
          } catch (e2) {
            this.context.logger.info("Unable to inline canvas contents, canvas is tainted", canvas);
          }
        }
        var clonedCanvas = canvas.cloneNode(false);
        try {
          clonedCanvas.width = canvas.width;
          clonedCanvas.height = canvas.height;
          var ctx = canvas.getContext("2d");
          var clonedCtx = clonedCanvas.getContext("2d");
          if (clonedCtx) {
            if (!this.options.allowTaint && ctx) {
              clonedCtx.putImageData(ctx.getImageData(0, 0, canvas.width, canvas.height), 0, 0);
            } else {
              var gl = (_a2 = canvas.getContext("webgl2")) !== null && _a2 !== void 0 ? _a2 : canvas.getContext("webgl");
              if (gl) {
                var attribs = gl.getContextAttributes();
                if ((attribs === null || attribs === void 0 ? void 0 : attribs.preserveDrawingBuffer) === false) {
                  this.context.logger.warn("Unable to clone WebGL context as it has preserveDrawingBuffer=false", canvas);
                }
              }
              clonedCtx.drawImage(canvas, 0, 0);
            }
          }
          return clonedCanvas;
        } catch (e2) {
          this.context.logger.info("Unable to clone canvas as it is tainted", canvas);
        }
        return clonedCanvas;
      };
      DocumentCloner2.prototype.createVideoClone = function(video) {
        var canvas = video.ownerDocument.createElement("canvas");
        canvas.width = video.offsetWidth;
        canvas.height = video.offsetHeight;
        var ctx = canvas.getContext("2d");
        try {
          if (ctx) {
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            if (!this.options.allowTaint) {
              ctx.getImageData(0, 0, canvas.width, canvas.height);
            }
          }
          return canvas;
        } catch (e2) {
          this.context.logger.info("Unable to clone video as it is tainted", video);
        }
        var blankCanvas = video.ownerDocument.createElement("canvas");
        blankCanvas.width = video.offsetWidth;
        blankCanvas.height = video.offsetHeight;
        return blankCanvas;
      };
      DocumentCloner2.prototype.appendChildNode = function(clone, child, copyStyles) {
        if (!isElementNode(child) || !isScriptElement(child) && !child.hasAttribute(IGNORE_ATTRIBUTE) && (typeof this.options.ignoreElements !== "function" || !this.options.ignoreElements(child))) {
          if (!this.options.copyStyles || !isElementNode(child) || !isStyleElement(child)) {
            clone.appendChild(this.cloneNode(child, copyStyles));
          }
        }
      };
      DocumentCloner2.prototype.cloneChildNodes = function(node, clone, copyStyles) {
        var _this = this;
        for (var child = node.shadowRoot ? node.shadowRoot.firstChild : node.firstChild; child; child = child.nextSibling) {
          if (isElementNode(child) && isSlotElement(child) && typeof child.assignedNodes === "function") {
            var assignedNodes = child.assignedNodes();
            if (assignedNodes.length) {
              assignedNodes.forEach(function(assignedNode) {
                return _this.appendChildNode(clone, assignedNode, copyStyles);
              });
            }
          } else {
            this.appendChildNode(clone, child, copyStyles);
          }
        }
      };
      DocumentCloner2.prototype.cloneNode = function(node, copyStyles) {
        if (isTextNode(node)) {
          return document.createTextNode(node.data);
        }
        if (!node.ownerDocument) {
          return node.cloneNode(false);
        }
        var window2 = node.ownerDocument.defaultView;
        if (window2 && isElementNode(node) && (isHTMLElementNode(node) || isSVGElementNode(node))) {
          var clone = this.createElementClone(node);
          clone.style.transitionProperty = "none";
          var style = window2.getComputedStyle(node);
          var styleBefore = window2.getComputedStyle(node, ":before");
          var styleAfter = window2.getComputedStyle(node, ":after");
          if (this.referenceElement === node && isHTMLElementNode(clone)) {
            this.clonedReferenceElement = clone;
          }
          if (isBodyElement(clone)) {
            createPseudoHideStyles(clone);
          }
          var counters = this.counters.parse(new CSSParsedCounterDeclaration(this.context, style));
          var before = this.resolvePseudoContent(node, clone, styleBefore, PseudoElementType.BEFORE);
          if (isCustomElement(node)) {
            copyStyles = true;
          }
          if (!isVideoElement(node)) {
            this.cloneChildNodes(node, clone, copyStyles);
          }
          if (before) {
            clone.insertBefore(before, clone.firstChild);
          }
          var after = this.resolvePseudoContent(node, clone, styleAfter, PseudoElementType.AFTER);
          if (after) {
            clone.appendChild(after);
          }
          this.counters.pop(counters);
          if (style && (this.options.copyStyles || isSVGElementNode(node)) && !isIFrameElement(node) || copyStyles) {
            copyCSSStyles(style, clone);
          }
          if (node.scrollTop !== 0 || node.scrollLeft !== 0) {
            this.scrolledElements.push([clone, node.scrollLeft, node.scrollTop]);
          }
          if ((isTextareaElement(node) || isSelectElement(node)) && (isTextareaElement(clone) || isSelectElement(clone))) {
            clone.value = node.value;
          }
          return clone;
        }
        return node.cloneNode(false);
      };
      DocumentCloner2.prototype.resolvePseudoContent = function(node, clone, style, pseudoElt) {
        var _this = this;
        if (!style) {
          return;
        }
        var value = style.content;
        var document2 = clone.ownerDocument;
        if (!document2 || !value || value === "none" || value === "-moz-alt-content" || style.display === "none") {
          return;
        }
        this.counters.parse(new CSSParsedCounterDeclaration(this.context, style));
        var declaration = new CSSParsedPseudoDeclaration(this.context, style);
        var anonymousReplacedElement = document2.createElement("html2canvaspseudoelement");
        copyCSSStyles(style, anonymousReplacedElement);
        declaration.content.forEach(function(token) {
          if (token.type === 0) {
            anonymousReplacedElement.appendChild(document2.createTextNode(token.value));
          } else if (token.type === 22) {
            var img = document2.createElement("img");
            img.src = token.value;
            img.style.opacity = "1";
            anonymousReplacedElement.appendChild(img);
          } else if (token.type === 18) {
            if (token.name === "attr") {
              var attr = token.values.filter(isIdentToken);
              if (attr.length) {
                anonymousReplacedElement.appendChild(document2.createTextNode(node.getAttribute(attr[0].value) || ""));
              }
            } else if (token.name === "counter") {
              var _a2 = token.values.filter(nonFunctionArgSeparator), counter = _a2[0], counterStyle = _a2[1];
              if (counter && isIdentToken(counter)) {
                var counterState = _this.counters.getCounterValue(counter.value);
                var counterType = counterStyle && isIdentToken(counterStyle) ? listStyleType.parse(_this.context, counterStyle.value) : 3;
                anonymousReplacedElement.appendChild(document2.createTextNode(createCounterText(counterState, counterType, false)));
              }
            } else if (token.name === "counters") {
              var _b = token.values.filter(nonFunctionArgSeparator), counter = _b[0], delim = _b[1], counterStyle = _b[2];
              if (counter && isIdentToken(counter)) {
                var counterStates = _this.counters.getCounterValues(counter.value);
                var counterType_1 = counterStyle && isIdentToken(counterStyle) ? listStyleType.parse(_this.context, counterStyle.value) : 3;
                var separator = delim && delim.type === 0 ? delim.value : "";
                var text = counterStates.map(function(value2) {
                  return createCounterText(value2, counterType_1, false);
                }).join(separator);
                anonymousReplacedElement.appendChild(document2.createTextNode(text));
              }
            } else ;
          } else if (token.type === 20) {
            switch (token.value) {
              case "open-quote":
                anonymousReplacedElement.appendChild(document2.createTextNode(getQuote(declaration.quotes, _this.quoteDepth++, true)));
                break;
              case "close-quote":
                anonymousReplacedElement.appendChild(document2.createTextNode(getQuote(declaration.quotes, --_this.quoteDepth, false)));
                break;
              default:
                anonymousReplacedElement.appendChild(document2.createTextNode(token.value));
            }
          }
        });
        anonymousReplacedElement.className = PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
        var newClassName = pseudoElt === PseudoElementType.BEFORE ? " " + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE : " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
        if (isSVGElementNode(clone)) {
          clone.className.baseValue += newClassName;
        } else {
          clone.className += newClassName;
        }
        return anonymousReplacedElement;
      };
      DocumentCloner2.destroy = function(container) {
        if (container.parentNode) {
          container.parentNode.removeChild(container);
          return true;
        }
        return false;
      };
      return DocumentCloner2;
    })();
    (function(PseudoElementType2) {
      PseudoElementType2[PseudoElementType2["BEFORE"] = 0] = "BEFORE";
      PseudoElementType2[PseudoElementType2["AFTER"] = 1] = "AFTER";
    })(PseudoElementType || (PseudoElementType = {}));
    createIFrameContainer = function(ownerDocument, bounds) {
      var cloneIframeContainer = ownerDocument.createElement("iframe");
      cloneIframeContainer.className = "html2canvas-container";
      cloneIframeContainer.style.visibility = "hidden";
      cloneIframeContainer.style.position = "fixed";
      cloneIframeContainer.style.left = "-10000px";
      cloneIframeContainer.style.top = "0px";
      cloneIframeContainer.style.border = "0";
      cloneIframeContainer.width = bounds.width.toString();
      cloneIframeContainer.height = bounds.height.toString();
      cloneIframeContainer.scrolling = "no";
      cloneIframeContainer.setAttribute(IGNORE_ATTRIBUTE, "true");
      ownerDocument.body.appendChild(cloneIframeContainer);
      return cloneIframeContainer;
    };
    imageReady = function(img) {
      return new Promise(function(resolve) {
        if (img.complete) {
          resolve();
          return;
        }
        if (!img.src) {
          resolve();
          return;
        }
        img.onload = resolve;
        img.onerror = resolve;
      });
    };
    imagesReady = function(document2) {
      return Promise.all([].slice.call(document2.images, 0).map(imageReady));
    };
    iframeLoader = function(iframe) {
      return new Promise(function(resolve, reject) {
        var cloneWindow = iframe.contentWindow;
        if (!cloneWindow) {
          return reject("No window assigned for iframe");
        }
        var documentClone = cloneWindow.document;
        cloneWindow.onload = iframe.onload = function() {
          cloneWindow.onload = iframe.onload = null;
          var interval = setInterval(function() {
            if (documentClone.body.childNodes.length > 0 && documentClone.readyState === "complete") {
              clearInterval(interval);
              resolve(iframe);
            }
          }, 50);
        };
      });
    };
    ignoredStyleProperties = [
      "all",
      "d",
      "content"
      // Safari shows pseudoelements if content is set
    ];
    copyCSSStyles = function(style, target) {
      for (var i = style.length - 1; i >= 0; i--) {
        var property = style.item(i);
        if (ignoredStyleProperties.indexOf(property) === -1) {
          target.style.setProperty(property, style.getPropertyValue(property));
        }
      }
      return target;
    };
    serializeDoctype = function(doctype) {
      var str = "";
      if (doctype) {
        str += "<!DOCTYPE ";
        if (doctype.name) {
          str += doctype.name;
        }
        if (doctype.internalSubset) {
          str += doctype.internalSubset;
        }
        if (doctype.publicId) {
          str += '"' + doctype.publicId + '"';
        }
        if (doctype.systemId) {
          str += '"' + doctype.systemId + '"';
        }
        str += ">";
      }
      return str;
    };
    restoreOwnerScroll = function(ownerDocument, x, y) {
      if (ownerDocument && ownerDocument.defaultView && (x !== ownerDocument.defaultView.pageXOffset || y !== ownerDocument.defaultView.pageYOffset)) {
        ownerDocument.defaultView.scrollTo(x, y);
      }
    };
    restoreNodeScroll = function(_a2) {
      var element = _a2[0], x = _a2[1], y = _a2[2];
      element.scrollLeft = x;
      element.scrollTop = y;
    };
    PSEUDO_BEFORE = ":before";
    PSEUDO_AFTER = ":after";
    PSEUDO_HIDE_ELEMENT_CLASS_BEFORE = "___html2canvas___pseudoelement_before";
    PSEUDO_HIDE_ELEMENT_CLASS_AFTER = "___html2canvas___pseudoelement_after";
    PSEUDO_HIDE_ELEMENT_STYLE = '{\n    content: "" !important;\n    display: none !important;\n}';
    createPseudoHideStyles = function(body) {
      createStyles(body, "." + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + PSEUDO_BEFORE + PSEUDO_HIDE_ELEMENT_STYLE + "\n         ." + PSEUDO_HIDE_ELEMENT_CLASS_AFTER + PSEUDO_AFTER + PSEUDO_HIDE_ELEMENT_STYLE);
    };
    createStyles = function(body, styles) {
      var document2 = body.ownerDocument;
      if (document2) {
        var style = document2.createElement("style");
        style.textContent = styles;
        body.appendChild(style);
      }
    };
    CacheStorage = /** @class */
    (function() {
      function CacheStorage2() {
      }
      CacheStorage2.getOrigin = function(url) {
        var link = CacheStorage2._link;
        if (!link) {
          return "about:blank";
        }
        link.href = url;
        link.href = link.href;
        return link.protocol + link.hostname + link.port;
      };
      CacheStorage2.isSameOrigin = function(src) {
        return CacheStorage2.getOrigin(src) === CacheStorage2._origin;
      };
      CacheStorage2.setContext = function(window2) {
        CacheStorage2._link = window2.document.createElement("a");
        CacheStorage2._origin = CacheStorage2.getOrigin(window2.location.href);
      };
      CacheStorage2._origin = "about:blank";
      return CacheStorage2;
    })();
    Cache = /** @class */
    (function() {
      function Cache2(context, _options) {
        this.context = context;
        this._options = _options;
        this._cache = {};
      }
      Cache2.prototype.addImage = function(src) {
        var result = Promise.resolve();
        if (this.has(src)) {
          return result;
        }
        if (isBlobImage(src) || isRenderable(src)) {
          (this._cache[src] = this.loadImage(src)).catch(function() {
          });
          return result;
        }
        return result;
      };
      Cache2.prototype.match = function(src) {
        return this._cache[src];
      };
      Cache2.prototype.loadImage = function(key) {
        return __awaiter(this, void 0, void 0, function() {
          var isSameOrigin, useCORS, useProxy, src;
          var _this = this;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                isSameOrigin = CacheStorage.isSameOrigin(key);
                useCORS = !isInlineImage(key) && this._options.useCORS === true && FEATURES.SUPPORT_CORS_IMAGES && !isSameOrigin;
                useProxy = !isInlineImage(key) && !isSameOrigin && !isBlobImage(key) && typeof this._options.proxy === "string" && FEATURES.SUPPORT_CORS_XHR && !useCORS;
                if (!isSameOrigin && this._options.allowTaint === false && !isInlineImage(key) && !isBlobImage(key) && !useProxy && !useCORS) {
                  return [
                    2
                    /*return*/
                  ];
                }
                src = key;
                if (!useProxy) return [3, 2];
                return [4, this.proxy(src)];
              case 1:
                src = _a2.sent();
                _a2.label = 2;
              case 2:
                this.context.logger.debug("Added image " + key.substring(0, 256));
                return [4, new Promise(function(resolve, reject) {
                  var img = new Image();
                  img.onload = function() {
                    return resolve(img);
                  };
                  img.onerror = reject;
                  if (isInlineBase64Image(src) || useCORS) {
                    img.crossOrigin = "anonymous";
                  }
                  img.src = src;
                  if (img.complete === true) {
                    setTimeout(function() {
                      return resolve(img);
                    }, 500);
                  }
                  if (_this._options.imageTimeout > 0) {
                    setTimeout(function() {
                      return reject("Timed out (" + _this._options.imageTimeout + "ms) loading image");
                    }, _this._options.imageTimeout);
                  }
                })];
              case 3:
                return [2, _a2.sent()];
            }
          });
        });
      };
      Cache2.prototype.has = function(key) {
        return typeof this._cache[key] !== "undefined";
      };
      Cache2.prototype.keys = function() {
        return Promise.resolve(Object.keys(this._cache));
      };
      Cache2.prototype.proxy = function(src) {
        var _this = this;
        var proxy = this._options.proxy;
        if (!proxy) {
          throw new Error("No proxy defined");
        }
        var key = src.substring(0, 256);
        return new Promise(function(resolve, reject) {
          var responseType = FEATURES.SUPPORT_RESPONSE_TYPE ? "blob" : "text";
          var xhr = new XMLHttpRequest();
          xhr.onload = function() {
            if (xhr.status === 200) {
              if (responseType === "text") {
                resolve(xhr.response);
              } else {
                var reader_1 = new FileReader();
                reader_1.addEventListener("load", function() {
                  return resolve(reader_1.result);
                }, false);
                reader_1.addEventListener("error", function(e2) {
                  return reject(e2);
                }, false);
                reader_1.readAsDataURL(xhr.response);
              }
            } else {
              reject("Failed to proxy resource " + key + " with status code " + xhr.status);
            }
          };
          xhr.onerror = reject;
          var queryString = proxy.indexOf("?") > -1 ? "&" : "?";
          xhr.open("GET", "" + proxy + queryString + "url=" + encodeURIComponent(src) + "&responseType=" + responseType);
          if (responseType !== "text" && xhr instanceof XMLHttpRequest) {
            xhr.responseType = responseType;
          }
          if (_this._options.imageTimeout) {
            var timeout_1 = _this._options.imageTimeout;
            xhr.timeout = timeout_1;
            xhr.ontimeout = function() {
              return reject("Timed out (" + timeout_1 + "ms) proxying " + key);
            };
          }
          xhr.send();
        });
      };
      return Cache2;
    })();
    INLINE_SVG = /^data:image\/svg\+xml/i;
    INLINE_BASE64 = /^data:image\/.*;base64,/i;
    INLINE_IMG = /^data:image\/.*/i;
    isRenderable = function(src) {
      return FEATURES.SUPPORT_SVG_DRAWING || !isSVG(src);
    };
    isInlineImage = function(src) {
      return INLINE_IMG.test(src);
    };
    isInlineBase64Image = function(src) {
      return INLINE_BASE64.test(src);
    };
    isBlobImage = function(src) {
      return src.substr(0, 4) === "blob";
    };
    isSVG = function(src) {
      return src.substr(-3).toLowerCase() === "svg" || INLINE_SVG.test(src);
    };
    Vector = /** @class */
    (function() {
      function Vector2(x, y) {
        this.type = 0;
        this.x = x;
        this.y = y;
      }
      Vector2.prototype.add = function(deltaX, deltaY) {
        return new Vector2(this.x + deltaX, this.y + deltaY);
      };
      return Vector2;
    })();
    lerp = function(a2, b, t) {
      return new Vector(a2.x + (b.x - a2.x) * t, a2.y + (b.y - a2.y) * t);
    };
    BezierCurve = /** @class */
    (function() {
      function BezierCurve2(start, startControl, endControl, end) {
        this.type = 1;
        this.start = start;
        this.startControl = startControl;
        this.endControl = endControl;
        this.end = end;
      }
      BezierCurve2.prototype.subdivide = function(t, firstHalf) {
        var ab = lerp(this.start, this.startControl, t);
        var bc = lerp(this.startControl, this.endControl, t);
        var cd = lerp(this.endControl, this.end, t);
        var abbc = lerp(ab, bc, t);
        var bccd = lerp(bc, cd, t);
        var dest = lerp(abbc, bccd, t);
        return firstHalf ? new BezierCurve2(this.start, ab, abbc, dest) : new BezierCurve2(dest, bccd, cd, this.end);
      };
      BezierCurve2.prototype.add = function(deltaX, deltaY) {
        return new BezierCurve2(this.start.add(deltaX, deltaY), this.startControl.add(deltaX, deltaY), this.endControl.add(deltaX, deltaY), this.end.add(deltaX, deltaY));
      };
      BezierCurve2.prototype.reverse = function() {
        return new BezierCurve2(this.end, this.endControl, this.startControl, this.start);
      };
      return BezierCurve2;
    })();
    isBezierCurve = function(path) {
      return path.type === 1;
    };
    BoundCurves = /** @class */
    /* @__PURE__ */ (function() {
      function BoundCurves2(element) {
        var styles = element.styles;
        var bounds = element.bounds;
        var _a2 = getAbsoluteValueForTuple(styles.borderTopLeftRadius, bounds.width, bounds.height), tlh = _a2[0], tlv = _a2[1];
        var _b = getAbsoluteValueForTuple(styles.borderTopRightRadius, bounds.width, bounds.height), trh = _b[0], trv = _b[1];
        var _c = getAbsoluteValueForTuple(styles.borderBottomRightRadius, bounds.width, bounds.height), brh = _c[0], brv = _c[1];
        var _d = getAbsoluteValueForTuple(styles.borderBottomLeftRadius, bounds.width, bounds.height), blh = _d[0], blv = _d[1];
        var factors = [];
        factors.push((tlh + trh) / bounds.width);
        factors.push((blh + brh) / bounds.width);
        factors.push((tlv + blv) / bounds.height);
        factors.push((trv + brv) / bounds.height);
        var maxFactor = Math.max.apply(Math, factors);
        if (maxFactor > 1) {
          tlh /= maxFactor;
          tlv /= maxFactor;
          trh /= maxFactor;
          trv /= maxFactor;
          brh /= maxFactor;
          brv /= maxFactor;
          blh /= maxFactor;
          blv /= maxFactor;
        }
        var topWidth = bounds.width - trh;
        var rightHeight = bounds.height - brv;
        var bottomWidth = bounds.width - brh;
        var leftHeight = bounds.height - blv;
        var borderTopWidth2 = styles.borderTopWidth;
        var borderRightWidth2 = styles.borderRightWidth;
        var borderBottomWidth2 = styles.borderBottomWidth;
        var borderLeftWidth2 = styles.borderLeftWidth;
        var paddingTop2 = getAbsoluteValue(styles.paddingTop, element.bounds.width);
        var paddingRight2 = getAbsoluteValue(styles.paddingRight, element.bounds.width);
        var paddingBottom2 = getAbsoluteValue(styles.paddingBottom, element.bounds.width);
        var paddingLeft2 = getAbsoluteValue(styles.paddingLeft, element.bounds.width);
        this.topLeftBorderDoubleOuterBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 3, bounds.top + borderTopWidth2 / 3, tlh - borderLeftWidth2 / 3, tlv - borderTopWidth2 / 3, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 3, bounds.top + borderTopWidth2 / 3);
        this.topRightBorderDoubleOuterBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 / 3, trh - borderRightWidth2 / 3, trv - borderTopWidth2 / 3, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 3, bounds.top + borderTopWidth2 / 3);
        this.bottomRightBorderDoubleOuterBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 / 3, brv - borderBottomWidth2 / 3, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 3, bounds.top + bounds.height - borderBottomWidth2 / 3);
        this.bottomLeftBorderDoubleOuterBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 3, bounds.top + leftHeight, blh - borderLeftWidth2 / 3, blv - borderBottomWidth2 / 3, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 3, bounds.top + bounds.height - borderBottomWidth2 / 3);
        this.topLeftBorderDoubleInnerBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3, tlh - borderLeftWidth2 * 2 / 3, tlv - borderTopWidth2 * 2 / 3, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3);
        this.topRightBorderDoubleInnerBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 * 2 / 3, trh - borderRightWidth2 * 2 / 3, trv - borderTopWidth2 * 2 / 3, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3);
        this.bottomRightBorderDoubleInnerBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 * 2 / 3, brv - borderBottomWidth2 * 2 / 3, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 * 2 / 3, bounds.top + bounds.height - borderBottomWidth2 * 2 / 3);
        this.bottomLeftBorderDoubleInnerBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + leftHeight, blh - borderLeftWidth2 * 2 / 3, blv - borderBottomWidth2 * 2 / 3, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + bounds.height - borderBottomWidth2 * 2 / 3);
        this.topLeftBorderStroke = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 2, bounds.top + borderTopWidth2 / 2, tlh - borderLeftWidth2 / 2, tlv - borderTopWidth2 / 2, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 2, bounds.top + borderTopWidth2 / 2);
        this.topRightBorderStroke = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 / 2, trh - borderRightWidth2 / 2, trv - borderTopWidth2 / 2, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 2, bounds.top + borderTopWidth2 / 2);
        this.bottomRightBorderStroke = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 / 2, brv - borderBottomWidth2 / 2, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 2, bounds.top + bounds.height - borderBottomWidth2 / 2);
        this.bottomLeftBorderStroke = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 2, bounds.top + leftHeight, blh - borderLeftWidth2 / 2, blv - borderBottomWidth2 / 2, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 2, bounds.top + bounds.height - borderBottomWidth2 / 2);
        this.topLeftBorderBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left, bounds.top, tlh, tlv, CORNER.TOP_LEFT) : new Vector(bounds.left, bounds.top);
        this.topRightBorderBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top, trh, trv, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width, bounds.top);
        this.bottomRightBorderBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh, brv, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width, bounds.top + bounds.height);
        this.bottomLeftBorderBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left, bounds.top + leftHeight, blh, blv, CORNER.BOTTOM_LEFT) : new Vector(bounds.left, bounds.top + bounds.height);
        this.topLeftPaddingBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2, bounds.top + borderTopWidth2, Math.max(0, tlh - borderLeftWidth2), Math.max(0, tlv - borderTopWidth2), CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2, bounds.top + borderTopWidth2);
        this.topRightPaddingBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width - borderRightWidth2), bounds.top + borderTopWidth2, topWidth > bounds.width + borderRightWidth2 ? 0 : Math.max(0, trh - borderRightWidth2), Math.max(0, trv - borderTopWidth2), CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2, bounds.top + borderTopWidth2);
        this.bottomRightPaddingBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - borderLeftWidth2), bounds.top + Math.min(rightHeight, bounds.height - borderBottomWidth2), Math.max(0, brh - borderRightWidth2), Math.max(0, brv - borderBottomWidth2), CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2, bounds.top + bounds.height - borderBottomWidth2);
        this.bottomLeftPaddingBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2, bounds.top + Math.min(leftHeight, bounds.height - borderBottomWidth2), Math.max(0, blh - borderLeftWidth2), Math.max(0, blv - borderBottomWidth2), CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2, bounds.top + bounds.height - borderBottomWidth2);
        this.topLeftContentBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + borderTopWidth2 + paddingTop2, Math.max(0, tlh - (borderLeftWidth2 + paddingLeft2)), Math.max(0, tlv - (borderTopWidth2 + paddingTop2)), CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + borderTopWidth2 + paddingTop2);
        this.topRightContentBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width + borderLeftWidth2 + paddingLeft2), bounds.top + borderTopWidth2 + paddingTop2, topWidth > bounds.width + borderLeftWidth2 + paddingLeft2 ? 0 : trh - borderLeftWidth2 + paddingLeft2, trv - (borderTopWidth2 + paddingTop2), CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - (borderRightWidth2 + paddingRight2), bounds.top + borderTopWidth2 + paddingTop2);
        this.bottomRightContentBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - (borderLeftWidth2 + paddingLeft2)), bounds.top + Math.min(rightHeight, bounds.height + borderTopWidth2 + paddingTop2), Math.max(0, brh - (borderRightWidth2 + paddingRight2)), brv - (borderBottomWidth2 + paddingBottom2), CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - (borderRightWidth2 + paddingRight2), bounds.top + bounds.height - (borderBottomWidth2 + paddingBottom2));
        this.bottomLeftContentBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + leftHeight, Math.max(0, blh - (borderLeftWidth2 + paddingLeft2)), blv - (borderBottomWidth2 + paddingBottom2), CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + bounds.height - (borderBottomWidth2 + paddingBottom2));
      }
      return BoundCurves2;
    })();
    (function(CORNER2) {
      CORNER2[CORNER2["TOP_LEFT"] = 0] = "TOP_LEFT";
      CORNER2[CORNER2["TOP_RIGHT"] = 1] = "TOP_RIGHT";
      CORNER2[CORNER2["BOTTOM_RIGHT"] = 2] = "BOTTOM_RIGHT";
      CORNER2[CORNER2["BOTTOM_LEFT"] = 3] = "BOTTOM_LEFT";
    })(CORNER || (CORNER = {}));
    getCurvePoints = function(x, y, r1, r2, position2) {
      var kappa = 4 * ((Math.sqrt(2) - 1) / 3);
      var ox = r1 * kappa;
      var oy = r2 * kappa;
      var xm = x + r1;
      var ym = y + r2;
      switch (position2) {
        case CORNER.TOP_LEFT:
          return new BezierCurve(new Vector(x, ym), new Vector(x, ym - oy), new Vector(xm - ox, y), new Vector(xm, y));
        case CORNER.TOP_RIGHT:
          return new BezierCurve(new Vector(x, y), new Vector(x + ox, y), new Vector(xm, ym - oy), new Vector(xm, ym));
        case CORNER.BOTTOM_RIGHT:
          return new BezierCurve(new Vector(xm, y), new Vector(xm, y + oy), new Vector(x + ox, ym), new Vector(x, ym));
        case CORNER.BOTTOM_LEFT:
        default:
          return new BezierCurve(new Vector(xm, ym), new Vector(xm - ox, ym), new Vector(x, y + oy), new Vector(x, y));
      }
    };
    calculateBorderBoxPath = function(curves) {
      return [curves.topLeftBorderBox, curves.topRightBorderBox, curves.bottomRightBorderBox, curves.bottomLeftBorderBox];
    };
    calculateContentBoxPath = function(curves) {
      return [
        curves.topLeftContentBox,
        curves.topRightContentBox,
        curves.bottomRightContentBox,
        curves.bottomLeftContentBox
      ];
    };
    calculatePaddingBoxPath = function(curves) {
      return [
        curves.topLeftPaddingBox,
        curves.topRightPaddingBox,
        curves.bottomRightPaddingBox,
        curves.bottomLeftPaddingBox
      ];
    };
    TransformEffect = /** @class */
    /* @__PURE__ */ (function() {
      function TransformEffect2(offsetX, offsetY, matrix2) {
        this.offsetX = offsetX;
        this.offsetY = offsetY;
        this.matrix = matrix2;
        this.type = 0;
        this.target = 2 | 4;
      }
      return TransformEffect2;
    })();
    ClipEffect = /** @class */
    /* @__PURE__ */ (function() {
      function ClipEffect2(path, target) {
        this.path = path;
        this.target = target;
        this.type = 1;
      }
      return ClipEffect2;
    })();
    OpacityEffect = /** @class */
    /* @__PURE__ */ (function() {
      function OpacityEffect2(opacity2) {
        this.opacity = opacity2;
        this.type = 2;
        this.target = 2 | 4;
      }
      return OpacityEffect2;
    })();
    isTransformEffect = function(effect) {
      return effect.type === 0;
    };
    isClipEffect = function(effect) {
      return effect.type === 1;
    };
    isOpacityEffect = function(effect) {
      return effect.type === 2;
    };
    equalPath = function(a2, b) {
      if (a2.length === b.length) {
        return a2.some(function(v, i) {
          return v === b[i];
        });
      }
      return false;
    };
    transformPath = function(path, deltaX, deltaY, deltaW, deltaH) {
      return path.map(function(point, index) {
        switch (index) {
          case 0:
            return point.add(deltaX, deltaY);
          case 1:
            return point.add(deltaX + deltaW, deltaY);
          case 2:
            return point.add(deltaX + deltaW, deltaY + deltaH);
          case 3:
            return point.add(deltaX, deltaY + deltaH);
        }
        return point;
      });
    };
    StackingContext = /** @class */
    /* @__PURE__ */ (function() {
      function StackingContext2(container) {
        this.element = container;
        this.inlineLevel = [];
        this.nonInlineLevel = [];
        this.negativeZIndex = [];
        this.zeroOrAutoZIndexOrTransformedOrOpacity = [];
        this.positiveZIndex = [];
        this.nonPositionedFloats = [];
        this.nonPositionedInlineLevel = [];
      }
      return StackingContext2;
    })();
    ElementPaint = /** @class */
    (function() {
      function ElementPaint2(container, parent) {
        this.container = container;
        this.parent = parent;
        this.effects = [];
        this.curves = new BoundCurves(this.container);
        if (this.container.styles.opacity < 1) {
          this.effects.push(new OpacityEffect(this.container.styles.opacity));
        }
        if (this.container.styles.transform !== null) {
          var offsetX = this.container.bounds.left + this.container.styles.transformOrigin[0].number;
          var offsetY = this.container.bounds.top + this.container.styles.transformOrigin[1].number;
          var matrix2 = this.container.styles.transform;
          this.effects.push(new TransformEffect(offsetX, offsetY, matrix2));
        }
        if (this.container.styles.overflowX !== 0) {
          var borderBox = calculateBorderBoxPath(this.curves);
          var paddingBox2 = calculatePaddingBoxPath(this.curves);
          if (equalPath(borderBox, paddingBox2)) {
            this.effects.push(new ClipEffect(
              borderBox,
              2 | 4
              /* CONTENT */
            ));
          } else {
            this.effects.push(new ClipEffect(
              borderBox,
              2
              /* BACKGROUND_BORDERS */
            ));
            this.effects.push(new ClipEffect(
              paddingBox2,
              4
              /* CONTENT */
            ));
          }
        }
      }
      ElementPaint2.prototype.getEffects = function(target) {
        var inFlow = [
          2,
          3
          /* FIXED */
        ].indexOf(this.container.styles.position) === -1;
        var parent = this.parent;
        var effects = this.effects.slice(0);
        while (parent) {
          var croplessEffects = parent.effects.filter(function(effect) {
            return !isClipEffect(effect);
          });
          if (inFlow || parent.container.styles.position !== 0 || !parent.parent) {
            effects.unshift.apply(effects, croplessEffects);
            inFlow = [
              2,
              3
              /* FIXED */
            ].indexOf(parent.container.styles.position) === -1;
            if (parent.container.styles.overflowX !== 0) {
              var borderBox = calculateBorderBoxPath(parent.curves);
              var paddingBox2 = calculatePaddingBoxPath(parent.curves);
              if (!equalPath(borderBox, paddingBox2)) {
                effects.unshift(new ClipEffect(
                  paddingBox2,
                  2 | 4
                  /* CONTENT */
                ));
              }
            }
          } else {
            effects.unshift.apply(effects, croplessEffects);
          }
          parent = parent.parent;
        }
        return effects.filter(function(effect) {
          return contains(effect.target, target);
        });
      };
      return ElementPaint2;
    })();
    parseStackTree = function(parent, stackingContext, realStackingContext, listItems) {
      parent.container.elements.forEach(function(child) {
        var treatAsRealStackingContext = contains(
          child.flags,
          4
          /* CREATES_REAL_STACKING_CONTEXT */
        );
        var createsStackingContext2 = contains(
          child.flags,
          2
          /* CREATES_STACKING_CONTEXT */
        );
        var paintContainer = new ElementPaint(child, parent);
        if (contains(
          child.styles.display,
          2048
          /* LIST_ITEM */
        )) {
          listItems.push(paintContainer);
        }
        var listOwnerItems = contains(
          child.flags,
          8
          /* IS_LIST_OWNER */
        ) ? [] : listItems;
        if (treatAsRealStackingContext || createsStackingContext2) {
          var parentStack = treatAsRealStackingContext || child.styles.isPositioned() ? realStackingContext : stackingContext;
          var stack = new StackingContext(paintContainer);
          if (child.styles.isPositioned() || child.styles.opacity < 1 || child.styles.isTransformed()) {
            var order_1 = child.styles.zIndex.order;
            if (order_1 < 0) {
              var index_1 = 0;
              parentStack.negativeZIndex.some(function(current, i) {
                if (order_1 > current.element.container.styles.zIndex.order) {
                  index_1 = i;
                  return false;
                } else if (index_1 > 0) {
                  return true;
                }
                return false;
              });
              parentStack.negativeZIndex.splice(index_1, 0, stack);
            } else if (order_1 > 0) {
              var index_2 = 0;
              parentStack.positiveZIndex.some(function(current, i) {
                if (order_1 >= current.element.container.styles.zIndex.order) {
                  index_2 = i + 1;
                  return false;
                } else if (index_2 > 0) {
                  return true;
                }
                return false;
              });
              parentStack.positiveZIndex.splice(index_2, 0, stack);
            } else {
              parentStack.zeroOrAutoZIndexOrTransformedOrOpacity.push(stack);
            }
          } else {
            if (child.styles.isFloating()) {
              parentStack.nonPositionedFloats.push(stack);
            } else {
              parentStack.nonPositionedInlineLevel.push(stack);
            }
          }
          parseStackTree(paintContainer, stack, treatAsRealStackingContext ? stack : realStackingContext, listOwnerItems);
        } else {
          if (child.styles.isInlineLevel()) {
            stackingContext.inlineLevel.push(paintContainer);
          } else {
            stackingContext.nonInlineLevel.push(paintContainer);
          }
          parseStackTree(paintContainer, stackingContext, realStackingContext, listOwnerItems);
        }
        if (contains(
          child.flags,
          8
          /* IS_LIST_OWNER */
        )) {
          processListItems(child, listOwnerItems);
        }
      });
    };
    processListItems = function(owner, elements) {
      var numbering = owner instanceof OLElementContainer ? owner.start : 1;
      var reversed = owner instanceof OLElementContainer ? owner.reversed : false;
      for (var i = 0; i < elements.length; i++) {
        var item = elements[i];
        if (item.container instanceof LIElementContainer && typeof item.container.value === "number" && item.container.value !== 0) {
          numbering = item.container.value;
        }
        item.listValue = createCounterText(numbering, item.container.styles.listStyleType, true);
        numbering += reversed ? -1 : 1;
      }
    };
    parseStackingContexts = function(container) {
      var paintContainer = new ElementPaint(container, null);
      var root = new StackingContext(paintContainer);
      var listItems = [];
      parseStackTree(paintContainer, root, root, listItems);
      processListItems(paintContainer.container, listItems);
      return root;
    };
    parsePathForBorder = function(curves, borderSide) {
      switch (borderSide) {
        case 0:
          return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftPaddingBox, curves.topRightBorderBox, curves.topRightPaddingBox);
        case 1:
          return createPathFromCurves(curves.topRightBorderBox, curves.topRightPaddingBox, curves.bottomRightBorderBox, curves.bottomRightPaddingBox);
        case 2:
          return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox);
        case 3:
        default:
          return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox, curves.topLeftBorderBox, curves.topLeftPaddingBox);
      }
    };
    parsePathForBorderDoubleOuter = function(curves, borderSide) {
      switch (borderSide) {
        case 0:
          return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox, curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox);
        case 1:
          return createPathFromCurves(curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox, curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox);
        case 2:
          return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox, curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox);
        case 3:
        default:
          return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox, curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox);
      }
    };
    parsePathForBorderDoubleInner = function(curves, borderSide) {
      switch (borderSide) {
        case 0:
          return createPathFromCurves(curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox, curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox);
        case 1:
          return createPathFromCurves(curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox, curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox);
        case 2:
          return createPathFromCurves(curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox);
        case 3:
        default:
          return createPathFromCurves(curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox, curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox);
      }
    };
    parsePathForBorderStroke = function(curves, borderSide) {
      switch (borderSide) {
        case 0:
          return createStrokePathFromCurves(curves.topLeftBorderStroke, curves.topRightBorderStroke);
        case 1:
          return createStrokePathFromCurves(curves.topRightBorderStroke, curves.bottomRightBorderStroke);
        case 2:
          return createStrokePathFromCurves(curves.bottomRightBorderStroke, curves.bottomLeftBorderStroke);
        case 3:
        default:
          return createStrokePathFromCurves(curves.bottomLeftBorderStroke, curves.topLeftBorderStroke);
      }
    };
    createStrokePathFromCurves = function(outer1, outer2) {
      var path = [];
      if (isBezierCurve(outer1)) {
        path.push(outer1.subdivide(0.5, false));
      } else {
        path.push(outer1);
      }
      if (isBezierCurve(outer2)) {
        path.push(outer2.subdivide(0.5, true));
      } else {
        path.push(outer2);
      }
      return path;
    };
    createPathFromCurves = function(outer1, inner1, outer2, inner2) {
      var path = [];
      if (isBezierCurve(outer1)) {
        path.push(outer1.subdivide(0.5, false));
      } else {
        path.push(outer1);
      }
      if (isBezierCurve(outer2)) {
        path.push(outer2.subdivide(0.5, true));
      } else {
        path.push(outer2);
      }
      if (isBezierCurve(inner2)) {
        path.push(inner2.subdivide(0.5, true).reverse());
      } else {
        path.push(inner2);
      }
      if (isBezierCurve(inner1)) {
        path.push(inner1.subdivide(0.5, false).reverse());
      } else {
        path.push(inner1);
      }
      return path;
    };
    paddingBox = function(element) {
      var bounds = element.bounds;
      var styles = element.styles;
      return bounds.add(styles.borderLeftWidth, styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth), -(styles.borderTopWidth + styles.borderBottomWidth));
    };
    contentBox = function(element) {
      var styles = element.styles;
      var bounds = element.bounds;
      var paddingLeft2 = getAbsoluteValue(styles.paddingLeft, bounds.width);
      var paddingRight2 = getAbsoluteValue(styles.paddingRight, bounds.width);
      var paddingTop2 = getAbsoluteValue(styles.paddingTop, bounds.width);
      var paddingBottom2 = getAbsoluteValue(styles.paddingBottom, bounds.width);
      return bounds.add(paddingLeft2 + styles.borderLeftWidth, paddingTop2 + styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth + paddingLeft2 + paddingRight2), -(styles.borderTopWidth + styles.borderBottomWidth + paddingTop2 + paddingBottom2));
    };
    calculateBackgroundPositioningArea = function(backgroundOrigin2, element) {
      if (backgroundOrigin2 === 0) {
        return element.bounds;
      }
      if (backgroundOrigin2 === 2) {
        return contentBox(element);
      }
      return paddingBox(element);
    };
    calculateBackgroundPaintingArea = function(backgroundClip2, element) {
      if (backgroundClip2 === 0) {
        return element.bounds;
      }
      if (backgroundClip2 === 2) {
        return contentBox(element);
      }
      return paddingBox(element);
    };
    calculateBackgroundRendering = function(container, index, intrinsicSize) {
      var backgroundPositioningArea = calculateBackgroundPositioningArea(getBackgroundValueForIndex(container.styles.backgroundOrigin, index), container);
      var backgroundPaintingArea = calculateBackgroundPaintingArea(getBackgroundValueForIndex(container.styles.backgroundClip, index), container);
      var backgroundImageSize = calculateBackgroundSize(getBackgroundValueForIndex(container.styles.backgroundSize, index), intrinsicSize, backgroundPositioningArea);
      var sizeWidth = backgroundImageSize[0], sizeHeight = backgroundImageSize[1];
      var position2 = getAbsoluteValueForTuple(getBackgroundValueForIndex(container.styles.backgroundPosition, index), backgroundPositioningArea.width - sizeWidth, backgroundPositioningArea.height - sizeHeight);
      var path = calculateBackgroundRepeatPath(getBackgroundValueForIndex(container.styles.backgroundRepeat, index), position2, backgroundImageSize, backgroundPositioningArea, backgroundPaintingArea);
      var offsetX = Math.round(backgroundPositioningArea.left + position2[0]);
      var offsetY = Math.round(backgroundPositioningArea.top + position2[1]);
      return [path, offsetX, offsetY, sizeWidth, sizeHeight];
    };
    isAuto = function(token) {
      return isIdentToken(token) && token.value === BACKGROUND_SIZE.AUTO;
    };
    hasIntrinsicValue = function(value) {
      return typeof value === "number";
    };
    calculateBackgroundSize = function(size, _a2, bounds) {
      var intrinsicWidth = _a2[0], intrinsicHeight = _a2[1], intrinsicProportion = _a2[2];
      var first = size[0], second = size[1];
      if (!first) {
        return [0, 0];
      }
      if (isLengthPercentage(first) && second && isLengthPercentage(second)) {
        return [getAbsoluteValue(first, bounds.width), getAbsoluteValue(second, bounds.height)];
      }
      var hasIntrinsicProportion = hasIntrinsicValue(intrinsicProportion);
      if (isIdentToken(first) && (first.value === BACKGROUND_SIZE.CONTAIN || first.value === BACKGROUND_SIZE.COVER)) {
        if (hasIntrinsicValue(intrinsicProportion)) {
          var targetRatio = bounds.width / bounds.height;
          return targetRatio < intrinsicProportion !== (first.value === BACKGROUND_SIZE.COVER) ? [bounds.width, bounds.width / intrinsicProportion] : [bounds.height * intrinsicProportion, bounds.height];
        }
        return [bounds.width, bounds.height];
      }
      var hasIntrinsicWidth = hasIntrinsicValue(intrinsicWidth);
      var hasIntrinsicHeight = hasIntrinsicValue(intrinsicHeight);
      var hasIntrinsicDimensions = hasIntrinsicWidth || hasIntrinsicHeight;
      if (isAuto(first) && (!second || isAuto(second))) {
        if (hasIntrinsicWidth && hasIntrinsicHeight) {
          return [intrinsicWidth, intrinsicHeight];
        }
        if (!hasIntrinsicProportion && !hasIntrinsicDimensions) {
          return [bounds.width, bounds.height];
        }
        if (hasIntrinsicDimensions && hasIntrinsicProportion) {
          var width_1 = hasIntrinsicWidth ? intrinsicWidth : intrinsicHeight * intrinsicProportion;
          var height_1 = hasIntrinsicHeight ? intrinsicHeight : intrinsicWidth / intrinsicProportion;
          return [width_1, height_1];
        }
        var width_2 = hasIntrinsicWidth ? intrinsicWidth : bounds.width;
        var height_2 = hasIntrinsicHeight ? intrinsicHeight : bounds.height;
        return [width_2, height_2];
      }
      if (hasIntrinsicProportion) {
        var width_3 = 0;
        var height_3 = 0;
        if (isLengthPercentage(first)) {
          width_3 = getAbsoluteValue(first, bounds.width);
        } else if (isLengthPercentage(second)) {
          height_3 = getAbsoluteValue(second, bounds.height);
        }
        if (isAuto(first)) {
          width_3 = height_3 * intrinsicProportion;
        } else if (!second || isAuto(second)) {
          height_3 = width_3 / intrinsicProportion;
        }
        return [width_3, height_3];
      }
      var width = null;
      var height = null;
      if (isLengthPercentage(first)) {
        width = getAbsoluteValue(first, bounds.width);
      } else if (second && isLengthPercentage(second)) {
        height = getAbsoluteValue(second, bounds.height);
      }
      if (width !== null && (!second || isAuto(second))) {
        height = hasIntrinsicWidth && hasIntrinsicHeight ? width / intrinsicWidth * intrinsicHeight : bounds.height;
      }
      if (height !== null && isAuto(first)) {
        width = hasIntrinsicWidth && hasIntrinsicHeight ? height / intrinsicHeight * intrinsicWidth : bounds.width;
      }
      if (width !== null && height !== null) {
        return [width, height];
      }
      throw new Error("Unable to calculate background-size for element");
    };
    getBackgroundValueForIndex = function(values, index) {
      var value = values[index];
      if (typeof value === "undefined") {
        return values[0];
      }
      return value;
    };
    calculateBackgroundRepeatPath = function(repeat, _a2, _b, backgroundPositioningArea, backgroundPaintingArea) {
      var x = _a2[0], y = _a2[1];
      var width = _b[0], height = _b[1];
      switch (repeat) {
        case 2:
          return [
            new Vector(Math.round(backgroundPositioningArea.left), Math.round(backgroundPositioningArea.top + y)),
            new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(backgroundPositioningArea.top + y)),
            new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(height + backgroundPositioningArea.top + y)),
            new Vector(Math.round(backgroundPositioningArea.left), Math.round(height + backgroundPositioningArea.top + y))
          ];
        case 3:
          return [
            new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.top)),
            new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.top)),
            new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top)),
            new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top))
          ];
        case 1:
          return [
            new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.top + y)),
            new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.top + y)),
            new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.top + y + height)),
            new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.top + y + height))
          ];
        default:
          return [
            new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.top)),
            new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.top)),
            new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top)),
            new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top))
          ];
      }
    };
    SMALL_IMAGE = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
    SAMPLE_TEXT = "Hidden Text";
    FontMetrics = /** @class */
    (function() {
      function FontMetrics2(document2) {
        this._data = {};
        this._document = document2;
      }
      FontMetrics2.prototype.parseMetrics = function(fontFamily2, fontSize2) {
        var container = this._document.createElement("div");
        var img = this._document.createElement("img");
        var span = this._document.createElement("span");
        var body = this._document.body;
        container.style.visibility = "hidden";
        container.style.fontFamily = fontFamily2;
        container.style.fontSize = fontSize2;
        container.style.margin = "0";
        container.style.padding = "0";
        container.style.whiteSpace = "nowrap";
        body.appendChild(container);
        img.src = SMALL_IMAGE;
        img.width = 1;
        img.height = 1;
        img.style.margin = "0";
        img.style.padding = "0";
        img.style.verticalAlign = "baseline";
        span.style.fontFamily = fontFamily2;
        span.style.fontSize = fontSize2;
        span.style.margin = "0";
        span.style.padding = "0";
        span.appendChild(this._document.createTextNode(SAMPLE_TEXT));
        container.appendChild(span);
        container.appendChild(img);
        var baseline = img.offsetTop - span.offsetTop + 2;
        container.removeChild(span);
        container.appendChild(this._document.createTextNode(SAMPLE_TEXT));
        container.style.lineHeight = "normal";
        img.style.verticalAlign = "super";
        var middle = img.offsetTop - container.offsetTop + 2;
        body.removeChild(container);
        return { baseline, middle };
      };
      FontMetrics2.prototype.getMetrics = function(fontFamily2, fontSize2) {
        var key = fontFamily2 + " " + fontSize2;
        if (typeof this._data[key] === "undefined") {
          this._data[key] = this.parseMetrics(fontFamily2, fontSize2);
        }
        return this._data[key];
      };
      return FontMetrics2;
    })();
    Renderer = /** @class */
    /* @__PURE__ */ (function() {
      function Renderer3(context, options) {
        this.context = context;
        this.options = options;
      }
      return Renderer3;
    })();
    MASK_OFFSET = 1e4;
    CanvasRenderer = /** @class */
    (function(_super) {
      __extends(CanvasRenderer2, _super);
      function CanvasRenderer2(context, options) {
        var _this = _super.call(this, context, options) || this;
        _this._activeEffects = [];
        _this.canvas = options.canvas ? options.canvas : document.createElement("canvas");
        _this.ctx = _this.canvas.getContext("2d");
        if (!options.canvas) {
          _this.canvas.width = Math.floor(options.width * options.scale);
          _this.canvas.height = Math.floor(options.height * options.scale);
          _this.canvas.style.width = options.width + "px";
          _this.canvas.style.height = options.height + "px";
        }
        _this.fontMetrics = new FontMetrics(document);
        _this.ctx.scale(_this.options.scale, _this.options.scale);
        _this.ctx.translate(-options.x, -options.y);
        _this.ctx.textBaseline = "bottom";
        _this._activeEffects = [];
        _this.context.logger.debug("Canvas renderer initialized (" + options.width + "x" + options.height + ") with scale " + options.scale);
        return _this;
      }
      CanvasRenderer2.prototype.applyEffects = function(effects) {
        var _this = this;
        while (this._activeEffects.length) {
          this.popEffect();
        }
        effects.forEach(function(effect) {
          return _this.applyEffect(effect);
        });
      };
      CanvasRenderer2.prototype.applyEffect = function(effect) {
        this.ctx.save();
        if (isOpacityEffect(effect)) {
          this.ctx.globalAlpha = effect.opacity;
        }
        if (isTransformEffect(effect)) {
          this.ctx.translate(effect.offsetX, effect.offsetY);
          this.ctx.transform(effect.matrix[0], effect.matrix[1], effect.matrix[2], effect.matrix[3], effect.matrix[4], effect.matrix[5]);
          this.ctx.translate(-effect.offsetX, -effect.offsetY);
        }
        if (isClipEffect(effect)) {
          this.path(effect.path);
          this.ctx.clip();
        }
        this._activeEffects.push(effect);
      };
      CanvasRenderer2.prototype.popEffect = function() {
        this._activeEffects.pop();
        this.ctx.restore();
      };
      CanvasRenderer2.prototype.renderStack = function(stack) {
        return __awaiter(this, void 0, void 0, function() {
          var styles;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                styles = stack.element.container.styles;
                if (!styles.isVisible()) return [3, 2];
                return [4, this.renderStackContent(stack)];
              case 1:
                _a2.sent();
                _a2.label = 2;
              case 2:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      CanvasRenderer2.prototype.renderNode = function(paint) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                if (contains(
                  paint.container.flags,
                  16
                  /* DEBUG_RENDER */
                )) {
                  debugger;
                }
                if (!paint.container.styles.isVisible()) return [3, 3];
                return [4, this.renderNodeBackgroundAndBorders(paint)];
              case 1:
                _a2.sent();
                return [4, this.renderNodeContent(paint)];
              case 2:
                _a2.sent();
                _a2.label = 3;
              case 3:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      CanvasRenderer2.prototype.renderTextWithLetterSpacing = function(text, letterSpacing2, baseline) {
        var _this = this;
        if (letterSpacing2 === 0) {
          this.ctx.fillText(text.text, text.bounds.left, text.bounds.top + baseline);
        } else {
          var letters = segmentGraphemes(text.text);
          letters.reduce(function(left, letter) {
            _this.ctx.fillText(letter, left, text.bounds.top + baseline);
            return left + _this.ctx.measureText(letter).width;
          }, text.bounds.left);
        }
      };
      CanvasRenderer2.prototype.createFontStyle = function(styles) {
        var fontVariant2 = styles.fontVariant.filter(function(variant) {
          return variant === "normal" || variant === "small-caps";
        }).join("");
        var fontFamily2 = fixIOSSystemFonts(styles.fontFamily).join(", ");
        var fontSize2 = isDimensionToken(styles.fontSize) ? "" + styles.fontSize.number + styles.fontSize.unit : styles.fontSize.number + "px";
        return [
          [styles.fontStyle, fontVariant2, styles.fontWeight, fontSize2, fontFamily2].join(" "),
          fontFamily2,
          fontSize2
        ];
      };
      CanvasRenderer2.prototype.renderTextNode = function(text, styles) {
        return __awaiter(this, void 0, void 0, function() {
          var _a2, font, fontFamily2, fontSize2, _b, baseline, middle, paintOrder2;
          var _this = this;
          return __generator(this, function(_c) {
            _a2 = this.createFontStyle(styles), font = _a2[0], fontFamily2 = _a2[1], fontSize2 = _a2[2];
            this.ctx.font = font;
            this.ctx.direction = styles.direction === 1 ? "rtl" : "ltr";
            this.ctx.textAlign = "left";
            this.ctx.textBaseline = "alphabetic";
            _b = this.fontMetrics.getMetrics(fontFamily2, fontSize2), baseline = _b.baseline, middle = _b.middle;
            paintOrder2 = styles.paintOrder;
            text.textBounds.forEach(function(text2) {
              paintOrder2.forEach(function(paintOrderLayer) {
                switch (paintOrderLayer) {
                  case 0:
                    _this.ctx.fillStyle = asString(styles.color);
                    _this.renderTextWithLetterSpacing(text2, styles.letterSpacing, baseline);
                    var textShadows = styles.textShadow;
                    if (textShadows.length && text2.text.trim().length) {
                      textShadows.slice(0).reverse().forEach(function(textShadow2) {
                        _this.ctx.shadowColor = asString(textShadow2.color);
                        _this.ctx.shadowOffsetX = textShadow2.offsetX.number * _this.options.scale;
                        _this.ctx.shadowOffsetY = textShadow2.offsetY.number * _this.options.scale;
                        _this.ctx.shadowBlur = textShadow2.blur.number;
                        _this.renderTextWithLetterSpacing(text2, styles.letterSpacing, baseline);
                      });
                      _this.ctx.shadowColor = "";
                      _this.ctx.shadowOffsetX = 0;
                      _this.ctx.shadowOffsetY = 0;
                      _this.ctx.shadowBlur = 0;
                    }
                    if (styles.textDecorationLine.length) {
                      _this.ctx.fillStyle = asString(styles.textDecorationColor || styles.color);
                      styles.textDecorationLine.forEach(function(textDecorationLine2) {
                        switch (textDecorationLine2) {
                          case 1:
                            _this.ctx.fillRect(text2.bounds.left, Math.round(text2.bounds.top + baseline), text2.bounds.width, 1);
                            break;
                          case 2:
                            _this.ctx.fillRect(text2.bounds.left, Math.round(text2.bounds.top), text2.bounds.width, 1);
                            break;
                          case 3:
                            _this.ctx.fillRect(text2.bounds.left, Math.ceil(text2.bounds.top + middle), text2.bounds.width, 1);
                            break;
                        }
                      });
                    }
                    break;
                  case 1:
                    if (styles.webkitTextStrokeWidth && text2.text.trim().length) {
                      _this.ctx.strokeStyle = asString(styles.webkitTextStrokeColor);
                      _this.ctx.lineWidth = styles.webkitTextStrokeWidth;
                      _this.ctx.lineJoin = !!window.chrome ? "miter" : "round";
                      _this.ctx.strokeText(text2.text, text2.bounds.left, text2.bounds.top + baseline);
                    }
                    _this.ctx.strokeStyle = "";
                    _this.ctx.lineWidth = 0;
                    _this.ctx.lineJoin = "miter";
                    break;
                }
              });
            });
            return [
              2
              /*return*/
            ];
          });
        });
      };
      CanvasRenderer2.prototype.renderReplacedElement = function(container, curves, image2) {
        if (image2 && container.intrinsicWidth > 0 && container.intrinsicHeight > 0) {
          var box = contentBox(container);
          var path = calculatePaddingBoxPath(curves);
          this.path(path);
          this.ctx.save();
          this.ctx.clip();
          this.ctx.drawImage(image2, 0, 0, container.intrinsicWidth, container.intrinsicHeight, box.left, box.top, box.width, box.height);
          this.ctx.restore();
        }
      };
      CanvasRenderer2.prototype.renderNodeContent = function(paint) {
        return __awaiter(this, void 0, void 0, function() {
          var container, curves, styles, _i, _a2, child, image2, image2, iframeRenderer, canvas, size, _b, fontFamily2, fontSize2, baseline, bounds, x, textBounds, img, image2, url, fontFamily2, bounds;
          return __generator(this, function(_c) {
            switch (_c.label) {
              case 0:
                this.applyEffects(paint.getEffects(
                  4
                  /* CONTENT */
                ));
                container = paint.container;
                curves = paint.curves;
                styles = container.styles;
                _i = 0, _a2 = container.textNodes;
                _c.label = 1;
              case 1:
                if (!(_i < _a2.length)) return [3, 4];
                child = _a2[_i];
                return [4, this.renderTextNode(child, styles)];
              case 2:
                _c.sent();
                _c.label = 3;
              case 3:
                _i++;
                return [3, 1];
              case 4:
                if (!(container instanceof ImageElementContainer)) return [3, 8];
                _c.label = 5;
              case 5:
                _c.trys.push([5, 7, , 8]);
                return [4, this.context.cache.match(container.src)];
              case 6:
                image2 = _c.sent();
                this.renderReplacedElement(container, curves, image2);
                return [3, 8];
              case 7:
                _c.sent();
                this.context.logger.error("Error loading image " + container.src);
                return [3, 8];
              case 8:
                if (container instanceof CanvasElementContainer) {
                  this.renderReplacedElement(container, curves, container.canvas);
                }
                if (!(container instanceof SVGElementContainer)) return [3, 12];
                _c.label = 9;
              case 9:
                _c.trys.push([9, 11, , 12]);
                return [4, this.context.cache.match(container.svg)];
              case 10:
                image2 = _c.sent();
                this.renderReplacedElement(container, curves, image2);
                return [3, 12];
              case 11:
                _c.sent();
                this.context.logger.error("Error loading svg " + container.svg.substring(0, 255));
                return [3, 12];
              case 12:
                if (!(container instanceof IFrameElementContainer && container.tree)) return [3, 14];
                iframeRenderer = new CanvasRenderer2(this.context, {
                  scale: this.options.scale,
                  backgroundColor: container.backgroundColor,
                  x: 0,
                  y: 0,
                  width: container.width,
                  height: container.height
                });
                return [4, iframeRenderer.render(container.tree)];
              case 13:
                canvas = _c.sent();
                if (container.width && container.height) {
                  this.ctx.drawImage(canvas, 0, 0, container.width, container.height, container.bounds.left, container.bounds.top, container.bounds.width, container.bounds.height);
                }
                _c.label = 14;
              case 14:
                if (container instanceof InputElementContainer) {
                  size = Math.min(container.bounds.width, container.bounds.height);
                  if (container.type === CHECKBOX) {
                    if (container.checked) {
                      this.ctx.save();
                      this.path([
                        new Vector(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79),
                        new Vector(container.bounds.left + size * 0.16, container.bounds.top + size * 0.5549),
                        new Vector(container.bounds.left + size * 0.27347, container.bounds.top + size * 0.44071),
                        new Vector(container.bounds.left + size * 0.39694, container.bounds.top + size * 0.5649),
                        new Vector(container.bounds.left + size * 0.72983, container.bounds.top + size * 0.23),
                        new Vector(container.bounds.left + size * 0.84, container.bounds.top + size * 0.34085),
                        new Vector(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79)
                      ]);
                      this.ctx.fillStyle = asString(INPUT_COLOR);
                      this.ctx.fill();
                      this.ctx.restore();
                    }
                  } else if (container.type === RADIO) {
                    if (container.checked) {
                      this.ctx.save();
                      this.ctx.beginPath();
                      this.ctx.arc(container.bounds.left + size / 2, container.bounds.top + size / 2, size / 4, 0, Math.PI * 2, true);
                      this.ctx.fillStyle = asString(INPUT_COLOR);
                      this.ctx.fill();
                      this.ctx.restore();
                    }
                  }
                }
                if (isTextInputElement(container) && container.value.length) {
                  _b = this.createFontStyle(styles), fontFamily2 = _b[0], fontSize2 = _b[1];
                  baseline = this.fontMetrics.getMetrics(fontFamily2, fontSize2).baseline;
                  this.ctx.font = fontFamily2;
                  this.ctx.fillStyle = asString(styles.color);
                  this.ctx.textBaseline = "alphabetic";
                  this.ctx.textAlign = canvasTextAlign(container.styles.textAlign);
                  bounds = contentBox(container);
                  x = 0;
                  switch (container.styles.textAlign) {
                    case 1:
                      x += bounds.width / 2;
                      break;
                    case 2:
                      x += bounds.width;
                      break;
                  }
                  textBounds = bounds.add(x, 0, 0, -bounds.height / 2 + 1);
                  this.ctx.save();
                  this.path([
                    new Vector(bounds.left, bounds.top),
                    new Vector(bounds.left + bounds.width, bounds.top),
                    new Vector(bounds.left + bounds.width, bounds.top + bounds.height),
                    new Vector(bounds.left, bounds.top + bounds.height)
                  ]);
                  this.ctx.clip();
                  this.renderTextWithLetterSpacing(new TextBounds(container.value, textBounds), styles.letterSpacing, baseline);
                  this.ctx.restore();
                  this.ctx.textBaseline = "alphabetic";
                  this.ctx.textAlign = "left";
                }
                if (!contains(
                  container.styles.display,
                  2048
                  /* LIST_ITEM */
                )) return [3, 20];
                if (!(container.styles.listStyleImage !== null)) return [3, 19];
                img = container.styles.listStyleImage;
                if (!(img.type === 0)) return [3, 18];
                image2 = void 0;
                url = img.url;
                _c.label = 15;
              case 15:
                _c.trys.push([15, 17, , 18]);
                return [4, this.context.cache.match(url)];
              case 16:
                image2 = _c.sent();
                this.ctx.drawImage(image2, container.bounds.left - (image2.width + 10), container.bounds.top);
                return [3, 18];
              case 17:
                _c.sent();
                this.context.logger.error("Error loading list-style-image " + url);
                return [3, 18];
              case 18:
                return [3, 20];
              case 19:
                if (paint.listValue && container.styles.listStyleType !== -1) {
                  fontFamily2 = this.createFontStyle(styles)[0];
                  this.ctx.font = fontFamily2;
                  this.ctx.fillStyle = asString(styles.color);
                  this.ctx.textBaseline = "middle";
                  this.ctx.textAlign = "right";
                  bounds = new Bounds(container.bounds.left, container.bounds.top + getAbsoluteValue(container.styles.paddingTop, container.bounds.width), container.bounds.width, computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 1);
                  this.renderTextWithLetterSpacing(new TextBounds(paint.listValue, bounds), styles.letterSpacing, computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 2);
                  this.ctx.textBaseline = "bottom";
                  this.ctx.textAlign = "left";
                }
                _c.label = 20;
              case 20:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      CanvasRenderer2.prototype.renderStackContent = function(stack) {
        return __awaiter(this, void 0, void 0, function() {
          var _i, _a2, child, _b, _c, child, _d, _e, child, _f, _g, child, _h, _j, child, _k, _l, child, _m, _o, child;
          return __generator(this, function(_p) {
            switch (_p.label) {
              case 0:
                if (contains(
                  stack.element.container.flags,
                  16
                  /* DEBUG_RENDER */
                )) {
                  debugger;
                }
                return [4, this.renderNodeBackgroundAndBorders(stack.element)];
              case 1:
                _p.sent();
                _i = 0, _a2 = stack.negativeZIndex;
                _p.label = 2;
              case 2:
                if (!(_i < _a2.length)) return [3, 5];
                child = _a2[_i];
                return [4, this.renderStack(child)];
              case 3:
                _p.sent();
                _p.label = 4;
              case 4:
                _i++;
                return [3, 2];
              case 5:
                return [4, this.renderNodeContent(stack.element)];
              case 6:
                _p.sent();
                _b = 0, _c = stack.nonInlineLevel;
                _p.label = 7;
              case 7:
                if (!(_b < _c.length)) return [3, 10];
                child = _c[_b];
                return [4, this.renderNode(child)];
              case 8:
                _p.sent();
                _p.label = 9;
              case 9:
                _b++;
                return [3, 7];
              case 10:
                _d = 0, _e = stack.nonPositionedFloats;
                _p.label = 11;
              case 11:
                if (!(_d < _e.length)) return [3, 14];
                child = _e[_d];
                return [4, this.renderStack(child)];
              case 12:
                _p.sent();
                _p.label = 13;
              case 13:
                _d++;
                return [3, 11];
              case 14:
                _f = 0, _g = stack.nonPositionedInlineLevel;
                _p.label = 15;
              case 15:
                if (!(_f < _g.length)) return [3, 18];
                child = _g[_f];
                return [4, this.renderStack(child)];
              case 16:
                _p.sent();
                _p.label = 17;
              case 17:
                _f++;
                return [3, 15];
              case 18:
                _h = 0, _j = stack.inlineLevel;
                _p.label = 19;
              case 19:
                if (!(_h < _j.length)) return [3, 22];
                child = _j[_h];
                return [4, this.renderNode(child)];
              case 20:
                _p.sent();
                _p.label = 21;
              case 21:
                _h++;
                return [3, 19];
              case 22:
                _k = 0, _l = stack.zeroOrAutoZIndexOrTransformedOrOpacity;
                _p.label = 23;
              case 23:
                if (!(_k < _l.length)) return [3, 26];
                child = _l[_k];
                return [4, this.renderStack(child)];
              case 24:
                _p.sent();
                _p.label = 25;
              case 25:
                _k++;
                return [3, 23];
              case 26:
                _m = 0, _o = stack.positiveZIndex;
                _p.label = 27;
              case 27:
                if (!(_m < _o.length)) return [3, 30];
                child = _o[_m];
                return [4, this.renderStack(child)];
              case 28:
                _p.sent();
                _p.label = 29;
              case 29:
                _m++;
                return [3, 27];
              case 30:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      CanvasRenderer2.prototype.mask = function(paths) {
        this.ctx.beginPath();
        this.ctx.moveTo(0, 0);
        this.ctx.lineTo(this.canvas.width, 0);
        this.ctx.lineTo(this.canvas.width, this.canvas.height);
        this.ctx.lineTo(0, this.canvas.height);
        this.ctx.lineTo(0, 0);
        this.formatPath(paths.slice(0).reverse());
        this.ctx.closePath();
      };
      CanvasRenderer2.prototype.path = function(paths) {
        this.ctx.beginPath();
        this.formatPath(paths);
        this.ctx.closePath();
      };
      CanvasRenderer2.prototype.formatPath = function(paths) {
        var _this = this;
        paths.forEach(function(point, index) {
          var start = isBezierCurve(point) ? point.start : point;
          if (index === 0) {
            _this.ctx.moveTo(start.x, start.y);
          } else {
            _this.ctx.lineTo(start.x, start.y);
          }
          if (isBezierCurve(point)) {
            _this.ctx.bezierCurveTo(point.startControl.x, point.startControl.y, point.endControl.x, point.endControl.y, point.end.x, point.end.y);
          }
        });
      };
      CanvasRenderer2.prototype.renderRepeat = function(path, pattern, offsetX, offsetY) {
        this.path(path);
        this.ctx.fillStyle = pattern;
        this.ctx.translate(offsetX, offsetY);
        this.ctx.fill();
        this.ctx.translate(-offsetX, -offsetY);
      };
      CanvasRenderer2.prototype.resizeImage = function(image2, width, height) {
        var _a2;
        if (image2.width === width && image2.height === height) {
          return image2;
        }
        var ownerDocument = (_a2 = this.canvas.ownerDocument) !== null && _a2 !== void 0 ? _a2 : document;
        var canvas = ownerDocument.createElement("canvas");
        canvas.width = Math.max(1, width);
        canvas.height = Math.max(1, height);
        var ctx = canvas.getContext("2d");
        ctx.drawImage(image2, 0, 0, image2.width, image2.height, 0, 0, width, height);
        return canvas;
      };
      CanvasRenderer2.prototype.renderBackgroundImage = function(container) {
        return __awaiter(this, void 0, void 0, function() {
          var index, _loop_1, this_1, _i, _a2, backgroundImage2;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                index = container.styles.backgroundImage.length - 1;
                _loop_1 = function(backgroundImage3) {
                  var image2, url, _c, path, x, y, width, height, pattern, _d, path, x, y, width, height, _e, lineLength, x0, x1, y0, y1, canvas, ctx, gradient_1, pattern, _f, path, left, top_1, width, height, position2, x, y, _g, rx, ry, radialGradient_1, midX, midY, f2, invF;
                  return __generator(this, function(_h) {
                    switch (_h.label) {
                      case 0:
                        if (!(backgroundImage3.type === 0)) return [3, 5];
                        image2 = void 0;
                        url = backgroundImage3.url;
                        _h.label = 1;
                      case 1:
                        _h.trys.push([1, 3, , 4]);
                        return [4, this_1.context.cache.match(url)];
                      case 2:
                        image2 = _h.sent();
                        return [3, 4];
                      case 3:
                        _h.sent();
                        this_1.context.logger.error("Error loading background-image " + url);
                        return [3, 4];
                      case 4:
                        if (image2) {
                          _c = calculateBackgroundRendering(container, index, [
                            image2.width,
                            image2.height,
                            image2.width / image2.height
                          ]), path = _c[0], x = _c[1], y = _c[2], width = _c[3], height = _c[4];
                          pattern = this_1.ctx.createPattern(this_1.resizeImage(image2, width, height), "repeat");
                          this_1.renderRepeat(path, pattern, x, y);
                        }
                        return [3, 6];
                      case 5:
                        if (isLinearGradient(backgroundImage3)) {
                          _d = calculateBackgroundRendering(container, index, [null, null, null]), path = _d[0], x = _d[1], y = _d[2], width = _d[3], height = _d[4];
                          _e = calculateGradientDirection(backgroundImage3.angle, width, height), lineLength = _e[0], x0 = _e[1], x1 = _e[2], y0 = _e[3], y1 = _e[4];
                          canvas = document.createElement("canvas");
                          canvas.width = width;
                          canvas.height = height;
                          ctx = canvas.getContext("2d");
                          gradient_1 = ctx.createLinearGradient(x0, y0, x1, y1);
                          processColorStops(backgroundImage3.stops, lineLength).forEach(function(colorStop) {
                            return gradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
                          });
                          ctx.fillStyle = gradient_1;
                          ctx.fillRect(0, 0, width, height);
                          if (width > 0 && height > 0) {
                            pattern = this_1.ctx.createPattern(canvas, "repeat");
                            this_1.renderRepeat(path, pattern, x, y);
                          }
                        } else if (isRadialGradient(backgroundImage3)) {
                          _f = calculateBackgroundRendering(container, index, [
                            null,
                            null,
                            null
                          ]), path = _f[0], left = _f[1], top_1 = _f[2], width = _f[3], height = _f[4];
                          position2 = backgroundImage3.position.length === 0 ? [FIFTY_PERCENT] : backgroundImage3.position;
                          x = getAbsoluteValue(position2[0], width);
                          y = getAbsoluteValue(position2[position2.length - 1], height);
                          _g = calculateRadius(backgroundImage3, x, y, width, height), rx = _g[0], ry = _g[1];
                          if (rx > 0 && ry > 0) {
                            radialGradient_1 = this_1.ctx.createRadialGradient(left + x, top_1 + y, 0, left + x, top_1 + y, rx);
                            processColorStops(backgroundImage3.stops, rx * 2).forEach(function(colorStop) {
                              return radialGradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
                            });
                            this_1.path(path);
                            this_1.ctx.fillStyle = radialGradient_1;
                            if (rx !== ry) {
                              midX = container.bounds.left + 0.5 * container.bounds.width;
                              midY = container.bounds.top + 0.5 * container.bounds.height;
                              f2 = ry / rx;
                              invF = 1 / f2;
                              this_1.ctx.save();
                              this_1.ctx.translate(midX, midY);
                              this_1.ctx.transform(1, 0, 0, f2, 0, 0);
                              this_1.ctx.translate(-midX, -midY);
                              this_1.ctx.fillRect(left, invF * (top_1 - midY) + midY, width, height * invF);
                              this_1.ctx.restore();
                            } else {
                              this_1.ctx.fill();
                            }
                          }
                        }
                        _h.label = 6;
                      case 6:
                        index--;
                        return [
                          2
                          /*return*/
                        ];
                    }
                  });
                };
                this_1 = this;
                _i = 0, _a2 = container.styles.backgroundImage.slice(0).reverse();
                _b.label = 1;
              case 1:
                if (!(_i < _a2.length)) return [3, 4];
                backgroundImage2 = _a2[_i];
                return [5, _loop_1(backgroundImage2)];
              case 2:
                _b.sent();
                _b.label = 3;
              case 3:
                _i++;
                return [3, 1];
              case 4:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      CanvasRenderer2.prototype.renderSolidBorder = function(color2, side, curvePoints) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a2) {
            this.path(parsePathForBorder(curvePoints, side));
            this.ctx.fillStyle = asString(color2);
            this.ctx.fill();
            return [
              2
              /*return*/
            ];
          });
        });
      };
      CanvasRenderer2.prototype.renderDoubleBorder = function(color2, width, side, curvePoints) {
        return __awaiter(this, void 0, void 0, function() {
          var outerPaths, innerPaths;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                if (!(width < 3)) return [3, 2];
                return [4, this.renderSolidBorder(color2, side, curvePoints)];
              case 1:
                _a2.sent();
                return [
                  2
                  /*return*/
                ];
              case 2:
                outerPaths = parsePathForBorderDoubleOuter(curvePoints, side);
                this.path(outerPaths);
                this.ctx.fillStyle = asString(color2);
                this.ctx.fill();
                innerPaths = parsePathForBorderDoubleInner(curvePoints, side);
                this.path(innerPaths);
                this.ctx.fill();
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      CanvasRenderer2.prototype.renderNodeBackgroundAndBorders = function(paint) {
        return __awaiter(this, void 0, void 0, function() {
          var styles, hasBackground, borders, backgroundPaintingArea, side, _i, borders_1, border;
          var _this = this;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                this.applyEffects(paint.getEffects(
                  2
                  /* BACKGROUND_BORDERS */
                ));
                styles = paint.container.styles;
                hasBackground = !isTransparent(styles.backgroundColor) || styles.backgroundImage.length;
                borders = [
                  { style: styles.borderTopStyle, color: styles.borderTopColor, width: styles.borderTopWidth },
                  { style: styles.borderRightStyle, color: styles.borderRightColor, width: styles.borderRightWidth },
                  { style: styles.borderBottomStyle, color: styles.borderBottomColor, width: styles.borderBottomWidth },
                  { style: styles.borderLeftStyle, color: styles.borderLeftColor, width: styles.borderLeftWidth }
                ];
                backgroundPaintingArea = calculateBackgroundCurvedPaintingArea(getBackgroundValueForIndex(styles.backgroundClip, 0), paint.curves);
                if (!(hasBackground || styles.boxShadow.length)) return [3, 2];
                this.ctx.save();
                this.path(backgroundPaintingArea);
                this.ctx.clip();
                if (!isTransparent(styles.backgroundColor)) {
                  this.ctx.fillStyle = asString(styles.backgroundColor);
                  this.ctx.fill();
                }
                return [4, this.renderBackgroundImage(paint.container)];
              case 1:
                _a2.sent();
                this.ctx.restore();
                styles.boxShadow.slice(0).reverse().forEach(function(shadow) {
                  _this.ctx.save();
                  var borderBoxArea = calculateBorderBoxPath(paint.curves);
                  var maskOffset = shadow.inset ? 0 : MASK_OFFSET;
                  var shadowPaintingArea = transformPath(borderBoxArea, -maskOffset + (shadow.inset ? 1 : -1) * shadow.spread.number, (shadow.inset ? 1 : -1) * shadow.spread.number, shadow.spread.number * (shadow.inset ? -2 : 2), shadow.spread.number * (shadow.inset ? -2 : 2));
                  if (shadow.inset) {
                    _this.path(borderBoxArea);
                    _this.ctx.clip();
                    _this.mask(shadowPaintingArea);
                  } else {
                    _this.mask(borderBoxArea);
                    _this.ctx.clip();
                    _this.path(shadowPaintingArea);
                  }
                  _this.ctx.shadowOffsetX = shadow.offsetX.number + maskOffset;
                  _this.ctx.shadowOffsetY = shadow.offsetY.number;
                  _this.ctx.shadowColor = asString(shadow.color);
                  _this.ctx.shadowBlur = shadow.blur.number;
                  _this.ctx.fillStyle = shadow.inset ? asString(shadow.color) : "rgba(0,0,0,1)";
                  _this.ctx.fill();
                  _this.ctx.restore();
                });
                _a2.label = 2;
              case 2:
                side = 0;
                _i = 0, borders_1 = borders;
                _a2.label = 3;
              case 3:
                if (!(_i < borders_1.length)) return [3, 13];
                border = borders_1[_i];
                if (!(border.style !== 0 && !isTransparent(border.color) && border.width > 0)) return [3, 11];
                if (!(border.style === 2)) return [3, 5];
                return [4, this.renderDashedDottedBorder(
                  border.color,
                  border.width,
                  side,
                  paint.curves,
                  2
                  /* DASHED */
                )];
              case 4:
                _a2.sent();
                return [3, 11];
              case 5:
                if (!(border.style === 3)) return [3, 7];
                return [4, this.renderDashedDottedBorder(
                  border.color,
                  border.width,
                  side,
                  paint.curves,
                  3
                  /* DOTTED */
                )];
              case 6:
                _a2.sent();
                return [3, 11];
              case 7:
                if (!(border.style === 4)) return [3, 9];
                return [4, this.renderDoubleBorder(border.color, border.width, side, paint.curves)];
              case 8:
                _a2.sent();
                return [3, 11];
              case 9:
                return [4, this.renderSolidBorder(border.color, side, paint.curves)];
              case 10:
                _a2.sent();
                _a2.label = 11;
              case 11:
                side++;
                _a2.label = 12;
              case 12:
                _i++;
                return [3, 3];
              case 13:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      CanvasRenderer2.prototype.renderDashedDottedBorder = function(color2, width, side, curvePoints, style) {
        return __awaiter(this, void 0, void 0, function() {
          var strokePaths, boxPaths, startX, startY, endX, endY, length, dashLength, spaceLength, useLineDash, multiplier, numberOfDashes, minSpace, maxSpace, path1, path2, path1, path2;
          return __generator(this, function(_a2) {
            this.ctx.save();
            strokePaths = parsePathForBorderStroke(curvePoints, side);
            boxPaths = parsePathForBorder(curvePoints, side);
            if (style === 2) {
              this.path(boxPaths);
              this.ctx.clip();
            }
            if (isBezierCurve(boxPaths[0])) {
              startX = boxPaths[0].start.x;
              startY = boxPaths[0].start.y;
            } else {
              startX = boxPaths[0].x;
              startY = boxPaths[0].y;
            }
            if (isBezierCurve(boxPaths[1])) {
              endX = boxPaths[1].end.x;
              endY = boxPaths[1].end.y;
            } else {
              endX = boxPaths[1].x;
              endY = boxPaths[1].y;
            }
            if (side === 0 || side === 2) {
              length = Math.abs(startX - endX);
            } else {
              length = Math.abs(startY - endY);
            }
            this.ctx.beginPath();
            if (style === 3) {
              this.formatPath(strokePaths);
            } else {
              this.formatPath(boxPaths.slice(0, 2));
            }
            dashLength = width < 3 ? width * 3 : width * 2;
            spaceLength = width < 3 ? width * 2 : width;
            if (style === 3) {
              dashLength = width;
              spaceLength = width;
            }
            useLineDash = true;
            if (length <= dashLength * 2) {
              useLineDash = false;
            } else if (length <= dashLength * 2 + spaceLength) {
              multiplier = length / (2 * dashLength + spaceLength);
              dashLength *= multiplier;
              spaceLength *= multiplier;
            } else {
              numberOfDashes = Math.floor((length + spaceLength) / (dashLength + spaceLength));
              minSpace = (length - numberOfDashes * dashLength) / (numberOfDashes - 1);
              maxSpace = (length - (numberOfDashes + 1) * dashLength) / numberOfDashes;
              spaceLength = maxSpace <= 0 || Math.abs(spaceLength - minSpace) < Math.abs(spaceLength - maxSpace) ? minSpace : maxSpace;
            }
            if (useLineDash) {
              if (style === 3) {
                this.ctx.setLineDash([0, dashLength + spaceLength]);
              } else {
                this.ctx.setLineDash([dashLength, spaceLength]);
              }
            }
            if (style === 3) {
              this.ctx.lineCap = "round";
              this.ctx.lineWidth = width;
            } else {
              this.ctx.lineWidth = width * 2 + 1.1;
            }
            this.ctx.strokeStyle = asString(color2);
            this.ctx.stroke();
            this.ctx.setLineDash([]);
            if (style === 2) {
              if (isBezierCurve(boxPaths[0])) {
                path1 = boxPaths[3];
                path2 = boxPaths[0];
                this.ctx.beginPath();
                this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);
                this.ctx.stroke();
              }
              if (isBezierCurve(boxPaths[1])) {
                path1 = boxPaths[1];
                path2 = boxPaths[2];
                this.ctx.beginPath();
                this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);
                this.ctx.stroke();
              }
            }
            this.ctx.restore();
            return [
              2
              /*return*/
            ];
          });
        });
      };
      CanvasRenderer2.prototype.render = function(element) {
        return __awaiter(this, void 0, void 0, function() {
          var stack;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                if (this.options.backgroundColor) {
                  this.ctx.fillStyle = asString(this.options.backgroundColor);
                  this.ctx.fillRect(this.options.x, this.options.y, this.options.width, this.options.height);
                }
                stack = parseStackingContexts(element);
                return [4, this.renderStack(stack)];
              case 1:
                _a2.sent();
                this.applyEffects([]);
                return [2, this.canvas];
            }
          });
        });
      };
      return CanvasRenderer2;
    })(Renderer);
    isTextInputElement = function(container) {
      if (container instanceof TextareaElementContainer) {
        return true;
      } else if (container instanceof SelectElementContainer) {
        return true;
      } else if (container instanceof InputElementContainer && container.type !== RADIO && container.type !== CHECKBOX) {
        return true;
      }
      return false;
    };
    calculateBackgroundCurvedPaintingArea = function(clip, curves) {
      switch (clip) {
        case 0:
          return calculateBorderBoxPath(curves);
        case 2:
          return calculateContentBoxPath(curves);
        case 1:
        default:
          return calculatePaddingBoxPath(curves);
      }
    };
    canvasTextAlign = function(textAlign2) {
      switch (textAlign2) {
        case 1:
          return "center";
        case 2:
          return "right";
        case 0:
        default:
          return "left";
      }
    };
    iOSBrokenFonts = ["-apple-system", "system-ui"];
    fixIOSSystemFonts = function(fontFamilies) {
      return /iPhone OS 15_(0|1)/.test(window.navigator.userAgent) ? fontFamilies.filter(function(fontFamily2) {
        return iOSBrokenFonts.indexOf(fontFamily2) === -1;
      }) : fontFamilies;
    };
    ForeignObjectRenderer = /** @class */
    (function(_super) {
      __extends(ForeignObjectRenderer2, _super);
      function ForeignObjectRenderer2(context, options) {
        var _this = _super.call(this, context, options) || this;
        _this.canvas = options.canvas ? options.canvas : document.createElement("canvas");
        _this.ctx = _this.canvas.getContext("2d");
        _this.options = options;
        _this.canvas.width = Math.floor(options.width * options.scale);
        _this.canvas.height = Math.floor(options.height * options.scale);
        _this.canvas.style.width = options.width + "px";
        _this.canvas.style.height = options.height + "px";
        _this.ctx.scale(_this.options.scale, _this.options.scale);
        _this.ctx.translate(-options.x, -options.y);
        _this.context.logger.debug("EXPERIMENTAL ForeignObject renderer initialized (" + options.width + "x" + options.height + " at " + options.x + "," + options.y + ") with scale " + options.scale);
        return _this;
      }
      ForeignObjectRenderer2.prototype.render = function(element) {
        return __awaiter(this, void 0, void 0, function() {
          var svg, img;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                svg = createForeignObjectSVG(this.options.width * this.options.scale, this.options.height * this.options.scale, this.options.scale, this.options.scale, element);
                return [4, loadSerializedSVG(svg)];
              case 1:
                img = _a2.sent();
                if (this.options.backgroundColor) {
                  this.ctx.fillStyle = asString(this.options.backgroundColor);
                  this.ctx.fillRect(0, 0, this.options.width * this.options.scale, this.options.height * this.options.scale);
                }
                this.ctx.drawImage(img, -this.options.x * this.options.scale, -this.options.y * this.options.scale);
                return [2, this.canvas];
            }
          });
        });
      };
      return ForeignObjectRenderer2;
    })(Renderer);
    loadSerializedSVG = function(svg) {
      return new Promise(function(resolve, reject) {
        var img = new Image();
        img.onload = function() {
          resolve(img);
        };
        img.onerror = reject;
        img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg));
      });
    };
    Logger = /** @class */
    (function() {
      function Logger2(_a2) {
        var id = _a2.id, enabled = _a2.enabled;
        this.id = id;
        this.enabled = enabled;
        this.start = Date.now();
      }
      Logger2.prototype.debug = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (this.enabled) {
          if (typeof window !== "undefined" && window.console && typeof console.debug === "function") {
            console.debug.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
          } else {
            this.info.apply(this, args);
          }
        }
      };
      Logger2.prototype.getTime = function() {
        return Date.now() - this.start;
      };
      Logger2.prototype.info = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (this.enabled) {
          if (typeof window !== "undefined" && window.console && typeof console.info === "function") {
            console.info.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
          }
        }
      };
      Logger2.prototype.warn = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (this.enabled) {
          if (typeof window !== "undefined" && window.console && typeof console.warn === "function") {
            console.warn.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
          } else {
            this.info.apply(this, args);
          }
        }
      };
      Logger2.prototype.error = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (this.enabled) {
          if (typeof window !== "undefined" && window.console && typeof console.error === "function") {
            console.error.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
          } else {
            this.info.apply(this, args);
          }
        }
      };
      Logger2.instances = {};
      return Logger2;
    })();
    Context = /** @class */
    (function() {
      function Context2(options, windowBounds) {
        var _a2;
        this.windowBounds = windowBounds;
        this.instanceName = "#" + Context2.instanceCount++;
        this.logger = new Logger({ id: this.instanceName, enabled: options.logging });
        this.cache = (_a2 = options.cache) !== null && _a2 !== void 0 ? _a2 : new Cache(this, options);
      }
      Context2.instanceCount = 1;
      return Context2;
    })();
    html2canvas = function(element, options) {
      if (options === void 0) {
        options = {};
      }
      return renderElement(element, options);
    };
    if (typeof window !== "undefined") {
      CacheStorage.setContext(window);
    }
    renderElement = function(element, opts) {
      return __awaiter(void 0, void 0, void 0, function() {
        var ownerDocument, defaultView, resourceOptions, contextOptions, windowOptions, windowBounds, context, foreignObjectRendering, cloneOptions, documentCloner, clonedElement, container, _a2, width, height, left, top, backgroundColor2, renderOptions, canvas, renderer, root, renderer;
        var _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
        return __generator(this, function(_u) {
          switch (_u.label) {
            case 0:
              if (!element || typeof element !== "object") {
                return [2, Promise.reject("Invalid element provided as first argument")];
              }
              ownerDocument = element.ownerDocument;
              if (!ownerDocument) {
                throw new Error("Element is not attached to a Document");
              }
              defaultView = ownerDocument.defaultView;
              if (!defaultView) {
                throw new Error("Document is not attached to a Window");
              }
              resourceOptions = {
                allowTaint: (_b = opts.allowTaint) !== null && _b !== void 0 ? _b : false,
                imageTimeout: (_c = opts.imageTimeout) !== null && _c !== void 0 ? _c : 15e3,
                proxy: opts.proxy,
                useCORS: (_d = opts.useCORS) !== null && _d !== void 0 ? _d : false
              };
              contextOptions = __assign({ logging: (_e = opts.logging) !== null && _e !== void 0 ? _e : true, cache: opts.cache }, resourceOptions);
              windowOptions = {
                windowWidth: (_f = opts.windowWidth) !== null && _f !== void 0 ? _f : defaultView.innerWidth,
                windowHeight: (_g = opts.windowHeight) !== null && _g !== void 0 ? _g : defaultView.innerHeight,
                scrollX: (_h = opts.scrollX) !== null && _h !== void 0 ? _h : defaultView.pageXOffset,
                scrollY: (_j = opts.scrollY) !== null && _j !== void 0 ? _j : defaultView.pageYOffset
              };
              windowBounds = new Bounds(windowOptions.scrollX, windowOptions.scrollY, windowOptions.windowWidth, windowOptions.windowHeight);
              context = new Context(contextOptions, windowBounds);
              foreignObjectRendering = (_k = opts.foreignObjectRendering) !== null && _k !== void 0 ? _k : false;
              cloneOptions = {
                allowTaint: (_l = opts.allowTaint) !== null && _l !== void 0 ? _l : false,
                onclone: opts.onclone,
                ignoreElements: opts.ignoreElements,
                inlineImages: foreignObjectRendering,
                copyStyles: foreignObjectRendering
              };
              context.logger.debug("Starting document clone with size " + windowBounds.width + "x" + windowBounds.height + " scrolled to " + -windowBounds.left + "," + -windowBounds.top);
              documentCloner = new DocumentCloner(context, element, cloneOptions);
              clonedElement = documentCloner.clonedReferenceElement;
              if (!clonedElement) {
                return [2, Promise.reject("Unable to find element in cloned iframe")];
              }
              return [4, documentCloner.toIFrame(ownerDocument, windowBounds)];
            case 1:
              container = _u.sent();
              _a2 = isBodyElement(clonedElement) || isHTMLElement(clonedElement) ? parseDocumentSize(clonedElement.ownerDocument) : parseBounds(context, clonedElement), width = _a2.width, height = _a2.height, left = _a2.left, top = _a2.top;
              backgroundColor2 = parseBackgroundColor(context, clonedElement, opts.backgroundColor);
              renderOptions = {
                canvas: opts.canvas,
                backgroundColor: backgroundColor2,
                scale: (_o = (_m = opts.scale) !== null && _m !== void 0 ? _m : defaultView.devicePixelRatio) !== null && _o !== void 0 ? _o : 1,
                x: ((_p = opts.x) !== null && _p !== void 0 ? _p : 0) + left,
                y: ((_q = opts.y) !== null && _q !== void 0 ? _q : 0) + top,
                width: (_r = opts.width) !== null && _r !== void 0 ? _r : Math.ceil(width),
                height: (_s = opts.height) !== null && _s !== void 0 ? _s : Math.ceil(height)
              };
              if (!foreignObjectRendering) return [3, 3];
              context.logger.debug("Document cloned, using foreign object rendering");
              renderer = new ForeignObjectRenderer(context, renderOptions);
              return [4, renderer.render(clonedElement)];
            case 2:
              canvas = _u.sent();
              return [3, 5];
            case 3:
              context.logger.debug("Document cloned, element located at " + left + "," + top + " with size " + width + "x" + height + " using computed rendering");
              context.logger.debug("Starting DOM parsing");
              root = parseTree(context, clonedElement);
              if (backgroundColor2 === root.styles.backgroundColor) {
                root.styles.backgroundColor = COLORS.TRANSPARENT;
              }
              context.logger.debug("Starting renderer for element at " + renderOptions.x + "," + renderOptions.y + " with size " + renderOptions.width + "x" + renderOptions.height);
              renderer = new CanvasRenderer(context, renderOptions);
              return [4, renderer.render(root)];
            case 4:
              canvas = _u.sent();
              _u.label = 5;
            case 5:
              if ((_t = opts.removeContainer) !== null && _t !== void 0 ? _t : true) {
                if (!DocumentCloner.destroy(container)) {
                  context.logger.error("Cannot detach cloned iframe as it is not in the DOM anymore");
                }
              }
              context.logger.debug("Finished rendering");
              return [2, canvas];
          }
        });
      });
    };
    parseBackgroundColor = function(context, element, backgroundColorOverride) {
      var ownerDocument = element.ownerDocument;
      var documentBackgroundColor = ownerDocument.documentElement ? parseColor(context, getComputedStyle(ownerDocument.documentElement).backgroundColor) : COLORS.TRANSPARENT;
      var bodyBackgroundColor = ownerDocument.body ? parseColor(context, getComputedStyle(ownerDocument.body).backgroundColor) : COLORS.TRANSPARENT;
      var defaultBackgroundColor = typeof backgroundColorOverride === "string" ? parseColor(context, backgroundColorOverride) : backgroundColorOverride === null ? COLORS.TRANSPARENT : 4294967295;
      return element === ownerDocument.documentElement ? isTransparent(documentBackgroundColor) ? isTransparent(bodyBackgroundColor) ? defaultBackgroundColor : bodyBackgroundColor : documentBackgroundColor : defaultBackgroundColor;
    };
    html2canvas_esm_default = html2canvas;
  }
});

// node_modules/dompurify/dist/purify.cjs.js
var require_purify_cjs = __commonJS({
  "node_modules/dompurify/dist/purify.cjs.js"(exports, module) {
    "use strict";
    var {
      entries,
      setPrototypeOf,
      isFrozen,
      getPrototypeOf,
      getOwnPropertyDescriptor
    } = Object;
    var {
      freeze,
      seal,
      create
    } = Object;
    var {
      apply,
      construct
    } = typeof Reflect !== "undefined" && Reflect;
    if (!freeze) {
      freeze = function freeze2(x) {
        return x;
      };
    }
    if (!seal) {
      seal = function seal2(x) {
        return x;
      };
    }
    if (!apply) {
      apply = function apply2(func, thisArg) {
        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }
        return func.apply(thisArg, args);
      };
    }
    if (!construct) {
      construct = function construct2(Func) {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }
        return new Func(...args);
      };
    }
    var arrayForEach = unapply(Array.prototype.forEach);
    var arrayLastIndexOf = unapply(Array.prototype.lastIndexOf);
    var arrayPop = unapply(Array.prototype.pop);
    var arrayPush = unapply(Array.prototype.push);
    var arraySplice = unapply(Array.prototype.splice);
    var stringToLowerCase = unapply(String.prototype.toLowerCase);
    var stringToString = unapply(String.prototype.toString);
    var stringMatch = unapply(String.prototype.match);
    var stringReplace = unapply(String.prototype.replace);
    var stringIndexOf = unapply(String.prototype.indexOf);
    var stringTrim = unapply(String.prototype.trim);
    var objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty);
    var regExpTest = unapply(RegExp.prototype.test);
    var typeErrorCreate = unconstruct(TypeError);
    function unapply(func) {
      return function(thisArg) {
        if (thisArg instanceof RegExp) {
          thisArg.lastIndex = 0;
        }
        for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
          args[_key3 - 1] = arguments[_key3];
        }
        return apply(func, thisArg, args);
      };
    }
    function unconstruct(Func) {
      return function() {
        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }
        return construct(Func, args);
      };
    }
    function addToSet(set, array) {
      let transformCaseFunc = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : stringToLowerCase;
      if (setPrototypeOf) {
        setPrototypeOf(set, null);
      }
      let l = array.length;
      while (l--) {
        let element = array[l];
        if (typeof element === "string") {
          const lcElement = transformCaseFunc(element);
          if (lcElement !== element) {
            if (!isFrozen(array)) {
              array[l] = lcElement;
            }
            element = lcElement;
          }
        }
        set[element] = true;
      }
      return set;
    }
    function cleanArray(array) {
      for (let index = 0; index < array.length; index++) {
        const isPropertyExist = objectHasOwnProperty(array, index);
        if (!isPropertyExist) {
          array[index] = null;
        }
      }
      return array;
    }
    function clone(object) {
      const newObject = create(null);
      for (const [property, value] of entries(object)) {
        const isPropertyExist = objectHasOwnProperty(object, property);
        if (isPropertyExist) {
          if (Array.isArray(value)) {
            newObject[property] = cleanArray(value);
          } else if (value && typeof value === "object" && value.constructor === Object) {
            newObject[property] = clone(value);
          } else {
            newObject[property] = value;
          }
        }
      }
      return newObject;
    }
    function lookupGetter(object, prop) {
      while (object !== null) {
        const desc = getOwnPropertyDescriptor(object, prop);
        if (desc) {
          if (desc.get) {
            return unapply(desc.get);
          }
          if (typeof desc.value === "function") {
            return unapply(desc.value);
          }
        }
        object = getPrototypeOf(object);
      }
      function fallbackValue() {
        return null;
      }
      return fallbackValue;
    }
    var html$1 = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "search", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
    var svg$1 = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "enterkeyhint", "exportparts", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "inputmode", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "part", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
    var svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
    var svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
    var mathMl$1 = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]);
    var mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
    var text = freeze(["#text"]);
    var html = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "exportparts", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inert", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "part", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "slot", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]);
    var svg = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "mask-type", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
    var mathMl = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
    var xml = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
    var MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
    var ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
    var TMPLIT_EXPR = seal(/\$\{[\w\W]*/gm);
    var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]+$/);
    var ARIA_ATTR = seal(/^aria-[\-\w]+$/);
    var IS_ALLOWED_URI = seal(
      /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
      // eslint-disable-line no-useless-escape
    );
    var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
    var ATTR_WHITESPACE = seal(
      /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
      // eslint-disable-line no-control-regex
    );
    var DOCTYPE_NAME = seal(/^html$/i);
    var CUSTOM_ELEMENT = seal(/^[a-z][.\w]*(-[.\w]+)+$/i);
    var EXPRESSIONS = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      ARIA_ATTR,
      ATTR_WHITESPACE,
      CUSTOM_ELEMENT,
      DATA_ATTR,
      DOCTYPE_NAME,
      ERB_EXPR,
      IS_ALLOWED_URI,
      IS_SCRIPT_OR_DATA,
      MUSTACHE_EXPR,
      TMPLIT_EXPR
    });
    var NODE_TYPE = {
      element: 1,
      attribute: 2,
      text: 3,
      cdataSection: 4,
      entityReference: 5,
      // Deprecated
      entityNode: 6,
      // Deprecated
      progressingInstruction: 7,
      comment: 8,
      document: 9,
      documentType: 10,
      documentFragment: 11,
      notation: 12
      // Deprecated
    };
    var getGlobal = function getGlobal2() {
      return typeof window === "undefined" ? null : window;
    };
    var _createTrustedTypesPolicy = function _createTrustedTypesPolicy2(trustedTypes, purifyHostElement) {
      if (typeof trustedTypes !== "object" || typeof trustedTypes.createPolicy !== "function") {
        return null;
      }
      let suffix = null;
      const ATTR_NAME = "data-tt-policy-suffix";
      if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {
        suffix = purifyHostElement.getAttribute(ATTR_NAME);
      }
      const policyName = "dompurify" + (suffix ? "#" + suffix : "");
      try {
        return trustedTypes.createPolicy(policyName, {
          createHTML(html2) {
            return html2;
          },
          createScriptURL(scriptUrl) {
            return scriptUrl;
          }
        });
      } catch (_) {
        console.warn("TrustedTypes policy " + policyName + " could not be created.");
        return null;
      }
    };
    var _createHooksMap = function _createHooksMap2() {
      return {
        afterSanitizeAttributes: [],
        afterSanitizeElements: [],
        afterSanitizeShadowDOM: [],
        beforeSanitizeAttributes: [],
        beforeSanitizeElements: [],
        beforeSanitizeShadowDOM: [],
        uponSanitizeAttribute: [],
        uponSanitizeElement: [],
        uponSanitizeShadowNode: []
      };
    };
    function createDOMPurify() {
      let window2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
      const DOMPurify = (root) => createDOMPurify(root);
      DOMPurify.version = "3.3.1";
      DOMPurify.removed = [];
      if (!window2 || !window2.document || window2.document.nodeType !== NODE_TYPE.document || !window2.Element) {
        DOMPurify.isSupported = false;
        return DOMPurify;
      }
      let {
        document: document2
      } = window2;
      const originalDocument = document2;
      const currentScript = originalDocument.currentScript;
      const {
        DocumentFragment,
        HTMLTemplateElement,
        Node: Node2,
        Element,
        NodeFilter,
        NamedNodeMap = window2.NamedNodeMap || window2.MozNamedAttrMap,
        HTMLFormElement,
        DOMParser: DOMParser2,
        trustedTypes
      } = window2;
      const ElementPrototype = Element.prototype;
      const cloneNode = lookupGetter(ElementPrototype, "cloneNode");
      const remove = lookupGetter(ElementPrototype, "remove");
      const getNextSibling = lookupGetter(ElementPrototype, "nextSibling");
      const getChildNodes = lookupGetter(ElementPrototype, "childNodes");
      const getParentNode = lookupGetter(ElementPrototype, "parentNode");
      if (typeof HTMLTemplateElement === "function") {
        const template = document2.createElement("template");
        if (template.content && template.content.ownerDocument) {
          document2 = template.content.ownerDocument;
        }
      }
      let trustedTypesPolicy;
      let emptyHTML = "";
      const {
        implementation,
        createNodeIterator,
        createDocumentFragment,
        getElementsByTagName
      } = document2;
      const {
        importNode
      } = originalDocument;
      let hooks = _createHooksMap();
      DOMPurify.isSupported = typeof entries === "function" && typeof getParentNode === "function" && implementation && implementation.createHTMLDocument !== void 0;
      const {
        MUSTACHE_EXPR: MUSTACHE_EXPR2,
        ERB_EXPR: ERB_EXPR2,
        TMPLIT_EXPR: TMPLIT_EXPR2,
        DATA_ATTR: DATA_ATTR2,
        ARIA_ATTR: ARIA_ATTR2,
        IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA2,
        ATTR_WHITESPACE: ATTR_WHITESPACE2,
        CUSTOM_ELEMENT: CUSTOM_ELEMENT2
      } = EXPRESSIONS;
      let {
        IS_ALLOWED_URI: IS_ALLOWED_URI$1
      } = EXPRESSIONS;
      let ALLOWED_TAGS = null;
      const DEFAULT_ALLOWED_TAGS = addToSet({}, [...html$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text]);
      let ALLOWED_ATTR = null;
      const DEFAULT_ALLOWED_ATTR = addToSet({}, [...html, ...svg, ...mathMl, ...xml]);
      let CUSTOM_ELEMENT_HANDLING = Object.seal(create(null, {
        tagNameCheck: {
          writable: true,
          configurable: false,
          enumerable: true,
          value: null
        },
        attributeNameCheck: {
          writable: true,
          configurable: false,
          enumerable: true,
          value: null
        },
        allowCustomizedBuiltInElements: {
          writable: true,
          configurable: false,
          enumerable: true,
          value: false
        }
      }));
      let FORBID_TAGS = null;
      let FORBID_ATTR = null;
      const EXTRA_ELEMENT_HANDLING = Object.seal(create(null, {
        tagCheck: {
          writable: true,
          configurable: false,
          enumerable: true,
          value: null
        },
        attributeCheck: {
          writable: true,
          configurable: false,
          enumerable: true,
          value: null
        }
      }));
      let ALLOW_ARIA_ATTR = true;
      let ALLOW_DATA_ATTR = true;
      let ALLOW_UNKNOWN_PROTOCOLS = false;
      let ALLOW_SELF_CLOSE_IN_ATTR = true;
      let SAFE_FOR_TEMPLATES = false;
      let SAFE_FOR_XML = true;
      let WHOLE_DOCUMENT = false;
      let SET_CONFIG = false;
      let FORCE_BODY = false;
      let RETURN_DOM = false;
      let RETURN_DOM_FRAGMENT = false;
      let RETURN_TRUSTED_TYPE = false;
      let SANITIZE_DOM = true;
      let SANITIZE_NAMED_PROPS = false;
      const SANITIZE_NAMED_PROPS_PREFIX = "user-content-";
      let KEEP_CONTENT = true;
      let IN_PLACE = false;
      let USE_PROFILES = {};
      let FORBID_CONTENTS = null;
      const DEFAULT_FORBID_CONTENTS = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
      let DATA_URI_TAGS = null;
      const DEFAULT_DATA_URI_TAGS = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
      let URI_SAFE_ATTRIBUTES = null;
      const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]);
      const MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
      const SVG_NAMESPACE = "http://www.w3.org/2000/svg";
      const HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
      let NAMESPACE = HTML_NAMESPACE;
      let IS_EMPTY_INPUT = false;
      let ALLOWED_NAMESPACES = null;
      const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);
      let MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]);
      let HTML_INTEGRATION_POINTS = addToSet({}, ["annotation-xml"]);
      const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ["title", "style", "font", "a", "script"]);
      let PARSER_MEDIA_TYPE = null;
      const SUPPORTED_PARSER_MEDIA_TYPES = ["application/xhtml+xml", "text/html"];
      const DEFAULT_PARSER_MEDIA_TYPE = "text/html";
      let transformCaseFunc = null;
      let CONFIG = null;
      const formElement = document2.createElement("form");
      const isRegexOrFunction = function isRegexOrFunction2(testValue) {
        return testValue instanceof RegExp || testValue instanceof Function;
      };
      const _parseConfig = function _parseConfig2() {
        let cfg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (CONFIG && CONFIG === cfg) {
          return;
        }
        if (!cfg || typeof cfg !== "object") {
          cfg = {};
        }
        cfg = clone(cfg);
        PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes
        SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? DEFAULT_PARSER_MEDIA_TYPE : cfg.PARSER_MEDIA_TYPE;
        transformCaseFunc = PARSER_MEDIA_TYPE === "application/xhtml+xml" ? stringToString : stringToLowerCase;
        ALLOWED_TAGS = objectHasOwnProperty(cfg, "ALLOWED_TAGS") ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
        ALLOWED_ATTR = objectHasOwnProperty(cfg, "ALLOWED_ATTR") ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
        ALLOWED_NAMESPACES = objectHasOwnProperty(cfg, "ALLOWED_NAMESPACES") ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
        URI_SAFE_ATTRIBUTES = objectHasOwnProperty(cfg, "ADD_URI_SAFE_ATTR") ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR, transformCaseFunc) : DEFAULT_URI_SAFE_ATTRIBUTES;
        DATA_URI_TAGS = objectHasOwnProperty(cfg, "ADD_DATA_URI_TAGS") ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS, transformCaseFunc) : DEFAULT_DATA_URI_TAGS;
        FORBID_CONTENTS = objectHasOwnProperty(cfg, "FORBID_CONTENTS") ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
        FORBID_TAGS = objectHasOwnProperty(cfg, "FORBID_TAGS") ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : clone({});
        FORBID_ATTR = objectHasOwnProperty(cfg, "FORBID_ATTR") ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : clone({});
        USE_PROFILES = objectHasOwnProperty(cfg, "USE_PROFILES") ? cfg.USE_PROFILES : false;
        ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
        ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
        ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
        ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false;
        SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
        SAFE_FOR_XML = cfg.SAFE_FOR_XML !== false;
        WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
        RETURN_DOM = cfg.RETURN_DOM || false;
        RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
        RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
        FORCE_BODY = cfg.FORCE_BODY || false;
        SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
        SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false;
        KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
        IN_PLACE = cfg.IN_PLACE || false;
        IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;
        NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
        MATHML_TEXT_INTEGRATION_POINTS = cfg.MATHML_TEXT_INTEGRATION_POINTS || MATHML_TEXT_INTEGRATION_POINTS;
        HTML_INTEGRATION_POINTS = cfg.HTML_INTEGRATION_POINTS || HTML_INTEGRATION_POINTS;
        CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};
        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
          CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
        }
        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
          CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
        }
        if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === "boolean") {
          CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
        }
        if (SAFE_FOR_TEMPLATES) {
          ALLOW_DATA_ATTR = false;
        }
        if (RETURN_DOM_FRAGMENT) {
          RETURN_DOM = true;
        }
        if (USE_PROFILES) {
          ALLOWED_TAGS = addToSet({}, text);
          ALLOWED_ATTR = [];
          if (USE_PROFILES.html === true) {
            addToSet(ALLOWED_TAGS, html$1);
            addToSet(ALLOWED_ATTR, html);
          }
          if (USE_PROFILES.svg === true) {
            addToSet(ALLOWED_TAGS, svg$1);
            addToSet(ALLOWED_ATTR, svg);
            addToSet(ALLOWED_ATTR, xml);
          }
          if (USE_PROFILES.svgFilters === true) {
            addToSet(ALLOWED_TAGS, svgFilters);
            addToSet(ALLOWED_ATTR, svg);
            addToSet(ALLOWED_ATTR, xml);
          }
          if (USE_PROFILES.mathMl === true) {
            addToSet(ALLOWED_TAGS, mathMl$1);
            addToSet(ALLOWED_ATTR, mathMl);
            addToSet(ALLOWED_ATTR, xml);
          }
        }
        if (cfg.ADD_TAGS) {
          if (typeof cfg.ADD_TAGS === "function") {
            EXTRA_ELEMENT_HANDLING.tagCheck = cfg.ADD_TAGS;
          } else {
            if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
              ALLOWED_TAGS = clone(ALLOWED_TAGS);
            }
            addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
          }
        }
        if (cfg.ADD_ATTR) {
          if (typeof cfg.ADD_ATTR === "function") {
            EXTRA_ELEMENT_HANDLING.attributeCheck = cfg.ADD_ATTR;
          } else {
            if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
              ALLOWED_ATTR = clone(ALLOWED_ATTR);
            }
            addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
          }
        }
        if (cfg.ADD_URI_SAFE_ATTR) {
          addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
        }
        if (cfg.FORBID_CONTENTS) {
          if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
            FORBID_CONTENTS = clone(FORBID_CONTENTS);
          }
          addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
        }
        if (cfg.ADD_FORBID_CONTENTS) {
          if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
            FORBID_CONTENTS = clone(FORBID_CONTENTS);
          }
          addToSet(FORBID_CONTENTS, cfg.ADD_FORBID_CONTENTS, transformCaseFunc);
        }
        if (KEEP_CONTENT) {
          ALLOWED_TAGS["#text"] = true;
        }
        if (WHOLE_DOCUMENT) {
          addToSet(ALLOWED_TAGS, ["html", "head", "body"]);
        }
        if (ALLOWED_TAGS.table) {
          addToSet(ALLOWED_TAGS, ["tbody"]);
          delete FORBID_TAGS.tbody;
        }
        if (cfg.TRUSTED_TYPES_POLICY) {
          if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== "function") {
            throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
          }
          if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== "function") {
            throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
          }
          trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;
          emptyHTML = trustedTypesPolicy.createHTML("");
        } else {
          if (trustedTypesPolicy === void 0) {
            trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);
          }
          if (trustedTypesPolicy !== null && typeof emptyHTML === "string") {
            emptyHTML = trustedTypesPolicy.createHTML("");
          }
        }
        if (freeze) {
          freeze(cfg);
        }
        CONFIG = cfg;
      };
      const ALL_SVG_TAGS = addToSet({}, [...svg$1, ...svgFilters, ...svgDisallowed]);
      const ALL_MATHML_TAGS = addToSet({}, [...mathMl$1, ...mathMlDisallowed]);
      const _checkValidNamespace = function _checkValidNamespace2(element) {
        let parent = getParentNode(element);
        if (!parent || !parent.tagName) {
          parent = {
            namespaceURI: NAMESPACE,
            tagName: "template"
          };
        }
        const tagName = stringToLowerCase(element.tagName);
        const parentTagName = stringToLowerCase(parent.tagName);
        if (!ALLOWED_NAMESPACES[element.namespaceURI]) {
          return false;
        }
        if (element.namespaceURI === SVG_NAMESPACE) {
          if (parent.namespaceURI === HTML_NAMESPACE) {
            return tagName === "svg";
          }
          if (parent.namespaceURI === MATHML_NAMESPACE) {
            return tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
          }
          return Boolean(ALL_SVG_TAGS[tagName]);
        }
        if (element.namespaceURI === MATHML_NAMESPACE) {
          if (parent.namespaceURI === HTML_NAMESPACE) {
            return tagName === "math";
          }
          if (parent.namespaceURI === SVG_NAMESPACE) {
            return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
          }
          return Boolean(ALL_MATHML_TAGS[tagName]);
        }
        if (element.namespaceURI === HTML_NAMESPACE) {
          if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
            return false;
          }
          if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
            return false;
          }
          return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
        }
        if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && ALLOWED_NAMESPACES[element.namespaceURI]) {
          return true;
        }
        return false;
      };
      const _forceRemove = function _forceRemove2(node) {
        arrayPush(DOMPurify.removed, {
          element: node
        });
        try {
          getParentNode(node).removeChild(node);
        } catch (_) {
          remove(node);
        }
      };
      const _removeAttribute = function _removeAttribute2(name, element) {
        try {
          arrayPush(DOMPurify.removed, {
            attribute: element.getAttributeNode(name),
            from: element
          });
        } catch (_) {
          arrayPush(DOMPurify.removed, {
            attribute: null,
            from: element
          });
        }
        element.removeAttribute(name);
        if (name === "is") {
          if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
            try {
              _forceRemove(element);
            } catch (_) {
            }
          } else {
            try {
              element.setAttribute(name, "");
            } catch (_) {
            }
          }
        }
      };
      const _initDocument = function _initDocument2(dirty) {
        let doc = null;
        let leadingWhitespace = null;
        if (FORCE_BODY) {
          dirty = "<remove></remove>" + dirty;
        } else {
          const matches = stringMatch(dirty, /^[\r\n\t ]+/);
          leadingWhitespace = matches && matches[0];
        }
        if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && NAMESPACE === HTML_NAMESPACE) {
          dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + "</body></html>";
        }
        const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
        if (NAMESPACE === HTML_NAMESPACE) {
          try {
            doc = new DOMParser2().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
          } catch (_) {
          }
        }
        if (!doc || !doc.documentElement) {
          doc = implementation.createDocument(NAMESPACE, "template", null);
          try {
            doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
          } catch (_) {
          }
        }
        const body = doc.body || doc.documentElement;
        if (dirty && leadingWhitespace) {
          body.insertBefore(document2.createTextNode(leadingWhitespace), body.childNodes[0] || null);
        }
        if (NAMESPACE === HTML_NAMESPACE) {
          return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? "html" : "body")[0];
        }
        return WHOLE_DOCUMENT ? doc.documentElement : body;
      };
      const _createNodeIterator = function _createNodeIterator2(root) {
        return createNodeIterator.call(
          root.ownerDocument || root,
          root,
          // eslint-disable-next-line no-bitwise
          NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_PROCESSING_INSTRUCTION | NodeFilter.SHOW_CDATA_SECTION,
          null
        );
      };
      const _isClobbered = function _isClobbered2(element) {
        return element instanceof HTMLFormElement && (typeof element.nodeName !== "string" || typeof element.textContent !== "string" || typeof element.removeChild !== "function" || !(element.attributes instanceof NamedNodeMap) || typeof element.removeAttribute !== "function" || typeof element.setAttribute !== "function" || typeof element.namespaceURI !== "string" || typeof element.insertBefore !== "function" || typeof element.hasChildNodes !== "function");
      };
      const _isNode = function _isNode2(value) {
        return typeof Node2 === "function" && value instanceof Node2;
      };
      function _executeHooks(hooks2, currentNode, data) {
        arrayForEach(hooks2, (hook) => {
          hook.call(DOMPurify, currentNode, data, CONFIG);
        });
      }
      const _sanitizeElements = function _sanitizeElements2(currentNode) {
        let content2 = null;
        _executeHooks(hooks.beforeSanitizeElements, currentNode, null);
        if (_isClobbered(currentNode)) {
          _forceRemove(currentNode);
          return true;
        }
        const tagName = transformCaseFunc(currentNode.nodeName);
        _executeHooks(hooks.uponSanitizeElement, currentNode, {
          tagName,
          allowedTags: ALLOWED_TAGS
        });
        if (SAFE_FOR_XML && currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && regExpTest(/<[/\w!]/g, currentNode.innerHTML) && regExpTest(/<[/\w!]/g, currentNode.textContent)) {
          _forceRemove(currentNode);
          return true;
        }
        if (currentNode.nodeType === NODE_TYPE.progressingInstruction) {
          _forceRemove(currentNode);
          return true;
        }
        if (SAFE_FOR_XML && currentNode.nodeType === NODE_TYPE.comment && regExpTest(/<[/\w]/g, currentNode.data)) {
          _forceRemove(currentNode);
          return true;
        }
        if (!(EXTRA_ELEMENT_HANDLING.tagCheck instanceof Function && EXTRA_ELEMENT_HANDLING.tagCheck(tagName)) && (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName])) {
          if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName)) {
            if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) {
              return false;
            }
            if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) {
              return false;
            }
          }
          if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
            const parentNode = getParentNode(currentNode) || currentNode.parentNode;
            const childNodes = getChildNodes(currentNode) || currentNode.childNodes;
            if (childNodes && parentNode) {
              const childCount = childNodes.length;
              for (let i = childCount - 1; i >= 0; --i) {
                const childClone = cloneNode(childNodes[i], true);
                childClone.__removalCount = (currentNode.__removalCount || 0) + 1;
                parentNode.insertBefore(childClone, getNextSibling(currentNode));
              }
            }
          }
          _forceRemove(currentNode);
          return true;
        }
        if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
          _forceRemove(currentNode);
          return true;
        }
        if ((tagName === "noscript" || tagName === "noembed" || tagName === "noframes") && regExpTest(/<\/no(script|embed|frames)/i, currentNode.innerHTML)) {
          _forceRemove(currentNode);
          return true;
        }
        if (SAFE_FOR_TEMPLATES && currentNode.nodeType === NODE_TYPE.text) {
          content2 = currentNode.textContent;
          arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
            content2 = stringReplace(content2, expr, " ");
          });
          if (currentNode.textContent !== content2) {
            arrayPush(DOMPurify.removed, {
              element: currentNode.cloneNode()
            });
            currentNode.textContent = content2;
          }
        }
        _executeHooks(hooks.afterSanitizeElements, currentNode, null);
        return false;
      };
      const _isValidAttribute = function _isValidAttribute2(lcTag, lcName, value) {
        if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value in document2 || value in formElement)) {
          return false;
        }
        if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR2, lcName)) ;
        else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR2, lcName)) ;
        else if (EXTRA_ELEMENT_HANDLING.attributeCheck instanceof Function && EXTRA_ELEMENT_HANDLING.attributeCheck(lcName, lcTag)) ;
        else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
          if (
            // First condition does a very basic check if a) it's basically a valid custom element tagname AND
            // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
            _isBasicCustomElement(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName, lcTag)) || // Alternative, second condition checks if it's an `is`-attribute, AND
            // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            lcName === "is" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))
          ) ;
          else {
            return false;
          }
        } else if (URI_SAFE_ATTRIBUTES[lcName]) ;
        else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE2, ""))) ;
        else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf(value, "data:") === 0 && DATA_URI_TAGS[lcTag]) ;
        else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA2, stringReplace(value, ATTR_WHITESPACE2, ""))) ;
        else if (value) {
          return false;
        } else ;
        return true;
      };
      const _isBasicCustomElement = function _isBasicCustomElement2(tagName) {
        return tagName !== "annotation-xml" && stringMatch(tagName, CUSTOM_ELEMENT2);
      };
      const _sanitizeAttributes = function _sanitizeAttributes2(currentNode) {
        _executeHooks(hooks.beforeSanitizeAttributes, currentNode, null);
        const {
          attributes
        } = currentNode;
        if (!attributes || _isClobbered(currentNode)) {
          return;
        }
        const hookEvent = {
          attrName: "",
          attrValue: "",
          keepAttr: true,
          allowedAttributes: ALLOWED_ATTR,
          forceKeepAttr: void 0
        };
        let l = attributes.length;
        while (l--) {
          const attr = attributes[l];
          const {
            name,
            namespaceURI,
            value: attrValue
          } = attr;
          const lcName = transformCaseFunc(name);
          const initValue = attrValue;
          let value = name === "value" ? initValue : stringTrim(initValue);
          hookEvent.attrName = lcName;
          hookEvent.attrValue = value;
          hookEvent.keepAttr = true;
          hookEvent.forceKeepAttr = void 0;
          _executeHooks(hooks.uponSanitizeAttribute, currentNode, hookEvent);
          value = hookEvent.attrValue;
          if (SANITIZE_NAMED_PROPS && (lcName === "id" || lcName === "name")) {
            _removeAttribute(name, currentNode);
            value = SANITIZE_NAMED_PROPS_PREFIX + value;
          }
          if (SAFE_FOR_XML && regExpTest(/((--!?|])>)|<\/(style|title|textarea)/i, value)) {
            _removeAttribute(name, currentNode);
            continue;
          }
          if (lcName === "attributename" && stringMatch(value, "href")) {
            _removeAttribute(name, currentNode);
            continue;
          }
          if (hookEvent.forceKeepAttr) {
            continue;
          }
          if (!hookEvent.keepAttr) {
            _removeAttribute(name, currentNode);
            continue;
          }
          if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
            _removeAttribute(name, currentNode);
            continue;
          }
          if (SAFE_FOR_TEMPLATES) {
            arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
              value = stringReplace(value, expr, " ");
            });
          }
          const lcTag = transformCaseFunc(currentNode.nodeName);
          if (!_isValidAttribute(lcTag, lcName, value)) {
            _removeAttribute(name, currentNode);
            continue;
          }
          if (trustedTypesPolicy && typeof trustedTypes === "object" && typeof trustedTypes.getAttributeType === "function") {
            if (namespaceURI) ;
            else {
              switch (trustedTypes.getAttributeType(lcTag, lcName)) {
                case "TrustedHTML": {
                  value = trustedTypesPolicy.createHTML(value);
                  break;
                }
                case "TrustedScriptURL": {
                  value = trustedTypesPolicy.createScriptURL(value);
                  break;
                }
              }
            }
          }
          if (value !== initValue) {
            try {
              if (namespaceURI) {
                currentNode.setAttributeNS(namespaceURI, name, value);
              } else {
                currentNode.setAttribute(name, value);
              }
              if (_isClobbered(currentNode)) {
                _forceRemove(currentNode);
              } else {
                arrayPop(DOMPurify.removed);
              }
            } catch (_) {
              _removeAttribute(name, currentNode);
            }
          }
        }
        _executeHooks(hooks.afterSanitizeAttributes, currentNode, null);
      };
      const _sanitizeShadowDOM = function _sanitizeShadowDOM2(fragment) {
        let shadowNode = null;
        const shadowIterator = _createNodeIterator(fragment);
        _executeHooks(hooks.beforeSanitizeShadowDOM, fragment, null);
        while (shadowNode = shadowIterator.nextNode()) {
          _executeHooks(hooks.uponSanitizeShadowNode, shadowNode, null);
          _sanitizeElements(shadowNode);
          _sanitizeAttributes(shadowNode);
          if (shadowNode.content instanceof DocumentFragment) {
            _sanitizeShadowDOM2(shadowNode.content);
          }
        }
        _executeHooks(hooks.afterSanitizeShadowDOM, fragment, null);
      };
      DOMPurify.sanitize = function(dirty) {
        let cfg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        let body = null;
        let importedNode = null;
        let currentNode = null;
        let returnNode = null;
        IS_EMPTY_INPUT = !dirty;
        if (IS_EMPTY_INPUT) {
          dirty = "<!-->";
        }
        if (typeof dirty !== "string" && !_isNode(dirty)) {
          if (typeof dirty.toString === "function") {
            dirty = dirty.toString();
            if (typeof dirty !== "string") {
              throw typeErrorCreate("dirty is not a string, aborting");
            }
          } else {
            throw typeErrorCreate("toString is not a function");
          }
        }
        if (!DOMPurify.isSupported) {
          return dirty;
        }
        if (!SET_CONFIG) {
          _parseConfig(cfg);
        }
        DOMPurify.removed = [];
        if (typeof dirty === "string") {
          IN_PLACE = false;
        }
        if (IN_PLACE) {
          if (dirty.nodeName) {
            const tagName = transformCaseFunc(dirty.nodeName);
            if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
              throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
            }
          }
        } else if (dirty instanceof Node2) {
          body = _initDocument("<!---->");
          importedNode = body.ownerDocument.importNode(dirty, true);
          if (importedNode.nodeType === NODE_TYPE.element && importedNode.nodeName === "BODY") {
            body = importedNode;
          } else if (importedNode.nodeName === "HTML") {
            body = importedNode;
          } else {
            body.appendChild(importedNode);
          }
        } else {
          if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes
          dirty.indexOf("<") === -1) {
            return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
          }
          body = _initDocument(dirty);
          if (!body) {
            return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : "";
          }
        }
        if (body && FORCE_BODY) {
          _forceRemove(body.firstChild);
        }
        const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);
        while (currentNode = nodeIterator.nextNode()) {
          _sanitizeElements(currentNode);
          _sanitizeAttributes(currentNode);
          if (currentNode.content instanceof DocumentFragment) {
            _sanitizeShadowDOM(currentNode.content);
          }
        }
        if (IN_PLACE) {
          return dirty;
        }
        if (RETURN_DOM) {
          if (RETURN_DOM_FRAGMENT) {
            returnNode = createDocumentFragment.call(body.ownerDocument);
            while (body.firstChild) {
              returnNode.appendChild(body.firstChild);
            }
          } else {
            returnNode = body;
          }
          if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {
            returnNode = importNode.call(originalDocument, returnNode, true);
          }
          return returnNode;
        }
        let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
        if (WHOLE_DOCUMENT && ALLOWED_TAGS["!doctype"] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
          serializedHTML = "<!DOCTYPE " + body.ownerDocument.doctype.name + ">\n" + serializedHTML;
        }
        if (SAFE_FOR_TEMPLATES) {
          arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
            serializedHTML = stringReplace(serializedHTML, expr, " ");
          });
        }
        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
      };
      DOMPurify.setConfig = function() {
        let cfg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _parseConfig(cfg);
        SET_CONFIG = true;
      };
      DOMPurify.clearConfig = function() {
        CONFIG = null;
        SET_CONFIG = false;
      };
      DOMPurify.isValidAttribute = function(tag, attr, value) {
        if (!CONFIG) {
          _parseConfig({});
        }
        const lcTag = transformCaseFunc(tag);
        const lcName = transformCaseFunc(attr);
        return _isValidAttribute(lcTag, lcName, value);
      };
      DOMPurify.addHook = function(entryPoint, hookFunction) {
        if (typeof hookFunction !== "function") {
          return;
        }
        arrayPush(hooks[entryPoint], hookFunction);
      };
      DOMPurify.removeHook = function(entryPoint, hookFunction) {
        if (hookFunction !== void 0) {
          const index = arrayLastIndexOf(hooks[entryPoint], hookFunction);
          return index === -1 ? void 0 : arraySplice(hooks[entryPoint], index, 1)[0];
        }
        return arrayPop(hooks[entryPoint]);
      };
      DOMPurify.removeHooks = function(entryPoint) {
        hooks[entryPoint] = [];
      };
      DOMPurify.removeAllHooks = function() {
        hooks = _createHooksMap();
      };
      return DOMPurify;
    }
    var purify = createDOMPurify();
    module.exports = purify;
  }
});

// node_modules/core-js/internals/global-this.js
var require_global_this = __commonJS({
  "node_modules/core-js/internals/global-this.js"(exports, module) {
    "use strict";
    var check = function(it) {
      return it && it.Math === Math && it;
    };
    module.exports = // eslint-disable-next-line es/no-global-this -- safe
    check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
    check(typeof self == "object" && self) || check(typeof global == "object" && global) || check(typeof exports == "object" && exports) || // eslint-disable-next-line no-new-func -- fallback
    /* @__PURE__ */ (function() {
      return this;
    })() || Function("return this")();
  }
});

// node_modules/core-js/internals/is-pure.js
var require_is_pure = __commonJS({
  "node_modules/core-js/internals/is-pure.js"(exports, module) {
    "use strict";
    module.exports = false;
  }
});

// node_modules/core-js/internals/define-global-property.js
var require_define_global_property = __commonJS({
  "node_modules/core-js/internals/define-global-property.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var defineProperty = Object.defineProperty;
    module.exports = function(key, value) {
      try {
        defineProperty(globalThis2, key, { value, configurable: true, writable: true });
      } catch (error) {
        globalThis2[key] = value;
      }
      return value;
    };
  }
});

// node_modules/core-js/internals/shared-store.js
var require_shared_store = __commonJS({
  "node_modules/core-js/internals/shared-store.js"(exports, module) {
    "use strict";
    var IS_PURE = require_is_pure();
    var globalThis2 = require_global_this();
    var defineGlobalProperty = require_define_global_property();
    var SHARED = "__core-js_shared__";
    var store = module.exports = globalThis2[SHARED] || defineGlobalProperty(SHARED, {});
    (store.versions || (store.versions = [])).push({
      version: "3.48.0",
      mode: IS_PURE ? "pure" : "global",
      copyright: "\xA9 2013\u20132025 Denis Pushkarev (zloirock.ru), 2025\u20132026 CoreJS Company (core-js.io). All rights reserved.",
      license: "https://github.com/zloirock/core-js/blob/v3.48.0/LICENSE",
      source: "https://github.com/zloirock/core-js"
    });
  }
});

// node_modules/core-js/internals/shared.js
var require_shared = __commonJS({
  "node_modules/core-js/internals/shared.js"(exports, module) {
    "use strict";
    var store = require_shared_store();
    module.exports = function(key, value) {
      return store[key] || (store[key] = value || {});
    };
  }
});

// node_modules/core-js/internals/fails.js
var require_fails = __commonJS({
  "node_modules/core-js/internals/fails.js"(exports, module) {
    "use strict";
    module.exports = function(exec) {
      try {
        return !!exec();
      } catch (error) {
        return true;
      }
    };
  }
});

// node_modules/core-js/internals/function-bind-native.js
var require_function_bind_native = __commonJS({
  "node_modules/core-js/internals/function-bind-native.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    module.exports = !fails(function() {
      var test = (function() {
      }).bind();
      return typeof test != "function" || test.hasOwnProperty("prototype");
    });
  }
});

// node_modules/core-js/internals/function-uncurry-this.js
var require_function_uncurry_this = __commonJS({
  "node_modules/core-js/internals/function-uncurry-this.js"(exports, module) {
    "use strict";
    var NATIVE_BIND = require_function_bind_native();
    var FunctionPrototype = Function.prototype;
    var call = FunctionPrototype.call;
    var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);
    module.exports = NATIVE_BIND ? uncurryThisWithBind : function(fn) {
      return function() {
        return call.apply(fn, arguments);
      };
    };
  }
});

// node_modules/core-js/internals/is-null-or-undefined.js
var require_is_null_or_undefined = __commonJS({
  "node_modules/core-js/internals/is-null-or-undefined.js"(exports, module) {
    "use strict";
    module.exports = function(it) {
      return it === null || it === void 0;
    };
  }
});

// node_modules/core-js/internals/require-object-coercible.js
var require_require_object_coercible = __commonJS({
  "node_modules/core-js/internals/require-object-coercible.js"(exports, module) {
    "use strict";
    var isNullOrUndefined = require_is_null_or_undefined();
    var $TypeError = TypeError;
    module.exports = function(it) {
      if (isNullOrUndefined(it)) throw new $TypeError("Can't call method on " + it);
      return it;
    };
  }
});

// node_modules/core-js/internals/to-object.js
var require_to_object = __commonJS({
  "node_modules/core-js/internals/to-object.js"(exports, module) {
    "use strict";
    var requireObjectCoercible = require_require_object_coercible();
    var $Object = Object;
    module.exports = function(argument) {
      return $Object(requireObjectCoercible(argument));
    };
  }
});

// node_modules/core-js/internals/has-own-property.js
var require_has_own_property = __commonJS({
  "node_modules/core-js/internals/has-own-property.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var toObject = require_to_object();
    var hasOwnProperty = uncurryThis({}.hasOwnProperty);
    module.exports = Object.hasOwn || function hasOwn(it, key) {
      return hasOwnProperty(toObject(it), key);
    };
  }
});

// node_modules/core-js/internals/uid.js
var require_uid = __commonJS({
  "node_modules/core-js/internals/uid.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var id = 0;
    var postfix = Math.random();
    var toString3 = uncurryThis(1.1.toString);
    module.exports = function(key) {
      return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString3(++id + postfix, 36);
    };
  }
});

// node_modules/core-js/internals/environment-user-agent.js
var require_environment_user_agent = __commonJS({
  "node_modules/core-js/internals/environment-user-agent.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var navigator2 = globalThis2.navigator;
    var userAgent = navigator2 && navigator2.userAgent;
    module.exports = userAgent ? String(userAgent) : "";
  }
});

// node_modules/core-js/internals/environment-v8-version.js
var require_environment_v8_version = __commonJS({
  "node_modules/core-js/internals/environment-v8-version.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var userAgent = require_environment_user_agent();
    var process2 = globalThis2.process;
    var Deno2 = globalThis2.Deno;
    var versions = process2 && process2.versions || Deno2 && Deno2.version;
    var v8 = versions && versions.v8;
    var match;
    var version;
    if (v8) {
      match = v8.split(".");
      version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
    }
    if (!version && userAgent) {
      match = userAgent.match(/Edge\/(\d+)/);
      if (!match || match[1] >= 74) {
        match = userAgent.match(/Chrome\/(\d+)/);
        if (match) version = +match[1];
      }
    }
    module.exports = version;
  }
});

// node_modules/core-js/internals/symbol-constructor-detection.js
var require_symbol_constructor_detection = __commonJS({
  "node_modules/core-js/internals/symbol-constructor-detection.js"(exports, module) {
    "use strict";
    var V8_VERSION = require_environment_v8_version();
    var fails = require_fails();
    var globalThis2 = require_global_this();
    var $String = globalThis2.String;
    module.exports = !!Object.getOwnPropertySymbols && !fails(function() {
      var symbol = /* @__PURE__ */ Symbol("symbol detection");
      return !$String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
      !Symbol.sham && V8_VERSION && V8_VERSION < 41;
    });
  }
});

// node_modules/core-js/internals/use-symbol-as-uid.js
var require_use_symbol_as_uid = __commonJS({
  "node_modules/core-js/internals/use-symbol-as-uid.js"(exports, module) {
    "use strict";
    var NATIVE_SYMBOL = require_symbol_constructor_detection();
    module.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
  }
});

// node_modules/core-js/internals/well-known-symbol.js
var require_well_known_symbol = __commonJS({
  "node_modules/core-js/internals/well-known-symbol.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var shared = require_shared();
    var hasOwn = require_has_own_property();
    var uid = require_uid();
    var NATIVE_SYMBOL = require_symbol_constructor_detection();
    var USE_SYMBOL_AS_UID = require_use_symbol_as_uid();
    var Symbol2 = globalThis2.Symbol;
    var WellKnownSymbolsStore = shared("wks");
    var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2["for"] || Symbol2 : Symbol2 && Symbol2.withoutSetter || uid;
    module.exports = function(name) {
      if (!hasOwn(WellKnownSymbolsStore, name)) {
        WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol2, name) ? Symbol2[name] : createWellKnownSymbol("Symbol." + name);
      }
      return WellKnownSymbolsStore[name];
    };
  }
});

// node_modules/core-js/internals/to-string-tag-support.js
var require_to_string_tag_support = __commonJS({
  "node_modules/core-js/internals/to-string-tag-support.js"(exports, module) {
    "use strict";
    var wellKnownSymbol = require_well_known_symbol();
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    var test = {};
    test[TO_STRING_TAG] = "z";
    module.exports = String(test) === "[object z]";
  }
});

// node_modules/core-js/internals/is-callable.js
var require_is_callable = __commonJS({
  "node_modules/core-js/internals/is-callable.js"(exports, module) {
    "use strict";
    var documentAll = typeof document == "object" && document.all;
    module.exports = typeof documentAll == "undefined" && documentAll !== void 0 ? function(argument) {
      return typeof argument == "function" || argument === documentAll;
    } : function(argument) {
      return typeof argument == "function";
    };
  }
});

// node_modules/core-js/internals/descriptors.js
var require_descriptors = __commonJS({
  "node_modules/core-js/internals/descriptors.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    module.exports = !fails(function() {
      return Object.defineProperty({}, 1, { get: function() {
        return 7;
      } })[1] !== 7;
    });
  }
});

// node_modules/core-js/internals/is-object.js
var require_is_object = __commonJS({
  "node_modules/core-js/internals/is-object.js"(exports, module) {
    "use strict";
    var isCallable = require_is_callable();
    module.exports = function(it) {
      return typeof it == "object" ? it !== null : isCallable(it);
    };
  }
});

// node_modules/core-js/internals/document-create-element.js
var require_document_create_element = __commonJS({
  "node_modules/core-js/internals/document-create-element.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var isObject = require_is_object();
    var document2 = globalThis2.document;
    var EXISTS = isObject(document2) && isObject(document2.createElement);
    module.exports = function(it) {
      return EXISTS ? document2.createElement(it) : {};
    };
  }
});

// node_modules/core-js/internals/ie8-dom-define.js
var require_ie8_dom_define = __commonJS({
  "node_modules/core-js/internals/ie8-dom-define.js"(exports, module) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var fails = require_fails();
    var createElement = require_document_create_element();
    module.exports = !DESCRIPTORS && !fails(function() {
      return Object.defineProperty(createElement("div"), "a", {
        get: function() {
          return 7;
        }
      }).a !== 7;
    });
  }
});

// node_modules/core-js/internals/v8-prototype-define-bug.js
var require_v8_prototype_define_bug = __commonJS({
  "node_modules/core-js/internals/v8-prototype-define-bug.js"(exports, module) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var fails = require_fails();
    module.exports = DESCRIPTORS && fails(function() {
      return Object.defineProperty(function() {
      }, "prototype", {
        value: 42,
        writable: false
      }).prototype !== 42;
    });
  }
});

// node_modules/core-js/internals/an-object.js
var require_an_object = __commonJS({
  "node_modules/core-js/internals/an-object.js"(exports, module) {
    "use strict";
    var isObject = require_is_object();
    var $String = String;
    var $TypeError = TypeError;
    module.exports = function(argument) {
      if (isObject(argument)) return argument;
      throw new $TypeError($String(argument) + " is not an object");
    };
  }
});

// node_modules/core-js/internals/function-call.js
var require_function_call = __commonJS({
  "node_modules/core-js/internals/function-call.js"(exports, module) {
    "use strict";
    var NATIVE_BIND = require_function_bind_native();
    var call = Function.prototype.call;
    module.exports = NATIVE_BIND ? call.bind(call) : function() {
      return call.apply(call, arguments);
    };
  }
});

// node_modules/core-js/internals/get-built-in.js
var require_get_built_in = __commonJS({
  "node_modules/core-js/internals/get-built-in.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var isCallable = require_is_callable();
    var aFunction = function(argument) {
      return isCallable(argument) ? argument : void 0;
    };
    module.exports = function(namespace, method) {
      return arguments.length < 2 ? aFunction(globalThis2[namespace]) : globalThis2[namespace] && globalThis2[namespace][method];
    };
  }
});

// node_modules/core-js/internals/object-is-prototype-of.js
var require_object_is_prototype_of = __commonJS({
  "node_modules/core-js/internals/object-is-prototype-of.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    module.exports = uncurryThis({}.isPrototypeOf);
  }
});

// node_modules/core-js/internals/is-symbol.js
var require_is_symbol = __commonJS({
  "node_modules/core-js/internals/is-symbol.js"(exports, module) {
    "use strict";
    var getBuiltIn = require_get_built_in();
    var isCallable = require_is_callable();
    var isPrototypeOf = require_object_is_prototype_of();
    var USE_SYMBOL_AS_UID = require_use_symbol_as_uid();
    var $Object = Object;
    module.exports = USE_SYMBOL_AS_UID ? function(it) {
      return typeof it == "symbol";
    } : function(it) {
      var $Symbol = getBuiltIn("Symbol");
      return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
    };
  }
});

// node_modules/core-js/internals/try-to-string.js
var require_try_to_string = __commonJS({
  "node_modules/core-js/internals/try-to-string.js"(exports, module) {
    "use strict";
    var $String = String;
    module.exports = function(argument) {
      try {
        return $String(argument);
      } catch (error) {
        return "Object";
      }
    };
  }
});

// node_modules/core-js/internals/a-callable.js
var require_a_callable = __commonJS({
  "node_modules/core-js/internals/a-callable.js"(exports, module) {
    "use strict";
    var isCallable = require_is_callable();
    var tryToString = require_try_to_string();
    var $TypeError = TypeError;
    module.exports = function(argument) {
      if (isCallable(argument)) return argument;
      throw new $TypeError(tryToString(argument) + " is not a function");
    };
  }
});

// node_modules/core-js/internals/get-method.js
var require_get_method = __commonJS({
  "node_modules/core-js/internals/get-method.js"(exports, module) {
    "use strict";
    var aCallable = require_a_callable();
    var isNullOrUndefined = require_is_null_or_undefined();
    module.exports = function(V2, P) {
      var func = V2[P];
      return isNullOrUndefined(func) ? void 0 : aCallable(func);
    };
  }
});

// node_modules/core-js/internals/ordinary-to-primitive.js
var require_ordinary_to_primitive = __commonJS({
  "node_modules/core-js/internals/ordinary-to-primitive.js"(exports, module) {
    "use strict";
    var call = require_function_call();
    var isCallable = require_is_callable();
    var isObject = require_is_object();
    var $TypeError = TypeError;
    module.exports = function(input, pref) {
      var fn, val;
      if (pref === "string" && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
      if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;
      if (pref !== "string" && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
      throw new $TypeError("Can't convert object to primitive value");
    };
  }
});

// node_modules/core-js/internals/to-primitive.js
var require_to_primitive = __commonJS({
  "node_modules/core-js/internals/to-primitive.js"(exports, module) {
    "use strict";
    var call = require_function_call();
    var isObject = require_is_object();
    var isSymbol = require_is_symbol();
    var getMethod = require_get_method();
    var ordinaryToPrimitive = require_ordinary_to_primitive();
    var wellKnownSymbol = require_well_known_symbol();
    var $TypeError = TypeError;
    var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
    module.exports = function(input, pref) {
      if (!isObject(input) || isSymbol(input)) return input;
      var exoticToPrim = getMethod(input, TO_PRIMITIVE);
      var result;
      if (exoticToPrim) {
        if (pref === void 0) pref = "default";
        result = call(exoticToPrim, input, pref);
        if (!isObject(result) || isSymbol(result)) return result;
        throw new $TypeError("Can't convert object to primitive value");
      }
      if (pref === void 0) pref = "number";
      return ordinaryToPrimitive(input, pref);
    };
  }
});

// node_modules/core-js/internals/to-property-key.js
var require_to_property_key = __commonJS({
  "node_modules/core-js/internals/to-property-key.js"(exports, module) {
    "use strict";
    var toPrimitive = require_to_primitive();
    var isSymbol = require_is_symbol();
    module.exports = function(argument) {
      var key = toPrimitive(argument, "string");
      return isSymbol(key) ? key : key + "";
    };
  }
});

// node_modules/core-js/internals/object-define-property.js
var require_object_define_property = __commonJS({
  "node_modules/core-js/internals/object-define-property.js"(exports) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var IE8_DOM_DEFINE = require_ie8_dom_define();
    var V8_PROTOTYPE_DEFINE_BUG = require_v8_prototype_define_bug();
    var anObject = require_an_object();
    var toPropertyKey = require_to_property_key();
    var $TypeError = TypeError;
    var $defineProperty = Object.defineProperty;
    var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var ENUMERABLE = "enumerable";
    var CONFIGURABLE = "configurable";
    var WRITABLE = "writable";
    exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
      anObject(O);
      P = toPropertyKey(P);
      anObject(Attributes);
      if (typeof O === "function" && P === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
        var current = $getOwnPropertyDescriptor(O, P);
        if (current && current[WRITABLE]) {
          O[P] = Attributes.value;
          Attributes = {
            configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
            enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
            writable: false
          };
        }
      }
      return $defineProperty(O, P, Attributes);
    } : $defineProperty : function defineProperty(O, P, Attributes) {
      anObject(O);
      P = toPropertyKey(P);
      anObject(Attributes);
      if (IE8_DOM_DEFINE) try {
        return $defineProperty(O, P, Attributes);
      } catch (error) {
      }
      if ("get" in Attributes || "set" in Attributes) throw new $TypeError("Accessors not supported");
      if ("value" in Attributes) O[P] = Attributes.value;
      return O;
    };
  }
});

// node_modules/core-js/internals/function-name.js
var require_function_name = __commonJS({
  "node_modules/core-js/internals/function-name.js"(exports, module) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var hasOwn = require_has_own_property();
    var FunctionPrototype = Function.prototype;
    var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;
    var EXISTS = hasOwn(FunctionPrototype, "name");
    var PROPER = EXISTS && (function something() {
    }).name === "something";
    var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, "name").configurable);
    module.exports = {
      EXISTS,
      PROPER,
      CONFIGURABLE
    };
  }
});

// node_modules/core-js/internals/inspect-source.js
var require_inspect_source = __commonJS({
  "node_modules/core-js/internals/inspect-source.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var isCallable = require_is_callable();
    var store = require_shared_store();
    var functionToString = uncurryThis(Function.toString);
    if (!isCallable(store.inspectSource)) {
      store.inspectSource = function(it) {
        return functionToString(it);
      };
    }
    module.exports = store.inspectSource;
  }
});

// node_modules/core-js/internals/weak-map-basic-detection.js
var require_weak_map_basic_detection = __commonJS({
  "node_modules/core-js/internals/weak-map-basic-detection.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var isCallable = require_is_callable();
    var WeakMap = globalThis2.WeakMap;
    module.exports = isCallable(WeakMap) && /native code/.test(String(WeakMap));
  }
});

// node_modules/core-js/internals/create-property-descriptor.js
var require_create_property_descriptor = __commonJS({
  "node_modules/core-js/internals/create-property-descriptor.js"(exports, module) {
    "use strict";
    module.exports = function(bitmap, value) {
      return {
        enumerable: !(bitmap & 1),
        configurable: !(bitmap & 2),
        writable: !(bitmap & 4),
        value
      };
    };
  }
});

// node_modules/core-js/internals/create-non-enumerable-property.js
var require_create_non_enumerable_property = __commonJS({
  "node_modules/core-js/internals/create-non-enumerable-property.js"(exports, module) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var definePropertyModule = require_object_define_property();
    var createPropertyDescriptor = require_create_property_descriptor();
    module.exports = DESCRIPTORS ? function(object, key, value) {
      return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
    } : function(object, key, value) {
      object[key] = value;
      return object;
    };
  }
});

// node_modules/core-js/internals/shared-key.js
var require_shared_key = __commonJS({
  "node_modules/core-js/internals/shared-key.js"(exports, module) {
    "use strict";
    var shared = require_shared();
    var uid = require_uid();
    var keys = shared("keys");
    module.exports = function(key) {
      return keys[key] || (keys[key] = uid(key));
    };
  }
});

// node_modules/core-js/internals/hidden-keys.js
var require_hidden_keys = __commonJS({
  "node_modules/core-js/internals/hidden-keys.js"(exports, module) {
    "use strict";
    module.exports = {};
  }
});

// node_modules/core-js/internals/internal-state.js
var require_internal_state = __commonJS({
  "node_modules/core-js/internals/internal-state.js"(exports, module) {
    "use strict";
    var NATIVE_WEAK_MAP = require_weak_map_basic_detection();
    var globalThis2 = require_global_this();
    var isObject = require_is_object();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var hasOwn = require_has_own_property();
    var shared = require_shared_store();
    var sharedKey = require_shared_key();
    var hiddenKeys = require_hidden_keys();
    var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
    var TypeError2 = globalThis2.TypeError;
    var WeakMap = globalThis2.WeakMap;
    var set;
    var get;
    var has;
    var enforce = function(it) {
      return has(it) ? get(it) : set(it, {});
    };
    var getterFor = function(TYPE2) {
      return function(it) {
        var state;
        if (!isObject(it) || (state = get(it)).type !== TYPE2) {
          throw new TypeError2("Incompatible receiver, " + TYPE2 + " required");
        }
        return state;
      };
    };
    if (NATIVE_WEAK_MAP || shared.state) {
      store = shared.state || (shared.state = new WeakMap());
      store.get = store.get;
      store.has = store.has;
      store.set = store.set;
      set = function(it, metadata) {
        if (store.has(it)) throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it;
        store.set(it, metadata);
        return metadata;
      };
      get = function(it) {
        return store.get(it) || {};
      };
      has = function(it) {
        return store.has(it);
      };
    } else {
      STATE = sharedKey("state");
      hiddenKeys[STATE] = true;
      set = function(it, metadata) {
        if (hasOwn(it, STATE)) throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it;
        createNonEnumerableProperty(it, STATE, metadata);
        return metadata;
      };
      get = function(it) {
        return hasOwn(it, STATE) ? it[STATE] : {};
      };
      has = function(it) {
        return hasOwn(it, STATE);
      };
    }
    var store;
    var STATE;
    module.exports = {
      set,
      get,
      has,
      enforce,
      getterFor
    };
  }
});

// node_modules/core-js/internals/make-built-in.js
var require_make_built_in = __commonJS({
  "node_modules/core-js/internals/make-built-in.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var fails = require_fails();
    var isCallable = require_is_callable();
    var hasOwn = require_has_own_property();
    var DESCRIPTORS = require_descriptors();
    var CONFIGURABLE_FUNCTION_NAME = require_function_name().CONFIGURABLE;
    var inspectSource = require_inspect_source();
    var InternalStateModule = require_internal_state();
    var enforceInternalState = InternalStateModule.enforce;
    var getInternalState = InternalStateModule.get;
    var $String = String;
    var defineProperty = Object.defineProperty;
    var stringSlice = uncurryThis("".slice);
    var replace = uncurryThis("".replace);
    var join = uncurryThis([].join);
    var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function() {
      return defineProperty(function() {
      }, "length", { value: 8 }).length !== 8;
    });
    var TEMPLATE = String(String).split("String");
    var makeBuiltIn = module.exports = function(value, name, options) {
      if (stringSlice($String(name), 0, 7) === "Symbol(") {
        name = "[" + replace($String(name), /^Symbol\(([^)]*)\).*$/, "$1") + "]";
      }
      if (options && options.getter) name = "get " + name;
      if (options && options.setter) name = "set " + name;
      if (!hasOwn(value, "name") || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {
        if (DESCRIPTORS) defineProperty(value, "name", { value: name, configurable: true });
        else value.name = name;
      }
      if (CONFIGURABLE_LENGTH && options && hasOwn(options, "arity") && value.length !== options.arity) {
        defineProperty(value, "length", { value: options.arity });
      }
      try {
        if (options && hasOwn(options, "constructor") && options.constructor) {
          if (DESCRIPTORS) defineProperty(value, "prototype", { writable: false });
        } else if (value.prototype) value.prototype = void 0;
      } catch (error) {
      }
      var state = enforceInternalState(value);
      if (!hasOwn(state, "source")) {
        state.source = join(TEMPLATE, typeof name == "string" ? name : "");
      }
      return value;
    };
    Function.prototype.toString = makeBuiltIn(function toString3() {
      return isCallable(this) && getInternalState(this).source || inspectSource(this);
    }, "toString");
  }
});

// node_modules/core-js/internals/define-built-in.js
var require_define_built_in = __commonJS({
  "node_modules/core-js/internals/define-built-in.js"(exports, module) {
    "use strict";
    var isCallable = require_is_callable();
    var definePropertyModule = require_object_define_property();
    var makeBuiltIn = require_make_built_in();
    var defineGlobalProperty = require_define_global_property();
    module.exports = function(O, key, value, options) {
      if (!options) options = {};
      var simple = options.enumerable;
      var name = options.name !== void 0 ? options.name : key;
      if (isCallable(value)) makeBuiltIn(value, name, options);
      if (options.global) {
        if (simple) O[key] = value;
        else defineGlobalProperty(key, value);
      } else {
        try {
          if (!options.unsafe) delete O[key];
          else if (O[key]) simple = true;
        } catch (error) {
        }
        if (simple) O[key] = value;
        else definePropertyModule.f(O, key, {
          value,
          enumerable: false,
          configurable: !options.nonConfigurable,
          writable: !options.nonWritable
        });
      }
      return O;
    };
  }
});

// node_modules/core-js/internals/classof-raw.js
var require_classof_raw = __commonJS({
  "node_modules/core-js/internals/classof-raw.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var toString3 = uncurryThis({}.toString);
    var stringSlice = uncurryThis("".slice);
    module.exports = function(it) {
      return stringSlice(toString3(it), 8, -1);
    };
  }
});

// node_modules/core-js/internals/classof.js
var require_classof = __commonJS({
  "node_modules/core-js/internals/classof.js"(exports, module) {
    "use strict";
    var TO_STRING_TAG_SUPPORT = require_to_string_tag_support();
    var isCallable = require_is_callable();
    var classofRaw = require_classof_raw();
    var wellKnownSymbol = require_well_known_symbol();
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    var $Object = Object;
    var CORRECT_ARGUMENTS = classofRaw(/* @__PURE__ */ (function() {
      return arguments;
    })()) === "Arguments";
    var tryGet = function(it, key) {
      try {
        return it[key];
      } catch (error) {
      }
    };
    module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {
      var O, tag, result;
      return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) === "Object" && isCallable(O.callee) ? "Arguments" : result;
    };
  }
});

// node_modules/core-js/internals/object-to-string.js
var require_object_to_string = __commonJS({
  "node_modules/core-js/internals/object-to-string.js"(exports, module) {
    "use strict";
    var TO_STRING_TAG_SUPPORT = require_to_string_tag_support();
    var classof = require_classof();
    module.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString3() {
      return "[object " + classof(this) + "]";
    };
  }
});

// node_modules/core-js/modules/es.object.to-string.js
var require_es_object_to_string = __commonJS({
  "node_modules/core-js/modules/es.object.to-string.js"() {
    "use strict";
    var TO_STRING_TAG_SUPPORT = require_to_string_tag_support();
    var defineBuiltIn = require_define_built_in();
    var toString3 = require_object_to_string();
    if (!TO_STRING_TAG_SUPPORT) {
      defineBuiltIn(Object.prototype, "toString", toString3, { unsafe: true });
    }
  }
});

// node_modules/core-js/internals/object-property-is-enumerable.js
var require_object_property_is_enumerable = __commonJS({
  "node_modules/core-js/internals/object-property-is-enumerable.js"(exports) {
    "use strict";
    var $propertyIsEnumerable = {}.propertyIsEnumerable;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);
    exports.f = NASHORN_BUG ? function propertyIsEnumerable(V2) {
      var descriptor = getOwnPropertyDescriptor(this, V2);
      return !!descriptor && descriptor.enumerable;
    } : $propertyIsEnumerable;
  }
});

// node_modules/core-js/internals/indexed-object.js
var require_indexed_object = __commonJS({
  "node_modules/core-js/internals/indexed-object.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var fails = require_fails();
    var classof = require_classof_raw();
    var $Object = Object;
    var split = uncurryThis("".split);
    module.exports = fails(function() {
      return !$Object("z").propertyIsEnumerable(0);
    }) ? function(it) {
      return classof(it) === "String" ? split(it, "") : $Object(it);
    } : $Object;
  }
});

// node_modules/core-js/internals/to-indexed-object.js
var require_to_indexed_object = __commonJS({
  "node_modules/core-js/internals/to-indexed-object.js"(exports, module) {
    "use strict";
    var IndexedObject = require_indexed_object();
    var requireObjectCoercible = require_require_object_coercible();
    module.exports = function(it) {
      return IndexedObject(requireObjectCoercible(it));
    };
  }
});

// node_modules/core-js/internals/object-get-own-property-descriptor.js
var require_object_get_own_property_descriptor = __commonJS({
  "node_modules/core-js/internals/object-get-own-property-descriptor.js"(exports) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var call = require_function_call();
    var propertyIsEnumerableModule = require_object_property_is_enumerable();
    var createPropertyDescriptor = require_create_property_descriptor();
    var toIndexedObject = require_to_indexed_object();
    var toPropertyKey = require_to_property_key();
    var hasOwn = require_has_own_property();
    var IE8_DOM_DEFINE = require_ie8_dom_define();
    var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
      O = toIndexedObject(O);
      P = toPropertyKey(P);
      if (IE8_DOM_DEFINE) try {
        return $getOwnPropertyDescriptor(O, P);
      } catch (error) {
      }
      if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
    };
  }
});

// node_modules/core-js/internals/math-trunc.js
var require_math_trunc = __commonJS({
  "node_modules/core-js/internals/math-trunc.js"(exports, module) {
    "use strict";
    var ceil = Math.ceil;
    var floor = Math.floor;
    module.exports = Math.trunc || function trunc(x) {
      var n = +x;
      return (n > 0 ? floor : ceil)(n);
    };
  }
});

// node_modules/core-js/internals/to-integer-or-infinity.js
var require_to_integer_or_infinity = __commonJS({
  "node_modules/core-js/internals/to-integer-or-infinity.js"(exports, module) {
    "use strict";
    var trunc = require_math_trunc();
    module.exports = function(argument) {
      var number = +argument;
      return number !== number || number === 0 ? 0 : trunc(number);
    };
  }
});

// node_modules/core-js/internals/to-absolute-index.js
var require_to_absolute_index = __commonJS({
  "node_modules/core-js/internals/to-absolute-index.js"(exports, module) {
    "use strict";
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var max = Math.max;
    var min = Math.min;
    module.exports = function(index, length) {
      var integer = toIntegerOrInfinity(index);
      return integer < 0 ? max(integer + length, 0) : min(integer, length);
    };
  }
});

// node_modules/core-js/internals/to-length.js
var require_to_length = __commonJS({
  "node_modules/core-js/internals/to-length.js"(exports, module) {
    "use strict";
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var min = Math.min;
    module.exports = function(argument) {
      var len = toIntegerOrInfinity(argument);
      return len > 0 ? min(len, 9007199254740991) : 0;
    };
  }
});

// node_modules/core-js/internals/length-of-array-like.js
var require_length_of_array_like = __commonJS({
  "node_modules/core-js/internals/length-of-array-like.js"(exports, module) {
    "use strict";
    var toLength = require_to_length();
    module.exports = function(obj) {
      return toLength(obj.length);
    };
  }
});

// node_modules/core-js/internals/array-includes.js
var require_array_includes = __commonJS({
  "node_modules/core-js/internals/array-includes.js"(exports, module) {
    "use strict";
    var toIndexedObject = require_to_indexed_object();
    var toAbsoluteIndex = require_to_absolute_index();
    var lengthOfArrayLike = require_length_of_array_like();
    var createMethod = function(IS_INCLUDES) {
      return function($this, el, fromIndex) {
        var O = toIndexedObject($this);
        var length = lengthOfArrayLike(O);
        if (length === 0) return !IS_INCLUDES && -1;
        var index = toAbsoluteIndex(fromIndex, length);
        var value;
        if (IS_INCLUDES && el !== el) while (length > index) {
          value = O[index++];
          if (value !== value) return true;
        }
        else for (; length > index; index++) {
          if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
        }
        return !IS_INCLUDES && -1;
      };
    };
    module.exports = {
      // `Array.prototype.includes` method
      // https://tc39.es/ecma262/#sec-array.prototype.includes
      includes: createMethod(true),
      // `Array.prototype.indexOf` method
      // https://tc39.es/ecma262/#sec-array.prototype.indexof
      indexOf: createMethod(false)
    };
  }
});

// node_modules/core-js/internals/object-keys-internal.js
var require_object_keys_internal = __commonJS({
  "node_modules/core-js/internals/object-keys-internal.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var hasOwn = require_has_own_property();
    var toIndexedObject = require_to_indexed_object();
    var indexOf = require_array_includes().indexOf;
    var hiddenKeys = require_hidden_keys();
    var push = uncurryThis([].push);
    module.exports = function(object, names) {
      var O = toIndexedObject(object);
      var i = 0;
      var result = [];
      var key;
      for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
      while (names.length > i) if (hasOwn(O, key = names[i++])) {
        ~indexOf(result, key) || push(result, key);
      }
      return result;
    };
  }
});

// node_modules/core-js/internals/enum-bug-keys.js
var require_enum_bug_keys = __commonJS({
  "node_modules/core-js/internals/enum-bug-keys.js"(exports, module) {
    "use strict";
    module.exports = [
      "constructor",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "toLocaleString",
      "toString",
      "valueOf"
    ];
  }
});

// node_modules/core-js/internals/object-get-own-property-names.js
var require_object_get_own_property_names = __commonJS({
  "node_modules/core-js/internals/object-get-own-property-names.js"(exports) {
    "use strict";
    var internalObjectKeys = require_object_keys_internal();
    var enumBugKeys = require_enum_bug_keys();
    var hiddenKeys = enumBugKeys.concat("length", "prototype");
    exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
      return internalObjectKeys(O, hiddenKeys);
    };
  }
});

// node_modules/core-js/internals/object-get-own-property-symbols.js
var require_object_get_own_property_symbols = __commonJS({
  "node_modules/core-js/internals/object-get-own-property-symbols.js"(exports) {
    "use strict";
    exports.f = Object.getOwnPropertySymbols;
  }
});

// node_modules/core-js/internals/own-keys.js
var require_own_keys = __commonJS({
  "node_modules/core-js/internals/own-keys.js"(exports, module) {
    "use strict";
    var getBuiltIn = require_get_built_in();
    var uncurryThis = require_function_uncurry_this();
    var getOwnPropertyNamesModule = require_object_get_own_property_names();
    var getOwnPropertySymbolsModule = require_object_get_own_property_symbols();
    var anObject = require_an_object();
    var concat = uncurryThis([].concat);
    module.exports = getBuiltIn("Reflect", "ownKeys") || function ownKeys(it) {
      var keys = getOwnPropertyNamesModule.f(anObject(it));
      var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
      return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
    };
  }
});

// node_modules/core-js/internals/copy-constructor-properties.js
var require_copy_constructor_properties = __commonJS({
  "node_modules/core-js/internals/copy-constructor-properties.js"(exports, module) {
    "use strict";
    var hasOwn = require_has_own_property();
    var ownKeys = require_own_keys();
    var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
    var definePropertyModule = require_object_define_property();
    module.exports = function(target, source, exceptions) {
      var keys = ownKeys(source);
      var defineProperty = definePropertyModule.f;
      var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
          defineProperty(target, key, getOwnPropertyDescriptor(source, key));
        }
      }
    };
  }
});

// node_modules/core-js/internals/is-forced.js
var require_is_forced = __commonJS({
  "node_modules/core-js/internals/is-forced.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    var isCallable = require_is_callable();
    var replacement = /#|\.prototype\./;
    var isForced = function(feature, detection) {
      var value = data[normalize(feature)];
      return value === POLYFILL ? true : value === NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;
    };
    var normalize = isForced.normalize = function(string) {
      return String(string).replace(replacement, ".").toLowerCase();
    };
    var data = isForced.data = {};
    var NATIVE = isForced.NATIVE = "N";
    var POLYFILL = isForced.POLYFILL = "P";
    module.exports = isForced;
  }
});

// node_modules/core-js/internals/export.js
var require_export = __commonJS({
  "node_modules/core-js/internals/export.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var defineBuiltIn = require_define_built_in();
    var defineGlobalProperty = require_define_global_property();
    var copyConstructorProperties = require_copy_constructor_properties();
    var isForced = require_is_forced();
    module.exports = function(options, source) {
      var TARGET = options.target;
      var GLOBAL = options.global;
      var STATIC = options.stat;
      var FORCED, target, key, targetProperty, sourceProperty, descriptor;
      if (GLOBAL) {
        target = globalThis2;
      } else if (STATIC) {
        target = globalThis2[TARGET] || defineGlobalProperty(TARGET, {});
      } else {
        target = globalThis2[TARGET] && globalThis2[TARGET].prototype;
      }
      if (target) for (key in source) {
        sourceProperty = source[key];
        if (options.dontCallGetSet) {
          descriptor = getOwnPropertyDescriptor(target, key);
          targetProperty = descriptor && descriptor.value;
        } else targetProperty = target[key];
        FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
        if (!FORCED && targetProperty !== void 0) {
          if (typeof sourceProperty == typeof targetProperty) continue;
          copyConstructorProperties(sourceProperty, targetProperty);
        }
        if (options.sham || targetProperty && targetProperty.sham) {
          createNonEnumerableProperty(sourceProperty, "sham", true);
        }
        defineBuiltIn(target, key, sourceProperty, options);
      }
    };
  }
});

// node_modules/core-js/internals/environment.js
var require_environment = __commonJS({
  "node_modules/core-js/internals/environment.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var userAgent = require_environment_user_agent();
    var classof = require_classof_raw();
    var userAgentStartsWith = function(string) {
      return userAgent.slice(0, string.length) === string;
    };
    module.exports = (function() {
      if (userAgentStartsWith("Bun/")) return "BUN";
      if (userAgentStartsWith("Cloudflare-Workers")) return "CLOUDFLARE";
      if (userAgentStartsWith("Deno/")) return "DENO";
      if (userAgentStartsWith("Node.js/")) return "NODE";
      if (globalThis2.Bun && typeof Bun.version == "string") return "BUN";
      if (globalThis2.Deno && typeof Deno.version == "object") return "DENO";
      if (classof(globalThis2.process) === "process") return "NODE";
      if (globalThis2.window && globalThis2.document) return "BROWSER";
      return "REST";
    })();
  }
});

// node_modules/core-js/internals/environment-is-node.js
var require_environment_is_node = __commonJS({
  "node_modules/core-js/internals/environment-is-node.js"(exports, module) {
    "use strict";
    var ENVIRONMENT = require_environment();
    module.exports = ENVIRONMENT === "NODE";
  }
});

// node_modules/core-js/internals/path.js
var require_path = __commonJS({
  "node_modules/core-js/internals/path.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    module.exports = globalThis2;
  }
});

// node_modules/core-js/internals/function-uncurry-this-accessor.js
var require_function_uncurry_this_accessor = __commonJS({
  "node_modules/core-js/internals/function-uncurry-this-accessor.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var aCallable = require_a_callable();
    module.exports = function(object, key, method) {
      try {
        return uncurryThis(aCallable(Object.getOwnPropertyDescriptor(object, key)[method]));
      } catch (error) {
      }
    };
  }
});

// node_modules/core-js/internals/is-possible-prototype.js
var require_is_possible_prototype = __commonJS({
  "node_modules/core-js/internals/is-possible-prototype.js"(exports, module) {
    "use strict";
    var isObject = require_is_object();
    module.exports = function(argument) {
      return isObject(argument) || argument === null;
    };
  }
});

// node_modules/core-js/internals/a-possible-prototype.js
var require_a_possible_prototype = __commonJS({
  "node_modules/core-js/internals/a-possible-prototype.js"(exports, module) {
    "use strict";
    var isPossiblePrototype = require_is_possible_prototype();
    var $String = String;
    var $TypeError = TypeError;
    module.exports = function(argument) {
      if (isPossiblePrototype(argument)) return argument;
      throw new $TypeError("Can't set " + $String(argument) + " as a prototype");
    };
  }
});

// node_modules/core-js/internals/object-set-prototype-of.js
var require_object_set_prototype_of = __commonJS({
  "node_modules/core-js/internals/object-set-prototype-of.js"(exports, module) {
    "use strict";
    var uncurryThisAccessor = require_function_uncurry_this_accessor();
    var isObject = require_is_object();
    var requireObjectCoercible = require_require_object_coercible();
    var aPossiblePrototype = require_a_possible_prototype();
    module.exports = Object.setPrototypeOf || ("__proto__" in {} ? (function() {
      var CORRECT_SETTER = false;
      var test = {};
      var setter;
      try {
        setter = uncurryThisAccessor(Object.prototype, "__proto__", "set");
        setter(test, []);
        CORRECT_SETTER = test instanceof Array;
      } catch (error) {
      }
      return function setPrototypeOf(O, proto) {
        requireObjectCoercible(O);
        aPossiblePrototype(proto);
        if (!isObject(O)) return O;
        if (CORRECT_SETTER) setter(O, proto);
        else O.__proto__ = proto;
        return O;
      };
    })() : void 0);
  }
});

// node_modules/core-js/internals/set-to-string-tag.js
var require_set_to_string_tag = __commonJS({
  "node_modules/core-js/internals/set-to-string-tag.js"(exports, module) {
    "use strict";
    var defineProperty = require_object_define_property().f;
    var hasOwn = require_has_own_property();
    var wellKnownSymbol = require_well_known_symbol();
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    module.exports = function(target, TAG, STATIC) {
      if (target && !STATIC) target = target.prototype;
      if (target && !hasOwn(target, TO_STRING_TAG)) {
        defineProperty(target, TO_STRING_TAG, { configurable: true, value: TAG });
      }
    };
  }
});

// node_modules/core-js/internals/define-built-in-accessor.js
var require_define_built_in_accessor = __commonJS({
  "node_modules/core-js/internals/define-built-in-accessor.js"(exports, module) {
    "use strict";
    var makeBuiltIn = require_make_built_in();
    var defineProperty = require_object_define_property();
    module.exports = function(target, name, descriptor) {
      if (descriptor.get) makeBuiltIn(descriptor.get, name, { getter: true });
      if (descriptor.set) makeBuiltIn(descriptor.set, name, { setter: true });
      return defineProperty.f(target, name, descriptor);
    };
  }
});

// node_modules/core-js/internals/set-species.js
var require_set_species = __commonJS({
  "node_modules/core-js/internals/set-species.js"(exports, module) {
    "use strict";
    var getBuiltIn = require_get_built_in();
    var defineBuiltInAccessor = require_define_built_in_accessor();
    var wellKnownSymbol = require_well_known_symbol();
    var DESCRIPTORS = require_descriptors();
    var SPECIES = wellKnownSymbol("species");
    module.exports = function(CONSTRUCTOR_NAME) {
      var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
      if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
        defineBuiltInAccessor(Constructor, SPECIES, {
          configurable: true,
          get: function() {
            return this;
          }
        });
      }
    };
  }
});

// node_modules/core-js/internals/an-instance.js
var require_an_instance = __commonJS({
  "node_modules/core-js/internals/an-instance.js"(exports, module) {
    "use strict";
    var isPrototypeOf = require_object_is_prototype_of();
    var $TypeError = TypeError;
    module.exports = function(it, Prototype) {
      if (isPrototypeOf(Prototype, it)) return it;
      throw new $TypeError("Incorrect invocation");
    };
  }
});

// node_modules/core-js/internals/is-constructor.js
var require_is_constructor = __commonJS({
  "node_modules/core-js/internals/is-constructor.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var fails = require_fails();
    var isCallable = require_is_callable();
    var classof = require_classof();
    var getBuiltIn = require_get_built_in();
    var inspectSource = require_inspect_source();
    var noop = function() {
    };
    var construct = getBuiltIn("Reflect", "construct");
    var constructorRegExp = /^\s*(?:class|function)\b/;
    var exec = uncurryThis(constructorRegExp.exec);
    var INCORRECT_TO_STRING = !constructorRegExp.test(noop);
    var isConstructorModern = function isConstructor(argument) {
      if (!isCallable(argument)) return false;
      try {
        construct(noop, [], argument);
        return true;
      } catch (error) {
        return false;
      }
    };
    var isConstructorLegacy = function isConstructor(argument) {
      if (!isCallable(argument)) return false;
      switch (classof(argument)) {
        case "AsyncFunction":
        case "GeneratorFunction":
        case "AsyncGeneratorFunction":
          return false;
      }
      try {
        return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
      } catch (error) {
        return true;
      }
    };
    isConstructorLegacy.sham = true;
    module.exports = !construct || fails(function() {
      var called;
      return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {
        called = true;
      }) || called;
    }) ? isConstructorLegacy : isConstructorModern;
  }
});

// node_modules/core-js/internals/a-constructor.js
var require_a_constructor = __commonJS({
  "node_modules/core-js/internals/a-constructor.js"(exports, module) {
    "use strict";
    var isConstructor = require_is_constructor();
    var tryToString = require_try_to_string();
    var $TypeError = TypeError;
    module.exports = function(argument) {
      if (isConstructor(argument)) return argument;
      throw new $TypeError(tryToString(argument) + " is not a constructor");
    };
  }
});

// node_modules/core-js/internals/species-constructor.js
var require_species_constructor = __commonJS({
  "node_modules/core-js/internals/species-constructor.js"(exports, module) {
    "use strict";
    var anObject = require_an_object();
    var aConstructor = require_a_constructor();
    var isNullOrUndefined = require_is_null_or_undefined();
    var wellKnownSymbol = require_well_known_symbol();
    var SPECIES = wellKnownSymbol("species");
    module.exports = function(O, defaultConstructor) {
      var C = anObject(O).constructor;
      var S;
      return C === void 0 || isNullOrUndefined(S = anObject(C)[SPECIES]) ? defaultConstructor : aConstructor(S);
    };
  }
});

// node_modules/core-js/internals/function-apply.js
var require_function_apply = __commonJS({
  "node_modules/core-js/internals/function-apply.js"(exports, module) {
    "use strict";
    var NATIVE_BIND = require_function_bind_native();
    var FunctionPrototype = Function.prototype;
    var apply = FunctionPrototype.apply;
    var call = FunctionPrototype.call;
    module.exports = typeof Reflect == "object" && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function() {
      return call.apply(apply, arguments);
    });
  }
});

// node_modules/core-js/internals/function-uncurry-this-clause.js
var require_function_uncurry_this_clause = __commonJS({
  "node_modules/core-js/internals/function-uncurry-this-clause.js"(exports, module) {
    "use strict";
    var classofRaw = require_classof_raw();
    var uncurryThis = require_function_uncurry_this();
    module.exports = function(fn) {
      if (classofRaw(fn) === "Function") return uncurryThis(fn);
    };
  }
});

// node_modules/core-js/internals/function-bind-context.js
var require_function_bind_context = __commonJS({
  "node_modules/core-js/internals/function-bind-context.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this_clause();
    var aCallable = require_a_callable();
    var NATIVE_BIND = require_function_bind_native();
    var bind = uncurryThis(uncurryThis.bind);
    module.exports = function(fn, that) {
      aCallable(fn);
      return that === void 0 ? fn : NATIVE_BIND ? bind(fn, that) : function() {
        return fn.apply(that, arguments);
      };
    };
  }
});

// node_modules/core-js/internals/html.js
var require_html = __commonJS({
  "node_modules/core-js/internals/html.js"(exports, module) {
    "use strict";
    var getBuiltIn = require_get_built_in();
    module.exports = getBuiltIn("document", "documentElement");
  }
});

// node_modules/core-js/internals/array-slice.js
var require_array_slice = __commonJS({
  "node_modules/core-js/internals/array-slice.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    module.exports = uncurryThis([].slice);
  }
});

// node_modules/core-js/internals/validate-arguments-length.js
var require_validate_arguments_length = __commonJS({
  "node_modules/core-js/internals/validate-arguments-length.js"(exports, module) {
    "use strict";
    var $TypeError = TypeError;
    module.exports = function(passed, required) {
      if (passed < required) throw new $TypeError("Not enough arguments");
      return passed;
    };
  }
});

// node_modules/core-js/internals/environment-is-ios.js
var require_environment_is_ios = __commonJS({
  "node_modules/core-js/internals/environment-is-ios.js"(exports, module) {
    "use strict";
    var userAgent = require_environment_user_agent();
    module.exports = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent);
  }
});

// node_modules/core-js/internals/task.js
var require_task = __commonJS({
  "node_modules/core-js/internals/task.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var apply = require_function_apply();
    var bind = require_function_bind_context();
    var isCallable = require_is_callable();
    var hasOwn = require_has_own_property();
    var fails = require_fails();
    var html = require_html();
    var arraySlice = require_array_slice();
    var createElement = require_document_create_element();
    var validateArgumentsLength = require_validate_arguments_length();
    var IS_IOS = require_environment_is_ios();
    var IS_NODE = require_environment_is_node();
    var set = globalThis2.setImmediate;
    var clear = globalThis2.clearImmediate;
    var process2 = globalThis2.process;
    var Dispatch = globalThis2.Dispatch;
    var Function2 = globalThis2.Function;
    var MessageChannel = globalThis2.MessageChannel;
    var String2 = globalThis2.String;
    var counter = 0;
    var queue = {};
    var ONREADYSTATECHANGE = "onreadystatechange";
    var $location;
    var defer;
    var channel;
    var port;
    fails(function() {
      $location = globalThis2.location;
    });
    var run = function(id) {
      if (hasOwn(queue, id)) {
        var fn = queue[id];
        delete queue[id];
        fn();
      }
    };
    var runner = function(id) {
      return function() {
        run(id);
      };
    };
    var eventListener = function(event) {
      run(event.data);
    };
    var globalPostMessageDefer = function(id) {
      globalThis2.postMessage(String2(id), $location.protocol + "//" + $location.host);
    };
    if (!set || !clear) {
      set = function setImmediate2(handler) {
        validateArgumentsLength(arguments.length, 1);
        var fn = isCallable(handler) ? handler : Function2(handler);
        var args = arraySlice(arguments, 1);
        queue[++counter] = function() {
          apply(fn, void 0, args);
        };
        defer(counter);
        return counter;
      };
      clear = function clearImmediate(id) {
        delete queue[id];
      };
      if (IS_NODE) {
        defer = function(id) {
          process2.nextTick(runner(id));
        };
      } else if (Dispatch && Dispatch.now) {
        defer = function(id) {
          Dispatch.now(runner(id));
        };
      } else if (MessageChannel && !IS_IOS) {
        channel = new MessageChannel();
        port = channel.port2;
        channel.port1.onmessage = eventListener;
        defer = bind(port.postMessage, port);
      } else if (globalThis2.addEventListener && isCallable(globalThis2.postMessage) && !globalThis2.importScripts && $location && $location.protocol !== "file:" && !fails(globalPostMessageDefer)) {
        defer = globalPostMessageDefer;
        globalThis2.addEventListener("message", eventListener, false);
      } else if (ONREADYSTATECHANGE in createElement("script")) {
        defer = function(id) {
          html.appendChild(createElement("script"))[ONREADYSTATECHANGE] = function() {
            html.removeChild(this);
            run(id);
          };
        };
      } else {
        defer = function(id) {
          setTimeout(runner(id), 0);
        };
      }
    }
    module.exports = {
      set,
      clear
    };
  }
});

// node_modules/core-js/internals/safe-get-built-in.js
var require_safe_get_built_in = __commonJS({
  "node_modules/core-js/internals/safe-get-built-in.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var DESCRIPTORS = require_descriptors();
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    module.exports = function(name) {
      if (!DESCRIPTORS) return globalThis2[name];
      var descriptor = getOwnPropertyDescriptor(globalThis2, name);
      return descriptor && descriptor.value;
    };
  }
});

// node_modules/core-js/internals/queue.js
var require_queue = __commonJS({
  "node_modules/core-js/internals/queue.js"(exports, module) {
    "use strict";
    var Queue = function() {
      this.head = null;
      this.tail = null;
    };
    Queue.prototype = {
      add: function(item) {
        var entry = { item, next: null };
        var tail = this.tail;
        if (tail) tail.next = entry;
        else this.head = entry;
        this.tail = entry;
      },
      get: function() {
        var entry = this.head;
        if (entry) {
          var next = this.head = entry.next;
          if (next === null) this.tail = null;
          return entry.item;
        }
      }
    };
    module.exports = Queue;
  }
});

// node_modules/core-js/internals/environment-is-ios-pebble.js
var require_environment_is_ios_pebble = __commonJS({
  "node_modules/core-js/internals/environment-is-ios-pebble.js"(exports, module) {
    "use strict";
    var userAgent = require_environment_user_agent();
    module.exports = /ipad|iphone|ipod/i.test(userAgent) && typeof Pebble != "undefined";
  }
});

// node_modules/core-js/internals/environment-is-webos-webkit.js
var require_environment_is_webos_webkit = __commonJS({
  "node_modules/core-js/internals/environment-is-webos-webkit.js"(exports, module) {
    "use strict";
    var userAgent = require_environment_user_agent();
    module.exports = /web0s(?!.*chrome)/i.test(userAgent);
  }
});

// node_modules/core-js/internals/microtask.js
var require_microtask = __commonJS({
  "node_modules/core-js/internals/microtask.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var safeGetBuiltIn = require_safe_get_built_in();
    var bind = require_function_bind_context();
    var macrotask = require_task().set;
    var Queue = require_queue();
    var IS_IOS = require_environment_is_ios();
    var IS_IOS_PEBBLE = require_environment_is_ios_pebble();
    var IS_WEBOS_WEBKIT = require_environment_is_webos_webkit();
    var IS_NODE = require_environment_is_node();
    var MutationObserver = globalThis2.MutationObserver || globalThis2.WebKitMutationObserver;
    var document2 = globalThis2.document;
    var process2 = globalThis2.process;
    var Promise2 = globalThis2.Promise;
    var microtask = safeGetBuiltIn("queueMicrotask");
    var notify;
    var toggle;
    var node;
    var promise;
    var then;
    if (!microtask) {
      queue = new Queue();
      flush = function() {
        var parent, fn;
        if (IS_NODE && (parent = process2.domain)) parent.exit();
        while (fn = queue.get()) try {
          fn();
        } catch (error) {
          if (queue.head) notify();
          throw error;
        }
        if (parent) parent.enter();
      };
      if (!IS_IOS && !IS_NODE && !IS_WEBOS_WEBKIT && MutationObserver && document2) {
        toggle = true;
        node = document2.createTextNode("");
        new MutationObserver(flush).observe(node, { characterData: true });
        notify = function() {
          node.data = toggle = !toggle;
        };
      } else if (!IS_IOS_PEBBLE && Promise2 && Promise2.resolve) {
        promise = Promise2.resolve(void 0);
        promise.constructor = Promise2;
        then = bind(promise.then, promise);
        notify = function() {
          then(flush);
        };
      } else if (IS_NODE) {
        notify = function() {
          process2.nextTick(flush);
        };
      } else {
        macrotask = bind(macrotask, globalThis2);
        notify = function() {
          macrotask(flush);
        };
      }
      microtask = function(fn) {
        if (!queue.head) notify();
        queue.add(fn);
      };
    }
    var queue;
    var flush;
    module.exports = microtask;
  }
});

// node_modules/core-js/internals/host-report-errors.js
var require_host_report_errors = __commonJS({
  "node_modules/core-js/internals/host-report-errors.js"(exports, module) {
    "use strict";
    module.exports = function(a2, b) {
      try {
        arguments.length === 1 ? console.error(a2) : console.error(a2, b);
      } catch (error) {
      }
    };
  }
});

// node_modules/core-js/internals/perform.js
var require_perform = __commonJS({
  "node_modules/core-js/internals/perform.js"(exports, module) {
    "use strict";
    module.exports = function(exec) {
      try {
        return { error: false, value: exec() };
      } catch (error) {
        return { error: true, value: error };
      }
    };
  }
});

// node_modules/core-js/internals/promise-native-constructor.js
var require_promise_native_constructor = __commonJS({
  "node_modules/core-js/internals/promise-native-constructor.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    module.exports = globalThis2.Promise;
  }
});

// node_modules/core-js/internals/promise-constructor-detection.js
var require_promise_constructor_detection = __commonJS({
  "node_modules/core-js/internals/promise-constructor-detection.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var NativePromiseConstructor = require_promise_native_constructor();
    var isCallable = require_is_callable();
    var isForced = require_is_forced();
    var inspectSource = require_inspect_source();
    var wellKnownSymbol = require_well_known_symbol();
    var ENVIRONMENT = require_environment();
    var IS_PURE = require_is_pure();
    var V8_VERSION = require_environment_v8_version();
    var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
    var SPECIES = wellKnownSymbol("species");
    var SUBCLASSING = false;
    var NATIVE_PROMISE_REJECTION_EVENT = isCallable(globalThis2.PromiseRejectionEvent);
    var FORCED_PROMISE_CONSTRUCTOR = isForced("Promise", function() {
      var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(NativePromiseConstructor);
      var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor);
      if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66) return true;
      if (IS_PURE && !(NativePromisePrototype["catch"] && NativePromisePrototype["finally"])) return true;
      if (!V8_VERSION || V8_VERSION < 51 || !/native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) {
        var promise = new NativePromiseConstructor(function(resolve) {
          resolve(1);
        });
        var FakePromise = function(exec) {
          exec(function() {
          }, function() {
          });
        };
        var constructor = promise.constructor = {};
        constructor[SPECIES] = FakePromise;
        SUBCLASSING = promise.then(function() {
        }) instanceof FakePromise;
        if (!SUBCLASSING) return true;
      }
      return !GLOBAL_CORE_JS_PROMISE && (ENVIRONMENT === "BROWSER" || ENVIRONMENT === "DENO") && !NATIVE_PROMISE_REJECTION_EVENT;
    });
    module.exports = {
      CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR,
      REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT,
      SUBCLASSING
    };
  }
});

// node_modules/core-js/internals/new-promise-capability.js
var require_new_promise_capability = __commonJS({
  "node_modules/core-js/internals/new-promise-capability.js"(exports, module) {
    "use strict";
    var aCallable = require_a_callable();
    var $TypeError = TypeError;
    var PromiseCapability = function(C) {
      var resolve, reject;
      this.promise = new C(function($$resolve, $$reject) {
        if (resolve !== void 0 || reject !== void 0) throw new $TypeError("Bad Promise constructor");
        resolve = $$resolve;
        reject = $$reject;
      });
      this.resolve = aCallable(resolve);
      this.reject = aCallable(reject);
    };
    module.exports.f = function(C) {
      return new PromiseCapability(C);
    };
  }
});

// node_modules/core-js/modules/es.promise.constructor.js
var require_es_promise_constructor = __commonJS({
  "node_modules/core-js/modules/es.promise.constructor.js"() {
    "use strict";
    var $ = require_export();
    var IS_PURE = require_is_pure();
    var IS_NODE = require_environment_is_node();
    var globalThis2 = require_global_this();
    var path = require_path();
    var call = require_function_call();
    var defineBuiltIn = require_define_built_in();
    var setPrototypeOf = require_object_set_prototype_of();
    var setToStringTag = require_set_to_string_tag();
    var setSpecies = require_set_species();
    var aCallable = require_a_callable();
    var isCallable = require_is_callable();
    var isObject = require_is_object();
    var anInstance = require_an_instance();
    var speciesConstructor = require_species_constructor();
    var task = require_task().set;
    var microtask = require_microtask();
    var hostReportErrors = require_host_report_errors();
    var perform = require_perform();
    var Queue = require_queue();
    var InternalStateModule = require_internal_state();
    var NativePromiseConstructor = require_promise_native_constructor();
    var PromiseConstructorDetection = require_promise_constructor_detection();
    var newPromiseCapabilityModule = require_new_promise_capability();
    var PROMISE = "Promise";
    var FORCED_PROMISE_CONSTRUCTOR = PromiseConstructorDetection.CONSTRUCTOR;
    var NATIVE_PROMISE_REJECTION_EVENT = PromiseConstructorDetection.REJECTION_EVENT;
    var NATIVE_PROMISE_SUBCLASSING = PromiseConstructorDetection.SUBCLASSING;
    var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
    var setInternalState = InternalStateModule.set;
    var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
    var PromiseConstructor = NativePromiseConstructor;
    var PromisePrototype = NativePromisePrototype;
    var TypeError2 = globalThis2.TypeError;
    var document2 = globalThis2.document;
    var process2 = globalThis2.process;
    var newPromiseCapability = newPromiseCapabilityModule.f;
    var newGenericPromiseCapability = newPromiseCapability;
    var DISPATCH_EVENT = !!(document2 && document2.createEvent && globalThis2.dispatchEvent);
    var UNHANDLED_REJECTION = "unhandledrejection";
    var REJECTION_HANDLED = "rejectionhandled";
    var PENDING = 0;
    var FULFILLED = 1;
    var REJECTED = 2;
    var HANDLED = 1;
    var UNHANDLED = 2;
    var Internal;
    var OwnPromiseCapability;
    var PromiseWrapper;
    var nativeThen;
    var isThenable = function(it) {
      var then;
      return isObject(it) && isCallable(then = it.then) ? then : false;
    };
    var callReaction = function(reaction, state) {
      var value = state.value;
      var ok = state.state === FULFILLED;
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (state.rejection === UNHANDLED) onHandleUnhandled(state);
            state.rejection = HANDLED;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value);
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(new TypeError2("Promise-chain cycle"));
          } else if (then = isThenable(result)) {
            call(then, result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (error) {
        if (domain && !exited) domain.exit();
        reject(error);
      }
    };
    var notify = function(state, isReject) {
      if (state.notified) return;
      state.notified = true;
      microtask(function() {
        var reactions = state.reactions;
        var reaction;
        while (reaction = reactions.get()) {
          callReaction(reaction, state);
        }
        state.notified = false;
        if (isReject && !state.rejection) onUnhandled(state);
      });
    };
    var dispatchEvent = function(name, promise, reason) {
      var event, handler;
      if (DISPATCH_EVENT) {
        event = document2.createEvent("Event");
        event.promise = promise;
        event.reason = reason;
        event.initEvent(name, false, true);
        globalThis2.dispatchEvent(event);
      } else event = { promise, reason };
      if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = globalThis2["on" + name])) handler(event);
      else if (name === UNHANDLED_REJECTION) hostReportErrors("Unhandled promise rejection", reason);
    };
    var onUnhandled = function(state) {
      call(task, globalThis2, function() {
        var promise = state.facade;
        var value = state.value;
        var IS_UNHANDLED = isUnhandled(state);
        var result;
        if (IS_UNHANDLED) {
          result = perform(function() {
            if (IS_NODE) {
              process2.emit("unhandledRejection", value, promise);
            } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
          });
          state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
          if (result.error) throw result.value;
        }
      });
    };
    var isUnhandled = function(state) {
      return state.rejection !== HANDLED && !state.parent;
    };
    var onHandleUnhandled = function(state) {
      call(task, globalThis2, function() {
        var promise = state.facade;
        if (IS_NODE) {
          process2.emit("rejectionHandled", promise);
        } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
      });
    };
    var bind = function(fn, state, unwrap) {
      return function(value) {
        fn(state, value, unwrap);
      };
    };
    var internalReject = function(state, value, unwrap) {
      if (state.done) return;
      state.done = true;
      if (unwrap) state = unwrap;
      state.value = value;
      state.state = REJECTED;
      notify(state, true);
    };
    var internalResolve = function(state, value, unwrap) {
      if (state.done) return;
      state.done = true;
      if (unwrap) state = unwrap;
      try {
        if (state.facade === value) throw new TypeError2("Promise can't be resolved itself");
        var then = isThenable(value);
        if (then) {
          microtask(function() {
            var wrapper = { done: false };
            try {
              call(
                then,
                value,
                bind(internalResolve, wrapper, state),
                bind(internalReject, wrapper, state)
              );
            } catch (error) {
              internalReject(wrapper, error, state);
            }
          });
        } else {
          state.value = value;
          state.state = FULFILLED;
          notify(state, false);
        }
      } catch (error) {
        internalReject({ done: false }, error, state);
      }
    };
    if (FORCED_PROMISE_CONSTRUCTOR) {
      PromiseConstructor = function Promise2(executor) {
        anInstance(this, PromisePrototype);
        aCallable(executor);
        call(Internal, this);
        var state = getInternalPromiseState(this);
        try {
          executor(bind(internalResolve, state), bind(internalReject, state));
        } catch (error) {
          internalReject(state, error);
        }
      };
      PromisePrototype = PromiseConstructor.prototype;
      Internal = function Promise2(executor) {
        setInternalState(this, {
          type: PROMISE,
          done: false,
          notified: false,
          parent: false,
          reactions: new Queue(),
          rejection: false,
          state: PENDING,
          value: null
        });
      };
      Internal.prototype = defineBuiltIn(PromisePrototype, "then", function then(onFulfilled, onRejected) {
        var state = getInternalPromiseState(this);
        var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
        state.parent = true;
        reaction.ok = isCallable(onFulfilled) ? onFulfilled : true;
        reaction.fail = isCallable(onRejected) && onRejected;
        reaction.domain = IS_NODE ? process2.domain : void 0;
        if (state.state === PENDING) state.reactions.add(reaction);
        else microtask(function() {
          callReaction(reaction, state);
        });
        return reaction.promise;
      });
      OwnPromiseCapability = function() {
        var promise = new Internal();
        var state = getInternalPromiseState(promise);
        this.promise = promise;
        this.resolve = bind(internalResolve, state);
        this.reject = bind(internalReject, state);
      };
      newPromiseCapabilityModule.f = newPromiseCapability = function(C) {
        return C === PromiseConstructor || C === PromiseWrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
      };
      if (!IS_PURE && isCallable(NativePromiseConstructor) && NativePromisePrototype !== Object.prototype) {
        nativeThen = NativePromisePrototype.then;
        if (!NATIVE_PROMISE_SUBCLASSING) {
          defineBuiltIn(NativePromisePrototype, "then", function then(onFulfilled, onRejected) {
            var that = this;
            return new PromiseConstructor(function(resolve, reject) {
              call(nativeThen, that, resolve, reject);
            }).then(onFulfilled, onRejected);
          }, { unsafe: true });
        }
        try {
          delete NativePromisePrototype.constructor;
        } catch (error) {
        }
        if (setPrototypeOf) {
          setPrototypeOf(NativePromisePrototype, PromisePrototype);
        }
      }
    }
    $({ global: true, constructor: true, wrap: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {
      Promise: PromiseConstructor
    });
    PromiseWrapper = path.Promise;
    setToStringTag(PromiseConstructor, PROMISE, false, true);
    setSpecies(PROMISE);
  }
});

// node_modules/core-js/internals/iterators.js
var require_iterators = __commonJS({
  "node_modules/core-js/internals/iterators.js"(exports, module) {
    "use strict";
    module.exports = {};
  }
});

// node_modules/core-js/internals/is-array-iterator-method.js
var require_is_array_iterator_method = __commonJS({
  "node_modules/core-js/internals/is-array-iterator-method.js"(exports, module) {
    "use strict";
    var wellKnownSymbol = require_well_known_symbol();
    var Iterators = require_iterators();
    var ITERATOR = wellKnownSymbol("iterator");
    var ArrayPrototype = Array.prototype;
    module.exports = function(it) {
      return it !== void 0 && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
    };
  }
});

// node_modules/core-js/internals/get-iterator-method.js
var require_get_iterator_method = __commonJS({
  "node_modules/core-js/internals/get-iterator-method.js"(exports, module) {
    "use strict";
    var classof = require_classof();
    var getMethod = require_get_method();
    var isNullOrUndefined = require_is_null_or_undefined();
    var Iterators = require_iterators();
    var wellKnownSymbol = require_well_known_symbol();
    var ITERATOR = wellKnownSymbol("iterator");
    module.exports = function(it) {
      if (!isNullOrUndefined(it)) return getMethod(it, ITERATOR) || getMethod(it, "@@iterator") || Iterators[classof(it)];
    };
  }
});

// node_modules/core-js/internals/get-iterator.js
var require_get_iterator = __commonJS({
  "node_modules/core-js/internals/get-iterator.js"(exports, module) {
    "use strict";
    var call = require_function_call();
    var aCallable = require_a_callable();
    var anObject = require_an_object();
    var tryToString = require_try_to_string();
    var getIteratorMethod = require_get_iterator_method();
    var $TypeError = TypeError;
    module.exports = function(argument, usingIterator) {
      var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
      if (aCallable(iteratorMethod)) return anObject(call(iteratorMethod, argument));
      throw new $TypeError(tryToString(argument) + " is not iterable");
    };
  }
});

// node_modules/core-js/internals/iterator-close.js
var require_iterator_close = __commonJS({
  "node_modules/core-js/internals/iterator-close.js"(exports, module) {
    "use strict";
    var call = require_function_call();
    var anObject = require_an_object();
    var getMethod = require_get_method();
    module.exports = function(iterator, kind, value) {
      var innerResult, innerError;
      anObject(iterator);
      try {
        innerResult = getMethod(iterator, "return");
        if (!innerResult) {
          if (kind === "throw") throw value;
          return value;
        }
        innerResult = call(innerResult, iterator);
      } catch (error) {
        innerError = true;
        innerResult = error;
      }
      if (kind === "throw") throw value;
      if (innerError) throw innerResult;
      anObject(innerResult);
      return value;
    };
  }
});

// node_modules/core-js/internals/iterate.js
var require_iterate = __commonJS({
  "node_modules/core-js/internals/iterate.js"(exports, module) {
    "use strict";
    var bind = require_function_bind_context();
    var call = require_function_call();
    var anObject = require_an_object();
    var tryToString = require_try_to_string();
    var isArrayIteratorMethod = require_is_array_iterator_method();
    var lengthOfArrayLike = require_length_of_array_like();
    var isPrototypeOf = require_object_is_prototype_of();
    var getIterator = require_get_iterator();
    var getIteratorMethod = require_get_iterator_method();
    var iteratorClose = require_iterator_close();
    var $TypeError = TypeError;
    var Result = function(stopped, result) {
      this.stopped = stopped;
      this.result = result;
    };
    var ResultPrototype = Result.prototype;
    module.exports = function(iterable, unboundFunction, options) {
      var that = options && options.that;
      var AS_ENTRIES = !!(options && options.AS_ENTRIES);
      var IS_RECORD = !!(options && options.IS_RECORD);
      var IS_ITERATOR = !!(options && options.IS_ITERATOR);
      var INTERRUPTED = !!(options && options.INTERRUPTED);
      var fn = bind(unboundFunction, that);
      var iterator, iterFn, index, length, result, next, step;
      var stop = function(condition) {
        if (iterator) iteratorClose(iterator, "normal");
        return new Result(true, condition);
      };
      var callFn = function(value) {
        if (AS_ENTRIES) {
          anObject(value);
          return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
        }
        return INTERRUPTED ? fn(value, stop) : fn(value);
      };
      if (IS_RECORD) {
        iterator = iterable.iterator;
      } else if (IS_ITERATOR) {
        iterator = iterable;
      } else {
        iterFn = getIteratorMethod(iterable);
        if (!iterFn) throw new $TypeError(tryToString(iterable) + " is not iterable");
        if (isArrayIteratorMethod(iterFn)) {
          for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {
            result = callFn(iterable[index]);
            if (result && isPrototypeOf(ResultPrototype, result)) return result;
          }
          return new Result(false);
        }
        iterator = getIterator(iterable, iterFn);
      }
      next = IS_RECORD ? iterable.next : iterator.next;
      while (!(step = call(next, iterator)).done) {
        try {
          result = callFn(step.value);
        } catch (error) {
          iteratorClose(iterator, "throw", error);
        }
        if (typeof result == "object" && result && isPrototypeOf(ResultPrototype, result)) return result;
      }
      return new Result(false);
    };
  }
});

// node_modules/core-js/internals/check-correctness-of-iteration.js
var require_check_correctness_of_iteration = __commonJS({
  "node_modules/core-js/internals/check-correctness-of-iteration.js"(exports, module) {
    "use strict";
    var wellKnownSymbol = require_well_known_symbol();
    var ITERATOR = wellKnownSymbol("iterator");
    var SAFE_CLOSING = false;
    try {
      called = 0;
      iteratorWithReturn = {
        next: function() {
          return { done: !!called++ };
        },
        "return": function() {
          SAFE_CLOSING = true;
        }
      };
      iteratorWithReturn[ITERATOR] = function() {
        return this;
      };
      Array.from(iteratorWithReturn, function() {
        throw 2;
      });
    } catch (error) {
    }
    var called;
    var iteratorWithReturn;
    module.exports = function(exec, SKIP_CLOSING) {
      try {
        if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
      } catch (error) {
        return false;
      }
      var ITERATION_SUPPORT = false;
      try {
        var object = {};
        object[ITERATOR] = function() {
          return {
            next: function() {
              return { done: ITERATION_SUPPORT = true };
            }
          };
        };
        exec(object);
      } catch (error) {
      }
      return ITERATION_SUPPORT;
    };
  }
});

// node_modules/core-js/internals/promise-statics-incorrect-iteration.js
var require_promise_statics_incorrect_iteration = __commonJS({
  "node_modules/core-js/internals/promise-statics-incorrect-iteration.js"(exports, module) {
    "use strict";
    var NativePromiseConstructor = require_promise_native_constructor();
    var checkCorrectnessOfIteration = require_check_correctness_of_iteration();
    var FORCED_PROMISE_CONSTRUCTOR = require_promise_constructor_detection().CONSTRUCTOR;
    module.exports = FORCED_PROMISE_CONSTRUCTOR || !checkCorrectnessOfIteration(function(iterable) {
      NativePromiseConstructor.all(iterable).then(void 0, function() {
      });
    });
  }
});

// node_modules/core-js/modules/es.promise.all.js
var require_es_promise_all = __commonJS({
  "node_modules/core-js/modules/es.promise.all.js"() {
    "use strict";
    var $ = require_export();
    var call = require_function_call();
    var aCallable = require_a_callable();
    var newPromiseCapabilityModule = require_new_promise_capability();
    var perform = require_perform();
    var iterate = require_iterate();
    var PROMISE_STATICS_INCORRECT_ITERATION = require_promise_statics_incorrect_iteration();
    $({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
      all: function all(iterable) {
        var C = this;
        var capability = newPromiseCapabilityModule.f(C);
        var resolve = capability.resolve;
        var reject = capability.reject;
        var result = perform(function() {
          var $promiseResolve = aCallable(C.resolve);
          var values = [];
          var counter = 0;
          var remaining = 1;
          iterate(iterable, function(promise) {
            var index = counter++;
            var alreadyCalled = false;
            remaining++;
            call($promiseResolve, C, promise).then(function(value) {
              if (alreadyCalled) return;
              alreadyCalled = true;
              values[index] = value;
              --remaining || resolve(values);
            }, reject);
          });
          --remaining || resolve(values);
        });
        if (result.error) reject(result.value);
        return capability.promise;
      }
    });
  }
});

// node_modules/core-js/modules/es.promise.catch.js
var require_es_promise_catch = __commonJS({
  "node_modules/core-js/modules/es.promise.catch.js"() {
    "use strict";
    var $ = require_export();
    var IS_PURE = require_is_pure();
    var FORCED_PROMISE_CONSTRUCTOR = require_promise_constructor_detection().CONSTRUCTOR;
    var NativePromiseConstructor = require_promise_native_constructor();
    var getBuiltIn = require_get_built_in();
    var isCallable = require_is_callable();
    var defineBuiltIn = require_define_built_in();
    var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
    $({ target: "Promise", proto: true, forced: FORCED_PROMISE_CONSTRUCTOR, real: true }, {
      "catch": function(onRejected) {
        return this.then(void 0, onRejected);
      }
    });
    if (!IS_PURE && isCallable(NativePromiseConstructor)) {
      method = getBuiltIn("Promise").prototype["catch"];
      if (NativePromisePrototype["catch"] !== method) {
        defineBuiltIn(NativePromisePrototype, "catch", method, { unsafe: true });
      }
    }
    var method;
  }
});

// node_modules/core-js/modules/es.promise.race.js
var require_es_promise_race = __commonJS({
  "node_modules/core-js/modules/es.promise.race.js"() {
    "use strict";
    var $ = require_export();
    var call = require_function_call();
    var aCallable = require_a_callable();
    var newPromiseCapabilityModule = require_new_promise_capability();
    var perform = require_perform();
    var iterate = require_iterate();
    var PROMISE_STATICS_INCORRECT_ITERATION = require_promise_statics_incorrect_iteration();
    $({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
      race: function race(iterable) {
        var C = this;
        var capability = newPromiseCapabilityModule.f(C);
        var reject = capability.reject;
        var result = perform(function() {
          var $promiseResolve = aCallable(C.resolve);
          iterate(iterable, function(promise) {
            call($promiseResolve, C, promise).then(capability.resolve, reject);
          });
        });
        if (result.error) reject(result.value);
        return capability.promise;
      }
    });
  }
});

// node_modules/core-js/modules/es.promise.reject.js
var require_es_promise_reject = __commonJS({
  "node_modules/core-js/modules/es.promise.reject.js"() {
    "use strict";
    var $ = require_export();
    var newPromiseCapabilityModule = require_new_promise_capability();
    var FORCED_PROMISE_CONSTRUCTOR = require_promise_constructor_detection().CONSTRUCTOR;
    $({ target: "Promise", stat: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {
      reject: function reject(r) {
        var capability = newPromiseCapabilityModule.f(this);
        var capabilityReject = capability.reject;
        capabilityReject(r);
        return capability.promise;
      }
    });
  }
});

// node_modules/core-js/internals/promise-resolve.js
var require_promise_resolve = __commonJS({
  "node_modules/core-js/internals/promise-resolve.js"(exports, module) {
    "use strict";
    var anObject = require_an_object();
    var isObject = require_is_object();
    var newPromiseCapability = require_new_promise_capability();
    module.exports = function(C, x) {
      anObject(C);
      if (isObject(x) && x.constructor === C) return x;
      var promiseCapability = newPromiseCapability.f(C);
      var resolve = promiseCapability.resolve;
      resolve(x);
      return promiseCapability.promise;
    };
  }
});

// node_modules/core-js/modules/es.promise.resolve.js
var require_es_promise_resolve = __commonJS({
  "node_modules/core-js/modules/es.promise.resolve.js"() {
    "use strict";
    var $ = require_export();
    var getBuiltIn = require_get_built_in();
    var IS_PURE = require_is_pure();
    var NativePromiseConstructor = require_promise_native_constructor();
    var FORCED_PROMISE_CONSTRUCTOR = require_promise_constructor_detection().CONSTRUCTOR;
    var promiseResolve = require_promise_resolve();
    var PromiseConstructorWrapper = getBuiltIn("Promise");
    var CHECK_WRAPPER = IS_PURE && !FORCED_PROMISE_CONSTRUCTOR;
    $({ target: "Promise", stat: true, forced: IS_PURE || FORCED_PROMISE_CONSTRUCTOR }, {
      resolve: function resolve(x) {
        return promiseResolve(CHECK_WRAPPER && this === PromiseConstructorWrapper ? NativePromiseConstructor : this, x);
      }
    });
  }
});

// node_modules/core-js/modules/es.promise.js
var require_es_promise = __commonJS({
  "node_modules/core-js/modules/es.promise.js"() {
    "use strict";
    require_es_promise_constructor();
    require_es_promise_all();
    require_es_promise_catch();
    require_es_promise_race();
    require_es_promise_reject();
    require_es_promise_resolve();
  }
});

// node_modules/core-js/modules/es.reflect.delete-property.js
var require_es_reflect_delete_property = __commonJS({
  "node_modules/core-js/modules/es.reflect.delete-property.js"() {
    "use strict";
    var $ = require_export();
    var anObject = require_an_object();
    var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
    $({ target: "Reflect", stat: true }, {
      deleteProperty: function deleteProperty(target, propertyKey) {
        var descriptor = getOwnPropertyDescriptor(anObject(target), propertyKey);
        return descriptor && !descriptor.configurable ? false : delete target[propertyKey];
      }
    });
  }
});

// node_modules/@babel/runtime/helpers/OverloadYield.js
var require_OverloadYield = __commonJS({
  "node_modules/@babel/runtime/helpers/OverloadYield.js"(exports, module) {
    "use strict";
    function _OverloadYield(e2, d) {
      this.v = e2, this.k = d;
    }
    module.exports = _OverloadYield, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/regeneratorDefine.js
var require_regeneratorDefine = __commonJS({
  "node_modules/@babel/runtime/helpers/regeneratorDefine.js"(exports, module) {
    "use strict";
    function _regeneratorDefine(e2, r, n, t) {
      var i = Object.defineProperty;
      try {
        i({}, "", {});
      } catch (e3) {
        i = 0;
      }
      module.exports = _regeneratorDefine = function regeneratorDefine(e3, r2, n2, t2) {
        function o(r3, n3) {
          _regeneratorDefine(e3, r3, function(e4) {
            return this._invoke(r3, n3, e4);
          });
        }
        r2 ? i ? i(e3, r2, {
          value: n2,
          enumerable: !t2,
          configurable: !t2,
          writable: !t2
        }) : e3[r2] = n2 : (o("next", 0), o("throw", 1), o("return", 2));
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _regeneratorDefine(e2, r, n, t);
    }
    module.exports = _regeneratorDefine, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/regenerator.js
var require_regenerator = __commonJS({
  "node_modules/@babel/runtime/helpers/regenerator.js"(exports, module) {
    "use strict";
    var regeneratorDefine = require_regeneratorDefine();
    function _regenerator() {
      var e2, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag";
      function i(r2, n2, o2, i2) {
        var c2 = n2 && n2.prototype instanceof Generator ? n2 : Generator, u3 = Object.create(c2.prototype);
        return regeneratorDefine(u3, "_invoke", (function(r3, n3, o3) {
          var i3, c3, u4, f3 = 0, p = o3 || [], y = false, G = {
            p: 0,
            n: 0,
            v: e2,
            a: d,
            f: d.bind(e2, 4),
            d: function d2(t2, r4) {
              return i3 = t2, c3 = 0, u4 = e2, G.n = r4, a2;
            }
          };
          function d(r4, n4) {
            for (c3 = r4, u4 = n4, t = 0; !y && f3 && !o4 && t < p.length; t++) {
              var o4, i4 = p[t], d2 = G.p, l = i4[2];
              r4 > 3 ? (o4 = l === n4) && (u4 = i4[(c3 = i4[4]) ? 5 : (c3 = 3, 3)], i4[4] = i4[5] = e2) : i4[0] <= d2 && ((o4 = r4 < 2 && d2 < i4[1]) ? (c3 = 0, G.v = n4, G.n = i4[1]) : d2 < l && (o4 = r4 < 3 || i4[0] > n4 || n4 > l) && (i4[4] = r4, i4[5] = n4, G.n = l, c3 = 0));
            }
            if (o4 || r4 > 1) return a2;
            throw y = true, n4;
          }
          return function(o4, p2, l) {
            if (f3 > 1) throw TypeError("Generator is already running");
            for (y && 1 === p2 && d(p2, l), c3 = p2, u4 = l; (t = c3 < 2 ? e2 : u4) || !y; ) {
              i3 || (c3 ? c3 < 3 ? (c3 > 1 && (G.n = -1), d(c3, u4)) : G.n = u4 : G.v = u4);
              try {
                if (f3 = 2, i3) {
                  if (c3 || (o4 = "next"), t = i3[o4]) {
                    if (!(t = t.call(i3, u4))) throw TypeError("iterator result is not an object");
                    if (!t.done) return t;
                    u4 = t.value, c3 < 2 && (c3 = 0);
                  } else 1 === c3 && (t = i3["return"]) && t.call(i3), c3 < 2 && (u4 = TypeError("The iterator does not provide a '" + o4 + "' method"), c3 = 1);
                  i3 = e2;
                } else if ((t = (y = G.n < 0) ? u4 : r3.call(n3, G)) !== a2) break;
              } catch (t2) {
                i3 = e2, c3 = 1, u4 = t2;
              } finally {
                f3 = 1;
              }
            }
            return {
              value: t,
              done: y
            };
          };
        })(r2, o2, i2), true), u3;
      }
      var a2 = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      t = Object.getPrototypeOf;
      var c = [][n] ? t(t([][n]())) : (regeneratorDefine(t = {}, n, function() {
        return this;
      }), t), u2 = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c);
      function f2(e3) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(e3, GeneratorFunctionPrototype) : (e3.__proto__ = GeneratorFunctionPrototype, regeneratorDefine(e3, o, "GeneratorFunction")), e3.prototype = Object.create(u2), e3;
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, regeneratorDefine(u2, "constructor", GeneratorFunctionPrototype), regeneratorDefine(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", regeneratorDefine(GeneratorFunctionPrototype, o, "GeneratorFunction"), regeneratorDefine(u2), regeneratorDefine(u2, o, "Generator"), regeneratorDefine(u2, n, function() {
        return this;
      }), regeneratorDefine(u2, "toString", function() {
        return "[object Generator]";
      }), (module.exports = _regenerator = function _regenerator2() {
        return {
          w: i,
          m: f2
        };
      }, module.exports.__esModule = true, module.exports["default"] = module.exports)();
    }
    module.exports = _regenerator, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/regeneratorAsyncIterator.js
var require_regeneratorAsyncIterator = __commonJS({
  "node_modules/@babel/runtime/helpers/regeneratorAsyncIterator.js"(exports, module) {
    "use strict";
    var OverloadYield = require_OverloadYield();
    var regeneratorDefine = require_regeneratorDefine();
    function AsyncIterator(t, e2) {
      function n(r2, o, i, f2) {
        try {
          var c = t[r2](o), u2 = c.value;
          return u2 instanceof OverloadYield ? e2.resolve(u2.v).then(function(t2) {
            n("next", t2, i, f2);
          }, function(t2) {
            n("throw", t2, i, f2);
          }) : e2.resolve(u2).then(function(t2) {
            c.value = t2, i(c);
          }, function(t2) {
            return n("throw", t2, i, f2);
          });
        } catch (t2) {
          f2(t2);
        }
      }
      var r;
      this.next || (regeneratorDefine(AsyncIterator.prototype), regeneratorDefine(AsyncIterator.prototype, "function" == typeof Symbol && Symbol.asyncIterator || "@asyncIterator", function() {
        return this;
      })), regeneratorDefine(this, "_invoke", function(t2, o, i) {
        function f2() {
          return new e2(function(e3, r2) {
            n(t2, i, e3, r2);
          });
        }
        return r = r ? r.then(f2, f2) : f2();
      }, true);
    }
    module.exports = AsyncIterator, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/regeneratorAsyncGen.js
var require_regeneratorAsyncGen = __commonJS({
  "node_modules/@babel/runtime/helpers/regeneratorAsyncGen.js"(exports, module) {
    "use strict";
    var regenerator = require_regenerator();
    var regeneratorAsyncIterator = require_regeneratorAsyncIterator();
    function _regeneratorAsyncGen(r, e2, t, o, n) {
      return new regeneratorAsyncIterator(regenerator().w(r, e2, t, o), n || Promise);
    }
    module.exports = _regeneratorAsyncGen, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/regeneratorAsync.js
var require_regeneratorAsync = __commonJS({
  "node_modules/@babel/runtime/helpers/regeneratorAsync.js"(exports, module) {
    "use strict";
    var regeneratorAsyncGen = require_regeneratorAsyncGen();
    function _regeneratorAsync(n, e2, r, t, o) {
      var a2 = regeneratorAsyncGen(n, e2, r, t, o);
      return a2.next().then(function(n2) {
        return n2.done ? n2.value : a2.next();
      });
    }
    module.exports = _regeneratorAsync, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/regeneratorKeys.js
var require_regeneratorKeys = __commonJS({
  "node_modules/@babel/runtime/helpers/regeneratorKeys.js"(exports, module) {
    "use strict";
    function _regeneratorKeys(e2) {
      var n = Object(e2), r = [];
      for (var t in n) r.unshift(t);
      return function e3() {
        for (; r.length; ) if ((t = r.pop()) in n) return e3.value = t, e3.done = false, e3;
        return e3.done = true, e3;
      };
    }
    module.exports = _regeneratorKeys, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/typeof.js
var require_typeof = __commonJS({
  "node_modules/@babel/runtime/helpers/typeof.js"(exports, module) {
    "use strict";
    function _typeof2(o) {
      "@babel/helpers - typeof";
      return module.exports = _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof2(o);
    }
    module.exports = _typeof2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/regeneratorValues.js
var require_regeneratorValues = __commonJS({
  "node_modules/@babel/runtime/helpers/regeneratorValues.js"(exports, module) {
    "use strict";
    var _typeof2 = require_typeof()["default"];
    function _regeneratorValues(e2) {
      if (null != e2) {
        var t = e2["function" == typeof Symbol && Symbol.iterator || "@@iterator"], r = 0;
        if (t) return t.call(e2);
        if ("function" == typeof e2.next) return e2;
        if (!isNaN(e2.length)) return {
          next: function next() {
            return e2 && r >= e2.length && (e2 = void 0), {
              value: e2 && e2[r++],
              done: !e2
            };
          }
        };
      }
      throw new TypeError(_typeof2(e2) + " is not iterable");
    }
    module.exports = _regeneratorValues, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/regeneratorRuntime.js
var require_regeneratorRuntime = __commonJS({
  "node_modules/@babel/runtime/helpers/regeneratorRuntime.js"(exports, module) {
    "use strict";
    var OverloadYield = require_OverloadYield();
    var regenerator = require_regenerator();
    var regeneratorAsync = require_regeneratorAsync();
    var regeneratorAsyncGen = require_regeneratorAsyncGen();
    var regeneratorAsyncIterator = require_regeneratorAsyncIterator();
    var regeneratorKeys = require_regeneratorKeys();
    var regeneratorValues = require_regeneratorValues();
    function _regeneratorRuntime() {
      "use strict";
      var r = regenerator(), e2 = r.m(_regeneratorRuntime), t = (Object.getPrototypeOf ? Object.getPrototypeOf(e2) : e2.__proto__).constructor;
      function n(r2) {
        var e3 = "function" == typeof r2 && r2.constructor;
        return !!e3 && (e3 === t || "GeneratorFunction" === (e3.displayName || e3.name));
      }
      var o = {
        "throw": 1,
        "return": 2,
        "break": 3,
        "continue": 3
      };
      function a2(r2) {
        var e3, t2;
        return function(n2) {
          e3 || (e3 = {
            stop: function stop() {
              return t2(n2.a, 2);
            },
            "catch": function _catch() {
              return n2.v;
            },
            abrupt: function abrupt(r3, e4) {
              return t2(n2.a, o[r3], e4);
            },
            delegateYield: function delegateYield(r3, o2, a3) {
              return e3.resultName = o2, t2(n2.d, regeneratorValues(r3), a3);
            },
            finish: function finish(r3) {
              return t2(n2.f, r3);
            }
          }, t2 = function t3(r3, _t, o2) {
            n2.p = e3.prev, n2.n = e3.next;
            try {
              return r3(_t, o2);
            } finally {
              e3.next = n2.n;
            }
          }), e3.resultName && (e3[e3.resultName] = n2.v, e3.resultName = void 0), e3.sent = n2.v, e3.next = n2.n;
          try {
            return r2.call(this, e3);
          } finally {
            n2.p = e3.prev, n2.n = e3.next;
          }
        };
      }
      return (module.exports = _regeneratorRuntime = function _regeneratorRuntime2() {
        return {
          wrap: function wrap(e3, t2, n2, o2) {
            return r.w(a2(e3), t2, n2, o2 && o2.reverse());
          },
          isGeneratorFunction: n,
          mark: r.m,
          awrap: function awrap(r2, e3) {
            return new OverloadYield(r2, e3);
          },
          AsyncIterator: regeneratorAsyncIterator,
          async: function async(r2, e3, t2, o2, u2) {
            return (n(e3) ? regeneratorAsyncGen : regeneratorAsync)(a2(r2), e3, t2, o2, u2);
          },
          keys: regeneratorKeys,
          values: regeneratorValues
        };
      }, module.exports.__esModule = true, module.exports["default"] = module.exports)();
    }
    module.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/regenerator/index.js
var require_regenerator2 = __commonJS({
  "node_modules/@babel/runtime/regenerator/index.js"(exports, module) {
    "use strict";
    var runtime = require_regeneratorRuntime()();
    module.exports = runtime;
    try {
      regeneratorRuntime = runtime;
    } catch (accidentalStrictMode) {
      if (typeof globalThis === "object") {
        globalThis.regeneratorRuntime = runtime;
      } else {
        Function("r", "regeneratorRuntime = r")(runtime);
      }
    }
  }
});

// node_modules/@babel/runtime/helpers/asyncToGenerator.js
var require_asyncToGenerator = __commonJS({
  "node_modules/@babel/runtime/helpers/asyncToGenerator.js"(exports, module) {
    "use strict";
    function asyncGeneratorStep(n, t, e2, r, o, a2, c) {
      try {
        var i = n[a2](c), u2 = i.value;
      } catch (n2) {
        return void e2(n2);
      }
      i.done ? t(u2) : Promise.resolve(u2).then(r, o);
    }
    function _asyncToGenerator(n) {
      return function() {
        var t = this, e2 = arguments;
        return new Promise(function(r, o) {
          var a2 = n.apply(t, e2);
          function _next(n2) {
            asyncGeneratorStep(a2, r, o, _next, _throw, "next", n2);
          }
          function _throw(n2) {
            asyncGeneratorStep(a2, r, o, _next, _throw, "throw", n2);
          }
          _next(void 0);
        });
      };
    }
    module.exports = _asyncToGenerator, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/core-js/internals/is-array.js
var require_is_array = __commonJS({
  "node_modules/core-js/internals/is-array.js"(exports, module) {
    "use strict";
    var classof = require_classof_raw();
    module.exports = Array.isArray || function isArray(argument) {
      return classof(argument) === "Array";
    };
  }
});

// node_modules/core-js/internals/array-species-constructor.js
var require_array_species_constructor = __commonJS({
  "node_modules/core-js/internals/array-species-constructor.js"(exports, module) {
    "use strict";
    var isArray = require_is_array();
    var isConstructor = require_is_constructor();
    var isObject = require_is_object();
    var wellKnownSymbol = require_well_known_symbol();
    var SPECIES = wellKnownSymbol("species");
    var $Array = Array;
    module.exports = function(originalArray) {
      var C;
      if (isArray(originalArray)) {
        C = originalArray.constructor;
        if (isConstructor(C) && (C === $Array || isArray(C.prototype))) C = void 0;
        else if (isObject(C)) {
          C = C[SPECIES];
          if (C === null) C = void 0;
        }
      }
      return C === void 0 ? $Array : C;
    };
  }
});

// node_modules/core-js/internals/array-species-create.js
var require_array_species_create = __commonJS({
  "node_modules/core-js/internals/array-species-create.js"(exports, module) {
    "use strict";
    var arraySpeciesConstructor = require_array_species_constructor();
    module.exports = function(originalArray, length) {
      return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
    };
  }
});

// node_modules/core-js/internals/create-property.js
var require_create_property = __commonJS({
  "node_modules/core-js/internals/create-property.js"(exports, module) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var definePropertyModule = require_object_define_property();
    var createPropertyDescriptor = require_create_property_descriptor();
    module.exports = function(object, key, value) {
      if (DESCRIPTORS) definePropertyModule.f(object, key, createPropertyDescriptor(0, value));
      else object[key] = value;
    };
  }
});

// node_modules/core-js/internals/array-iteration.js
var require_array_iteration = __commonJS({
  "node_modules/core-js/internals/array-iteration.js"(exports, module) {
    "use strict";
    var bind = require_function_bind_context();
    var IndexedObject = require_indexed_object();
    var toObject = require_to_object();
    var lengthOfArrayLike = require_length_of_array_like();
    var arraySpeciesCreate = require_array_species_create();
    var createProperty = require_create_property();
    var createMethod = function(TYPE2) {
      var IS_MAP = TYPE2 === 1;
      var IS_FILTER = TYPE2 === 2;
      var IS_SOME = TYPE2 === 3;
      var IS_EVERY = TYPE2 === 4;
      var IS_FIND_INDEX = TYPE2 === 6;
      var IS_FILTER_REJECT = TYPE2 === 7;
      var NO_HOLES = TYPE2 === 5 || IS_FIND_INDEX;
      return function($this, callbackfn, that) {
        var O = toObject($this);
        var self2 = IndexedObject(O);
        var length = lengthOfArrayLike(self2);
        var boundFunction = bind(callbackfn, that);
        var index = 0;
        var resIndex = 0;
        var target = IS_MAP ? arraySpeciesCreate($this, length) : IS_FILTER || IS_FILTER_REJECT ? arraySpeciesCreate($this, 0) : void 0;
        var value, result;
        for (; length > index; index++) if (NO_HOLES || index in self2) {
          value = self2[index];
          result = boundFunction(value, index, O);
          if (TYPE2) {
            if (IS_MAP) createProperty(target, index, result);
            else if (result) switch (TYPE2) {
              case 3:
                return true;
              // some
              case 5:
                return value;
              // find
              case 6:
                return index;
              // findIndex
              case 2:
                createProperty(target, resIndex++, value);
            }
            else switch (TYPE2) {
              case 4:
                return false;
              // every
              case 7:
                createProperty(target, resIndex++, value);
            }
          }
        }
        return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
      };
    };
    module.exports = {
      // `Array.prototype.forEach` method
      // https://tc39.es/ecma262/#sec-array.prototype.foreach
      forEach: createMethod(0),
      // `Array.prototype.map` method
      // https://tc39.es/ecma262/#sec-array.prototype.map
      map: createMethod(1),
      // `Array.prototype.filter` method
      // https://tc39.es/ecma262/#sec-array.prototype.filter
      filter: createMethod(2),
      // `Array.prototype.some` method
      // https://tc39.es/ecma262/#sec-array.prototype.some
      some: createMethod(3),
      // `Array.prototype.every` method
      // https://tc39.es/ecma262/#sec-array.prototype.every
      every: createMethod(4),
      // `Array.prototype.find` method
      // https://tc39.es/ecma262/#sec-array.prototype.find
      find: createMethod(5),
      // `Array.prototype.findIndex` method
      // https://tc39.es/ecma262/#sec-array.prototype.findIndex
      findIndex: createMethod(6),
      // `Array.prototype.filterReject` method
      // https://github.com/tc39/proposal-array-filtering
      filterReject: createMethod(7)
    };
  }
});

// node_modules/core-js/internals/array-method-has-species-support.js
var require_array_method_has_species_support = __commonJS({
  "node_modules/core-js/internals/array-method-has-species-support.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    var wellKnownSymbol = require_well_known_symbol();
    var V8_VERSION = require_environment_v8_version();
    var SPECIES = wellKnownSymbol("species");
    module.exports = function(METHOD_NAME) {
      return V8_VERSION >= 51 || !fails(function() {
        var array = [];
        var constructor = array.constructor = {};
        constructor[SPECIES] = function() {
          return { foo: 1 };
        };
        return array[METHOD_NAME](Boolean).foo !== 1;
      });
    };
  }
});

// node_modules/core-js/modules/es.array.map.js
var require_es_array_map = __commonJS({
  "node_modules/core-js/modules/es.array.map.js"() {
    "use strict";
    var $ = require_export();
    var $map = require_array_iteration().map;
    var arrayMethodHasSpeciesSupport = require_array_method_has_species_support();
    var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("map");
    $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
      map: function map(callbackfn) {
        return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      }
    });
  }
});

// node_modules/core-js/internals/to-string.js
var require_to_string = __commonJS({
  "node_modules/core-js/internals/to-string.js"(exports, module) {
    "use strict";
    var classof = require_classof();
    var $String = String;
    module.exports = function(argument) {
      if (classof(argument) === "Symbol") throw new TypeError("Cannot convert a Symbol value to a string");
      return $String(argument);
    };
  }
});

// node_modules/core-js/internals/whitespaces.js
var require_whitespaces = __commonJS({
  "node_modules/core-js/internals/whitespaces.js"(exports, module) {
    "use strict";
    module.exports = "	\n\v\f\r \xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF";
  }
});

// node_modules/core-js/internals/string-trim.js
var require_string_trim = __commonJS({
  "node_modules/core-js/internals/string-trim.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var requireObjectCoercible = require_require_object_coercible();
    var toString3 = require_to_string();
    var whitespaces = require_whitespaces();
    var replace = uncurryThis("".replace);
    var ltrim = RegExp("^[" + whitespaces + "]+");
    var rtrim = RegExp("(^|[^" + whitespaces + "])[" + whitespaces + "]+$");
    var createMethod = function(TYPE2) {
      return function($this) {
        var string = toString3(requireObjectCoercible($this));
        if (TYPE2 & 1) string = replace(string, ltrim, "");
        if (TYPE2 & 2) string = replace(string, rtrim, "$1");
        return string;
      };
    };
    module.exports = {
      // `String.prototype.{ trimLeft, trimStart }` methods
      // https://tc39.es/ecma262/#sec-string.prototype.trimstart
      start: createMethod(1),
      // `String.prototype.{ trimRight, trimEnd }` methods
      // https://tc39.es/ecma262/#sec-string.prototype.trimend
      end: createMethod(2),
      // `String.prototype.trim` method
      // https://tc39.es/ecma262/#sec-string.prototype.trim
      trim: createMethod(3)
    };
  }
});

// node_modules/core-js/internals/number-parse-float.js
var require_number_parse_float = __commonJS({
  "node_modules/core-js/internals/number-parse-float.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var fails = require_fails();
    var uncurryThis = require_function_uncurry_this();
    var toString3 = require_to_string();
    var trim = require_string_trim().trim;
    var whitespaces = require_whitespaces();
    var charAt = uncurryThis("".charAt);
    var $parseFloat = globalThis2.parseFloat;
    var Symbol2 = globalThis2.Symbol;
    var ITERATOR = Symbol2 && Symbol2.iterator;
    var FORCED = 1 / $parseFloat(whitespaces + "-0") !== -Infinity || ITERATOR && !fails(function() {
      $parseFloat(Object(ITERATOR));
    });
    module.exports = FORCED ? function parseFloat2(string) {
      var trimmedString = trim(toString3(string));
      var result = $parseFloat(trimmedString);
      return result === 0 && charAt(trimmedString, 0) === "-" ? -0 : result;
    } : $parseFloat;
  }
});

// node_modules/core-js/modules/es.parse-float.js
var require_es_parse_float = __commonJS({
  "node_modules/core-js/modules/es.parse-float.js"() {
    "use strict";
    var $ = require_export();
    var $parseFloat = require_number_parse_float();
    $({ global: true, forced: parseFloat !== $parseFloat }, {
      parseFloat: $parseFloat
    });
  }
});

// node_modules/core-js/internals/regexp-flags.js
var require_regexp_flags = __commonJS({
  "node_modules/core-js/internals/regexp-flags.js"(exports, module) {
    "use strict";
    var anObject = require_an_object();
    module.exports = function() {
      var that = anObject(this);
      var result = "";
      if (that.hasIndices) result += "d";
      if (that.global) result += "g";
      if (that.ignoreCase) result += "i";
      if (that.multiline) result += "m";
      if (that.dotAll) result += "s";
      if (that.unicode) result += "u";
      if (that.unicodeSets) result += "v";
      if (that.sticky) result += "y";
      return result;
    };
  }
});

// node_modules/core-js/internals/regexp-sticky-helpers.js
var require_regexp_sticky_helpers = __commonJS({
  "node_modules/core-js/internals/regexp-sticky-helpers.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    var globalThis2 = require_global_this();
    var $RegExp = globalThis2.RegExp;
    var UNSUPPORTED_Y = fails(function() {
      var re = $RegExp("a", "y");
      re.lastIndex = 2;
      return re.exec("abcd") !== null;
    });
    var MISSED_STICKY = UNSUPPORTED_Y || fails(function() {
      return !$RegExp("a", "y").sticky;
    });
    var BROKEN_CARET = UNSUPPORTED_Y || fails(function() {
      var re = $RegExp("^r", "gy");
      re.lastIndex = 2;
      return re.exec("str") !== null;
    });
    module.exports = {
      BROKEN_CARET,
      MISSED_STICKY,
      UNSUPPORTED_Y
    };
  }
});

// node_modules/core-js/internals/object-keys.js
var require_object_keys = __commonJS({
  "node_modules/core-js/internals/object-keys.js"(exports, module) {
    "use strict";
    var internalObjectKeys = require_object_keys_internal();
    var enumBugKeys = require_enum_bug_keys();
    module.exports = Object.keys || function keys(O) {
      return internalObjectKeys(O, enumBugKeys);
    };
  }
});

// node_modules/core-js/internals/object-define-properties.js
var require_object_define_properties = __commonJS({
  "node_modules/core-js/internals/object-define-properties.js"(exports) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var V8_PROTOTYPE_DEFINE_BUG = require_v8_prototype_define_bug();
    var definePropertyModule = require_object_define_property();
    var anObject = require_an_object();
    var toIndexedObject = require_to_indexed_object();
    var objectKeys = require_object_keys();
    exports.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
      anObject(O);
      var props = toIndexedObject(Properties);
      var keys = objectKeys(Properties);
      var length = keys.length;
      var index = 0;
      var key;
      while (length > index) definePropertyModule.f(O, key = keys[index++], props[key]);
      return O;
    };
  }
});

// node_modules/core-js/internals/object-create.js
var require_object_create = __commonJS({
  "node_modules/core-js/internals/object-create.js"(exports, module) {
    "use strict";
    var anObject = require_an_object();
    var definePropertiesModule = require_object_define_properties();
    var enumBugKeys = require_enum_bug_keys();
    var hiddenKeys = require_hidden_keys();
    var html = require_html();
    var documentCreateElement = require_document_create_element();
    var sharedKey = require_shared_key();
    var GT = ">";
    var LT = "<";
    var PROTOTYPE = "prototype";
    var SCRIPT = "script";
    var IE_PROTO = sharedKey("IE_PROTO");
    var EmptyConstructor = function() {
    };
    var scriptTag = function(content2) {
      return LT + SCRIPT + GT + content2 + LT + "/" + SCRIPT + GT;
    };
    var NullProtoObjectViaActiveX = function(activeXDocument2) {
      activeXDocument2.write(scriptTag(""));
      activeXDocument2.close();
      var temp = activeXDocument2.parentWindow.Object;
      activeXDocument2 = null;
      return temp;
    };
    var NullProtoObjectViaIFrame = function() {
      var iframe = documentCreateElement("iframe");
      var JS = "java" + SCRIPT + ":";
      var iframeDocument;
      iframe.style.display = "none";
      html.appendChild(iframe);
      iframe.src = String(JS);
      iframeDocument = iframe.contentWindow.document;
      iframeDocument.open();
      iframeDocument.write(scriptTag("document.F=Object"));
      iframeDocument.close();
      return iframeDocument.F;
    };
    var activeXDocument;
    var NullProtoObject = function() {
      try {
        activeXDocument = new ActiveXObject("htmlfile");
      } catch (error) {
      }
      NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
      var length = enumBugKeys.length;
      while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
      return NullProtoObject();
    };
    hiddenKeys[IE_PROTO] = true;
    module.exports = Object.create || function create(O, Properties) {
      var result;
      if (O !== null) {
        EmptyConstructor[PROTOTYPE] = anObject(O);
        result = new EmptyConstructor();
        EmptyConstructor[PROTOTYPE] = null;
        result[IE_PROTO] = O;
      } else result = NullProtoObject();
      return Properties === void 0 ? result : definePropertiesModule.f(result, Properties);
    };
  }
});

// node_modules/core-js/internals/regexp-unsupported-dot-all.js
var require_regexp_unsupported_dot_all = __commonJS({
  "node_modules/core-js/internals/regexp-unsupported-dot-all.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    var globalThis2 = require_global_this();
    var $RegExp = globalThis2.RegExp;
    module.exports = fails(function() {
      var re = $RegExp(".", "s");
      return !(re.dotAll && re.test("\n") && re.flags === "s");
    });
  }
});

// node_modules/core-js/internals/regexp-unsupported-ncg.js
var require_regexp_unsupported_ncg = __commonJS({
  "node_modules/core-js/internals/regexp-unsupported-ncg.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    var globalThis2 = require_global_this();
    var $RegExp = globalThis2.RegExp;
    module.exports = fails(function() {
      var re = $RegExp("(?<a>b)", "g");
      return re.exec("b").groups.a !== "b" || "b".replace(re, "$<a>c") !== "bc";
    });
  }
});

// node_modules/core-js/internals/regexp-exec.js
var require_regexp_exec = __commonJS({
  "node_modules/core-js/internals/regexp-exec.js"(exports, module) {
    "use strict";
    var call = require_function_call();
    var uncurryThis = require_function_uncurry_this();
    var toString3 = require_to_string();
    var regexpFlags = require_regexp_flags();
    var stickyHelpers = require_regexp_sticky_helpers();
    var shared = require_shared();
    var create = require_object_create();
    var getInternalState = require_internal_state().get;
    var UNSUPPORTED_DOT_ALL = require_regexp_unsupported_dot_all();
    var UNSUPPORTED_NCG = require_regexp_unsupported_ncg();
    var nativeReplace = shared("native-string-replace", String.prototype.replace);
    var nativeExec = RegExp.prototype.exec;
    var patchedExec = nativeExec;
    var charAt = uncurryThis("".charAt);
    var indexOf = uncurryThis("".indexOf);
    var replace = uncurryThis("".replace);
    var stringSlice = uncurryThis("".slice);
    var UPDATES_LAST_INDEX_WRONG = (function() {
      var re1 = /a/;
      var re2 = /b*/g;
      call(nativeExec, re1, "a");
      call(nativeExec, re2, "a");
      return re1.lastIndex !== 0 || re2.lastIndex !== 0;
    })();
    var UNSUPPORTED_Y = stickyHelpers.BROKEN_CARET;
    var NPCG_INCLUDED = /()??/.exec("")[1] !== void 0;
    var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;
    if (PATCH) {
      patchedExec = function exec(string) {
        var re = this;
        var state = getInternalState(re);
        var str = toString3(string);
        var raw = state.raw;
        var result, reCopy, lastIndex, match, i, object, group;
        if (raw) {
          raw.lastIndex = re.lastIndex;
          result = call(patchedExec, raw, str);
          re.lastIndex = raw.lastIndex;
          return result;
        }
        var groups = state.groups;
        var sticky = UNSUPPORTED_Y && re.sticky;
        var flags = call(regexpFlags, re);
        var source = re.source;
        var charsAdded = 0;
        var strCopy = str;
        if (sticky) {
          flags = replace(flags, "y", "");
          if (indexOf(flags, "g") === -1) {
            flags += "g";
          }
          strCopy = stringSlice(str, re.lastIndex);
          if (re.lastIndex > 0 && (!re.multiline || re.multiline && charAt(str, re.lastIndex - 1) !== "\n")) {
            source = "(?: " + source + ")";
            strCopy = " " + strCopy;
            charsAdded++;
          }
          reCopy = new RegExp("^(?:" + source + ")", flags);
        }
        if (NPCG_INCLUDED) {
          reCopy = new RegExp("^" + source + "$(?!\\s)", flags);
        }
        if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;
        match = call(nativeExec, sticky ? reCopy : re, strCopy);
        if (sticky) {
          if (match) {
            match.input = stringSlice(match.input, charsAdded);
            match[0] = stringSlice(match[0], charsAdded);
            match.index = re.lastIndex;
            re.lastIndex += match[0].length;
          } else re.lastIndex = 0;
        } else if (UPDATES_LAST_INDEX_WRONG && match) {
          re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
        }
        if (NPCG_INCLUDED && match && match.length > 1) {
          call(nativeReplace, match[0], reCopy, function() {
            for (i = 1; i < arguments.length - 2; i++) {
              if (arguments[i] === void 0) match[i] = void 0;
            }
          });
        }
        if (match && groups) {
          match.groups = object = create(null);
          for (i = 0; i < groups.length; i++) {
            group = groups[i];
            object[group[0]] = match[group[1]];
          }
        }
        return match;
      };
    }
    module.exports = patchedExec;
  }
});

// node_modules/core-js/modules/es.regexp.exec.js
var require_es_regexp_exec = __commonJS({
  "node_modules/core-js/modules/es.regexp.exec.js"() {
    "use strict";
    var $ = require_export();
    var exec = require_regexp_exec();
    $({ target: "RegExp", proto: true, forced: /./.exec !== exec }, {
      exec
    });
  }
});

// node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js
var require_fix_regexp_well_known_symbol_logic = __commonJS({
  "node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js"(exports, module) {
    "use strict";
    require_es_regexp_exec();
    var call = require_function_call();
    var defineBuiltIn = require_define_built_in();
    var regexpExec = require_regexp_exec();
    var fails = require_fails();
    var wellKnownSymbol = require_well_known_symbol();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var SPECIES = wellKnownSymbol("species");
    var RegExpPrototype = RegExp.prototype;
    module.exports = function(KEY, exec, FORCED, SHAM) {
      var SYMBOL = wellKnownSymbol(KEY);
      var DELEGATES_TO_SYMBOL = !fails(function() {
        var O = {};
        O[SYMBOL] = function() {
          return 7;
        };
        return ""[KEY](O) !== 7;
      });
      var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function() {
        var execCalled = false;
        var re = /a/;
        if (KEY === "split") {
          var constructor = {};
          constructor[SPECIES] = function() {
            return re;
          };
          re = { constructor, flags: "" };
          re[SYMBOL] = /./[SYMBOL];
        }
        re.exec = function() {
          execCalled = true;
          return null;
        };
        re[SYMBOL]("");
        return !execCalled;
      });
      if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || FORCED) {
        var nativeRegExpMethod = /./[SYMBOL];
        var methods = exec(SYMBOL, ""[KEY], function(nativeMethod, regexp, str, arg2, forceStringMethod) {
          var $exec = regexp.exec;
          if ($exec === regexpExec || $exec === RegExpPrototype.exec) {
            if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
              return { done: true, value: call(nativeRegExpMethod, regexp, str, arg2) };
            }
            return { done: true, value: call(nativeMethod, str, regexp, arg2) };
          }
          return { done: false };
        });
        defineBuiltIn(String.prototype, KEY, methods[0]);
        defineBuiltIn(RegExpPrototype, SYMBOL, methods[1]);
      }
      if (SHAM) createNonEnumerableProperty(RegExpPrototype[SYMBOL], "sham", true);
    };
  }
});

// node_modules/core-js/internals/string-multibyte.js
var require_string_multibyte = __commonJS({
  "node_modules/core-js/internals/string-multibyte.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var toString3 = require_to_string();
    var requireObjectCoercible = require_require_object_coercible();
    var charAt = uncurryThis("".charAt);
    var charCodeAt = uncurryThis("".charCodeAt);
    var stringSlice = uncurryThis("".slice);
    var createMethod = function(CONVERT_TO_STRING) {
      return function($this, pos) {
        var S = toString3(requireObjectCoercible($this));
        var position2 = toIntegerOrInfinity(pos);
        var size = S.length;
        var first, second;
        if (position2 < 0 || position2 >= size) return CONVERT_TO_STRING ? "" : void 0;
        first = charCodeAt(S, position2);
        return first < 55296 || first > 56319 || position2 + 1 === size || (second = charCodeAt(S, position2 + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? charAt(S, position2) : first : CONVERT_TO_STRING ? stringSlice(S, position2, position2 + 2) : (first - 55296 << 10) + (second - 56320) + 65536;
      };
    };
    module.exports = {
      // `String.prototype.codePointAt` method
      // https://tc39.es/ecma262/#sec-string.prototype.codepointat
      codeAt: createMethod(false),
      // `String.prototype.at` method
      // https://github.com/mathiasbynens/String.prototype.at
      charAt: createMethod(true)
    };
  }
});

// node_modules/core-js/internals/advance-string-index.js
var require_advance_string_index = __commonJS({
  "node_modules/core-js/internals/advance-string-index.js"(exports, module) {
    "use strict";
    var charAt = require_string_multibyte().charAt;
    module.exports = function(S, index, unicode) {
      return index + (unicode ? charAt(S, index).length : 1);
    };
  }
});

// node_modules/core-js/internals/regexp-flags-detection.js
var require_regexp_flags_detection = __commonJS({
  "node_modules/core-js/internals/regexp-flags-detection.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var fails = require_fails();
    var RegExp2 = globalThis2.RegExp;
    var FLAGS_GETTER_IS_CORRECT = !fails(function() {
      var INDICES_SUPPORT = true;
      try {
        RegExp2(".", "d");
      } catch (error) {
        INDICES_SUPPORT = false;
      }
      var O = {};
      var calls = "";
      var expected = INDICES_SUPPORT ? "dgimsy" : "gimsy";
      var addGetter = function(key2, chr) {
        Object.defineProperty(O, key2, { get: function() {
          calls += chr;
          return true;
        } });
      };
      var pairs = {
        dotAll: "s",
        global: "g",
        ignoreCase: "i",
        multiline: "m",
        sticky: "y"
      };
      if (INDICES_SUPPORT) pairs.hasIndices = "d";
      for (var key in pairs) addGetter(key, pairs[key]);
      var result = Object.getOwnPropertyDescriptor(RegExp2.prototype, "flags").get.call(O);
      return result !== expected || calls !== expected;
    });
    module.exports = { correct: FLAGS_GETTER_IS_CORRECT };
  }
});

// node_modules/core-js/internals/regexp-get-flags.js
var require_regexp_get_flags = __commonJS({
  "node_modules/core-js/internals/regexp-get-flags.js"(exports, module) {
    "use strict";
    var call = require_function_call();
    var hasOwn = require_has_own_property();
    var isPrototypeOf = require_object_is_prototype_of();
    var regExpFlagsDetection = require_regexp_flags_detection();
    var regExpFlagsGetterImplementation = require_regexp_flags();
    var RegExpPrototype = RegExp.prototype;
    module.exports = regExpFlagsDetection.correct ? function(it) {
      return it.flags;
    } : function(it) {
      return !regExpFlagsDetection.correct && isPrototypeOf(RegExpPrototype, it) && !hasOwn(it, "flags") ? call(regExpFlagsGetterImplementation, it) : it.flags;
    };
  }
});

// node_modules/core-js/internals/regexp-exec-abstract.js
var require_regexp_exec_abstract = __commonJS({
  "node_modules/core-js/internals/regexp-exec-abstract.js"(exports, module) {
    "use strict";
    var call = require_function_call();
    var anObject = require_an_object();
    var isCallable = require_is_callable();
    var classof = require_classof_raw();
    var regexpExec = require_regexp_exec();
    var $TypeError = TypeError;
    module.exports = function(R, S) {
      var exec = R.exec;
      if (isCallable(exec)) {
        var result = call(exec, R, S);
        if (result !== null) anObject(result);
        return result;
      }
      if (classof(R) === "RegExp") return call(regexpExec, R, S);
      throw new $TypeError("RegExp#exec called on incompatible receiver");
    };
  }
});

// node_modules/core-js/modules/es.string.match.js
var require_es_string_match = __commonJS({
  "node_modules/core-js/modules/es.string.match.js"() {
    "use strict";
    var call = require_function_call();
    var uncurryThis = require_function_uncurry_this();
    var fixRegExpWellKnownSymbolLogic = require_fix_regexp_well_known_symbol_logic();
    var anObject = require_an_object();
    var isObject = require_is_object();
    var toLength = require_to_length();
    var toString3 = require_to_string();
    var requireObjectCoercible = require_require_object_coercible();
    var getMethod = require_get_method();
    var advanceStringIndex = require_advance_string_index();
    var getRegExpFlags = require_regexp_get_flags();
    var regExpExec = require_regexp_exec_abstract();
    var stringIndexOf = uncurryThis("".indexOf);
    fixRegExpWellKnownSymbolLogic("match", function(MATCH2, nativeMatch, maybeCallNative) {
      return [
        // `String.prototype.match` method
        // https://tc39.es/ecma262/#sec-string.prototype.match
        function match(regexp) {
          var O = requireObjectCoercible(this);
          var matcher = isObject(regexp) ? getMethod(regexp, MATCH2) : void 0;
          return matcher ? call(matcher, regexp, O) : new RegExp(regexp)[MATCH2](toString3(O));
        },
        // `RegExp.prototype[@@match]` method
        // https://tc39.es/ecma262/#sec-regexp.prototype-@@match
        function(string) {
          var rx = anObject(this);
          var S = toString3(string);
          var res = maybeCallNative(nativeMatch, rx, S);
          if (res.done) return res.value;
          var flags = toString3(getRegExpFlags(rx));
          if (stringIndexOf(flags, "g") === -1) return regExpExec(rx, S);
          var fullUnicode = stringIndexOf(flags, "u") !== -1;
          rx.lastIndex = 0;
          var A2 = [];
          var n = 0;
          var result;
          while ((result = regExpExec(rx, S)) !== null) {
            var matchStr = toString3(result[0]);
            A2[n] = matchStr;
            if (matchStr === "") rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
            n++;
          }
          return n === 0 ? null : A2;
        }
      ];
    });
  }
});

// node_modules/core-js/internals/get-substitution.js
var require_get_substitution = __commonJS({
  "node_modules/core-js/internals/get-substitution.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var toObject = require_to_object();
    var floor = Math.floor;
    var charAt = uncurryThis("".charAt);
    var replace = uncurryThis("".replace);
    var stringSlice = uncurryThis("".slice);
    var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
    var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;
    module.exports = function(matched, str, position2, captures, namedCaptures, replacement) {
      var tailPos = position2 + matched.length;
      var m = captures.length;
      var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
      if (namedCaptures !== void 0) {
        namedCaptures = toObject(namedCaptures);
        symbols = SUBSTITUTION_SYMBOLS;
      }
      return replace(replacement, symbols, function(match, ch) {
        var capture;
        switch (charAt(ch, 0)) {
          case "$":
            return "$";
          case "&":
            return matched;
          case "`":
            return stringSlice(str, 0, position2);
          case "'":
            return stringSlice(str, tailPos);
          case "<":
            capture = namedCaptures[stringSlice(ch, 1, -1)];
            break;
          default:
            var n = +ch;
            if (n === 0) return match;
            if (n > m) {
              var f2 = floor(n / 10);
              if (f2 === 0) return match;
              if (f2 <= m) return captures[f2 - 1] === void 0 ? charAt(ch, 1) : captures[f2 - 1] + charAt(ch, 1);
              return match;
            }
            capture = captures[n - 1];
        }
        return capture === void 0 ? "" : capture;
      });
    };
  }
});

// node_modules/core-js/modules/es.string.replace.js
var require_es_string_replace = __commonJS({
  "node_modules/core-js/modules/es.string.replace.js"() {
    "use strict";
    var apply = require_function_apply();
    var call = require_function_call();
    var uncurryThis = require_function_uncurry_this();
    var fixRegExpWellKnownSymbolLogic = require_fix_regexp_well_known_symbol_logic();
    var fails = require_fails();
    var anObject = require_an_object();
    var isCallable = require_is_callable();
    var isObject = require_is_object();
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var toLength = require_to_length();
    var toString3 = require_to_string();
    var requireObjectCoercible = require_require_object_coercible();
    var advanceStringIndex = require_advance_string_index();
    var getMethod = require_get_method();
    var getSubstitution = require_get_substitution();
    var getRegExpFlags = require_regexp_get_flags();
    var regExpExec = require_regexp_exec_abstract();
    var wellKnownSymbol = require_well_known_symbol();
    var REPLACE = wellKnownSymbol("replace");
    var max = Math.max;
    var min = Math.min;
    var concat = uncurryThis([].concat);
    var push = uncurryThis([].push);
    var stringIndexOf = uncurryThis("".indexOf);
    var stringSlice = uncurryThis("".slice);
    var maybeToString = function(it) {
      return it === void 0 ? it : String(it);
    };
    var REPLACE_KEEPS_$0 = (function() {
      return "a".replace(/./, "$0") === "$0";
    })();
    var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = (function() {
      if (/./[REPLACE]) {
        return /./[REPLACE]("a", "$0") === "";
      }
      return false;
    })();
    var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function() {
      var re = /./;
      re.exec = function() {
        var result = [];
        result.groups = { a: "7" };
        return result;
      };
      return "".replace(re, "$<a>") !== "7";
    });
    fixRegExpWellKnownSymbolLogic("replace", function(_, nativeReplace, maybeCallNative) {
      var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? "$" : "$0";
      return [
        // `String.prototype.replace` method
        // https://tc39.es/ecma262/#sec-string.prototype.replace
        function replace(searchValue, replaceValue) {
          var O = requireObjectCoercible(this);
          var replacer = isObject(searchValue) ? getMethod(searchValue, REPLACE) : void 0;
          return replacer ? call(replacer, searchValue, O, replaceValue) : call(nativeReplace, toString3(O), searchValue, replaceValue);
        },
        // `RegExp.prototype[@@replace]` method
        // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
        function(string, replaceValue) {
          var rx = anObject(this);
          var S = toString3(string);
          if (typeof replaceValue == "string" && stringIndexOf(replaceValue, UNSAFE_SUBSTITUTE) === -1 && stringIndexOf(replaceValue, "$<") === -1) {
            var res = maybeCallNative(nativeReplace, rx, S, replaceValue);
            if (res.done) return res.value;
          }
          var functionalReplace = isCallable(replaceValue);
          if (!functionalReplace) replaceValue = toString3(replaceValue);
          var flags = toString3(getRegExpFlags(rx));
          var global2 = stringIndexOf(flags, "g") !== -1;
          var fullUnicode;
          if (global2) {
            fullUnicode = stringIndexOf(flags, "u") !== -1;
            rx.lastIndex = 0;
          }
          var results = [];
          var result;
          while (true) {
            result = regExpExec(rx, S);
            if (result === null) break;
            push(results, result);
            if (!global2) break;
            var matchStr = toString3(result[0]);
            if (matchStr === "") rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
          }
          var accumulatedResult = "";
          var nextSourcePosition = 0;
          for (var i = 0; i < results.length; i++) {
            result = results[i];
            var matched = toString3(result[0]);
            var position2 = max(min(toIntegerOrInfinity(result.index), S.length), 0);
            var captures = [];
            var replacement;
            for (var j = 1; j < result.length; j++) push(captures, maybeToString(result[j]));
            var namedCaptures = result.groups;
            if (functionalReplace) {
              var replacerArgs = concat([matched], captures, position2, S);
              if (namedCaptures !== void 0) push(replacerArgs, namedCaptures);
              replacement = toString3(apply(replaceValue, void 0, replacerArgs));
            } else {
              replacement = getSubstitution(matched, S, position2, captures, namedCaptures, replaceValue);
            }
            if (position2 >= nextSourcePosition) {
              accumulatedResult += stringSlice(S, nextSourcePosition, position2) + replacement;
              nextSourcePosition = position2 + matched.length;
            }
          }
          return accumulatedResult + stringSlice(S, nextSourcePosition);
        }
      ];
    }, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);
  }
});

// node_modules/core-js/internals/is-regexp.js
var require_is_regexp = __commonJS({
  "node_modules/core-js/internals/is-regexp.js"(exports, module) {
    "use strict";
    var isObject = require_is_object();
    var classof = require_classof_raw();
    var wellKnownSymbol = require_well_known_symbol();
    var MATCH2 = wellKnownSymbol("match");
    module.exports = function(it) {
      var isRegExp;
      return isObject(it) && ((isRegExp = it[MATCH2]) !== void 0 ? !!isRegExp : classof(it) === "RegExp");
    };
  }
});

// node_modules/core-js/internals/not-a-regexp.js
var require_not_a_regexp = __commonJS({
  "node_modules/core-js/internals/not-a-regexp.js"(exports, module) {
    "use strict";
    var isRegExp = require_is_regexp();
    var $TypeError = TypeError;
    module.exports = function(it) {
      if (isRegExp(it)) {
        throw new $TypeError("The method doesn't accept regular expressions");
      }
      return it;
    };
  }
});

// node_modules/core-js/internals/correct-is-regexp-logic.js
var require_correct_is_regexp_logic = __commonJS({
  "node_modules/core-js/internals/correct-is-regexp-logic.js"(exports, module) {
    "use strict";
    var wellKnownSymbol = require_well_known_symbol();
    var MATCH2 = wellKnownSymbol("match");
    module.exports = function(METHOD_NAME) {
      var regexp = /./;
      try {
        "/./"[METHOD_NAME](regexp);
      } catch (error1) {
        try {
          regexp[MATCH2] = false;
          return "/./"[METHOD_NAME](regexp);
        } catch (error2) {
        }
      }
      return false;
    };
  }
});

// node_modules/core-js/modules/es.string.starts-with.js
var require_es_string_starts_with = __commonJS({
  "node_modules/core-js/modules/es.string.starts-with.js"() {
    "use strict";
    var $ = require_export();
    var uncurryThis = require_function_uncurry_this_clause();
    var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
    var toLength = require_to_length();
    var toString3 = require_to_string();
    var notARegExp = require_not_a_regexp();
    var requireObjectCoercible = require_require_object_coercible();
    var correctIsRegExpLogic = require_correct_is_regexp_logic();
    var IS_PURE = require_is_pure();
    var stringSlice = uncurryThis("".slice);
    var min = Math.min;
    var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic("startsWith");
    var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!(function() {
      var descriptor = getOwnPropertyDescriptor(String.prototype, "startsWith");
      return descriptor && !descriptor.writable;
    })();
    $({ target: "String", proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
      startsWith: function startsWith(searchString) {
        var that = toString3(requireObjectCoercible(this));
        notARegExp(searchString);
        var index = toLength(min(arguments.length > 1 ? arguments[1] : void 0, that.length));
        var search = toString3(searchString);
        return stringSlice(that, index, index + search.length) === search;
      }
    });
  }
});

// node_modules/core-js/internals/array-method-is-strict.js
var require_array_method_is_strict = __commonJS({
  "node_modules/core-js/internals/array-method-is-strict.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    module.exports = function(METHOD_NAME, argument) {
      var method = [][METHOD_NAME];
      return !!method && fails(function() {
        method.call(null, argument || function() {
          return 1;
        }, 1);
      });
    };
  }
});

// node_modules/core-js/modules/es.array.join.js
var require_es_array_join = __commonJS({
  "node_modules/core-js/modules/es.array.join.js"() {
    "use strict";
    var $ = require_export();
    var uncurryThis = require_function_uncurry_this();
    var IndexedObject = require_indexed_object();
    var toIndexedObject = require_to_indexed_object();
    var arrayMethodIsStrict = require_array_method_is_strict();
    var nativeJoin = uncurryThis([].join);
    var ES3_STRINGS = IndexedObject !== Object;
    var FORCED = ES3_STRINGS || !arrayMethodIsStrict("join", ",");
    $({ target: "Array", proto: true, forced: FORCED }, {
      join: function join(separator) {
        return nativeJoin(toIndexedObject(this), separator === void 0 ? "," : separator);
      }
    });
  }
});

// node_modules/@babel/runtime/helpers/arrayWithHoles.js
var require_arrayWithHoles = __commonJS({
  "node_modules/@babel/runtime/helpers/arrayWithHoles.js"(exports, module) {
    "use strict";
    function _arrayWithHoles(r) {
      if (Array.isArray(r)) return r;
    }
    module.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/iterableToArrayLimit.js
var require_iterableToArrayLimit = __commonJS({
  "node_modules/@babel/runtime/helpers/iterableToArrayLimit.js"(exports, module) {
    "use strict";
    function _iterableToArrayLimit(r, l) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e2, n, i, u2, a2 = [], f2 = true, o = false;
        try {
          if (i = (t = t.call(r)).next, 0 === l) {
            if (Object(t) !== t) return;
            f2 = false;
          } else for (; !(f2 = (e2 = i.call(t)).done) && (a2.push(e2.value), a2.length !== l); f2 = true) ;
        } catch (r2) {
          o = true, n = r2;
        } finally {
          try {
            if (!f2 && null != t["return"] && (u2 = t["return"](), Object(u2) !== u2)) return;
          } finally {
            if (o) throw n;
          }
        }
        return a2;
      }
    }
    module.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/arrayLikeToArray.js
var require_arrayLikeToArray = __commonJS({
  "node_modules/@babel/runtime/helpers/arrayLikeToArray.js"(exports, module) {
    "use strict";
    function _arrayLikeToArray(r, a2) {
      (null == a2 || a2 > r.length) && (a2 = r.length);
      for (var e2 = 0, n = Array(a2); e2 < a2; e2++) n[e2] = r[e2];
      return n;
    }
    module.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js
var require_unsupportedIterableToArray = __commonJS({
  "node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js"(exports, module) {
    "use strict";
    var arrayLikeToArray = require_arrayLikeToArray();
    function _unsupportedIterableToArray(r, a2) {
      if (r) {
        if ("string" == typeof r) return arrayLikeToArray(r, a2);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? arrayLikeToArray(r, a2) : void 0;
      }
    }
    module.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/nonIterableRest.js
var require_nonIterableRest = __commonJS({
  "node_modules/@babel/runtime/helpers/nonIterableRest.js"(exports, module) {
    "use strict";
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    module.exports = _nonIterableRest, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/slicedToArray.js
var require_slicedToArray = __commonJS({
  "node_modules/@babel/runtime/helpers/slicedToArray.js"(exports, module) {
    "use strict";
    var arrayWithHoles = require_arrayWithHoles();
    var iterableToArrayLimit = require_iterableToArrayLimit();
    var unsupportedIterableToArray = require_unsupportedIterableToArray();
    var nonIterableRest = require_nonIterableRest();
    function _slicedToArray(r, e2) {
      return arrayWithHoles(r) || iterableToArrayLimit(r, e2) || unsupportedIterableToArray(r, e2) || nonIterableRest();
    }
    module.exports = _slicedToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/toPrimitive.js
var require_toPrimitive = __commonJS({
  "node_modules/@babel/runtime/helpers/toPrimitive.js"(exports, module) {
    "use strict";
    var _typeof2 = require_typeof()["default"];
    function toPrimitive(t, r) {
      if ("object" != _typeof2(t) || !t) return t;
      var e2 = t[Symbol.toPrimitive];
      if (void 0 !== e2) {
        var i = e2.call(t, r || "default");
        if ("object" != _typeof2(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    module.exports = toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/toPropertyKey.js
var require_toPropertyKey = __commonJS({
  "node_modules/@babel/runtime/helpers/toPropertyKey.js"(exports, module) {
    "use strict";
    var _typeof2 = require_typeof()["default"];
    var toPrimitive = require_toPrimitive();
    function toPropertyKey(t) {
      var i = toPrimitive(t, "string");
      return "symbol" == _typeof2(i) ? i : i + "";
    }
    module.exports = toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/defineProperty.js
var require_defineProperty = __commonJS({
  "node_modules/@babel/runtime/helpers/defineProperty.js"(exports, module) {
    "use strict";
    var toPropertyKey = require_toPropertyKey();
    function _defineProperty(e2, r, t) {
      return (r = toPropertyKey(r)) in e2 ? Object.defineProperty(e2, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
      }) : e2[r] = t, e2;
    }
    module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/classCallCheck.js
var require_classCallCheck = __commonJS({
  "node_modules/@babel/runtime/helpers/classCallCheck.js"(exports, module) {
    "use strict";
    function _classCallCheck2(a2, n) {
      if (!(a2 instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    module.exports = _classCallCheck2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/createClass.js
var require_createClass = __commonJS({
  "node_modules/@babel/runtime/helpers/createClass.js"(exports, module) {
    "use strict";
    var toPropertyKey = require_toPropertyKey();
    function _defineProperties(e2, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e2, toPropertyKey(o.key), o);
      }
    }
    function _createClass(e2, r, t) {
      return r && _defineProperties(e2.prototype, r), t && _defineProperties(e2, t), Object.defineProperty(e2, "prototype", {
        writable: false
      }), e2;
    }
    module.exports = _createClass, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/core-js/internals/does-not-exceed-safe-integer.js
var require_does_not_exceed_safe_integer = __commonJS({
  "node_modules/core-js/internals/does-not-exceed-safe-integer.js"(exports, module) {
    "use strict";
    var $TypeError = TypeError;
    var MAX_SAFE_INTEGER = 9007199254740991;
    module.exports = function(it) {
      if (it > MAX_SAFE_INTEGER) throw $TypeError("Maximum allowed index exceeded");
      return it;
    };
  }
});

// node_modules/core-js/internals/array-set-length.js
var require_array_set_length = __commonJS({
  "node_modules/core-js/internals/array-set-length.js"(exports, module) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var isArray = require_is_array();
    var $TypeError = TypeError;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var SILENT_ON_NON_WRITABLE_LENGTH_SET = DESCRIPTORS && !(function() {
      if (this !== void 0) return true;
      try {
        Object.defineProperty([], "length", { writable: false }).length = 1;
      } catch (error) {
        return error instanceof TypeError;
      }
    })();
    module.exports = SILENT_ON_NON_WRITABLE_LENGTH_SET ? function(O, length) {
      if (isArray(O) && !getOwnPropertyDescriptor(O, "length").writable) {
        throw new $TypeError("Cannot set read only .length");
      }
      return O.length = length;
    } : function(O, length) {
      return O.length = length;
    };
  }
});

// node_modules/core-js/modules/es.array.concat.js
var require_es_array_concat = __commonJS({
  "node_modules/core-js/modules/es.array.concat.js"() {
    "use strict";
    var $ = require_export();
    var fails = require_fails();
    var isArray = require_is_array();
    var isObject = require_is_object();
    var toObject = require_to_object();
    var lengthOfArrayLike = require_length_of_array_like();
    var doesNotExceedSafeInteger = require_does_not_exceed_safe_integer();
    var createProperty = require_create_property();
    var setArrayLength = require_array_set_length();
    var arraySpeciesCreate = require_array_species_create();
    var arrayMethodHasSpeciesSupport = require_array_method_has_species_support();
    var wellKnownSymbol = require_well_known_symbol();
    var V8_VERSION = require_environment_v8_version();
    var IS_CONCAT_SPREADABLE = wellKnownSymbol("isConcatSpreadable");
    var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function() {
      var array = [];
      array[IS_CONCAT_SPREADABLE] = false;
      return array.concat()[0] !== array;
    });
    var isConcatSpreadable = function(O) {
      if (!isObject(O)) return false;
      var spreadable = O[IS_CONCAT_SPREADABLE];
      return spreadable !== void 0 ? !!spreadable : isArray(O);
    };
    var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !arrayMethodHasSpeciesSupport("concat");
    $({ target: "Array", proto: true, arity: 1, forced: FORCED }, {
      // eslint-disable-next-line no-unused-vars -- required for `.length`
      concat: function concat(arg) {
        var O = toObject(this);
        var A2 = arraySpeciesCreate(O, 0);
        var n = 0;
        var i, k, length, len, E2;
        for (i = -1, length = arguments.length; i < length; i++) {
          E2 = i === -1 ? O : arguments[i];
          if (isConcatSpreadable(E2)) {
            len = lengthOfArrayLike(E2);
            doesNotExceedSafeInteger(n + len);
            for (k = 0; k < len; k++, n++) if (k in E2) createProperty(A2, n, E2[k]);
          } else {
            doesNotExceedSafeInteger(n + 1);
            createProperty(A2, n++, E2);
          }
        }
        setArrayLength(A2, n);
        return A2;
      }
    });
  }
});

// node_modules/core-js/modules/es.array.every.js
var require_es_array_every = __commonJS({
  "node_modules/core-js/modules/es.array.every.js"() {
    "use strict";
    var $ = require_export();
    var $every = require_array_iteration().every;
    var arrayMethodIsStrict = require_array_method_is_strict();
    var STRICT_METHOD = arrayMethodIsStrict("every");
    $({ target: "Array", proto: true, forced: !STRICT_METHOD }, {
      every: function every(callbackfn) {
        return $every(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      }
    });
  }
});

// node_modules/core-js/internals/array-reduce.js
var require_array_reduce = __commonJS({
  "node_modules/core-js/internals/array-reduce.js"(exports, module) {
    "use strict";
    var aCallable = require_a_callable();
    var toObject = require_to_object();
    var IndexedObject = require_indexed_object();
    var lengthOfArrayLike = require_length_of_array_like();
    var $TypeError = TypeError;
    var REDUCE_EMPTY = "Reduce of empty array with no initial value";
    var createMethod = function(IS_RIGHT) {
      return function(that, callbackfn, argumentsLength, memo) {
        var O = toObject(that);
        var self2 = IndexedObject(O);
        var length = lengthOfArrayLike(O);
        aCallable(callbackfn);
        if (length === 0 && argumentsLength < 2) throw new $TypeError(REDUCE_EMPTY);
        var index = IS_RIGHT ? length - 1 : 0;
        var i = IS_RIGHT ? -1 : 1;
        if (argumentsLength < 2) while (true) {
          if (index in self2) {
            memo = self2[index];
            index += i;
            break;
          }
          index += i;
          if (IS_RIGHT ? index < 0 : length <= index) {
            throw new $TypeError(REDUCE_EMPTY);
          }
        }
        for (; IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self2) {
          memo = callbackfn(memo, self2[index], index, O);
        }
        return memo;
      };
    };
    module.exports = {
      // `Array.prototype.reduce` method
      // https://tc39.es/ecma262/#sec-array.prototype.reduce
      left: createMethod(false),
      // `Array.prototype.reduceRight` method
      // https://tc39.es/ecma262/#sec-array.prototype.reduceright
      right: createMethod(true)
    };
  }
});

// node_modules/core-js/modules/es.array.reduce.js
var require_es_array_reduce = __commonJS({
  "node_modules/core-js/modules/es.array.reduce.js"() {
    "use strict";
    var $ = require_export();
    var $reduce = require_array_reduce().left;
    var arrayMethodIsStrict = require_array_method_is_strict();
    var CHROME_VERSION = require_environment_v8_version();
    var IS_NODE = require_environment_is_node();
    var CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;
    var FORCED = CHROME_BUG || !arrayMethodIsStrict("reduce");
    $({ target: "Array", proto: true, forced: FORCED }, {
      reduce: function reduce(callbackfn) {
        var length = arguments.length;
        return $reduce(this, callbackfn, length, length > 1 ? arguments[1] : void 0);
      }
    });
  }
});

// node_modules/core-js/modules/es.string.ends-with.js
var require_es_string_ends_with = __commonJS({
  "node_modules/core-js/modules/es.string.ends-with.js"() {
    "use strict";
    var $ = require_export();
    var uncurryThis = require_function_uncurry_this_clause();
    var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
    var toLength = require_to_length();
    var toString3 = require_to_string();
    var notARegExp = require_not_a_regexp();
    var requireObjectCoercible = require_require_object_coercible();
    var correctIsRegExpLogic = require_correct_is_regexp_logic();
    var IS_PURE = require_is_pure();
    var slice = uncurryThis("".slice);
    var min = Math.min;
    var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic("endsWith");
    var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!(function() {
      var descriptor = getOwnPropertyDescriptor(String.prototype, "endsWith");
      return descriptor && !descriptor.writable;
    })();
    $({ target: "String", proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
      endsWith: function endsWith(searchString) {
        var that = toString3(requireObjectCoercible(this));
        notARegExp(searchString);
        var endPosition = arguments.length > 1 ? arguments[1] : void 0;
        var len = that.length;
        var end = endPosition === void 0 ? len : min(toLength(endPosition), len);
        var search = toString3(searchString);
        return slice(that, end - search.length, end) === search;
      }
    });
  }
});

// node_modules/core-js/modules/es.string.split.js
var require_es_string_split = __commonJS({
  "node_modules/core-js/modules/es.string.split.js"() {
    "use strict";
    var call = require_function_call();
    var uncurryThis = require_function_uncurry_this();
    var fixRegExpWellKnownSymbolLogic = require_fix_regexp_well_known_symbol_logic();
    var anObject = require_an_object();
    var isObject = require_is_object();
    var requireObjectCoercible = require_require_object_coercible();
    var speciesConstructor = require_species_constructor();
    var advanceStringIndex = require_advance_string_index();
    var toLength = require_to_length();
    var toString3 = require_to_string();
    var getMethod = require_get_method();
    var regExpExec = require_regexp_exec_abstract();
    var stickyHelpers = require_regexp_sticky_helpers();
    var fails = require_fails();
    var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
    var MAX_UINT32 = 4294967295;
    var min = Math.min;
    var push = uncurryThis([].push);
    var stringSlice = uncurryThis("".slice);
    var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function() {
      var re = /(?:)/;
      var originalExec = re.exec;
      re.exec = function() {
        return originalExec.apply(this, arguments);
      };
      var result = "ab".split(re);
      return result.length !== 2 || result[0] !== "a" || result[1] !== "b";
    });
    var BUGGY = "abbc".split(/(b)*/)[1] === "c" || // eslint-disable-next-line regexp/no-empty-group -- required for testing
    "test".split(/(?:)/, -1).length !== 4 || "ab".split(/(?:ab)*/).length !== 2 || ".".split(/(.?)(.?)/).length !== 4 || // eslint-disable-next-line regexp/no-empty-capturing-group, regexp/no-empty-group -- required for testing
    ".".split(/()()/).length > 1 || "".split(/.?/).length;
    fixRegExpWellKnownSymbolLogic("split", function(SPLIT, nativeSplit, maybeCallNative) {
      var internalSplit = "0".split(void 0, 0).length ? function(separator, limit) {
        return separator === void 0 && limit === 0 ? [] : call(nativeSplit, this, separator, limit);
      } : nativeSplit;
      return [
        // `String.prototype.split` method
        // https://tc39.es/ecma262/#sec-string.prototype.split
        function split(separator, limit) {
          var O = requireObjectCoercible(this);
          var splitter = isObject(separator) ? getMethod(separator, SPLIT) : void 0;
          return splitter ? call(splitter, separator, O, limit) : call(internalSplit, toString3(O), separator, limit);
        },
        // `RegExp.prototype[@@split]` method
        // https://tc39.es/ecma262/#sec-regexp.prototype-@@split
        //
        // NOTE: This cannot be properly polyfilled in engines that don't support
        // the 'y' flag.
        function(string, limit) {
          var rx = anObject(this);
          var S = toString3(string);
          if (!BUGGY) {
            var res = maybeCallNative(internalSplit, rx, S, limit, internalSplit !== nativeSplit);
            if (res.done) return res.value;
          }
          var C = speciesConstructor(rx, RegExp);
          var unicodeMatching = rx.unicode;
          var flags = (rx.ignoreCase ? "i" : "") + (rx.multiline ? "m" : "") + (rx.unicode ? "u" : "") + (UNSUPPORTED_Y ? "g" : "y");
          var splitter = new C(UNSUPPORTED_Y ? "^(?:" + rx.source + ")" : rx, flags);
          var lim = limit === void 0 ? MAX_UINT32 : limit >>> 0;
          if (lim === 0) return [];
          if (S.length === 0) return regExpExec(splitter, S) === null ? [S] : [];
          var p = 0;
          var q = 0;
          var A2 = [];
          while (q < S.length) {
            splitter.lastIndex = UNSUPPORTED_Y ? 0 : q;
            var z2 = regExpExec(splitter, UNSUPPORTED_Y ? stringSlice(S, q) : S);
            var e2;
            if (z2 === null || (e2 = min(toLength(splitter.lastIndex + (UNSUPPORTED_Y ? q : 0)), S.length)) === p) {
              q = advanceStringIndex(S, q, unicodeMatching);
            } else {
              push(A2, stringSlice(S, p, q));
              if (A2.length === lim) return A2;
              for (var i = 1; i <= z2.length - 1; i++) {
                push(A2, z2[i]);
                if (A2.length === lim) return A2;
              }
              q = p = e2;
            }
          }
          push(A2, stringSlice(S, p));
          return A2;
        }
      ];
    }, BUGGY || !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC, UNSUPPORTED_Y);
  }
});

// node_modules/performance-now/lib/performance-now.js
var require_performance_now = __commonJS({
  "node_modules/performance-now/lib/performance-now.js"(exports, module) {
    "use strict";
    (function() {
      var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;
      if (typeof performance !== "undefined" && performance !== null && performance.now) {
        module.exports = function() {
          return performance.now();
        };
      } else if (typeof process !== "undefined" && process !== null && process.hrtime) {
        module.exports = function() {
          return (getNanoSeconds() - nodeLoadTime) / 1e6;
        };
        hrtime = process.hrtime;
        getNanoSeconds = function() {
          var hr;
          hr = hrtime();
          return hr[0] * 1e9 + hr[1];
        };
        moduleLoadTime = getNanoSeconds();
        upTime = process.uptime() * 1e9;
        nodeLoadTime = moduleLoadTime - upTime;
      } else if (Date.now) {
        module.exports = function() {
          return Date.now() - loadTime;
        };
        loadTime = Date.now();
      } else {
        module.exports = function() {
          return (/* @__PURE__ */ new Date()).getTime() - loadTime;
        };
        loadTime = (/* @__PURE__ */ new Date()).getTime();
      }
    }).call(exports);
  }
});

// node_modules/raf/index.js
var require_raf = __commonJS({
  "node_modules/raf/index.js"(exports, module) {
    "use strict";
    var now = require_performance_now();
    var root = typeof window === "undefined" ? global : window;
    var vendors = ["moz", "webkit"];
    var suffix = "AnimationFrame";
    var raf = root["request" + suffix];
    var caf = root["cancel" + suffix] || root["cancelRequest" + suffix];
    for (i = 0; !raf && i < vendors.length; i++) {
      raf = root[vendors[i] + "Request" + suffix];
      caf = root[vendors[i] + "Cancel" + suffix] || root[vendors[i] + "CancelRequest" + suffix];
    }
    var i;
    if (!raf || !caf) {
      last = 0, id = 0, queue = [], frameDuration = 1e3 / 60;
      raf = function(callback) {
        if (queue.length === 0) {
          var _now = now(), next = Math.max(0, frameDuration - (_now - last));
          last = next + _now;
          setTimeout(function() {
            var cp = queue.slice(0);
            queue.length = 0;
            for (var i2 = 0; i2 < cp.length; i2++) {
              if (!cp[i2].cancelled) {
                try {
                  cp[i2].callback(last);
                } catch (e2) {
                  setTimeout(function() {
                    throw e2;
                  }, 0);
                }
              }
            }
          }, Math.round(next));
        }
        queue.push({
          handle: ++id,
          callback,
          cancelled: false
        });
        return id;
      };
      caf = function(handle) {
        for (var i2 = 0; i2 < queue.length; i2++) {
          if (queue[i2].handle === handle) {
            queue[i2].cancelled = true;
          }
        }
      };
    }
    var last;
    var id;
    var queue;
    var frameDuration;
    module.exports = function(fn) {
      return raf.call(root, fn);
    };
    module.exports.cancel = function() {
      caf.apply(root, arguments);
    };
    module.exports.polyfill = function(object) {
      if (!object) {
        object = root;
      }
      object.requestAnimationFrame = raf;
      object.cancelAnimationFrame = caf;
    };
  }
});

// node_modules/core-js/modules/es.function.name.js
var require_es_function_name = __commonJS({
  "node_modules/core-js/modules/es.function.name.js"() {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var FUNCTION_NAME_EXISTS = require_function_name().EXISTS;
    var uncurryThis = require_function_uncurry_this();
    var defineBuiltInAccessor = require_define_built_in_accessor();
    var FunctionPrototype = Function.prototype;
    var functionToString = uncurryThis(FunctionPrototype.toString);
    var nameRE = /function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/;
    var regExpExec = uncurryThis(nameRE.exec);
    var NAME2 = "name";
    if (DESCRIPTORS && !FUNCTION_NAME_EXISTS) {
      defineBuiltInAccessor(FunctionPrototype, NAME2, {
        configurable: true,
        get: function() {
          try {
            return regExpExec(nameRE, functionToString(this))[1];
          } catch (error) {
            return "";
          }
        }
      });
    }
  }
});

// node_modules/core-js/internals/string-trim-forced.js
var require_string_trim_forced = __commonJS({
  "node_modules/core-js/internals/string-trim-forced.js"(exports, module) {
    "use strict";
    var PROPER_FUNCTION_NAME = require_function_name().PROPER;
    var fails = require_fails();
    var whitespaces = require_whitespaces();
    var non = "\u200B\x85\u180E";
    module.exports = function(METHOD_NAME) {
      return fails(function() {
        return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() !== non || PROPER_FUNCTION_NAME && whitespaces[METHOD_NAME].name !== METHOD_NAME;
      });
    };
  }
});

// node_modules/core-js/modules/es.string.trim.js
var require_es_string_trim = __commonJS({
  "node_modules/core-js/modules/es.string.trim.js"() {
    "use strict";
    var $ = require_export();
    var $trim = require_string_trim().trim;
    var forcedStringTrimMethod = require_string_trim_forced();
    $({ target: "String", proto: true, forced: forcedStringTrimMethod("trim") }, {
      trim: function trim() {
        return $trim(this);
      }
    });
  }
});

// node_modules/rgbcolor/index.js
var require_rgbcolor = __commonJS({
  "node_modules/rgbcolor/index.js"(exports, module) {
    "use strict";
    module.exports = function(color_string) {
      this.ok = false;
      this.alpha = 1;
      if (color_string.charAt(0) == "#") {
        color_string = color_string.substr(1, 6);
      }
      color_string = color_string.replace(/ /g, "");
      color_string = color_string.toLowerCase();
      var simple_colors = {
        aliceblue: "f0f8ff",
        antiquewhite: "faebd7",
        aqua: "00ffff",
        aquamarine: "7fffd4",
        azure: "f0ffff",
        beige: "f5f5dc",
        bisque: "ffe4c4",
        black: "000000",
        blanchedalmond: "ffebcd",
        blue: "0000ff",
        blueviolet: "8a2be2",
        brown: "a52a2a",
        burlywood: "deb887",
        cadetblue: "5f9ea0",
        chartreuse: "7fff00",
        chocolate: "d2691e",
        coral: "ff7f50",
        cornflowerblue: "6495ed",
        cornsilk: "fff8dc",
        crimson: "dc143c",
        cyan: "00ffff",
        darkblue: "00008b",
        darkcyan: "008b8b",
        darkgoldenrod: "b8860b",
        darkgray: "a9a9a9",
        darkgreen: "006400",
        darkkhaki: "bdb76b",
        darkmagenta: "8b008b",
        darkolivegreen: "556b2f",
        darkorange: "ff8c00",
        darkorchid: "9932cc",
        darkred: "8b0000",
        darksalmon: "e9967a",
        darkseagreen: "8fbc8f",
        darkslateblue: "483d8b",
        darkslategray: "2f4f4f",
        darkturquoise: "00ced1",
        darkviolet: "9400d3",
        deeppink: "ff1493",
        deepskyblue: "00bfff",
        dimgray: "696969",
        dodgerblue: "1e90ff",
        feldspar: "d19275",
        firebrick: "b22222",
        floralwhite: "fffaf0",
        forestgreen: "228b22",
        fuchsia: "ff00ff",
        gainsboro: "dcdcdc",
        ghostwhite: "f8f8ff",
        gold: "ffd700",
        goldenrod: "daa520",
        gray: "808080",
        green: "008000",
        greenyellow: "adff2f",
        honeydew: "f0fff0",
        hotpink: "ff69b4",
        indianred: "cd5c5c",
        indigo: "4b0082",
        ivory: "fffff0",
        khaki: "f0e68c",
        lavender: "e6e6fa",
        lavenderblush: "fff0f5",
        lawngreen: "7cfc00",
        lemonchiffon: "fffacd",
        lightblue: "add8e6",
        lightcoral: "f08080",
        lightcyan: "e0ffff",
        lightgoldenrodyellow: "fafad2",
        lightgrey: "d3d3d3",
        lightgreen: "90ee90",
        lightpink: "ffb6c1",
        lightsalmon: "ffa07a",
        lightseagreen: "20b2aa",
        lightskyblue: "87cefa",
        lightslateblue: "8470ff",
        lightslategray: "778899",
        lightsteelblue: "b0c4de",
        lightyellow: "ffffe0",
        lime: "00ff00",
        limegreen: "32cd32",
        linen: "faf0e6",
        magenta: "ff00ff",
        maroon: "800000",
        mediumaquamarine: "66cdaa",
        mediumblue: "0000cd",
        mediumorchid: "ba55d3",
        mediumpurple: "9370d8",
        mediumseagreen: "3cb371",
        mediumslateblue: "7b68ee",
        mediumspringgreen: "00fa9a",
        mediumturquoise: "48d1cc",
        mediumvioletred: "c71585",
        midnightblue: "191970",
        mintcream: "f5fffa",
        mistyrose: "ffe4e1",
        moccasin: "ffe4b5",
        navajowhite: "ffdead",
        navy: "000080",
        oldlace: "fdf5e6",
        olive: "808000",
        olivedrab: "6b8e23",
        orange: "ffa500",
        orangered: "ff4500",
        orchid: "da70d6",
        palegoldenrod: "eee8aa",
        palegreen: "98fb98",
        paleturquoise: "afeeee",
        palevioletred: "d87093",
        papayawhip: "ffefd5",
        peachpuff: "ffdab9",
        peru: "cd853f",
        pink: "ffc0cb",
        plum: "dda0dd",
        powderblue: "b0e0e6",
        purple: "800080",
        rebeccapurple: "663399",
        red: "ff0000",
        rosybrown: "bc8f8f",
        royalblue: "4169e1",
        saddlebrown: "8b4513",
        salmon: "fa8072",
        sandybrown: "f4a460",
        seagreen: "2e8b57",
        seashell: "fff5ee",
        sienna: "a0522d",
        silver: "c0c0c0",
        skyblue: "87ceeb",
        slateblue: "6a5acd",
        slategray: "708090",
        snow: "fffafa",
        springgreen: "00ff7f",
        steelblue: "4682b4",
        tan: "d2b48c",
        teal: "008080",
        thistle: "d8bfd8",
        tomato: "ff6347",
        turquoise: "40e0d0",
        violet: "ee82ee",
        violetred: "d02090",
        wheat: "f5deb3",
        white: "ffffff",
        whitesmoke: "f5f5f5",
        yellow: "ffff00",
        yellowgreen: "9acd32"
      };
      color_string = simple_colors[color_string] || color_string;
      var color_defs = [
        {
          re: /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*((?:\d?\.)?\d)\)$/,
          example: ["rgba(123, 234, 45, 0.8)", "rgba(255,234,245,1.0)"],
          process: function(bits2) {
            return [
              parseInt(bits2[1]),
              parseInt(bits2[2]),
              parseInt(bits2[3]),
              parseFloat(bits2[4])
            ];
          }
        },
        {
          re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
          example: ["rgb(123, 234, 45)", "rgb(255,234,245)"],
          process: function(bits2) {
            return [
              parseInt(bits2[1]),
              parseInt(bits2[2]),
              parseInt(bits2[3])
            ];
          }
        },
        {
          re: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
          example: ["#00ff00", "336699"],
          process: function(bits2) {
            return [
              parseInt(bits2[1], 16),
              parseInt(bits2[2], 16),
              parseInt(bits2[3], 16)
            ];
          }
        },
        {
          re: /^([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
          example: ["#fb0", "f0f"],
          process: function(bits2) {
            return [
              parseInt(bits2[1] + bits2[1], 16),
              parseInt(bits2[2] + bits2[2], 16),
              parseInt(bits2[3] + bits2[3], 16)
            ];
          }
        }
      ];
      for (var i = 0; i < color_defs.length; i++) {
        var re = color_defs[i].re;
        var processor = color_defs[i].process;
        var bits = re.exec(color_string);
        if (bits) {
          var channels = processor(bits);
          this.r = channels[0];
          this.g = channels[1];
          this.b = channels[2];
          if (channels.length > 3) {
            this.alpha = channels[3];
          }
          this.ok = true;
        }
      }
      this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r;
      this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g;
      this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b;
      this.alpha = this.alpha < 0 ? 0 : this.alpha > 1 || isNaN(this.alpha) ? 1 : this.alpha;
      this.toRGB = function() {
        return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
      };
      this.toRGBA = function() {
        return "rgba(" + this.r + ", " + this.g + ", " + this.b + ", " + this.alpha + ")";
      };
      this.toHex = function() {
        var r = this.r.toString(16);
        var g = this.g.toString(16);
        var b = this.b.toString(16);
        if (r.length == 1) r = "0" + r;
        if (g.length == 1) g = "0" + g;
        if (b.length == 1) b = "0" + b;
        return "#" + r + g + b;
      };
      this.getHelpXML = function() {
        var examples = new Array();
        for (var i2 = 0; i2 < color_defs.length; i2++) {
          var example = color_defs[i2].example;
          for (var j = 0; j < example.length; j++) {
            examples[examples.length] = example[j];
          }
        }
        for (var sc in simple_colors) {
          examples[examples.length] = sc;
        }
        var xml = document.createElement("ul");
        xml.setAttribute("id", "rgbcolor-examples");
        for (var i2 = 0; i2 < examples.length; i2++) {
          try {
            var list_item = document.createElement("li");
            var list_color = new RGBColor(examples[i2]);
            var example_div = document.createElement("div");
            example_div.style.cssText = "margin: 3px; border: 1px solid black; background:" + list_color.toHex() + "; color:" + list_color.toHex();
            example_div.appendChild(document.createTextNode("test"));
            var list_item_value = document.createTextNode(
              " " + examples[i2] + " -> " + list_color.toRGB() + " -> " + list_color.toHex()
            );
            list_item.appendChild(example_div);
            list_item.appendChild(list_item_value);
            xml.appendChild(list_item);
          } catch (e2) {
          }
        }
        return xml;
      };
    };
  }
});

// node_modules/core-js/internals/array-for-each.js
var require_array_for_each = __commonJS({
  "node_modules/core-js/internals/array-for-each.js"(exports, module) {
    "use strict";
    var $forEach = require_array_iteration().forEach;
    var arrayMethodIsStrict = require_array_method_is_strict();
    var STRICT_METHOD = arrayMethodIsStrict("forEach");
    module.exports = !STRICT_METHOD ? function forEach(callbackfn) {
      return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    } : [].forEach;
  }
});

// node_modules/core-js/modules/es.array.for-each.js
var require_es_array_for_each = __commonJS({
  "node_modules/core-js/modules/es.array.for-each.js"() {
    "use strict";
    var $ = require_export();
    var forEach = require_array_for_each();
    $({ target: "Array", proto: true, forced: [].forEach !== forEach }, {
      forEach
    });
  }
});

// node_modules/core-js/internals/dom-iterables.js
var require_dom_iterables = __commonJS({
  "node_modules/core-js/internals/dom-iterables.js"(exports, module) {
    "use strict";
    module.exports = {
      CSSRuleList: 0,
      CSSStyleDeclaration: 0,
      CSSValueList: 0,
      ClientRectList: 0,
      DOMRectList: 0,
      DOMStringList: 0,
      DOMTokenList: 1,
      DataTransferItemList: 0,
      FileList: 0,
      HTMLAllCollection: 0,
      HTMLCollection: 0,
      HTMLFormElement: 0,
      HTMLSelectElement: 0,
      MediaList: 0,
      MimeTypeArray: 0,
      NamedNodeMap: 0,
      NodeList: 1,
      PaintRequestList: 0,
      Plugin: 0,
      PluginArray: 0,
      SVGLengthList: 0,
      SVGNumberList: 0,
      SVGPathSegList: 0,
      SVGPointList: 0,
      SVGStringList: 0,
      SVGTransformList: 0,
      SourceBufferList: 0,
      StyleSheetList: 0,
      TextTrackCueList: 0,
      TextTrackList: 0,
      TouchList: 0
    };
  }
});

// node_modules/core-js/internals/dom-token-list-prototype.js
var require_dom_token_list_prototype = __commonJS({
  "node_modules/core-js/internals/dom-token-list-prototype.js"(exports, module) {
    "use strict";
    var documentCreateElement = require_document_create_element();
    var classList = documentCreateElement("span").classList;
    var DOMTokenListPrototype = classList && classList.constructor && classList.constructor.prototype;
    module.exports = DOMTokenListPrototype === Object.prototype ? void 0 : DOMTokenListPrototype;
  }
});

// node_modules/core-js/modules/web.dom-collections.for-each.js
var require_web_dom_collections_for_each = __commonJS({
  "node_modules/core-js/modules/web.dom-collections.for-each.js"() {
    "use strict";
    var globalThis2 = require_global_this();
    var DOMIterables = require_dom_iterables();
    var DOMTokenListPrototype = require_dom_token_list_prototype();
    var forEach = require_array_for_each();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var handlePrototype = function(CollectionPrototype) {
      if (CollectionPrototype && CollectionPrototype.forEach !== forEach) try {
        createNonEnumerableProperty(CollectionPrototype, "forEach", forEach);
      } catch (error) {
        CollectionPrototype.forEach = forEach;
      }
    };
    for (COLLECTION_NAME in DOMIterables) {
      if (DOMIterables[COLLECTION_NAME]) {
        handlePrototype(globalThis2[COLLECTION_NAME] && globalThis2[COLLECTION_NAME].prototype);
      }
    }
    var COLLECTION_NAME;
    handlePrototype(DOMTokenListPrototype);
  }
});

// node_modules/@babel/runtime/helpers/setPrototypeOf.js
var require_setPrototypeOf = __commonJS({
  "node_modules/@babel/runtime/helpers/setPrototypeOf.js"(exports, module) {
    "use strict";
    function _setPrototypeOf(t, e2) {
      return module.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e3) {
        return t2.__proto__ = e3, t2;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _setPrototypeOf(t, e2);
    }
    module.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/inherits.js
var require_inherits = __commonJS({
  "node_modules/@babel/runtime/helpers/inherits.js"(exports, module) {
    "use strict";
    var setPrototypeOf = require_setPrototypeOf();
    function _inherits(t, e2) {
      if ("function" != typeof e2 && null !== e2) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e2 && e2.prototype, {
        constructor: {
          value: t,
          writable: true,
          configurable: true
        }
      }), Object.defineProperty(t, "prototype", {
        writable: false
      }), e2 && setPrototypeOf(t, e2);
    }
    module.exports = _inherits, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/assertThisInitialized.js
var require_assertThisInitialized = __commonJS({
  "node_modules/@babel/runtime/helpers/assertThisInitialized.js"(exports, module) {
    "use strict";
    function _assertThisInitialized(e2) {
      if (void 0 === e2) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e2;
    }
    module.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/possibleConstructorReturn.js
var require_possibleConstructorReturn = __commonJS({
  "node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"(exports, module) {
    "use strict";
    var _typeof2 = require_typeof()["default"];
    var assertThisInitialized = require_assertThisInitialized();
    function _possibleConstructorReturn(t, e2) {
      if (e2 && ("object" == _typeof2(e2) || "function" == typeof e2)) return e2;
      if (void 0 !== e2) throw new TypeError("Derived constructors may only return object or undefined");
      return assertThisInitialized(t);
    }
    module.exports = _possibleConstructorReturn, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/getPrototypeOf.js
var require_getPrototypeOf = __commonJS({
  "node_modules/@babel/runtime/helpers/getPrototypeOf.js"(exports, module) {
    "use strict";
    function _getPrototypeOf(t) {
      return module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
        return t2.__proto__ || Object.getPrototypeOf(t2);
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _getPrototypeOf(t);
    }
    module.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/core-js/internals/call-with-safe-iteration-closing.js
var require_call_with_safe_iteration_closing = __commonJS({
  "node_modules/core-js/internals/call-with-safe-iteration-closing.js"(exports, module) {
    "use strict";
    var anObject = require_an_object();
    var iteratorClose = require_iterator_close();
    module.exports = function(iterator, fn, value, ENTRIES) {
      try {
        return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
      } catch (error) {
        iteratorClose(iterator, "throw", error);
      }
    };
  }
});

// node_modules/core-js/internals/array-from.js
var require_array_from = __commonJS({
  "node_modules/core-js/internals/array-from.js"(exports, module) {
    "use strict";
    var bind = require_function_bind_context();
    var call = require_function_call();
    var toObject = require_to_object();
    var callWithSafeIterationClosing = require_call_with_safe_iteration_closing();
    var isArrayIteratorMethod = require_is_array_iterator_method();
    var isConstructor = require_is_constructor();
    var lengthOfArrayLike = require_length_of_array_like();
    var createProperty = require_create_property();
    var setArrayLength = require_array_set_length();
    var getIterator = require_get_iterator();
    var getIteratorMethod = require_get_iterator_method();
    var $Array = Array;
    module.exports = function from(arrayLike) {
      var O = toObject(arrayLike);
      var IS_CONSTRUCTOR = isConstructor(this);
      var argumentsLength = arguments.length;
      var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
      var mapping = mapfn !== void 0;
      if (mapping) mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : void 0);
      var iteratorMethod = getIteratorMethod(O);
      var index = 0;
      var length, result, step, iterator, next, value;
      if (iteratorMethod && !(this === $Array && isArrayIteratorMethod(iteratorMethod))) {
        result = IS_CONSTRUCTOR ? new this() : [];
        iterator = getIterator(O, iteratorMethod);
        next = iterator.next;
        for (; !(step = call(next, iterator)).done; index++) {
          value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
          createProperty(result, index, value);
        }
      } else {
        length = lengthOfArrayLike(O);
        result = IS_CONSTRUCTOR ? new this(length) : $Array(length);
        for (; length > index; index++) {
          value = mapping ? mapfn(O[index], index) : O[index];
          createProperty(result, index, value);
        }
      }
      setArrayLength(result, index);
      return result;
    };
  }
});

// node_modules/core-js/modules/es.array.from.js
var require_es_array_from = __commonJS({
  "node_modules/core-js/modules/es.array.from.js"() {
    "use strict";
    var $ = require_export();
    var from = require_array_from();
    var checkCorrectnessOfIteration = require_check_correctness_of_iteration();
    var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function(iterable) {
      Array.from(iterable);
    });
    $({ target: "Array", stat: true, forced: INCORRECT_ITERATION }, {
      from
    });
  }
});

// node_modules/core-js/internals/add-to-unscopables.js
var require_add_to_unscopables = __commonJS({
  "node_modules/core-js/internals/add-to-unscopables.js"(exports, module) {
    "use strict";
    var wellKnownSymbol = require_well_known_symbol();
    var create = require_object_create();
    var defineProperty = require_object_define_property().f;
    var UNSCOPABLES = wellKnownSymbol("unscopables");
    var ArrayPrototype = Array.prototype;
    if (ArrayPrototype[UNSCOPABLES] === void 0) {
      defineProperty(ArrayPrototype, UNSCOPABLES, {
        configurable: true,
        value: create(null)
      });
    }
    module.exports = function(key) {
      ArrayPrototype[UNSCOPABLES][key] = true;
    };
  }
});

// node_modules/core-js/modules/es.array.includes.js
var require_es_array_includes = __commonJS({
  "node_modules/core-js/modules/es.array.includes.js"() {
    "use strict";
    var $ = require_export();
    var $includes = require_array_includes().includes;
    var fails = require_fails();
    var addToUnscopables = require_add_to_unscopables();
    var BROKEN_ON_SPARSE = fails(function() {
      return !Array(1).includes();
    });
    $({ target: "Array", proto: true, forced: BROKEN_ON_SPARSE }, {
      includes: function includes(el) {
        return $includes(this, el, arguments.length > 1 ? arguments[1] : void 0);
      }
    });
    addToUnscopables("includes");
  }
});

// node_modules/core-js/modules/es.array.index-of.js
var require_es_array_index_of = __commonJS({
  "node_modules/core-js/modules/es.array.index-of.js"() {
    "use strict";
    var $ = require_export();
    var uncurryThis = require_function_uncurry_this_clause();
    var $indexOf = require_array_includes().indexOf;
    var arrayMethodIsStrict = require_array_method_is_strict();
    var nativeIndexOf = uncurryThis([].indexOf);
    var NEGATIVE_ZERO = !!nativeIndexOf && 1 / nativeIndexOf([1], 1, -0) < 0;
    var FORCED = NEGATIVE_ZERO || !arrayMethodIsStrict("indexOf");
    $({ target: "Array", proto: true, forced: FORCED }, {
      indexOf: function indexOf(searchElement) {
        var fromIndex = arguments.length > 1 ? arguments[1] : void 0;
        return NEGATIVE_ZERO ? nativeIndexOf(this, searchElement, fromIndex) || 0 : $indexOf(this, searchElement, fromIndex);
      }
    });
  }
});

// node_modules/core-js/modules/es.array.some.js
var require_es_array_some = __commonJS({
  "node_modules/core-js/modules/es.array.some.js"() {
    "use strict";
    var $ = require_export();
    var $some = require_array_iteration().some;
    var arrayMethodIsStrict = require_array_method_is_strict();
    var STRICT_METHOD = arrayMethodIsStrict("some");
    $({ target: "Array", proto: true, forced: !STRICT_METHOD }, {
      some: function some(callbackfn) {
        return $some(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      }
    });
  }
});

// node_modules/core-js/modules/es.string.includes.js
var require_es_string_includes = __commonJS({
  "node_modules/core-js/modules/es.string.includes.js"() {
    "use strict";
    var $ = require_export();
    var uncurryThis = require_function_uncurry_this();
    var notARegExp = require_not_a_regexp();
    var requireObjectCoercible = require_require_object_coercible();
    var toString3 = require_to_string();
    var correctIsRegExpLogic = require_correct_is_regexp_logic();
    var stringIndexOf = uncurryThis("".indexOf);
    $({ target: "String", proto: true, forced: !correctIsRegExpLogic("includes") }, {
      includes: function includes(searchString) {
        return !!~stringIndexOf(
          toString3(requireObjectCoercible(this)),
          toString3(notARegExp(searchString)),
          arguments.length > 1 ? arguments[1] : void 0
        );
      }
    });
  }
});

// node_modules/core-js/internals/correct-prototype-getter.js
var require_correct_prototype_getter = __commonJS({
  "node_modules/core-js/internals/correct-prototype-getter.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    module.exports = !fails(function() {
      function F2() {
      }
      F2.prototype.constructor = null;
      return Object.getPrototypeOf(new F2()) !== F2.prototype;
    });
  }
});

// node_modules/core-js/internals/object-get-prototype-of.js
var require_object_get_prototype_of = __commonJS({
  "node_modules/core-js/internals/object-get-prototype-of.js"(exports, module) {
    "use strict";
    var hasOwn = require_has_own_property();
    var isCallable = require_is_callable();
    var toObject = require_to_object();
    var sharedKey = require_shared_key();
    var CORRECT_PROTOTYPE_GETTER = require_correct_prototype_getter();
    var IE_PROTO = sharedKey("IE_PROTO");
    var $Object = Object;
    var ObjectPrototype = $Object.prototype;
    module.exports = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function(O) {
      var object = toObject(O);
      if (hasOwn(object, IE_PROTO)) return object[IE_PROTO];
      var constructor = object.constructor;
      if (isCallable(constructor) && object instanceof constructor) {
        return constructor.prototype;
      }
      return object instanceof $Object ? ObjectPrototype : null;
    };
  }
});

// node_modules/core-js/internals/iterators-core.js
var require_iterators_core = __commonJS({
  "node_modules/core-js/internals/iterators-core.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    var isCallable = require_is_callable();
    var isObject = require_is_object();
    var create = require_object_create();
    var getPrototypeOf = require_object_get_prototype_of();
    var defineBuiltIn = require_define_built_in();
    var wellKnownSymbol = require_well_known_symbol();
    var IS_PURE = require_is_pure();
    var ITERATOR = wellKnownSymbol("iterator");
    var BUGGY_SAFARI_ITERATORS = false;
    var IteratorPrototype;
    var PrototypeOfArrayIteratorPrototype;
    var arrayIterator;
    if ([].keys) {
      arrayIterator = [].keys();
      if (!("next" in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
      else {
        PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
        if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
      }
    }
    var NEW_ITERATOR_PROTOTYPE = !isObject(IteratorPrototype) || fails(function() {
      var test = {};
      return IteratorPrototype[ITERATOR].call(test) !== test;
    });
    if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};
    else if (IS_PURE) IteratorPrototype = create(IteratorPrototype);
    if (!isCallable(IteratorPrototype[ITERATOR])) {
      defineBuiltIn(IteratorPrototype, ITERATOR, function() {
        return this;
      });
    }
    module.exports = {
      IteratorPrototype,
      BUGGY_SAFARI_ITERATORS
    };
  }
});

// node_modules/core-js/internals/iterator-create-constructor.js
var require_iterator_create_constructor = __commonJS({
  "node_modules/core-js/internals/iterator-create-constructor.js"(exports, module) {
    "use strict";
    var IteratorPrototype = require_iterators_core().IteratorPrototype;
    var create = require_object_create();
    var createPropertyDescriptor = require_create_property_descriptor();
    var setToStringTag = require_set_to_string_tag();
    var Iterators = require_iterators();
    var returnThis = function() {
      return this;
    };
    module.exports = function(IteratorConstructor, NAME2, next, ENUMERABLE_NEXT) {
      var TO_STRING_TAG = NAME2 + " Iterator";
      IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });
      setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
      Iterators[TO_STRING_TAG] = returnThis;
      return IteratorConstructor;
    };
  }
});

// node_modules/core-js/internals/iterator-define.js
var require_iterator_define = __commonJS({
  "node_modules/core-js/internals/iterator-define.js"(exports, module) {
    "use strict";
    var $ = require_export();
    var call = require_function_call();
    var IS_PURE = require_is_pure();
    var FunctionName = require_function_name();
    var isCallable = require_is_callable();
    var createIteratorConstructor = require_iterator_create_constructor();
    var getPrototypeOf = require_object_get_prototype_of();
    var setPrototypeOf = require_object_set_prototype_of();
    var setToStringTag = require_set_to_string_tag();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var defineBuiltIn = require_define_built_in();
    var wellKnownSymbol = require_well_known_symbol();
    var Iterators = require_iterators();
    var IteratorsCore = require_iterators_core();
    var PROPER_FUNCTION_NAME = FunctionName.PROPER;
    var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
    var IteratorPrototype = IteratorsCore.IteratorPrototype;
    var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
    var ITERATOR = wellKnownSymbol("iterator");
    var KEYS = "keys";
    var VALUES = "values";
    var ENTRIES = "entries";
    var returnThis = function() {
      return this;
    };
    module.exports = function(Iterable, NAME2, IteratorConstructor, next, DEFAULT2, IS_SET, FORCED) {
      createIteratorConstructor(IteratorConstructor, NAME2, next);
      var getIterationMethod = function(KIND) {
        if (KIND === DEFAULT2 && defaultIterator) return defaultIterator;
        if (!BUGGY_SAFARI_ITERATORS && KIND && KIND in IterablePrototype) return IterablePrototype[KIND];
        switch (KIND) {
          case KEYS:
            return function keys() {
              return new IteratorConstructor(this, KIND);
            };
          case VALUES:
            return function values() {
              return new IteratorConstructor(this, KIND);
            };
          case ENTRIES:
            return function entries() {
              return new IteratorConstructor(this, KIND);
            };
        }
        return function() {
          return new IteratorConstructor(this);
        };
      };
      var TO_STRING_TAG = NAME2 + " Iterator";
      var INCORRECT_VALUES_NAME = false;
      var IterablePrototype = Iterable.prototype;
      var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype["@@iterator"] || DEFAULT2 && IterablePrototype[DEFAULT2];
      var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT2);
      var anyNativeIterator = NAME2 === "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
      var CurrentIteratorPrototype, methods, KEY;
      if (anyNativeIterator) {
        CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
        if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
          if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
            if (setPrototypeOf) {
              setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
            } else if (!isCallable(CurrentIteratorPrototype[ITERATOR])) {
              defineBuiltIn(CurrentIteratorPrototype, ITERATOR, returnThis);
            }
          }
          setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
          if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
        }
      }
      if (PROPER_FUNCTION_NAME && DEFAULT2 === VALUES && nativeIterator && nativeIterator.name !== VALUES) {
        if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) {
          createNonEnumerableProperty(IterablePrototype, "name", VALUES);
        } else {
          INCORRECT_VALUES_NAME = true;
          defaultIterator = function values() {
            return call(nativeIterator, this);
          };
        }
      }
      if (DEFAULT2) {
        methods = {
          values: getIterationMethod(VALUES),
          keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
          entries: getIterationMethod(ENTRIES)
        };
        if (FORCED) for (KEY in methods) {
          if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
            defineBuiltIn(IterablePrototype, KEY, methods[KEY]);
          }
        }
        else $({ target: NAME2, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
      }
      if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
        defineBuiltIn(IterablePrototype, ITERATOR, defaultIterator, { name: DEFAULT2 });
      }
      Iterators[NAME2] = defaultIterator;
      return methods;
    };
  }
});

// node_modules/core-js/internals/create-iter-result-object.js
var require_create_iter_result_object = __commonJS({
  "node_modules/core-js/internals/create-iter-result-object.js"(exports, module) {
    "use strict";
    module.exports = function(value, done) {
      return { value, done };
    };
  }
});

// node_modules/core-js/modules/es.string.iterator.js
var require_es_string_iterator = __commonJS({
  "node_modules/core-js/modules/es.string.iterator.js"() {
    "use strict";
    var charAt = require_string_multibyte().charAt;
    var toString3 = require_to_string();
    var InternalStateModule = require_internal_state();
    var defineIterator = require_iterator_define();
    var createIterResultObject = require_create_iter_result_object();
    var STRING_ITERATOR = "String Iterator";
    var setInternalState = InternalStateModule.set;
    var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);
    defineIterator(String, "String", function(iterated) {
      setInternalState(this, {
        type: STRING_ITERATOR,
        string: toString3(iterated),
        index: 0
      });
    }, function next() {
      var state = getInternalState(this);
      var string = state.string;
      var index = state.index;
      var point;
      if (index >= string.length) return createIterResultObject(void 0, true);
      point = charAt(string, index);
      state.index += point.length;
      return createIterResultObject(point, false);
    });
  }
});

// node_modules/@babel/runtime/helpers/arrayWithoutHoles.js
var require_arrayWithoutHoles = __commonJS({
  "node_modules/@babel/runtime/helpers/arrayWithoutHoles.js"(exports, module) {
    "use strict";
    var arrayLikeToArray = require_arrayLikeToArray();
    function _arrayWithoutHoles(r) {
      if (Array.isArray(r)) return arrayLikeToArray(r);
    }
    module.exports = _arrayWithoutHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/iterableToArray.js
var require_iterableToArray = __commonJS({
  "node_modules/@babel/runtime/helpers/iterableToArray.js"(exports, module) {
    "use strict";
    function _iterableToArray(r) {
      if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
    }
    module.exports = _iterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/nonIterableSpread.js
var require_nonIterableSpread = __commonJS({
  "node_modules/@babel/runtime/helpers/nonIterableSpread.js"(exports, module) {
    "use strict";
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    module.exports = _nonIterableSpread, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/toConsumableArray.js
var require_toConsumableArray = __commonJS({
  "node_modules/@babel/runtime/helpers/toConsumableArray.js"(exports, module) {
    "use strict";
    var arrayWithoutHoles = require_arrayWithoutHoles();
    var iterableToArray = require_iterableToArray();
    var unsupportedIterableToArray = require_unsupportedIterableToArray();
    var nonIterableSpread = require_nonIterableSpread();
    function _toConsumableArray(r) {
      return arrayWithoutHoles(r) || iterableToArray(r) || unsupportedIterableToArray(r) || nonIterableSpread();
    }
    module.exports = _toConsumableArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/core-js/modules/es.array.reverse.js
var require_es_array_reverse = __commonJS({
  "node_modules/core-js/modules/es.array.reverse.js"() {
    "use strict";
    var $ = require_export();
    var uncurryThis = require_function_uncurry_this();
    var isArray = require_is_array();
    var nativeReverse = uncurryThis([].reverse);
    var test = [1, 2];
    $({ target: "Array", proto: true, forced: String(test) === String(test.reverse()) }, {
      reverse: function reverse() {
        if (isArray(this)) this.length = this.length;
        return nativeReverse(this);
      }
    });
  }
});

// node_modules/core-js/internals/inherit-if-required.js
var require_inherit_if_required = __commonJS({
  "node_modules/core-js/internals/inherit-if-required.js"(exports, module) {
    "use strict";
    var isCallable = require_is_callable();
    var isObject = require_is_object();
    var setPrototypeOf = require_object_set_prototype_of();
    module.exports = function($this, dummy, Wrapper) {
      var NewTarget, NewTargetPrototype;
      if (
        // it can work only with native `setPrototypeOf`
        setPrototypeOf && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
        isCallable(NewTarget = dummy.constructor) && NewTarget !== Wrapper && isObject(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype
      ) setPrototypeOf($this, NewTargetPrototype);
      return $this;
    };
  }
});

// node_modules/core-js/internals/this-number-value.js
var require_this_number_value = __commonJS({
  "node_modules/core-js/internals/this-number-value.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    module.exports = uncurryThis(1.1.valueOf);
  }
});

// node_modules/core-js/modules/es.number.constructor.js
var require_es_number_constructor = __commonJS({
  "node_modules/core-js/modules/es.number.constructor.js"() {
    "use strict";
    var $ = require_export();
    var IS_PURE = require_is_pure();
    var DESCRIPTORS = require_descriptors();
    var globalThis2 = require_global_this();
    var path = require_path();
    var uncurryThis = require_function_uncurry_this();
    var isForced = require_is_forced();
    var hasOwn = require_has_own_property();
    var inheritIfRequired = require_inherit_if_required();
    var isPrototypeOf = require_object_is_prototype_of();
    var isSymbol = require_is_symbol();
    var toPrimitive = require_to_primitive();
    var fails = require_fails();
    var getOwnPropertyNames = require_object_get_own_property_names().f;
    var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
    var defineProperty = require_object_define_property().f;
    var thisNumberValue = require_this_number_value();
    var trim = require_string_trim().trim;
    var NUMBER = "Number";
    var NativeNumber = globalThis2[NUMBER];
    var PureNumberNamespace = path[NUMBER];
    var NumberPrototype = NativeNumber.prototype;
    var TypeError2 = globalThis2.TypeError;
    var stringSlice = uncurryThis("".slice);
    var charCodeAt = uncurryThis("".charCodeAt);
    var toNumeric = function(value) {
      var primValue = toPrimitive(value, "number");
      return typeof primValue == "bigint" ? primValue : toNumber(primValue);
    };
    var toNumber = function(argument) {
      var it = toPrimitive(argument, "number");
      var first, third, radix, maxCode, digits, length, index, code;
      if (isSymbol(it)) throw new TypeError2("Cannot convert a Symbol value to a number");
      if (typeof it == "string" && it.length > 2) {
        it = trim(it);
        first = charCodeAt(it, 0);
        if (first === 43 || first === 45) {
          third = charCodeAt(it, 2);
          if (third === 88 || third === 120) return NaN;
        } else if (first === 48) {
          switch (charCodeAt(it, 1)) {
            // fast equal of /^0b[01]+$/i
            case 66:
            case 98:
              radix = 2;
              maxCode = 49;
              break;
            // fast equal of /^0o[0-7]+$/i
            case 79:
            case 111:
              radix = 8;
              maxCode = 55;
              break;
            default:
              return +it;
          }
          digits = stringSlice(it, 2);
          length = digits.length;
          for (index = 0; index < length; index++) {
            code = charCodeAt(digits, index);
            if (code < 48 || code > maxCode) return NaN;
          }
          return parseInt(digits, radix);
        }
      }
      return +it;
    };
    var FORCED = isForced(NUMBER, !NativeNumber(" 0o1") || !NativeNumber("0b1") || NativeNumber("+0x1"));
    var calledWithNew = function(dummy) {
      return isPrototypeOf(NumberPrototype, dummy) && fails(function() {
        thisNumberValue(dummy);
      });
    };
    var NumberWrapper = function Number2(value) {
      var n = arguments.length < 1 ? 0 : NativeNumber(toNumeric(value));
      return calledWithNew(this) ? inheritIfRequired(Object(n), this, NumberWrapper) : n;
    };
    NumberWrapper.prototype = NumberPrototype;
    if (FORCED && !IS_PURE) NumberPrototype.constructor = NumberWrapper;
    $({ global: true, constructor: true, wrap: true, forced: FORCED }, {
      Number: NumberWrapper
    });
    var copyConstructorProperties = function(target, source) {
      for (var keys = DESCRIPTORS ? getOwnPropertyNames(source) : (
        // ES3:
        "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,fromString,range".split(",")
      ), j = 0, key; keys.length > j; j++) {
        if (hasOwn(source, key = keys[j]) && !hasOwn(target, key)) {
          defineProperty(target, key, getOwnPropertyDescriptor(source, key));
        }
      }
    };
    if (IS_PURE && PureNumberNamespace) copyConstructorProperties(path[NUMBER], PureNumberNamespace);
    if (FORCED || IS_PURE) copyConstructorProperties(path[NUMBER], NativeNumber);
  }
});

// node_modules/@babel/runtime/helpers/superPropBase.js
var require_superPropBase = __commonJS({
  "node_modules/@babel/runtime/helpers/superPropBase.js"(exports, module) {
    "use strict";
    var getPrototypeOf = require_getPrototypeOf();
    function _superPropBase(t, o) {
      for (; !{}.hasOwnProperty.call(t, o) && null !== (t = getPrototypeOf(t)); ) ;
      return t;
    }
    module.exports = _superPropBase, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/get.js
var require_get = __commonJS({
  "node_modules/@babel/runtime/helpers/get.js"(exports, module) {
    "use strict";
    var superPropBase = require_superPropBase();
    function _get() {
      return module.exports = _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(e2, t, r) {
        var p = superPropBase(e2, t);
        if (p) {
          var n = Object.getOwnPropertyDescriptor(p, t);
          return n.get ? n.get.call(arguments.length < 3 ? e2 : r) : n.value;
        }
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _get.apply(null, arguments);
    }
    module.exports = _get, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/core-js/internals/array-fill.js
var require_array_fill = __commonJS({
  "node_modules/core-js/internals/array-fill.js"(exports, module) {
    "use strict";
    var toObject = require_to_object();
    var toAbsoluteIndex = require_to_absolute_index();
    var lengthOfArrayLike = require_length_of_array_like();
    module.exports = function fill(value) {
      var O = toObject(this);
      var length = lengthOfArrayLike(O);
      var argumentsLength = arguments.length;
      var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : void 0, length);
      var end = argumentsLength > 2 ? arguments[2] : void 0;
      var endPos = end === void 0 ? length : toAbsoluteIndex(end, length);
      while (endPos > index) O[index++] = value;
      return O;
    };
  }
});

// node_modules/core-js/modules/es.array.fill.js
var require_es_array_fill = __commonJS({
  "node_modules/core-js/modules/es.array.fill.js"() {
    "use strict";
    var $ = require_export();
    var fill = require_array_fill();
    var addToUnscopables = require_add_to_unscopables();
    $({ target: "Array", proto: true }, {
      fill
    });
    addToUnscopables("fill");
  }
});

// node_modules/svg-pathdata/lib/SVGPathData.cjs
var require_SVGPathData = __commonJS({
  "node_modules/svg-pathdata/lib/SVGPathData.cjs"(exports, module) {
    "use strict";
    !(function(t, r) {
      "object" == typeof exports && "undefined" != typeof module ? r(exports) : "function" == typeof define && define.amd ? define(["exports"], r) : r((t = "undefined" != typeof globalThis ? globalThis : t || self).svgpathdata = {});
    })(exports, (function(t) {
      "use strict";
      var r = function(t2, e3) {
        return (r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, r2) {
          t3.__proto__ = r2;
        } || function(t3, r2) {
          for (var e4 in r2) Object.prototype.hasOwnProperty.call(r2, e4) && (t3[e4] = r2[e4]);
        })(t2, e3);
      };
      function e2(t2, e3) {
        if ("function" != typeof e3 && null !== e3) throw new TypeError("Class extends value " + String(e3) + " is not a constructor or null");
        function a3() {
          this.constructor = t2;
        }
        r(t2, e3), t2.prototype = null === e3 ? Object.create(e3) : (a3.prototype = e3.prototype, new a3());
      }
      var a2 = " ";
      function i(t2) {
        var r2 = "";
        Array.isArray(t2) || (t2 = [t2]);
        for (var e3 = 0; e3 < t2.length; e3++) {
          var i2 = t2[e3];
          if (i2.type === N.CLOSE_PATH) r2 += "z";
          else if (i2.type === N.HORIZ_LINE_TO) r2 += (i2.relative ? "h" : "H") + i2.x;
          else if (i2.type === N.VERT_LINE_TO) r2 += (i2.relative ? "v" : "V") + i2.y;
          else if (i2.type === N.MOVE_TO) r2 += (i2.relative ? "m" : "M") + i2.x + a2 + i2.y;
          else if (i2.type === N.LINE_TO) r2 += (i2.relative ? "l" : "L") + i2.x + a2 + i2.y;
          else if (i2.type === N.CURVE_TO) r2 += (i2.relative ? "c" : "C") + i2.x1 + a2 + i2.y1 + a2 + i2.x2 + a2 + i2.y2 + a2 + i2.x + a2 + i2.y;
          else if (i2.type === N.SMOOTH_CURVE_TO) r2 += (i2.relative ? "s" : "S") + i2.x2 + a2 + i2.y2 + a2 + i2.x + a2 + i2.y;
          else if (i2.type === N.QUAD_TO) r2 += (i2.relative ? "q" : "Q") + i2.x1 + a2 + i2.y1 + a2 + i2.x + a2 + i2.y;
          else if (i2.type === N.SMOOTH_QUAD_TO) r2 += (i2.relative ? "t" : "T") + i2.x + a2 + i2.y;
          else {
            if (i2.type !== N.ARC) throw new Error('Unexpected command type "' + i2.type + '" at index ' + e3 + ".");
            r2 += (i2.relative ? "a" : "A") + i2.rX + a2 + i2.rY + a2 + i2.xRot + a2 + +i2.lArcFlag + a2 + +i2.sweepFlag + a2 + i2.x + a2 + i2.y;
          }
        }
        return r2;
      }
      function n(t2, r2) {
        var e3 = t2[0], a3 = t2[1];
        return [e3 * Math.cos(r2) - a3 * Math.sin(r2), e3 * Math.sin(r2) + a3 * Math.cos(r2)];
      }
      function o() {
        for (var t2 = [], r2 = 0; r2 < arguments.length; r2++) t2[r2] = arguments[r2];
        for (var e3 = 0; e3 < t2.length; e3++) if ("number" != typeof t2[e3]) throw new Error("assertNumbers arguments[" + e3 + "] is not a number. " + typeof t2[e3] + " == typeof " + t2[e3]);
        return true;
      }
      var s = Math.PI;
      function u2(t2, r2, e3) {
        t2.lArcFlag = 0 === t2.lArcFlag ? 0 : 1, t2.sweepFlag = 0 === t2.sweepFlag ? 0 : 1;
        var a3 = t2.rX, i2 = t2.rY, o2 = t2.x, u3 = t2.y;
        a3 = Math.abs(t2.rX), i2 = Math.abs(t2.rY);
        var h2 = n([(r2 - o2) / 2, (e3 - u3) / 2], -t2.xRot / 180 * s), c2 = h2[0], m2 = h2[1], y2 = Math.pow(c2, 2) / Math.pow(a3, 2) + Math.pow(m2, 2) / Math.pow(i2, 2);
        1 < y2 && (a3 *= Math.sqrt(y2), i2 *= Math.sqrt(y2)), t2.rX = a3, t2.rY = i2;
        var p2 = Math.pow(a3, 2) * Math.pow(m2, 2) + Math.pow(i2, 2) * Math.pow(c2, 2), f3 = (t2.lArcFlag !== t2.sweepFlag ? 1 : -1) * Math.sqrt(Math.max(0, (Math.pow(a3, 2) * Math.pow(i2, 2) - p2) / p2)), T3 = a3 * m2 / i2 * f3, O2 = -i2 * c2 / a3 * f3, l2 = n([T3, O2], t2.xRot / 180 * s);
        t2.cX = l2[0] + (r2 + o2) / 2, t2.cY = l2[1] + (e3 + u3) / 2, t2.phi1 = Math.atan2((m2 - O2) / i2, (c2 - T3) / a3), t2.phi2 = Math.atan2((-m2 - O2) / i2, (-c2 - T3) / a3), 0 === t2.sweepFlag && t2.phi2 > t2.phi1 && (t2.phi2 -= 2 * s), 1 === t2.sweepFlag && t2.phi2 < t2.phi1 && (t2.phi2 += 2 * s), t2.phi1 *= 180 / s, t2.phi2 *= 180 / s;
      }
      function h(t2, r2, e3) {
        o(t2, r2, e3);
        var a3 = t2 * t2 + r2 * r2 - e3 * e3;
        if (0 > a3) return [];
        if (0 === a3) return [[t2 * e3 / (t2 * t2 + r2 * r2), r2 * e3 / (t2 * t2 + r2 * r2)]];
        var i2 = Math.sqrt(a3);
        return [[(t2 * e3 + r2 * i2) / (t2 * t2 + r2 * r2), (r2 * e3 - t2 * i2) / (t2 * t2 + r2 * r2)], [(t2 * e3 - r2 * i2) / (t2 * t2 + r2 * r2), (r2 * e3 + t2 * i2) / (t2 * t2 + r2 * r2)]];
      }
      var c = Math.PI / 180;
      function m(t2, r2, e3) {
        return (1 - e3) * t2 + e3 * r2;
      }
      function y(t2, r2, e3, a3) {
        return t2 + Math.cos(a3 / 180 * s) * r2 + Math.sin(a3 / 180 * s) * e3;
      }
      function p(t2, r2, e3, a3) {
        var i2 = 1e-6, n2 = r2 - t2, o2 = e3 - r2, s2 = 3 * n2 + 3 * (a3 - e3) - 6 * o2, u3 = 6 * (o2 - n2), h2 = 3 * n2;
        return Math.abs(s2) < i2 ? [-h2 / u3] : (function(t3, r3, e4) {
          void 0 === e4 && (e4 = 1e-6);
          var a4 = t3 * t3 / 4 - r3;
          if (a4 < -e4) return [];
          if (a4 <= e4) return [-t3 / 2];
          var i3 = Math.sqrt(a4);
          return [-t3 / 2 - i3, -t3 / 2 + i3];
        })(u3 / s2, h2 / s2, i2);
      }
      function f2(t2, r2, e3, a3, i2) {
        var n2 = 1 - i2;
        return t2 * (n2 * n2 * n2) + r2 * (3 * n2 * n2 * i2) + e3 * (3 * n2 * i2 * i2) + a3 * (i2 * i2 * i2);
      }
      t.SVGPathDataTransformer = void 0, (function(t2) {
        function r2() {
          return i2((function(t3, r3, e4) {
            return t3.relative && (void 0 !== t3.x1 && (t3.x1 += r3), void 0 !== t3.y1 && (t3.y1 += e4), void 0 !== t3.x2 && (t3.x2 += r3), void 0 !== t3.y2 && (t3.y2 += e4), void 0 !== t3.x && (t3.x += r3), void 0 !== t3.y && (t3.y += e4), t3.relative = false), t3;
          }));
        }
        function e3() {
          var t3 = NaN, r3 = NaN, e4 = NaN, a4 = NaN;
          return i2((function(i3, n2, o2) {
            return i3.type & N.SMOOTH_CURVE_TO && (i3.type = N.CURVE_TO, t3 = isNaN(t3) ? n2 : t3, r3 = isNaN(r3) ? o2 : r3, i3.x1 = i3.relative ? n2 - t3 : 2 * n2 - t3, i3.y1 = i3.relative ? o2 - r3 : 2 * o2 - r3), i3.type & N.CURVE_TO ? (t3 = i3.relative ? n2 + i3.x2 : i3.x2, r3 = i3.relative ? o2 + i3.y2 : i3.y2) : (t3 = NaN, r3 = NaN), i3.type & N.SMOOTH_QUAD_TO && (i3.type = N.QUAD_TO, e4 = isNaN(e4) ? n2 : e4, a4 = isNaN(a4) ? o2 : a4, i3.x1 = i3.relative ? n2 - e4 : 2 * n2 - e4, i3.y1 = i3.relative ? o2 - a4 : 2 * o2 - a4), i3.type & N.QUAD_TO ? (e4 = i3.relative ? n2 + i3.x1 : i3.x1, a4 = i3.relative ? o2 + i3.y1 : i3.y1) : (e4 = NaN, a4 = NaN), i3;
          }));
        }
        function a3() {
          var t3 = NaN, r3 = NaN;
          return i2((function(e4, a4, i3) {
            if (e4.type & N.SMOOTH_QUAD_TO && (e4.type = N.QUAD_TO, t3 = isNaN(t3) ? a4 : t3, r3 = isNaN(r3) ? i3 : r3, e4.x1 = e4.relative ? a4 - t3 : 2 * a4 - t3, e4.y1 = e4.relative ? i3 - r3 : 2 * i3 - r3), e4.type & N.QUAD_TO) {
              t3 = e4.relative ? a4 + e4.x1 : e4.x1, r3 = e4.relative ? i3 + e4.y1 : e4.y1;
              var n2 = e4.x1, o2 = e4.y1;
              e4.type = N.CURVE_TO, e4.x1 = ((e4.relative ? 0 : a4) + 2 * n2) / 3, e4.y1 = ((e4.relative ? 0 : i3) + 2 * o2) / 3, e4.x2 = (e4.x + 2 * n2) / 3, e4.y2 = (e4.y + 2 * o2) / 3;
            } else t3 = NaN, r3 = NaN;
            return e4;
          }));
        }
        function i2(t3) {
          var r3 = 0, e4 = 0, a4 = NaN, i3 = NaN;
          return function(n2) {
            if (isNaN(a4) && !(n2.type & N.MOVE_TO)) throw new Error("path must start with moveto");
            var o2 = t3(n2, r3, e4, a4, i3);
            return n2.type & N.CLOSE_PATH && (r3 = a4, e4 = i3), void 0 !== n2.x && (r3 = n2.relative ? r3 + n2.x : n2.x), void 0 !== n2.y && (e4 = n2.relative ? e4 + n2.y : n2.y), n2.type & N.MOVE_TO && (a4 = r3, i3 = e4), o2;
          };
        }
        function s2(t3, r3, e4, a4, n2, s3) {
          return o(t3, r3, e4, a4, n2, s3), i2((function(i3, o2, u3, h2) {
            var c2 = i3.x1, m2 = i3.x2, y2 = i3.relative && !isNaN(h2), p2 = void 0 !== i3.x ? i3.x : y2 ? 0 : o2, f3 = void 0 !== i3.y ? i3.y : y2 ? 0 : u3;
            function T4(t4) {
              return t4 * t4;
            }
            i3.type & N.HORIZ_LINE_TO && 0 !== r3 && (i3.type = N.LINE_TO, i3.y = i3.relative ? 0 : u3), i3.type & N.VERT_LINE_TO && 0 !== e4 && (i3.type = N.LINE_TO, i3.x = i3.relative ? 0 : o2), void 0 !== i3.x && (i3.x = i3.x * t3 + f3 * e4 + (y2 ? 0 : n2)), void 0 !== i3.y && (i3.y = p2 * r3 + i3.y * a4 + (y2 ? 0 : s3)), void 0 !== i3.x1 && (i3.x1 = i3.x1 * t3 + i3.y1 * e4 + (y2 ? 0 : n2)), void 0 !== i3.y1 && (i3.y1 = c2 * r3 + i3.y1 * a4 + (y2 ? 0 : s3)), void 0 !== i3.x2 && (i3.x2 = i3.x2 * t3 + i3.y2 * e4 + (y2 ? 0 : n2)), void 0 !== i3.y2 && (i3.y2 = m2 * r3 + i3.y2 * a4 + (y2 ? 0 : s3));
            var O2 = t3 * a4 - r3 * e4;
            if (void 0 !== i3.xRot && (1 !== t3 || 0 !== r3 || 0 !== e4 || 1 !== a4)) if (0 === O2) delete i3.rX, delete i3.rY, delete i3.xRot, delete i3.lArcFlag, delete i3.sweepFlag, i3.type = N.LINE_TO;
            else {
              var l2 = i3.xRot * Math.PI / 180, v2 = Math.sin(l2), _2 = Math.cos(l2), d2 = 1 / T4(i3.rX), x = 1 / T4(i3.rY), A2 = T4(_2) * d2 + T4(v2) * x, E2 = 2 * v2 * _2 * (d2 - x), C = T4(v2) * d2 + T4(_2) * x, M = A2 * a4 * a4 - E2 * r3 * a4 + C * r3 * r3, R = E2 * (t3 * a4 + r3 * e4) - 2 * (A2 * e4 * a4 + C * t3 * r3), S = A2 * e4 * e4 - E2 * t3 * e4 + C * t3 * t3, g = (Math.atan2(R, M - S) + Math.PI) % Math.PI / 2, I = Math.sin(g), V2 = Math.cos(g);
              i3.rX = Math.abs(O2) / Math.sqrt(M * T4(V2) + R * I * V2 + S * T4(I)), i3.rY = Math.abs(O2) / Math.sqrt(M * T4(I) - R * I * V2 + S * T4(V2)), i3.xRot = 180 * g / Math.PI;
            }
            return void 0 !== i3.sweepFlag && 0 > O2 && (i3.sweepFlag = +!i3.sweepFlag), i3;
          }));
        }
        function T3() {
          return function(t3) {
            var r3 = {};
            for (var e4 in t3) r3[e4] = t3[e4];
            return r3;
          };
        }
        t2.ROUND = function(t3) {
          function r3(r4) {
            return Math.round(r4 * t3) / t3;
          }
          return void 0 === t3 && (t3 = 1e13), o(t3), function(t4) {
            return void 0 !== t4.x1 && (t4.x1 = r3(t4.x1)), void 0 !== t4.y1 && (t4.y1 = r3(t4.y1)), void 0 !== t4.x2 && (t4.x2 = r3(t4.x2)), void 0 !== t4.y2 && (t4.y2 = r3(t4.y2)), void 0 !== t4.x && (t4.x = r3(t4.x)), void 0 !== t4.y && (t4.y = r3(t4.y)), void 0 !== t4.rX && (t4.rX = r3(t4.rX)), void 0 !== t4.rY && (t4.rY = r3(t4.rY)), t4;
          };
        }, t2.TO_ABS = r2, t2.TO_REL = function() {
          return i2((function(t3, r3, e4) {
            return t3.relative || (void 0 !== t3.x1 && (t3.x1 -= r3), void 0 !== t3.y1 && (t3.y1 -= e4), void 0 !== t3.x2 && (t3.x2 -= r3), void 0 !== t3.y2 && (t3.y2 -= e4), void 0 !== t3.x && (t3.x -= r3), void 0 !== t3.y && (t3.y -= e4), t3.relative = true), t3;
          }));
        }, t2.NORMALIZE_HVZ = function(t3, r3, e4) {
          return void 0 === t3 && (t3 = true), void 0 === r3 && (r3 = true), void 0 === e4 && (e4 = true), i2((function(a4, i3, n2, o2, s3) {
            if (isNaN(o2) && !(a4.type & N.MOVE_TO)) throw new Error("path must start with moveto");
            return r3 && a4.type & N.HORIZ_LINE_TO && (a4.type = N.LINE_TO, a4.y = a4.relative ? 0 : n2), e4 && a4.type & N.VERT_LINE_TO && (a4.type = N.LINE_TO, a4.x = a4.relative ? 0 : i3), t3 && a4.type & N.CLOSE_PATH && (a4.type = N.LINE_TO, a4.x = a4.relative ? o2 - i3 : o2, a4.y = a4.relative ? s3 - n2 : s3), a4.type & N.ARC && (0 === a4.rX || 0 === a4.rY) && (a4.type = N.LINE_TO, delete a4.rX, delete a4.rY, delete a4.xRot, delete a4.lArcFlag, delete a4.sweepFlag), a4;
          }));
        }, t2.NORMALIZE_ST = e3, t2.QT_TO_C = a3, t2.INFO = i2, t2.SANITIZE = function(t3) {
          void 0 === t3 && (t3 = 0), o(t3);
          var r3 = NaN, e4 = NaN, a4 = NaN, n2 = NaN;
          return i2((function(i3, o2, s3, u3, h2) {
            var c2 = Math.abs, m2 = false, y2 = 0, p2 = 0;
            if (i3.type & N.SMOOTH_CURVE_TO && (y2 = isNaN(r3) ? 0 : o2 - r3, p2 = isNaN(e4) ? 0 : s3 - e4), i3.type & (N.CURVE_TO | N.SMOOTH_CURVE_TO) ? (r3 = i3.relative ? o2 + i3.x2 : i3.x2, e4 = i3.relative ? s3 + i3.y2 : i3.y2) : (r3 = NaN, e4 = NaN), i3.type & N.SMOOTH_QUAD_TO ? (a4 = isNaN(a4) ? o2 : 2 * o2 - a4, n2 = isNaN(n2) ? s3 : 2 * s3 - n2) : i3.type & N.QUAD_TO ? (a4 = i3.relative ? o2 + i3.x1 : i3.x1, n2 = i3.relative ? s3 + i3.y1 : i3.y2) : (a4 = NaN, n2 = NaN), i3.type & N.LINE_COMMANDS || i3.type & N.ARC && (0 === i3.rX || 0 === i3.rY || !i3.lArcFlag) || i3.type & N.CURVE_TO || i3.type & N.SMOOTH_CURVE_TO || i3.type & N.QUAD_TO || i3.type & N.SMOOTH_QUAD_TO) {
              var f3 = void 0 === i3.x ? 0 : i3.relative ? i3.x : i3.x - o2, T4 = void 0 === i3.y ? 0 : i3.relative ? i3.y : i3.y - s3;
              y2 = isNaN(a4) ? void 0 === i3.x1 ? y2 : i3.relative ? i3.x : i3.x1 - o2 : a4 - o2, p2 = isNaN(n2) ? void 0 === i3.y1 ? p2 : i3.relative ? i3.y : i3.y1 - s3 : n2 - s3;
              var O2 = void 0 === i3.x2 ? 0 : i3.relative ? i3.x : i3.x2 - o2, l2 = void 0 === i3.y2 ? 0 : i3.relative ? i3.y : i3.y2 - s3;
              c2(f3) <= t3 && c2(T4) <= t3 && c2(y2) <= t3 && c2(p2) <= t3 && c2(O2) <= t3 && c2(l2) <= t3 && (m2 = true);
            }
            return i3.type & N.CLOSE_PATH && c2(o2 - u3) <= t3 && c2(s3 - h2) <= t3 && (m2 = true), m2 ? [] : i3;
          }));
        }, t2.MATRIX = s2, t2.ROTATE = function(t3, r3, e4) {
          void 0 === r3 && (r3 = 0), void 0 === e4 && (e4 = 0), o(t3, r3, e4);
          var a4 = Math.sin(t3), i3 = Math.cos(t3);
          return s2(i3, a4, -a4, i3, r3 - r3 * i3 + e4 * a4, e4 - r3 * a4 - e4 * i3);
        }, t2.TRANSLATE = function(t3, r3) {
          return void 0 === r3 && (r3 = 0), o(t3, r3), s2(1, 0, 0, 1, t3, r3);
        }, t2.SCALE = function(t3, r3) {
          return void 0 === r3 && (r3 = t3), o(t3, r3), s2(t3, 0, 0, r3, 0, 0);
        }, t2.SKEW_X = function(t3) {
          return o(t3), s2(1, 0, Math.atan(t3), 1, 0, 0);
        }, t2.SKEW_Y = function(t3) {
          return o(t3), s2(1, Math.atan(t3), 0, 1, 0, 0);
        }, t2.X_AXIS_SYMMETRY = function(t3) {
          return void 0 === t3 && (t3 = 0), o(t3), s2(-1, 0, 0, 1, t3, 0);
        }, t2.Y_AXIS_SYMMETRY = function(t3) {
          return void 0 === t3 && (t3 = 0), o(t3), s2(1, 0, 0, -1, 0, t3);
        }, t2.A_TO_C = function() {
          return i2((function(t3, r3, e4) {
            return N.ARC === t3.type ? (function(t4, r4, e5) {
              var a4, i3, o2, s3;
              t4.cX || u2(t4, r4, e5);
              for (var h2 = Math.min(t4.phi1, t4.phi2), y2 = Math.max(t4.phi1, t4.phi2) - h2, p2 = Math.ceil(y2 / 90), f3 = new Array(p2), T4 = r4, O2 = e5, l2 = 0; l2 < p2; l2++) {
                var v2 = m(t4.phi1, t4.phi2, l2 / p2), _2 = m(t4.phi1, t4.phi2, (l2 + 1) / p2), d2 = _2 - v2, x = 4 / 3 * Math.tan(d2 * c / 4), A2 = [Math.cos(v2 * c) - x * Math.sin(v2 * c), Math.sin(v2 * c) + x * Math.cos(v2 * c)], E2 = A2[0], C = A2[1], M = [Math.cos(_2 * c), Math.sin(_2 * c)], R = M[0], S = M[1], g = [R + x * Math.sin(_2 * c), S - x * Math.cos(_2 * c)], I = g[0], V2 = g[1];
                f3[l2] = { relative: t4.relative, type: N.CURVE_TO };
                var D = function(r5, e6) {
                  var a5 = n([r5 * t4.rX, e6 * t4.rY], t4.xRot), i4 = a5[0], o3 = a5[1];
                  return [t4.cX + i4, t4.cY + o3];
                };
                a4 = D(E2, C), f3[l2].x1 = a4[0], f3[l2].y1 = a4[1], i3 = D(I, V2), f3[l2].x2 = i3[0], f3[l2].y2 = i3[1], o2 = D(R, S), f3[l2].x = o2[0], f3[l2].y = o2[1], t4.relative && (f3[l2].x1 -= T4, f3[l2].y1 -= O2, f3[l2].x2 -= T4, f3[l2].y2 -= O2, f3[l2].x -= T4, f3[l2].y -= O2), T4 = (s3 = [f3[l2].x, f3[l2].y])[0], O2 = s3[1];
              }
              return f3;
            })(t3, t3.relative ? 0 : r3, t3.relative ? 0 : e4) : t3;
          }));
        }, t2.ANNOTATE_ARCS = function() {
          return i2((function(t3, r3, e4) {
            return t3.relative && (r3 = 0, e4 = 0), N.ARC === t3.type && u2(t3, r3, e4), t3;
          }));
        }, t2.CLONE = T3, t2.CALCULATE_BOUNDS = function() {
          var t3 = function(t4) {
            var r3 = {};
            for (var e4 in t4) r3[e4] = t4[e4];
            return r3;
          }, n2 = r2(), o2 = a3(), s3 = e3(), c2 = i2((function(r3, e4, a4) {
            var i3 = s3(o2(n2(t3(r3))));
            function m2(t4) {
              t4 > c2.maxX && (c2.maxX = t4), t4 < c2.minX && (c2.minX = t4);
            }
            function T4(t4) {
              t4 > c2.maxY && (c2.maxY = t4), t4 < c2.minY && (c2.minY = t4);
            }
            if (i3.type & N.DRAWING_COMMANDS && (m2(e4), T4(a4)), i3.type & N.HORIZ_LINE_TO && m2(i3.x), i3.type & N.VERT_LINE_TO && T4(i3.y), i3.type & N.LINE_TO && (m2(i3.x), T4(i3.y)), i3.type & N.CURVE_TO) {
              m2(i3.x), T4(i3.y);
              for (var O2 = 0, l2 = p(e4, i3.x1, i3.x2, i3.x); O2 < l2.length; O2++) {
                0 < (H = l2[O2]) && 1 > H && m2(f2(e4, i3.x1, i3.x2, i3.x, H));
              }
              for (var v2 = 0, _2 = p(a4, i3.y1, i3.y2, i3.y); v2 < _2.length; v2++) {
                0 < (H = _2[v2]) && 1 > H && T4(f2(a4, i3.y1, i3.y2, i3.y, H));
              }
            }
            if (i3.type & N.ARC) {
              m2(i3.x), T4(i3.y), u2(i3, e4, a4);
              for (var d2 = i3.xRot / 180 * Math.PI, x = Math.cos(d2) * i3.rX, A2 = Math.sin(d2) * i3.rX, E2 = -Math.sin(d2) * i3.rY, C = Math.cos(d2) * i3.rY, M = i3.phi1 < i3.phi2 ? [i3.phi1, i3.phi2] : -180 > i3.phi2 ? [i3.phi2 + 360, i3.phi1 + 360] : [i3.phi2, i3.phi1], R = M[0], S = M[1], g = function(t4) {
                var r4 = t4[0], e5 = t4[1], a5 = 180 * Math.atan2(e5, r4) / Math.PI;
                return a5 < R ? a5 + 360 : a5;
              }, I = 0, V2 = h(E2, -x, 0).map(g); I < V2.length; I++) {
                (H = V2[I]) > R && H < S && m2(y(i3.cX, x, E2, H));
              }
              for (var D = 0, L2 = h(C, -A2, 0).map(g); D < L2.length; D++) {
                var H;
                (H = L2[D]) > R && H < S && T4(y(i3.cY, A2, C, H));
              }
            }
            return r3;
          }));
          return c2.minX = 1 / 0, c2.maxX = -1 / 0, c2.minY = 1 / 0, c2.maxY = -1 / 0, c2;
        };
      })(t.SVGPathDataTransformer || (t.SVGPathDataTransformer = {}));
      var T2, O = (function() {
        function r2() {
        }
        return r2.prototype.round = function(r3) {
          return this.transform(t.SVGPathDataTransformer.ROUND(r3));
        }, r2.prototype.toAbs = function() {
          return this.transform(t.SVGPathDataTransformer.TO_ABS());
        }, r2.prototype.toRel = function() {
          return this.transform(t.SVGPathDataTransformer.TO_REL());
        }, r2.prototype.normalizeHVZ = function(r3, e3, a3) {
          return this.transform(t.SVGPathDataTransformer.NORMALIZE_HVZ(r3, e3, a3));
        }, r2.prototype.normalizeST = function() {
          return this.transform(t.SVGPathDataTransformer.NORMALIZE_ST());
        }, r2.prototype.qtToC = function() {
          return this.transform(t.SVGPathDataTransformer.QT_TO_C());
        }, r2.prototype.aToC = function() {
          return this.transform(t.SVGPathDataTransformer.A_TO_C());
        }, r2.prototype.sanitize = function(r3) {
          return this.transform(t.SVGPathDataTransformer.SANITIZE(r3));
        }, r2.prototype.translate = function(r3, e3) {
          return this.transform(t.SVGPathDataTransformer.TRANSLATE(r3, e3));
        }, r2.prototype.scale = function(r3, e3) {
          return this.transform(t.SVGPathDataTransformer.SCALE(r3, e3));
        }, r2.prototype.rotate = function(r3, e3, a3) {
          return this.transform(t.SVGPathDataTransformer.ROTATE(r3, e3, a3));
        }, r2.prototype.matrix = function(r3, e3, a3, i2, n2, o2) {
          return this.transform(t.SVGPathDataTransformer.MATRIX(r3, e3, a3, i2, n2, o2));
        }, r2.prototype.skewX = function(r3) {
          return this.transform(t.SVGPathDataTransformer.SKEW_X(r3));
        }, r2.prototype.skewY = function(r3) {
          return this.transform(t.SVGPathDataTransformer.SKEW_Y(r3));
        }, r2.prototype.xSymmetry = function(r3) {
          return this.transform(t.SVGPathDataTransformer.X_AXIS_SYMMETRY(r3));
        }, r2.prototype.ySymmetry = function(r3) {
          return this.transform(t.SVGPathDataTransformer.Y_AXIS_SYMMETRY(r3));
        }, r2.prototype.annotateArcs = function() {
          return this.transform(t.SVGPathDataTransformer.ANNOTATE_ARCS());
        }, r2;
      })(), l = function(t2) {
        return " " === t2 || "	" === t2 || "\r" === t2 || "\n" === t2;
      }, v = function(t2) {
        return "0".charCodeAt(0) <= t2.charCodeAt(0) && t2.charCodeAt(0) <= "9".charCodeAt(0);
      }, _ = (function(t2) {
        function r2() {
          var r3 = t2.call(this) || this;
          return r3.curNumber = "", r3.curCommandType = -1, r3.curCommandRelative = false, r3.canParseCommandOrComma = true, r3.curNumberHasExp = false, r3.curNumberHasExpDigits = false, r3.curNumberHasDecimal = false, r3.curArgs = [], r3;
        }
        return e2(r2, t2), r2.prototype.finish = function(t3) {
          if (void 0 === t3 && (t3 = []), this.parse(" ", t3), 0 !== this.curArgs.length || !this.canParseCommandOrComma) throw new SyntaxError("Unterminated command at the path end.");
          return t3;
        }, r2.prototype.parse = function(t3, r3) {
          var e3 = this;
          void 0 === r3 && (r3 = []);
          for (var a3 = function(t4) {
            r3.push(t4), e3.curArgs.length = 0, e3.canParseCommandOrComma = true;
          }, i2 = 0; i2 < t3.length; i2++) {
            var n2 = t3[i2], o2 = !(this.curCommandType !== N.ARC || 3 !== this.curArgs.length && 4 !== this.curArgs.length || 1 !== this.curNumber.length || "0" !== this.curNumber && "1" !== this.curNumber), s2 = v(n2) && ("0" === this.curNumber && "0" === n2 || o2);
            if (!v(n2) || s2) if ("e" !== n2 && "E" !== n2) if ("-" !== n2 && "+" !== n2 || !this.curNumberHasExp || this.curNumberHasExpDigits) if ("." !== n2 || this.curNumberHasExp || this.curNumberHasDecimal || o2) {
              if (this.curNumber && -1 !== this.curCommandType) {
                var u3 = Number(this.curNumber);
                if (isNaN(u3)) throw new SyntaxError("Invalid number ending at " + i2);
                if (this.curCommandType === N.ARC) {
                  if (0 === this.curArgs.length || 1 === this.curArgs.length) {
                    if (0 > u3) throw new SyntaxError('Expected positive number, got "' + u3 + '" at index "' + i2 + '"');
                  } else if ((3 === this.curArgs.length || 4 === this.curArgs.length) && "0" !== this.curNumber && "1" !== this.curNumber) throw new SyntaxError('Expected a flag, got "' + this.curNumber + '" at index "' + i2 + '"');
                }
                this.curArgs.push(u3), this.curArgs.length === d[this.curCommandType] && (N.HORIZ_LINE_TO === this.curCommandType ? a3({ type: N.HORIZ_LINE_TO, relative: this.curCommandRelative, x: u3 }) : N.VERT_LINE_TO === this.curCommandType ? a3({ type: N.VERT_LINE_TO, relative: this.curCommandRelative, y: u3 }) : this.curCommandType === N.MOVE_TO || this.curCommandType === N.LINE_TO || this.curCommandType === N.SMOOTH_QUAD_TO ? (a3({ type: this.curCommandType, relative: this.curCommandRelative, x: this.curArgs[0], y: this.curArgs[1] }), N.MOVE_TO === this.curCommandType && (this.curCommandType = N.LINE_TO)) : this.curCommandType === N.CURVE_TO ? a3({ type: N.CURVE_TO, relative: this.curCommandRelative, x1: this.curArgs[0], y1: this.curArgs[1], x2: this.curArgs[2], y2: this.curArgs[3], x: this.curArgs[4], y: this.curArgs[5] }) : this.curCommandType === N.SMOOTH_CURVE_TO ? a3({ type: N.SMOOTH_CURVE_TO, relative: this.curCommandRelative, x2: this.curArgs[0], y2: this.curArgs[1], x: this.curArgs[2], y: this.curArgs[3] }) : this.curCommandType === N.QUAD_TO ? a3({ type: N.QUAD_TO, relative: this.curCommandRelative, x1: this.curArgs[0], y1: this.curArgs[1], x: this.curArgs[2], y: this.curArgs[3] }) : this.curCommandType === N.ARC && a3({ type: N.ARC, relative: this.curCommandRelative, rX: this.curArgs[0], rY: this.curArgs[1], xRot: this.curArgs[2], lArcFlag: this.curArgs[3], sweepFlag: this.curArgs[4], x: this.curArgs[5], y: this.curArgs[6] })), this.curNumber = "", this.curNumberHasExpDigits = false, this.curNumberHasExp = false, this.curNumberHasDecimal = false, this.canParseCommandOrComma = true;
              }
              if (!l(n2)) if ("," === n2 && this.canParseCommandOrComma) this.canParseCommandOrComma = false;
              else if ("+" !== n2 && "-" !== n2 && "." !== n2) if (s2) this.curNumber = n2, this.curNumberHasDecimal = false;
              else {
                if (0 !== this.curArgs.length) throw new SyntaxError("Unterminated command at index " + i2 + ".");
                if (!this.canParseCommandOrComma) throw new SyntaxError('Unexpected character "' + n2 + '" at index ' + i2 + ". Command cannot follow comma");
                if (this.canParseCommandOrComma = false, "z" !== n2 && "Z" !== n2) if ("h" === n2 || "H" === n2) this.curCommandType = N.HORIZ_LINE_TO, this.curCommandRelative = "h" === n2;
                else if ("v" === n2 || "V" === n2) this.curCommandType = N.VERT_LINE_TO, this.curCommandRelative = "v" === n2;
                else if ("m" === n2 || "M" === n2) this.curCommandType = N.MOVE_TO, this.curCommandRelative = "m" === n2;
                else if ("l" === n2 || "L" === n2) this.curCommandType = N.LINE_TO, this.curCommandRelative = "l" === n2;
                else if ("c" === n2 || "C" === n2) this.curCommandType = N.CURVE_TO, this.curCommandRelative = "c" === n2;
                else if ("s" === n2 || "S" === n2) this.curCommandType = N.SMOOTH_CURVE_TO, this.curCommandRelative = "s" === n2;
                else if ("q" === n2 || "Q" === n2) this.curCommandType = N.QUAD_TO, this.curCommandRelative = "q" === n2;
                else if ("t" === n2 || "T" === n2) this.curCommandType = N.SMOOTH_QUAD_TO, this.curCommandRelative = "t" === n2;
                else {
                  if ("a" !== n2 && "A" !== n2) throw new SyntaxError('Unexpected character "' + n2 + '" at index ' + i2 + ".");
                  this.curCommandType = N.ARC, this.curCommandRelative = "a" === n2;
                }
                else r3.push({ type: N.CLOSE_PATH }), this.canParseCommandOrComma = true, this.curCommandType = -1;
              }
              else this.curNumber = n2, this.curNumberHasDecimal = "." === n2;
            } else this.curNumber += n2, this.curNumberHasDecimal = true;
            else this.curNumber += n2;
            else this.curNumber += n2, this.curNumberHasExp = true;
            else this.curNumber += n2, this.curNumberHasExpDigits = this.curNumberHasExp;
          }
          return r3;
        }, r2.prototype.transform = function(t3) {
          return Object.create(this, { parse: { value: function(r3, e3) {
            void 0 === e3 && (e3 = []);
            for (var a3 = 0, i2 = Object.getPrototypeOf(this).parse.call(this, r3); a3 < i2.length; a3++) {
              var n2 = i2[a3], o2 = t3(n2);
              Array.isArray(o2) ? e3.push.apply(e3, o2) : e3.push(o2);
            }
            return e3;
          } } });
        }, r2;
      })(O), N = (function(r2) {
        function a3(t2) {
          var e3 = r2.call(this) || this;
          return e3.commands = "string" == typeof t2 ? a3.parse(t2) : t2, e3;
        }
        return e2(a3, r2), a3.prototype.encode = function() {
          return a3.encode(this.commands);
        }, a3.prototype.getBounds = function() {
          var r3 = t.SVGPathDataTransformer.CALCULATE_BOUNDS();
          return this.transform(r3), r3;
        }, a3.prototype.transform = function(t2) {
          for (var r3 = [], e3 = 0, a4 = this.commands; e3 < a4.length; e3++) {
            var i2 = t2(a4[e3]);
            Array.isArray(i2) ? r3.push.apply(r3, i2) : r3.push(i2);
          }
          return this.commands = r3, this;
        }, a3.encode = function(t2) {
          return i(t2);
        }, a3.parse = function(t2) {
          var r3 = new _(), e3 = [];
          return r3.parse(t2, e3), r3.finish(e3), e3;
        }, a3.CLOSE_PATH = 1, a3.MOVE_TO = 2, a3.HORIZ_LINE_TO = 4, a3.VERT_LINE_TO = 8, a3.LINE_TO = 16, a3.CURVE_TO = 32, a3.SMOOTH_CURVE_TO = 64, a3.QUAD_TO = 128, a3.SMOOTH_QUAD_TO = 256, a3.ARC = 512, a3.LINE_COMMANDS = a3.LINE_TO | a3.HORIZ_LINE_TO | a3.VERT_LINE_TO, a3.DRAWING_COMMANDS = a3.HORIZ_LINE_TO | a3.VERT_LINE_TO | a3.LINE_TO | a3.CURVE_TO | a3.SMOOTH_CURVE_TO | a3.QUAD_TO | a3.SMOOTH_QUAD_TO | a3.ARC, a3;
      })(O), d = ((T2 = {})[N.MOVE_TO] = 2, T2[N.LINE_TO] = 2, T2[N.HORIZ_LINE_TO] = 1, T2[N.VERT_LINE_TO] = 1, T2[N.CLOSE_PATH] = 0, T2[N.QUAD_TO] = 4, T2[N.SMOOTH_QUAD_TO] = 2, T2[N.CURVE_TO] = 6, T2[N.SMOOTH_CURVE_TO] = 4, T2[N.ARC] = 7, T2);
      t.COMMAND_ARG_COUNTS = d, t.SVGPathData = N, t.SVGPathDataParser = _, t.encodeSVGPath = i, Object.defineProperty(t, "__esModule", { value: true });
    }));
  }
});

// node_modules/core-js/modules/es.regexp.to-string.js
var require_es_regexp_to_string = __commonJS({
  "node_modules/core-js/modules/es.regexp.to-string.js"() {
    "use strict";
    var PROPER_FUNCTION_NAME = require_function_name().PROPER;
    var defineBuiltIn = require_define_built_in();
    var anObject = require_an_object();
    var $toString = require_to_string();
    var fails = require_fails();
    var getRegExpFlags = require_regexp_get_flags();
    var TO_STRING = "toString";
    var RegExpPrototype = RegExp.prototype;
    var nativeToString = RegExpPrototype[TO_STRING];
    var NOT_GENERIC = fails(function() {
      return nativeToString.call({ source: "a", flags: "b" }) !== "/a/b";
    });
    var INCORRECT_NAME = PROPER_FUNCTION_NAME && nativeToString.name !== TO_STRING;
    if (NOT_GENERIC || INCORRECT_NAME) {
      defineBuiltIn(RegExpPrototype, TO_STRING, function toString3() {
        var R = anObject(this);
        var pattern = $toString(R.source);
        var flags = $toString(getRegExpFlags(R));
        return "/" + pattern + "/" + flags;
      }, { unsafe: true });
    }
  }
});

// node_modules/core-js/modules/es.array.iterator.js
var require_es_array_iterator = __commonJS({
  "node_modules/core-js/modules/es.array.iterator.js"(exports, module) {
    "use strict";
    var toIndexedObject = require_to_indexed_object();
    var addToUnscopables = require_add_to_unscopables();
    var Iterators = require_iterators();
    var InternalStateModule = require_internal_state();
    var defineProperty = require_object_define_property().f;
    var defineIterator = require_iterator_define();
    var createIterResultObject = require_create_iter_result_object();
    var IS_PURE = require_is_pure();
    var DESCRIPTORS = require_descriptors();
    var ARRAY_ITERATOR = "Array Iterator";
    var setInternalState = InternalStateModule.set;
    var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
    module.exports = defineIterator(Array, "Array", function(iterated, kind) {
      setInternalState(this, {
        type: ARRAY_ITERATOR,
        target: toIndexedObject(iterated),
        // target
        index: 0,
        // next index
        kind
        // kind
      });
    }, function() {
      var state = getInternalState(this);
      var target = state.target;
      var index = state.index++;
      if (!target || index >= target.length) {
        state.target = null;
        return createIterResultObject(void 0, true);
      }
      switch (state.kind) {
        case "keys":
          return createIterResultObject(index, false);
        case "values":
          return createIterResultObject(target[index], false);
      }
      return createIterResultObject([index, target[index]], false);
    }, "values");
    var values = Iterators.Arguments = Iterators.Array;
    addToUnscopables("keys");
    addToUnscopables("values");
    addToUnscopables("entries");
    if (!IS_PURE && DESCRIPTORS && values.name !== "values") try {
      defineProperty(values, "name", { value: "values" });
    } catch (error) {
    }
  }
});

// node_modules/core-js/modules/web.dom-collections.iterator.js
var require_web_dom_collections_iterator = __commonJS({
  "node_modules/core-js/modules/web.dom-collections.iterator.js"() {
    "use strict";
    var globalThis2 = require_global_this();
    var DOMIterables = require_dom_iterables();
    var DOMTokenListPrototype = require_dom_token_list_prototype();
    var ArrayIteratorMethods = require_es_array_iterator();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var setToStringTag = require_set_to_string_tag();
    var wellKnownSymbol = require_well_known_symbol();
    var ITERATOR = wellKnownSymbol("iterator");
    var ArrayValues = ArrayIteratorMethods.values;
    var handlePrototype = function(CollectionPrototype, COLLECTION_NAME2) {
      if (CollectionPrototype) {
        if (CollectionPrototype[ITERATOR] !== ArrayValues) try {
          createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
        } catch (error) {
          CollectionPrototype[ITERATOR] = ArrayValues;
        }
        setToStringTag(CollectionPrototype, COLLECTION_NAME2, true);
        if (DOMIterables[COLLECTION_NAME2]) for (var METHOD_NAME in ArrayIteratorMethods) {
          if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
            createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
          } catch (error) {
            CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
          }
        }
      }
    };
    for (COLLECTION_NAME in DOMIterables) {
      handlePrototype(globalThis2[COLLECTION_NAME] && globalThis2[COLLECTION_NAME].prototype, COLLECTION_NAME);
    }
    var COLLECTION_NAME;
    handlePrototype(DOMTokenListPrototype, "DOMTokenList");
  }
});

// node_modules/core-js/internals/object-get-own-property-names-external.js
var require_object_get_own_property_names_external = __commonJS({
  "node_modules/core-js/internals/object-get-own-property-names-external.js"(exports, module) {
    "use strict";
    var classof = require_classof_raw();
    var toIndexedObject = require_to_indexed_object();
    var $getOwnPropertyNames = require_object_get_own_property_names().f;
    var arraySlice = require_array_slice();
    var windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
    var getWindowNames = function(it) {
      try {
        return $getOwnPropertyNames(it);
      } catch (error) {
        return arraySlice(windowNames);
      }
    };
    module.exports.f = function getOwnPropertyNames(it) {
      return windowNames && classof(it) === "Window" ? getWindowNames(it) : $getOwnPropertyNames(toIndexedObject(it));
    };
  }
});

// node_modules/core-js/internals/array-buffer-non-extensible.js
var require_array_buffer_non_extensible = __commonJS({
  "node_modules/core-js/internals/array-buffer-non-extensible.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    module.exports = fails(function() {
      if (typeof ArrayBuffer == "function") {
        var buffer = new ArrayBuffer(8);
        if (Object.isExtensible(buffer)) Object.defineProperty(buffer, "a", { value: 8 });
      }
    });
  }
});

// node_modules/core-js/internals/object-is-extensible.js
var require_object_is_extensible = __commonJS({
  "node_modules/core-js/internals/object-is-extensible.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    var isObject = require_is_object();
    var classof = require_classof_raw();
    var ARRAY_BUFFER_NON_EXTENSIBLE = require_array_buffer_non_extensible();
    var $isExtensible = Object.isExtensible;
    var FAILS_ON_PRIMITIVES = fails(function() {
      $isExtensible(1);
    });
    module.exports = FAILS_ON_PRIMITIVES || ARRAY_BUFFER_NON_EXTENSIBLE ? function isExtensible(it) {
      if (!isObject(it)) return false;
      if (ARRAY_BUFFER_NON_EXTENSIBLE && classof(it) === "ArrayBuffer") return false;
      return $isExtensible ? $isExtensible(it) : true;
    } : $isExtensible;
  }
});

// node_modules/core-js/internals/freezing.js
var require_freezing = __commonJS({
  "node_modules/core-js/internals/freezing.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    module.exports = !fails(function() {
      return Object.isExtensible(Object.preventExtensions({}));
    });
  }
});

// node_modules/core-js/internals/internal-metadata.js
var require_internal_metadata = __commonJS({
  "node_modules/core-js/internals/internal-metadata.js"(exports, module) {
    "use strict";
    var $ = require_export();
    var uncurryThis = require_function_uncurry_this();
    var hiddenKeys = require_hidden_keys();
    var isObject = require_is_object();
    var hasOwn = require_has_own_property();
    var defineProperty = require_object_define_property().f;
    var getOwnPropertyNamesModule = require_object_get_own_property_names();
    var getOwnPropertyNamesExternalModule = require_object_get_own_property_names_external();
    var isExtensible = require_object_is_extensible();
    var uid = require_uid();
    var FREEZING = require_freezing();
    var REQUIRED = false;
    var METADATA = uid("meta");
    var id = 0;
    var setMetadata = function(it) {
      defineProperty(it, METADATA, { value: {
        objectID: "O" + id++,
        // object ID
        weakData: {}
        // weak collections IDs
      } });
    };
    var fastKey = function(it, create) {
      if (!isObject(it)) return typeof it == "symbol" ? it : (typeof it == "string" ? "S" : "P") + it;
      if (!hasOwn(it, METADATA)) {
        if (!isExtensible(it)) return "F";
        if (!create) return "E";
        setMetadata(it);
      }
      return it[METADATA].objectID;
    };
    var getWeakData = function(it, create) {
      if (!hasOwn(it, METADATA)) {
        if (!isExtensible(it)) return true;
        if (!create) return false;
        setMetadata(it);
      }
      return it[METADATA].weakData;
    };
    var onFreeze = function(it) {
      if (FREEZING && REQUIRED && isExtensible(it) && !hasOwn(it, METADATA)) setMetadata(it);
      return it;
    };
    var enable = function() {
      meta.enable = function() {
      };
      REQUIRED = true;
      var getOwnPropertyNames = getOwnPropertyNamesModule.f;
      var splice = uncurryThis([].splice);
      var test = {};
      test[METADATA] = 1;
      if (getOwnPropertyNames(test).length) {
        getOwnPropertyNamesModule.f = function(it) {
          var result = getOwnPropertyNames(it);
          for (var i = 0, length = result.length; i < length; i++) {
            if (result[i] === METADATA) {
              splice(result, i, 1);
              break;
            }
          }
          return result;
        };
        $({ target: "Object", stat: true, forced: true }, {
          getOwnPropertyNames: getOwnPropertyNamesExternalModule.f
        });
      }
    };
    var meta = module.exports = {
      enable,
      fastKey,
      getWeakData,
      onFreeze
    };
    hiddenKeys[METADATA] = true;
  }
});

// node_modules/core-js/internals/collection.js
var require_collection = __commonJS({
  "node_modules/core-js/internals/collection.js"(exports, module) {
    "use strict";
    var $ = require_export();
    var globalThis2 = require_global_this();
    var uncurryThis = require_function_uncurry_this();
    var isForced = require_is_forced();
    var defineBuiltIn = require_define_built_in();
    var InternalMetadataModule = require_internal_metadata();
    var iterate = require_iterate();
    var anInstance = require_an_instance();
    var isCallable = require_is_callable();
    var isNullOrUndefined = require_is_null_or_undefined();
    var isObject = require_is_object();
    var fails = require_fails();
    var checkCorrectnessOfIteration = require_check_correctness_of_iteration();
    var setToStringTag = require_set_to_string_tag();
    var inheritIfRequired = require_inherit_if_required();
    module.exports = function(CONSTRUCTOR_NAME, wrapper, common2) {
      var IS_MAP = CONSTRUCTOR_NAME.indexOf("Map") !== -1;
      var IS_WEAK = CONSTRUCTOR_NAME.indexOf("Weak") !== -1;
      var ADDER = IS_MAP ? "set" : "add";
      var NativeConstructor = globalThis2[CONSTRUCTOR_NAME];
      var NativePrototype = NativeConstructor && NativeConstructor.prototype;
      var Constructor = NativeConstructor;
      var exported = {};
      var fixMethod = function(KEY) {
        var uncurriedNativeMethod = uncurryThis(NativePrototype[KEY]);
        defineBuiltIn(
          NativePrototype,
          KEY,
          KEY === "add" ? function add(value) {
            uncurriedNativeMethod(this, value === 0 ? 0 : value);
            return this;
          } : KEY === "delete" ? function(key) {
            return IS_WEAK && !isObject(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
          } : KEY === "get" ? function get(key) {
            return IS_WEAK && !isObject(key) ? void 0 : uncurriedNativeMethod(this, key === 0 ? 0 : key);
          } : KEY === "has" ? function has(key) {
            return IS_WEAK && !isObject(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
          } : function set(key, value) {
            uncurriedNativeMethod(this, key === 0 ? 0 : key, value);
            return this;
          }
        );
      };
      var REPLACE = isForced(
        CONSTRUCTOR_NAME,
        !isCallable(NativeConstructor) || !(IS_WEAK || NativePrototype.forEach && !fails(function() {
          new NativeConstructor().entries().next();
        }))
      );
      if (REPLACE) {
        Constructor = common2.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
        InternalMetadataModule.enable();
      } else if (isForced(CONSTRUCTOR_NAME, true)) {
        var instance = new Constructor();
        var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) !== instance;
        var THROWS_ON_PRIMITIVES = fails(function() {
          instance.has(1);
        });
        var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function(iterable) {
          new NativeConstructor(iterable);
        });
        var BUGGY_ZERO = !IS_WEAK && fails(function() {
          var $instance = new NativeConstructor();
          var index = 5;
          while (index--) $instance[ADDER](index, index);
          return !$instance.has(-0);
        });
        if (!ACCEPT_ITERABLES) {
          Constructor = wrapper(function(dummy, iterable) {
            anInstance(dummy, NativePrototype);
            var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
            if (!isNullOrUndefined(iterable)) iterate(iterable, that[ADDER], { that, AS_ENTRIES: IS_MAP });
            return that;
          });
          Constructor.prototype = NativePrototype;
          NativePrototype.constructor = Constructor;
        }
        if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
          fixMethod("delete");
          fixMethod("has");
          IS_MAP && fixMethod("get");
        }
        if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
        if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;
      }
      exported[CONSTRUCTOR_NAME] = Constructor;
      $({ global: true, constructor: true, forced: Constructor !== NativeConstructor }, exported);
      setToStringTag(Constructor, CONSTRUCTOR_NAME);
      if (!IS_WEAK) common2.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);
      return Constructor;
    };
  }
});

// node_modules/core-js/internals/define-built-ins.js
var require_define_built_ins = __commonJS({
  "node_modules/core-js/internals/define-built-ins.js"(exports, module) {
    "use strict";
    var defineBuiltIn = require_define_built_in();
    module.exports = function(target, src, options) {
      for (var key in src) defineBuiltIn(target, key, src[key], options);
      return target;
    };
  }
});

// node_modules/core-js/internals/collection-strong.js
var require_collection_strong = __commonJS({
  "node_modules/core-js/internals/collection-strong.js"(exports, module) {
    "use strict";
    var create = require_object_create();
    var defineBuiltInAccessor = require_define_built_in_accessor();
    var defineBuiltIns = require_define_built_ins();
    var bind = require_function_bind_context();
    var anInstance = require_an_instance();
    var isNullOrUndefined = require_is_null_or_undefined();
    var iterate = require_iterate();
    var defineIterator = require_iterator_define();
    var createIterResultObject = require_create_iter_result_object();
    var setSpecies = require_set_species();
    var DESCRIPTORS = require_descriptors();
    var fastKey = require_internal_metadata().fastKey;
    var InternalStateModule = require_internal_state();
    var setInternalState = InternalStateModule.set;
    var internalStateGetterFor = InternalStateModule.getterFor;
    module.exports = {
      getConstructor: function(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
        var Constructor = wrapper(function(that, iterable) {
          anInstance(that, Prototype);
          setInternalState(that, {
            type: CONSTRUCTOR_NAME,
            index: create(null),
            first: null,
            last: null,
            size: 0
          });
          if (!DESCRIPTORS) that.size = 0;
          if (!isNullOrUndefined(iterable)) iterate(iterable, that[ADDER], { that, AS_ENTRIES: IS_MAP });
        });
        var Prototype = Constructor.prototype;
        var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);
        var define2 = function(that, key, value) {
          var state = getInternalState(that);
          var entry = getEntry(that, key);
          var previous, index;
          if (entry) {
            entry.value = value;
          } else {
            state.last = entry = {
              index: index = fastKey(key, true),
              key,
              value,
              previous: previous = state.last,
              next: null,
              removed: false
            };
            if (!state.first) state.first = entry;
            if (previous) previous.next = entry;
            if (DESCRIPTORS) state.size++;
            else that.size++;
            if (index !== "F") state.index[index] = entry;
          }
          return that;
        };
        var getEntry = function(that, key) {
          var state = getInternalState(that);
          var index = fastKey(key);
          var entry;
          if (index !== "F") return state.index[index];
          for (entry = state.first; entry; entry = entry.next) {
            if (entry.key === key) return entry;
          }
        };
        defineBuiltIns(Prototype, {
          // `{ Map, Set }.prototype.clear()` methods
          // https://tc39.es/ecma262/#sec-map.prototype.clear
          // https://tc39.es/ecma262/#sec-set.prototype.clear
          clear: function clear() {
            var that = this;
            var state = getInternalState(that);
            var entry = state.first;
            while (entry) {
              entry.removed = true;
              if (entry.previous) entry.previous = entry.previous.next = null;
              entry = entry.next;
            }
            state.first = state.last = null;
            state.index = create(null);
            if (DESCRIPTORS) state.size = 0;
            else that.size = 0;
          },
          // `{ Map, Set }.prototype.delete(key)` methods
          // https://tc39.es/ecma262/#sec-map.prototype.delete
          // https://tc39.es/ecma262/#sec-set.prototype.delete
          "delete": function(key) {
            var that = this;
            var state = getInternalState(that);
            var entry = getEntry(that, key);
            if (entry) {
              var next = entry.next;
              var prev = entry.previous;
              delete state.index[entry.index];
              entry.removed = true;
              if (prev) prev.next = next;
              if (next) next.previous = prev;
              if (state.first === entry) state.first = next;
              if (state.last === entry) state.last = prev;
              if (DESCRIPTORS) state.size--;
              else that.size--;
            }
            return !!entry;
          },
          // `{ Map, Set }.prototype.forEach(callbackfn, thisArg = undefined)` methods
          // https://tc39.es/ecma262/#sec-map.prototype.foreach
          // https://tc39.es/ecma262/#sec-set.prototype.foreach
          forEach: function forEach(callbackfn) {
            var state = getInternalState(this);
            var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
            var entry;
            while (entry = entry ? entry.next : state.first) {
              boundFunction(entry.value, entry.key, this);
              while (entry && entry.removed) entry = entry.previous;
            }
          },
          // `{ Map, Set}.prototype.has(key)` methods
          // https://tc39.es/ecma262/#sec-map.prototype.has
          // https://tc39.es/ecma262/#sec-set.prototype.has
          has: function has(key) {
            return !!getEntry(this, key);
          }
        });
        defineBuiltIns(Prototype, IS_MAP ? {
          // `Map.prototype.get(key)` method
          // https://tc39.es/ecma262/#sec-map.prototype.get
          get: function get(key) {
            var entry = getEntry(this, key);
            return entry && entry.value;
          },
          // `Map.prototype.set(key, value)` method
          // https://tc39.es/ecma262/#sec-map.prototype.set
          set: function set(key, value) {
            return define2(this, key === 0 ? 0 : key, value);
          }
        } : {
          // `Set.prototype.add(value)` method
          // https://tc39.es/ecma262/#sec-set.prototype.add
          add: function add(value) {
            return define2(this, value = value === 0 ? 0 : value, value);
          }
        });
        if (DESCRIPTORS) defineBuiltInAccessor(Prototype, "size", {
          configurable: true,
          get: function() {
            return getInternalState(this).size;
          }
        });
        return Constructor;
      },
      setStrong: function(Constructor, CONSTRUCTOR_NAME, IS_MAP) {
        var ITERATOR_NAME = CONSTRUCTOR_NAME + " Iterator";
        var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
        var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);
        defineIterator(Constructor, CONSTRUCTOR_NAME, function(iterated, kind) {
          setInternalState(this, {
            type: ITERATOR_NAME,
            target: iterated,
            state: getInternalCollectionState(iterated),
            kind,
            last: null
          });
        }, function() {
          var state = getInternalIteratorState(this);
          var kind = state.kind;
          var entry = state.last;
          while (entry && entry.removed) entry = entry.previous;
          if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
            state.target = null;
            return createIterResultObject(void 0, true);
          }
          if (kind === "keys") return createIterResultObject(entry.key, false);
          if (kind === "values") return createIterResultObject(entry.value, false);
          return createIterResultObject([entry.key, entry.value], false);
        }, IS_MAP ? "entries" : "values", !IS_MAP, true);
        setSpecies(CONSTRUCTOR_NAME);
      }
    };
  }
});

// node_modules/core-js/modules/es.map.constructor.js
var require_es_map_constructor = __commonJS({
  "node_modules/core-js/modules/es.map.constructor.js"() {
    "use strict";
    var collection = require_collection();
    var collectionStrong = require_collection_strong();
    collection("Map", function(init) {
      return function Map2() {
        return init(this, arguments.length ? arguments[0] : void 0);
      };
    }, collectionStrong);
  }
});

// node_modules/core-js/modules/es.map.js
var require_es_map = __commonJS({
  "node_modules/core-js/modules/es.map.js"() {
    "use strict";
    require_es_map_constructor();
  }
});

// node_modules/core-js/modules/es.reflect.apply.js
var require_es_reflect_apply = __commonJS({
  "node_modules/core-js/modules/es.reflect.apply.js"() {
    "use strict";
    var $ = require_export();
    var functionApply = require_function_apply();
    var aCallable = require_a_callable();
    var anObject = require_an_object();
    var fails = require_fails();
    var OPTIONAL_ARGUMENTS_LIST = !fails(function() {
      Reflect.apply(function() {
      });
    });
    $({ target: "Reflect", stat: true, forced: OPTIONAL_ARGUMENTS_LIST }, {
      apply: function apply(target, thisArgument, argumentsList) {
        return functionApply(aCallable(target), thisArgument, anObject(argumentsList));
      }
    });
  }
});

// node_modules/core-js/modules/es.reflect.get-prototype-of.js
var require_es_reflect_get_prototype_of = __commonJS({
  "node_modules/core-js/modules/es.reflect.get-prototype-of.js"() {
    "use strict";
    var $ = require_export();
    var anObject = require_an_object();
    var objectGetPrototypeOf = require_object_get_prototype_of();
    var CORRECT_PROTOTYPE_GETTER = require_correct_prototype_getter();
    $({ target: "Reflect", stat: true, sham: !CORRECT_PROTOTYPE_GETTER }, {
      getPrototypeOf: function getPrototypeOf(target) {
        return objectGetPrototypeOf(anObject(target));
      }
    });
  }
});

// node_modules/stackblur-canvas/dist/stackblur-es.js
var stackblur_es_exports = {};
__export(stackblur_es_exports, {
  BlurStack: () => BlurStack,
  canvasRGB: () => processCanvasRGB,
  canvasRGBA: () => processCanvasRGBA,
  image: () => processImage,
  imageDataRGB: () => processImageDataRGB,
  imageDataRGBA: () => processImageDataRGBA
});
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function processImage(img, canvas, radius, blurAlphaChannel, useOffset, skipStyles) {
  if (typeof img === "string") {
    img = document.getElementById(img);
  }
  if (!img || Object.prototype.toString.call(img).slice(8, -1) === "HTMLImageElement" && !("naturalWidth" in img)) {
    return;
  }
  var dimensionType = useOffset ? "offset" : "natural";
  var w = img[dimensionType + "Width"];
  var h = img[dimensionType + "Height"];
  if (Object.prototype.toString.call(img).slice(8, -1) === "ImageBitmap") {
    w = img.width;
    h = img.height;
  }
  if (typeof canvas === "string") {
    canvas = document.getElementById(canvas);
  }
  if (!canvas || !("getContext" in canvas)) {
    return;
  }
  if (!skipStyles) {
    canvas.style.width = w + "px";
    canvas.style.height = h + "px";
  }
  canvas.width = w;
  canvas.height = h;
  var context = canvas.getContext("2d");
  context.clearRect(0, 0, w, h);
  context.drawImage(img, 0, 0, img.naturalWidth, img.naturalHeight, 0, 0, w, h);
  if (isNaN(radius) || radius < 1) {
    return;
  }
  if (blurAlphaChannel) {
    processCanvasRGBA(canvas, 0, 0, w, h, radius);
  } else {
    processCanvasRGB(canvas, 0, 0, w, h, radius);
  }
}
function getImageDataFromCanvas(canvas, topX, topY, width, height) {
  if (typeof canvas === "string") {
    canvas = document.getElementById(canvas);
  }
  if (!canvas || _typeof(canvas) !== "object" || !("getContext" in canvas)) {
    throw new TypeError("Expecting canvas with `getContext` method in processCanvasRGB(A) calls!");
  }
  var context = canvas.getContext("2d");
  try {
    return context.getImageData(topX, topY, width, height);
  } catch (e2) {
    throw new Error("unable to access image data: " + e2);
  }
}
function processCanvasRGBA(canvas, topX, topY, width, height, radius) {
  if (isNaN(radius) || radius < 1) {
    return;
  }
  radius |= 0;
  var imageData = getImageDataFromCanvas(canvas, topX, topY, width, height);
  imageData = processImageDataRGBA(imageData, topX, topY, width, height, radius);
  canvas.getContext("2d").putImageData(imageData, topX, topY);
}
function processImageDataRGBA(imageData, topX, topY, width, height, radius) {
  var pixels = imageData.data;
  var div = 2 * radius + 1;
  var widthMinus1 = width - 1;
  var heightMinus1 = height - 1;
  var radiusPlus1 = radius + 1;
  var sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2;
  var stackStart = new BlurStack();
  var stack = stackStart;
  var stackEnd;
  for (var i = 1; i < div; i++) {
    stack = stack.next = new BlurStack();
    if (i === radiusPlus1) {
      stackEnd = stack;
    }
  }
  stack.next = stackStart;
  var stackIn = null, stackOut = null, yw = 0, yi = 0;
  var mulSum = mulTable[radius];
  var shgSum = shgTable[radius];
  for (var y = 0; y < height; y++) {
    stack = stackStart;
    var pr = pixels[yi], pg = pixels[yi + 1], pb = pixels[yi + 2], pa = pixels[yi + 3];
    for (var _i = 0; _i < radiusPlus1; _i++) {
      stack.r = pr;
      stack.g = pg;
      stack.b = pb;
      stack.a = pa;
      stack = stack.next;
    }
    var rInSum = 0, gInSum = 0, bInSum = 0, aInSum = 0, rOutSum = radiusPlus1 * pr, gOutSum = radiusPlus1 * pg, bOutSum = radiusPlus1 * pb, aOutSum = radiusPlus1 * pa, rSum = sumFactor * pr, gSum = sumFactor * pg, bSum = sumFactor * pb, aSum = sumFactor * pa;
    for (var _i2 = 1; _i2 < radiusPlus1; _i2++) {
      var p = yi + ((widthMinus1 < _i2 ? widthMinus1 : _i2) << 2);
      var r = pixels[p], g = pixels[p + 1], b = pixels[p + 2], a2 = pixels[p + 3];
      var rbs = radiusPlus1 - _i2;
      rSum += (stack.r = r) * rbs;
      gSum += (stack.g = g) * rbs;
      bSum += (stack.b = b) * rbs;
      aSum += (stack.a = a2) * rbs;
      rInSum += r;
      gInSum += g;
      bInSum += b;
      aInSum += a2;
      stack = stack.next;
    }
    stackIn = stackStart;
    stackOut = stackEnd;
    for (var x = 0; x < width; x++) {
      var paInitial = aSum * mulSum >>> shgSum;
      pixels[yi + 3] = paInitial;
      if (paInitial !== 0) {
        var _a2 = 255 / paInitial;
        pixels[yi] = (rSum * mulSum >>> shgSum) * _a2;
        pixels[yi + 1] = (gSum * mulSum >>> shgSum) * _a2;
        pixels[yi + 2] = (bSum * mulSum >>> shgSum) * _a2;
      } else {
        pixels[yi] = pixels[yi + 1] = pixels[yi + 2] = 0;
      }
      rSum -= rOutSum;
      gSum -= gOutSum;
      bSum -= bOutSum;
      aSum -= aOutSum;
      rOutSum -= stackIn.r;
      gOutSum -= stackIn.g;
      bOutSum -= stackIn.b;
      aOutSum -= stackIn.a;
      var _p = x + radius + 1;
      _p = yw + (_p < widthMinus1 ? _p : widthMinus1) << 2;
      rInSum += stackIn.r = pixels[_p];
      gInSum += stackIn.g = pixels[_p + 1];
      bInSum += stackIn.b = pixels[_p + 2];
      aInSum += stackIn.a = pixels[_p + 3];
      rSum += rInSum;
      gSum += gInSum;
      bSum += bInSum;
      aSum += aInSum;
      stackIn = stackIn.next;
      var _stackOut = stackOut, _r = _stackOut.r, _g = _stackOut.g, _b = _stackOut.b, _a3 = _stackOut.a;
      rOutSum += _r;
      gOutSum += _g;
      bOutSum += _b;
      aOutSum += _a3;
      rInSum -= _r;
      gInSum -= _g;
      bInSum -= _b;
      aInSum -= _a3;
      stackOut = stackOut.next;
      yi += 4;
    }
    yw += width;
  }
  for (var _x = 0; _x < width; _x++) {
    yi = _x << 2;
    var _pr = pixels[yi], _pg = pixels[yi + 1], _pb = pixels[yi + 2], _pa = pixels[yi + 3], _rOutSum = radiusPlus1 * _pr, _gOutSum = radiusPlus1 * _pg, _bOutSum = radiusPlus1 * _pb, _aOutSum = radiusPlus1 * _pa, _rSum = sumFactor * _pr, _gSum = sumFactor * _pg, _bSum = sumFactor * _pb, _aSum = sumFactor * _pa;
    stack = stackStart;
    for (var _i3 = 0; _i3 < radiusPlus1; _i3++) {
      stack.r = _pr;
      stack.g = _pg;
      stack.b = _pb;
      stack.a = _pa;
      stack = stack.next;
    }
    var yp = width;
    var _gInSum = 0, _bInSum = 0, _aInSum = 0, _rInSum = 0;
    for (var _i4 = 1; _i4 <= radius; _i4++) {
      yi = yp + _x << 2;
      var _rbs = radiusPlus1 - _i4;
      _rSum += (stack.r = _pr = pixels[yi]) * _rbs;
      _gSum += (stack.g = _pg = pixels[yi + 1]) * _rbs;
      _bSum += (stack.b = _pb = pixels[yi + 2]) * _rbs;
      _aSum += (stack.a = _pa = pixels[yi + 3]) * _rbs;
      _rInSum += _pr;
      _gInSum += _pg;
      _bInSum += _pb;
      _aInSum += _pa;
      stack = stack.next;
      if (_i4 < heightMinus1) {
        yp += width;
      }
    }
    yi = _x;
    stackIn = stackStart;
    stackOut = stackEnd;
    for (var _y = 0; _y < height; _y++) {
      var _p2 = yi << 2;
      pixels[_p2 + 3] = _pa = _aSum * mulSum >>> shgSum;
      if (_pa > 0) {
        _pa = 255 / _pa;
        pixels[_p2] = (_rSum * mulSum >>> shgSum) * _pa;
        pixels[_p2 + 1] = (_gSum * mulSum >>> shgSum) * _pa;
        pixels[_p2 + 2] = (_bSum * mulSum >>> shgSum) * _pa;
      } else {
        pixels[_p2] = pixels[_p2 + 1] = pixels[_p2 + 2] = 0;
      }
      _rSum -= _rOutSum;
      _gSum -= _gOutSum;
      _bSum -= _bOutSum;
      _aSum -= _aOutSum;
      _rOutSum -= stackIn.r;
      _gOutSum -= stackIn.g;
      _bOutSum -= stackIn.b;
      _aOutSum -= stackIn.a;
      _p2 = _x + ((_p2 = _y + radiusPlus1) < heightMinus1 ? _p2 : heightMinus1) * width << 2;
      _rSum += _rInSum += stackIn.r = pixels[_p2];
      _gSum += _gInSum += stackIn.g = pixels[_p2 + 1];
      _bSum += _bInSum += stackIn.b = pixels[_p2 + 2];
      _aSum += _aInSum += stackIn.a = pixels[_p2 + 3];
      stackIn = stackIn.next;
      _rOutSum += _pr = stackOut.r;
      _gOutSum += _pg = stackOut.g;
      _bOutSum += _pb = stackOut.b;
      _aOutSum += _pa = stackOut.a;
      _rInSum -= _pr;
      _gInSum -= _pg;
      _bInSum -= _pb;
      _aInSum -= _pa;
      stackOut = stackOut.next;
      yi += width;
    }
  }
  return imageData;
}
function processCanvasRGB(canvas, topX, topY, width, height, radius) {
  if (isNaN(radius) || radius < 1) {
    return;
  }
  radius |= 0;
  var imageData = getImageDataFromCanvas(canvas, topX, topY, width, height);
  imageData = processImageDataRGB(imageData, topX, topY, width, height, radius);
  canvas.getContext("2d").putImageData(imageData, topX, topY);
}
function processImageDataRGB(imageData, topX, topY, width, height, radius) {
  var pixels = imageData.data;
  var div = 2 * radius + 1;
  var widthMinus1 = width - 1;
  var heightMinus1 = height - 1;
  var radiusPlus1 = radius + 1;
  var sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2;
  var stackStart = new BlurStack();
  var stack = stackStart;
  var stackEnd;
  for (var i = 1; i < div; i++) {
    stack = stack.next = new BlurStack();
    if (i === radiusPlus1) {
      stackEnd = stack;
    }
  }
  stack.next = stackStart;
  var stackIn = null;
  var stackOut = null;
  var mulSum = mulTable[radius];
  var shgSum = shgTable[radius];
  var p, rbs;
  var yw = 0, yi = 0;
  for (var y = 0; y < height; y++) {
    var pr = pixels[yi], pg = pixels[yi + 1], pb = pixels[yi + 2], rOutSum = radiusPlus1 * pr, gOutSum = radiusPlus1 * pg, bOutSum = radiusPlus1 * pb, rSum = sumFactor * pr, gSum = sumFactor * pg, bSum = sumFactor * pb;
    stack = stackStart;
    for (var _i5 = 0; _i5 < radiusPlus1; _i5++) {
      stack.r = pr;
      stack.g = pg;
      stack.b = pb;
      stack = stack.next;
    }
    var rInSum = 0, gInSum = 0, bInSum = 0;
    for (var _i6 = 1; _i6 < radiusPlus1; _i6++) {
      p = yi + ((widthMinus1 < _i6 ? widthMinus1 : _i6) << 2);
      rSum += (stack.r = pr = pixels[p]) * (rbs = radiusPlus1 - _i6);
      gSum += (stack.g = pg = pixels[p + 1]) * rbs;
      bSum += (stack.b = pb = pixels[p + 2]) * rbs;
      rInSum += pr;
      gInSum += pg;
      bInSum += pb;
      stack = stack.next;
    }
    stackIn = stackStart;
    stackOut = stackEnd;
    for (var x = 0; x < width; x++) {
      pixels[yi] = rSum * mulSum >>> shgSum;
      pixels[yi + 1] = gSum * mulSum >>> shgSum;
      pixels[yi + 2] = bSum * mulSum >>> shgSum;
      rSum -= rOutSum;
      gSum -= gOutSum;
      bSum -= bOutSum;
      rOutSum -= stackIn.r;
      gOutSum -= stackIn.g;
      bOutSum -= stackIn.b;
      p = yw + ((p = x + radius + 1) < widthMinus1 ? p : widthMinus1) << 2;
      rInSum += stackIn.r = pixels[p];
      gInSum += stackIn.g = pixels[p + 1];
      bInSum += stackIn.b = pixels[p + 2];
      rSum += rInSum;
      gSum += gInSum;
      bSum += bInSum;
      stackIn = stackIn.next;
      rOutSum += pr = stackOut.r;
      gOutSum += pg = stackOut.g;
      bOutSum += pb = stackOut.b;
      rInSum -= pr;
      gInSum -= pg;
      bInSum -= pb;
      stackOut = stackOut.next;
      yi += 4;
    }
    yw += width;
  }
  for (var _x2 = 0; _x2 < width; _x2++) {
    yi = _x2 << 2;
    var _pr2 = pixels[yi], _pg2 = pixels[yi + 1], _pb2 = pixels[yi + 2], _rOutSum2 = radiusPlus1 * _pr2, _gOutSum2 = radiusPlus1 * _pg2, _bOutSum2 = radiusPlus1 * _pb2, _rSum2 = sumFactor * _pr2, _gSum2 = sumFactor * _pg2, _bSum2 = sumFactor * _pb2;
    stack = stackStart;
    for (var _i7 = 0; _i7 < radiusPlus1; _i7++) {
      stack.r = _pr2;
      stack.g = _pg2;
      stack.b = _pb2;
      stack = stack.next;
    }
    var _rInSum2 = 0, _gInSum2 = 0, _bInSum2 = 0;
    for (var _i8 = 1, yp = width; _i8 <= radius; _i8++) {
      yi = yp + _x2 << 2;
      _rSum2 += (stack.r = _pr2 = pixels[yi]) * (rbs = radiusPlus1 - _i8);
      _gSum2 += (stack.g = _pg2 = pixels[yi + 1]) * rbs;
      _bSum2 += (stack.b = _pb2 = pixels[yi + 2]) * rbs;
      _rInSum2 += _pr2;
      _gInSum2 += _pg2;
      _bInSum2 += _pb2;
      stack = stack.next;
      if (_i8 < heightMinus1) {
        yp += width;
      }
    }
    yi = _x2;
    stackIn = stackStart;
    stackOut = stackEnd;
    for (var _y2 = 0; _y2 < height; _y2++) {
      p = yi << 2;
      pixels[p] = _rSum2 * mulSum >>> shgSum;
      pixels[p + 1] = _gSum2 * mulSum >>> shgSum;
      pixels[p + 2] = _bSum2 * mulSum >>> shgSum;
      _rSum2 -= _rOutSum2;
      _gSum2 -= _gOutSum2;
      _bSum2 -= _bOutSum2;
      _rOutSum2 -= stackIn.r;
      _gOutSum2 -= stackIn.g;
      _bOutSum2 -= stackIn.b;
      p = _x2 + ((p = _y2 + radiusPlus1) < heightMinus1 ? p : heightMinus1) * width << 2;
      _rSum2 += _rInSum2 += stackIn.r = pixels[p];
      _gSum2 += _gInSum2 += stackIn.g = pixels[p + 1];
      _bSum2 += _bInSum2 += stackIn.b = pixels[p + 2];
      stackIn = stackIn.next;
      _rOutSum2 += _pr2 = stackOut.r;
      _gOutSum2 += _pg2 = stackOut.g;
      _bOutSum2 += _pb2 = stackOut.b;
      _rInSum2 -= _pr2;
      _gInSum2 -= _pg2;
      _bInSum2 -= _pb2;
      stackOut = stackOut.next;
      yi += width;
    }
  }
  return imageData;
}
var mulTable, shgTable, BlurStack;
var init_stackblur_es = __esm({
  "node_modules/stackblur-canvas/dist/stackblur-es.js"() {
    "use strict";
    mulTable = [512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292, 289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259];
    shgTable = [9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24];
    BlurStack = /**
     * Set properties.
     */
    function BlurStack2() {
      _classCallCheck(this, BlurStack2);
      this.r = 0;
      this.g = 0;
      this.b = 0;
      this.a = 0;
      this.next = null;
    };
  }
});

// node_modules/canvg/lib/index.cjs
var require_lib2 = __commonJS({
  "node_modules/canvg/lib/index.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    require_es_object_to_string();
    require_es_promise();
    require_es_reflect_delete_property();
    var _regeneratorRuntime = require_regenerator2();
    var _asyncToGenerator = require_asyncToGenerator();
    require_es_array_map();
    require_es_parse_float();
    require_es_regexp_exec();
    require_es_string_match();
    require_es_string_replace();
    require_es_string_starts_with();
    require_es_array_join();
    var _slicedToArray = require_slicedToArray();
    var _defineProperty = require_defineProperty();
    var _classCallCheck2 = require_classCallCheck();
    var _createClass = require_createClass();
    require_es_array_concat();
    require_es_array_every();
    require_es_array_reduce();
    require_es_string_ends_with();
    require_es_string_split();
    var requestAnimationFrame = require_raf();
    require_es_function_name();
    require_es_string_trim();
    var RGBColor2 = require_rgbcolor();
    require_es_array_for_each();
    require_web_dom_collections_for_each();
    var _inherits = require_inherits();
    var _possibleConstructorReturn = require_possibleConstructorReturn();
    var _getPrototypeOf = require_getPrototypeOf();
    require_es_array_from();
    require_es_array_includes();
    require_es_array_index_of();
    require_es_array_some();
    require_es_string_includes();
    require_es_string_iterator();
    var _toConsumableArray = require_toConsumableArray();
    require_es_array_reverse();
    require_es_number_constructor();
    var _get = require_get();
    require_es_array_fill();
    var svgPathdata = require_SVGPathData();
    require_es_regexp_to_string();
    var _assertThisInitialized = require_assertThisInitialized();
    require_es_array_iterator();
    require_web_dom_collections_iterator();
    require_es_map();
    require_es_reflect_apply();
    require_es_reflect_get_prototype_of();
    var stackblurCanvas = (init_stackblur_es(), __toCommonJS(stackblur_es_exports));
    function _interopDefaultLegacy(e2) {
      return e2 && typeof e2 === "object" && "default" in e2 ? e2 : { "default": e2 };
    }
    var _regeneratorRuntime__default = /* @__PURE__ */ _interopDefaultLegacy(_regeneratorRuntime);
    var _asyncToGenerator__default = /* @__PURE__ */ _interopDefaultLegacy(_asyncToGenerator);
    var _slicedToArray__default = /* @__PURE__ */ _interopDefaultLegacy(_slicedToArray);
    var _defineProperty__default = /* @__PURE__ */ _interopDefaultLegacy(_defineProperty);
    var _classCallCheck__default = /* @__PURE__ */ _interopDefaultLegacy(_classCallCheck2);
    var _createClass__default = /* @__PURE__ */ _interopDefaultLegacy(_createClass);
    var requestAnimationFrame__default = /* @__PURE__ */ _interopDefaultLegacy(requestAnimationFrame);
    var RGBColor__default = /* @__PURE__ */ _interopDefaultLegacy(RGBColor2);
    var _inherits__default = /* @__PURE__ */ _interopDefaultLegacy(_inherits);
    var _possibleConstructorReturn__default = /* @__PURE__ */ _interopDefaultLegacy(_possibleConstructorReturn);
    var _getPrototypeOf__default = /* @__PURE__ */ _interopDefaultLegacy(_getPrototypeOf);
    var _toConsumableArray__default = /* @__PURE__ */ _interopDefaultLegacy(_toConsumableArray);
    var _get__default = /* @__PURE__ */ _interopDefaultLegacy(_get);
    var _assertThisInitialized__default = /* @__PURE__ */ _interopDefaultLegacy(_assertThisInitialized);
    function offscreen() {
      var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, DOMParserFallback = _ref.DOMParser;
      var preset = {
        window: null,
        ignoreAnimation: true,
        ignoreMouse: true,
        DOMParser: DOMParserFallback,
        createCanvas: function createCanvas2(width, height) {
          return new OffscreenCanvas(width, height);
        },
        createImage: function createImage2(url) {
          return _asyncToGenerator__default["default"](/* @__PURE__ */ _regeneratorRuntime__default["default"].mark(function _callee() {
            var response, blob, img;
            return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return fetch(url);
                  case 2:
                    response = _context.sent;
                    _context.next = 5;
                    return response.blob();
                  case 5:
                    blob = _context.sent;
                    _context.next = 8;
                    return createImageBitmap(blob);
                  case 8:
                    img = _context.sent;
                    return _context.abrupt("return", img);
                  case 10:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          }))();
        }
      };
      if (typeof DOMParser !== "undefined" || typeof DOMParserFallback === "undefined") {
        Reflect.deleteProperty(preset, "DOMParser");
      }
      return preset;
    }
    function node(_ref) {
      var DOMParser2 = _ref.DOMParser, canvas = _ref.canvas, fetch2 = _ref.fetch;
      return {
        window: null,
        ignoreAnimation: true,
        ignoreMouse: true,
        DOMParser: DOMParser2,
        fetch: fetch2,
        createCanvas: canvas.createCanvas,
        createImage: canvas.loadImage
      };
    }
    var index = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      offscreen,
      node
    });
    function compressSpaces(str) {
      return str.replace(/(?!\u3000)\s+/gm, " ");
    }
    function trimLeft(str) {
      return str.replace(/^[\n \t]+/, "");
    }
    function trimRight(str) {
      return str.replace(/[\n \t]+$/, "");
    }
    function toNumbers(str) {
      var matches = (str || "").match(/-?(\d+(?:\.\d*(?:[eE][+-]?\d+)?)?|\.\d+)(?=\D|$)/gm) || [];
      return matches.map(parseFloat);
    }
    var allUppercase = /^[A-Z-]+$/;
    function normalizeAttributeName(name) {
      if (allUppercase.test(name)) {
        return name.toLowerCase();
      }
      return name;
    }
    function parseExternalUrl(url) {
      var urlMatch = /url\(('([^']+)'|"([^"]+)"|([^'")]+))\)/.exec(url) || [];
      return urlMatch[2] || urlMatch[3] || urlMatch[4];
    }
    function normalizeColor(color2) {
      if (!color2.startsWith("rgb")) {
        return color2;
      }
      var rgbParts = 3;
      var normalizedColor = color2.replace(/\d+(\.\d+)?/g, function(num, isFloat) {
        return rgbParts-- && isFloat ? String(Math.round(parseFloat(num))) : num;
      });
      return normalizedColor;
    }
    var attributeRegex = /(\[[^\]]+\])/g;
    var idRegex = /(#[^\s+>~.[:]+)/g;
    var classRegex = /(\.[^\s+>~.[:]+)/g;
    var pseudoElementRegex = /(::[^\s+>~.[:]+|:first-line|:first-letter|:before|:after)/gi;
    var pseudoClassWithBracketsRegex = /(:[\w-]+\([^)]*\))/gi;
    var pseudoClassRegex = /(:[^\s+>~.[:]+)/g;
    var elementRegex = /([^\s+>~.[:]+)/g;
    function findSelectorMatch(selector, regex) {
      var matches = regex.exec(selector);
      if (!matches) {
        return [selector, 0];
      }
      return [selector.replace(regex, " "), matches.length];
    }
    function getSelectorSpecificity(selector) {
      var specificity = [0, 0, 0];
      var currentSelector = selector.replace(/:not\(([^)]*)\)/g, "     $1 ").replace(/{[\s\S]*/gm, " ");
      var delta = 0;
      var _findSelectorMatch = findSelectorMatch(currentSelector, attributeRegex);
      var _findSelectorMatch2 = _slicedToArray__default["default"](_findSelectorMatch, 2);
      currentSelector = _findSelectorMatch2[0];
      delta = _findSelectorMatch2[1];
      specificity[1] += delta;
      var _findSelectorMatch3 = findSelectorMatch(currentSelector, idRegex);
      var _findSelectorMatch4 = _slicedToArray__default["default"](_findSelectorMatch3, 2);
      currentSelector = _findSelectorMatch4[0];
      delta = _findSelectorMatch4[1];
      specificity[0] += delta;
      var _findSelectorMatch5 = findSelectorMatch(currentSelector, classRegex);
      var _findSelectorMatch6 = _slicedToArray__default["default"](_findSelectorMatch5, 2);
      currentSelector = _findSelectorMatch6[0];
      delta = _findSelectorMatch6[1];
      specificity[1] += delta;
      var _findSelectorMatch7 = findSelectorMatch(currentSelector, pseudoElementRegex);
      var _findSelectorMatch8 = _slicedToArray__default["default"](_findSelectorMatch7, 2);
      currentSelector = _findSelectorMatch8[0];
      delta = _findSelectorMatch8[1];
      specificity[2] += delta;
      var _findSelectorMatch9 = findSelectorMatch(currentSelector, pseudoClassWithBracketsRegex);
      var _findSelectorMatch10 = _slicedToArray__default["default"](_findSelectorMatch9, 2);
      currentSelector = _findSelectorMatch10[0];
      delta = _findSelectorMatch10[1];
      specificity[1] += delta;
      var _findSelectorMatch11 = findSelectorMatch(currentSelector, pseudoClassRegex);
      var _findSelectorMatch12 = _slicedToArray__default["default"](_findSelectorMatch11, 2);
      currentSelector = _findSelectorMatch12[0];
      delta = _findSelectorMatch12[1];
      specificity[1] += delta;
      currentSelector = currentSelector.replace(/[*\s+>~]/g, " ").replace(/[#.]/g, " ");
      var _findSelectorMatch13 = findSelectorMatch(currentSelector, elementRegex);
      var _findSelectorMatch14 = _slicedToArray__default["default"](_findSelectorMatch13, 2);
      currentSelector = _findSelectorMatch14[0];
      delta = _findSelectorMatch14[1];
      specificity[2] += delta;
      return specificity.join("");
    }
    var PSEUDO_ZERO = 1e-8;
    function vectorMagnitude(v) {
      return Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2));
    }
    function vectorsRatio(u2, v) {
      return (u2[0] * v[0] + u2[1] * v[1]) / (vectorMagnitude(u2) * vectorMagnitude(v));
    }
    function vectorsAngle(u2, v) {
      return (u2[0] * v[1] < u2[1] * v[0] ? -1 : 1) * Math.acos(vectorsRatio(u2, v));
    }
    function CB1(t) {
      return t * t * t;
    }
    function CB2(t) {
      return 3 * t * t * (1 - t);
    }
    function CB3(t) {
      return 3 * t * (1 - t) * (1 - t);
    }
    function CB4(t) {
      return (1 - t) * (1 - t) * (1 - t);
    }
    function QB1(t) {
      return t * t;
    }
    function QB2(t) {
      return 2 * t * (1 - t);
    }
    function QB3(t) {
      return (1 - t) * (1 - t);
    }
    var Property = /* @__PURE__ */ (function() {
      function Property2(document2, name, value) {
        _classCallCheck__default["default"](this, Property2);
        this.document = document2;
        this.name = name;
        this.value = value;
        this.isNormalizedColor = false;
      }
      _createClass__default["default"](Property2, [{
        key: "split",
        value: function split() {
          var separator = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : " ";
          var document2 = this.document, name = this.name;
          return compressSpaces(this.getString()).trim().split(separator).map(function(value) {
            return new Property2(document2, name, value);
          });
        }
      }, {
        key: "hasValue",
        value: function hasValue(zeroIsValue) {
          var value = this.value;
          return value !== null && value !== "" && (zeroIsValue || value !== 0) && typeof value !== "undefined";
        }
      }, {
        key: "isString",
        value: function isString(regexp) {
          var value = this.value;
          var result = typeof value === "string";
          if (!result || !regexp) {
            return result;
          }
          return regexp.test(value);
        }
      }, {
        key: "isUrlDefinition",
        value: function isUrlDefinition() {
          return this.isString(/^url\(/);
        }
      }, {
        key: "isPixels",
        value: function isPixels() {
          if (!this.hasValue()) {
            return false;
          }
          var asString2 = this.getString();
          switch (true) {
            case asString2.endsWith("px"):
            case /^[0-9]+$/.test(asString2):
              return true;
            default:
              return false;
          }
        }
      }, {
        key: "setValue",
        value: function setValue(value) {
          this.value = value;
          return this;
        }
      }, {
        key: "getValue",
        value: function getValue(def) {
          if (typeof def === "undefined" || this.hasValue()) {
            return this.value;
          }
          return def;
        }
      }, {
        key: "getNumber",
        value: function getNumber(def) {
          if (!this.hasValue()) {
            if (typeof def === "undefined") {
              return 0;
            }
            return parseFloat(def);
          }
          var value = this.value;
          var n = parseFloat(value);
          if (this.isString(/%$/)) {
            n /= 100;
          }
          return n;
        }
      }, {
        key: "getString",
        value: function getString(def) {
          if (typeof def === "undefined" || this.hasValue()) {
            return typeof this.value === "undefined" ? "" : String(this.value);
          }
          return String(def);
        }
      }, {
        key: "getColor",
        value: function getColor(def) {
          var color2 = this.getString(def);
          if (this.isNormalizedColor) {
            return color2;
          }
          this.isNormalizedColor = true;
          color2 = normalizeColor(color2);
          this.value = color2;
          return color2;
        }
      }, {
        key: "getDpi",
        value: function getDpi() {
          return 96;
        }
      }, {
        key: "getRem",
        value: function getRem() {
          return this.document.rootEmSize;
        }
      }, {
        key: "getEm",
        value: function getEm() {
          return this.document.emSize;
        }
      }, {
        key: "getUnits",
        value: function getUnits() {
          return this.getString().replace(/[0-9.-]/g, "");
        }
      }, {
        key: "getPixels",
        value: function getPixels(axisOrIsFontSize) {
          var processPercent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          if (!this.hasValue()) {
            return 0;
          }
          var _ref = typeof axisOrIsFontSize === "boolean" ? [void 0, axisOrIsFontSize] : [axisOrIsFontSize], _ref2 = _slicedToArray__default["default"](_ref, 2), axis = _ref2[0], isFontSize = _ref2[1];
          var viewPort = this.document.screen.viewPort;
          switch (true) {
            case this.isString(/vmin$/):
              return this.getNumber() / 100 * Math.min(viewPort.computeSize("x"), viewPort.computeSize("y"));
            case this.isString(/vmax$/):
              return this.getNumber() / 100 * Math.max(viewPort.computeSize("x"), viewPort.computeSize("y"));
            case this.isString(/vw$/):
              return this.getNumber() / 100 * viewPort.computeSize("x");
            case this.isString(/vh$/):
              return this.getNumber() / 100 * viewPort.computeSize("y");
            case this.isString(/rem$/):
              return this.getNumber() * this.getRem();
            case this.isString(/em$/):
              return this.getNumber() * this.getEm();
            case this.isString(/ex$/):
              return this.getNumber() * this.getEm() / 2;
            case this.isString(/px$/):
              return this.getNumber();
            case this.isString(/pt$/):
              return this.getNumber() * this.getDpi() * (1 / 72);
            case this.isString(/pc$/):
              return this.getNumber() * 15;
            case this.isString(/cm$/):
              return this.getNumber() * this.getDpi() / 2.54;
            case this.isString(/mm$/):
              return this.getNumber() * this.getDpi() / 25.4;
            case this.isString(/in$/):
              return this.getNumber() * this.getDpi();
            case (this.isString(/%$/) && isFontSize):
              return this.getNumber() * this.getEm();
            case this.isString(/%$/):
              return this.getNumber() * viewPort.computeSize(axis);
            default: {
              var n = this.getNumber();
              if (processPercent && n < 1) {
                return n * viewPort.computeSize(axis);
              }
              return n;
            }
          }
        }
      }, {
        key: "getMilliseconds",
        value: function getMilliseconds() {
          if (!this.hasValue()) {
            return 0;
          }
          if (this.isString(/ms$/)) {
            return this.getNumber();
          }
          return this.getNumber() * 1e3;
        }
      }, {
        key: "getRadians",
        value: function getRadians() {
          if (!this.hasValue()) {
            return 0;
          }
          switch (true) {
            case this.isString(/deg$/):
              return this.getNumber() * (Math.PI / 180);
            case this.isString(/grad$/):
              return this.getNumber() * (Math.PI / 200);
            case this.isString(/rad$/):
              return this.getNumber();
            default:
              return this.getNumber() * (Math.PI / 180);
          }
        }
      }, {
        key: "getDefinition",
        value: function getDefinition() {
          var asString2 = this.getString();
          var name = /#([^)'"]+)/.exec(asString2);
          if (name) {
            name = name[1];
          }
          if (!name) {
            name = asString2;
          }
          return this.document.definitions[name];
        }
      }, {
        key: "getFillStyleDefinition",
        value: function getFillStyleDefinition(element, opacity2) {
          var def = this.getDefinition();
          if (!def) {
            return null;
          }
          if (typeof def.createGradient === "function") {
            return def.createGradient(this.document.ctx, element, opacity2);
          }
          if (typeof def.createPattern === "function") {
            if (def.getHrefAttribute().hasValue()) {
              var patternTransform = def.getAttribute("patternTransform");
              def = def.getHrefAttribute().getDefinition();
              if (patternTransform.hasValue()) {
                def.getAttribute("patternTransform", true).setValue(patternTransform.value);
              }
            }
            return def.createPattern(this.document.ctx, element, opacity2);
          }
          return null;
        }
      }, {
        key: "getTextBaseline",
        value: function getTextBaseline() {
          if (!this.hasValue()) {
            return null;
          }
          return Property2.textBaselineMapping[this.getString()];
        }
      }, {
        key: "addOpacity",
        value: function addOpacity(opacity2) {
          var value = this.getColor();
          var len = value.length;
          var commas = 0;
          for (var i = 0; i < len; i++) {
            if (value[i] === ",") {
              commas++;
            }
            if (commas === 3) {
              break;
            }
          }
          if (opacity2.hasValue() && this.isString() && commas !== 3) {
            var color2 = new RGBColor__default["default"](value);
            if (color2.ok) {
              color2.alpha = opacity2.getNumber();
              value = color2.toRGBA();
            }
          }
          return new Property2(this.document, this.name, value);
        }
      }], [{
        key: "empty",
        value: function empty2(document2) {
          return new Property2(document2, "EMPTY", "");
        }
      }]);
      return Property2;
    })();
    Property.textBaselineMapping = {
      "baseline": "alphabetic",
      "before-edge": "top",
      "text-before-edge": "top",
      "middle": "middle",
      "central": "middle",
      "after-edge": "bottom",
      "text-after-edge": "bottom",
      "ideographic": "ideographic",
      "alphabetic": "alphabetic",
      "hanging": "hanging",
      "mathematical": "alphabetic"
    };
    var ViewPort = /* @__PURE__ */ (function() {
      function ViewPort2() {
        _classCallCheck__default["default"](this, ViewPort2);
        this.viewPorts = [];
      }
      _createClass__default["default"](ViewPort2, [{
        key: "clear",
        value: function clear() {
          this.viewPorts = [];
        }
      }, {
        key: "setCurrent",
        value: function setCurrent(width, height) {
          this.viewPorts.push({
            width,
            height
          });
        }
      }, {
        key: "removeCurrent",
        value: function removeCurrent() {
          this.viewPorts.pop();
        }
      }, {
        key: "getCurrent",
        value: function getCurrent() {
          var viewPorts = this.viewPorts;
          return viewPorts[viewPorts.length - 1];
        }
      }, {
        key: "computeSize",
        value: function computeSize(d) {
          if (typeof d === "number") {
            return d;
          }
          if (d === "x") {
            return this.width;
          }
          if (d === "y") {
            return this.height;
          }
          return Math.sqrt(Math.pow(this.width, 2) + Math.pow(this.height, 2)) / Math.sqrt(2);
        }
      }, {
        key: "width",
        get: function get() {
          return this.getCurrent().width;
        }
      }, {
        key: "height",
        get: function get() {
          return this.getCurrent().height;
        }
      }]);
      return ViewPort2;
    })();
    var Point = /* @__PURE__ */ (function() {
      function Point2(x, y) {
        _classCallCheck__default["default"](this, Point2);
        this.x = x;
        this.y = y;
      }
      _createClass__default["default"](Point2, [{
        key: "angleTo",
        value: function angleTo(point) {
          return Math.atan2(point.y - this.y, point.x - this.x);
        }
      }, {
        key: "applyTransform",
        value: function applyTransform(transform2) {
          var x = this.x, y = this.y;
          var xp = x * transform2[0] + y * transform2[2] + transform2[4];
          var yp = x * transform2[1] + y * transform2[3] + transform2[5];
          this.x = xp;
          this.y = yp;
        }
      }], [{
        key: "parse",
        value: function parse2(point) {
          var defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
          var _toNumbers = toNumbers(point), _toNumbers2 = _slicedToArray__default["default"](_toNumbers, 2), _toNumbers2$ = _toNumbers2[0], x = _toNumbers2$ === void 0 ? defaultValue : _toNumbers2$, _toNumbers2$2 = _toNumbers2[1], y = _toNumbers2$2 === void 0 ? defaultValue : _toNumbers2$2;
          return new Point2(x, y);
        }
      }, {
        key: "parseScale",
        value: function parseScale(scale) {
          var defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
          var _toNumbers3 = toNumbers(scale), _toNumbers4 = _slicedToArray__default["default"](_toNumbers3, 2), _toNumbers4$ = _toNumbers4[0], x = _toNumbers4$ === void 0 ? defaultValue : _toNumbers4$, _toNumbers4$2 = _toNumbers4[1], y = _toNumbers4$2 === void 0 ? x : _toNumbers4$2;
          return new Point2(x, y);
        }
      }, {
        key: "parsePath",
        value: function parsePath(path) {
          var points = toNumbers(path);
          var len = points.length;
          var pathPoints = [];
          for (var i = 0; i < len; i += 2) {
            pathPoints.push(new Point2(points[i], points[i + 1]));
          }
          return pathPoints;
        }
      }]);
      return Point2;
    })();
    var Mouse = /* @__PURE__ */ (function() {
      function Mouse2(screen) {
        _classCallCheck__default["default"](this, Mouse2);
        this.screen = screen;
        this.working = false;
        this.events = [];
        this.eventElements = [];
        this.onClick = this.onClick.bind(this);
        this.onMouseMove = this.onMouseMove.bind(this);
      }
      _createClass__default["default"](Mouse2, [{
        key: "isWorking",
        value: function isWorking() {
          return this.working;
        }
      }, {
        key: "start",
        value: function start() {
          if (this.working) {
            return;
          }
          var screen = this.screen, onClick = this.onClick, onMouseMove = this.onMouseMove;
          var canvas = screen.ctx.canvas;
          canvas.onclick = onClick;
          canvas.onmousemove = onMouseMove;
          this.working = true;
        }
      }, {
        key: "stop",
        value: function stop() {
          if (!this.working) {
            return;
          }
          var canvas = this.screen.ctx.canvas;
          this.working = false;
          canvas.onclick = null;
          canvas.onmousemove = null;
        }
      }, {
        key: "hasEvents",
        value: function hasEvents() {
          return this.working && this.events.length > 0;
        }
      }, {
        key: "runEvents",
        value: function runEvents() {
          if (!this.working) {
            return;
          }
          var document2 = this.screen, events = this.events, eventElements = this.eventElements;
          var style = document2.ctx.canvas.style;
          if (style) {
            style.cursor = "";
          }
          events.forEach(function(_ref, i) {
            var run = _ref.run;
            var element = eventElements[i];
            while (element) {
              run(element);
              element = element.parent;
            }
          });
          this.events = [];
          this.eventElements = [];
        }
      }, {
        key: "checkPath",
        value: function checkPath(element, ctx) {
          if (!this.working || !ctx) {
            return;
          }
          var events = this.events, eventElements = this.eventElements;
          events.forEach(function(_ref2, i) {
            var x = _ref2.x, y = _ref2.y;
            if (!eventElements[i] && ctx.isPointInPath && ctx.isPointInPath(x, y)) {
              eventElements[i] = element;
            }
          });
        }
      }, {
        key: "checkBoundingBox",
        value: function checkBoundingBox(element, boundingBox) {
          if (!this.working || !boundingBox) {
            return;
          }
          var events = this.events, eventElements = this.eventElements;
          events.forEach(function(_ref3, i) {
            var x = _ref3.x, y = _ref3.y;
            if (!eventElements[i] && boundingBox.isPointInBox(x, y)) {
              eventElements[i] = element;
            }
          });
        }
      }, {
        key: "mapXY",
        value: function mapXY(x, y) {
          var _this$screen = this.screen, window2 = _this$screen.window, ctx = _this$screen.ctx;
          var point = new Point(x, y);
          var element = ctx.canvas;
          while (element) {
            point.x -= element.offsetLeft;
            point.y -= element.offsetTop;
            element = element.offsetParent;
          }
          if (window2.scrollX) {
            point.x += window2.scrollX;
          }
          if (window2.scrollY) {
            point.y += window2.scrollY;
          }
          return point;
        }
      }, {
        key: "onClick",
        value: function onClick(event) {
          var _this$mapXY = this.mapXY(event.clientX, event.clientY), x = _this$mapXY.x, y = _this$mapXY.y;
          this.events.push({
            type: "onclick",
            x,
            y,
            run: function run(eventTarget) {
              if (eventTarget.onClick) {
                eventTarget.onClick();
              }
            }
          });
        }
      }, {
        key: "onMouseMove",
        value: function onMouseMove(event) {
          var _this$mapXY2 = this.mapXY(event.clientX, event.clientY), x = _this$mapXY2.x, y = _this$mapXY2.y;
          this.events.push({
            type: "onmousemove",
            x,
            y,
            run: function run(eventTarget) {
              if (eventTarget.onMouseMove) {
                eventTarget.onMouseMove();
              }
            }
          });
        }
      }]);
      return Mouse2;
    })();
    var defaultWindow = typeof window !== "undefined" ? window : null;
    var defaultFetch$1 = typeof fetch !== "undefined" ? fetch.bind(void 0) : null;
    var Screen = /* @__PURE__ */ (function() {
      function Screen2(ctx) {
        var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$fetch = _ref.fetch, fetch2 = _ref$fetch === void 0 ? defaultFetch$1 : _ref$fetch, _ref$window = _ref.window, window2 = _ref$window === void 0 ? defaultWindow : _ref$window;
        _classCallCheck__default["default"](this, Screen2);
        this.ctx = ctx;
        this.FRAMERATE = 30;
        this.MAX_VIRTUAL_PIXELS = 3e4;
        this.CLIENT_WIDTH = 800;
        this.CLIENT_HEIGHT = 600;
        this.viewPort = new ViewPort();
        this.mouse = new Mouse(this);
        this.animations = [];
        this.waits = [];
        this.frameDuration = 0;
        this.isReadyLock = false;
        this.isFirstRender = true;
        this.intervalId = null;
        this.window = window2;
        this.fetch = fetch2;
      }
      _createClass__default["default"](Screen2, [{
        key: "wait",
        value: function wait(checker) {
          this.waits.push(checker);
        }
      }, {
        key: "ready",
        value: function ready() {
          if (!this.readyPromise) {
            return Promise.resolve();
          }
          return this.readyPromise;
        }
      }, {
        key: "isReady",
        value: function isReady() {
          if (this.isReadyLock) {
            return true;
          }
          var isReadyLock = this.waits.every(function(_) {
            return _();
          });
          if (isReadyLock) {
            this.waits = [];
            if (this.resolveReady) {
              this.resolveReady();
            }
          }
          this.isReadyLock = isReadyLock;
          return isReadyLock;
        }
      }, {
        key: "setDefaults",
        value: function setDefaults(ctx) {
          ctx.strokeStyle = "rgba(0,0,0,0)";
          ctx.lineCap = "butt";
          ctx.lineJoin = "miter";
          ctx.miterLimit = 4;
        }
      }, {
        key: "setViewBox",
        value: function setViewBox(_ref2) {
          var document2 = _ref2.document, ctx = _ref2.ctx, aspectRatio = _ref2.aspectRatio, width = _ref2.width, desiredWidth = _ref2.desiredWidth, height = _ref2.height, desiredHeight = _ref2.desiredHeight, _ref2$minX = _ref2.minX, minX = _ref2$minX === void 0 ? 0 : _ref2$minX, _ref2$minY = _ref2.minY, minY = _ref2$minY === void 0 ? 0 : _ref2$minY, refX = _ref2.refX, refY = _ref2.refY, _ref2$clip = _ref2.clip, clip = _ref2$clip === void 0 ? false : _ref2$clip, _ref2$clipX = _ref2.clipX, clipX = _ref2$clipX === void 0 ? 0 : _ref2$clipX, _ref2$clipY = _ref2.clipY, clipY = _ref2$clipY === void 0 ? 0 : _ref2$clipY;
          var cleanAspectRatio = compressSpaces(aspectRatio).replace(/^defer\s/, "");
          var _cleanAspectRatio$spl = cleanAspectRatio.split(" "), _cleanAspectRatio$spl2 = _slicedToArray__default["default"](_cleanAspectRatio$spl, 2), aspectRatioAlign = _cleanAspectRatio$spl2[0], aspectRatioMeetOrSlice = _cleanAspectRatio$spl2[1];
          var align = aspectRatioAlign || "xMidYMid";
          var meetOrSlice = aspectRatioMeetOrSlice || "meet";
          var scaleX = width / desiredWidth;
          var scaleY = height / desiredHeight;
          var scaleMin = Math.min(scaleX, scaleY);
          var scaleMax = Math.max(scaleX, scaleY);
          var finalDesiredWidth = desiredWidth;
          var finalDesiredHeight = desiredHeight;
          if (meetOrSlice === "meet") {
            finalDesiredWidth *= scaleMin;
            finalDesiredHeight *= scaleMin;
          }
          if (meetOrSlice === "slice") {
            finalDesiredWidth *= scaleMax;
            finalDesiredHeight *= scaleMax;
          }
          var refXProp = new Property(document2, "refX", refX);
          var refYProp = new Property(document2, "refY", refY);
          var hasRefs = refXProp.hasValue() && refYProp.hasValue();
          if (hasRefs) {
            ctx.translate(-scaleMin * refXProp.getPixels("x"), -scaleMin * refYProp.getPixels("y"));
          }
          if (clip) {
            var scaledClipX = scaleMin * clipX;
            var scaledClipY = scaleMin * clipY;
            ctx.beginPath();
            ctx.moveTo(scaledClipX, scaledClipY);
            ctx.lineTo(width, scaledClipY);
            ctx.lineTo(width, height);
            ctx.lineTo(scaledClipX, height);
            ctx.closePath();
            ctx.clip();
          }
          if (!hasRefs) {
            var isMeetMinY = meetOrSlice === "meet" && scaleMin === scaleY;
            var isSliceMaxY = meetOrSlice === "slice" && scaleMax === scaleY;
            var isMeetMinX = meetOrSlice === "meet" && scaleMin === scaleX;
            var isSliceMaxX = meetOrSlice === "slice" && scaleMax === scaleX;
            if (align.startsWith("xMid") && (isMeetMinY || isSliceMaxY)) {
              ctx.translate(width / 2 - finalDesiredWidth / 2, 0);
            }
            if (align.endsWith("YMid") && (isMeetMinX || isSliceMaxX)) {
              ctx.translate(0, height / 2 - finalDesiredHeight / 2);
            }
            if (align.startsWith("xMax") && (isMeetMinY || isSliceMaxY)) {
              ctx.translate(width - finalDesiredWidth, 0);
            }
            if (align.endsWith("YMax") && (isMeetMinX || isSliceMaxX)) {
              ctx.translate(0, height - finalDesiredHeight);
            }
          }
          switch (true) {
            case align === "none":
              ctx.scale(scaleX, scaleY);
              break;
            case meetOrSlice === "meet":
              ctx.scale(scaleMin, scaleMin);
              break;
            case meetOrSlice === "slice":
              ctx.scale(scaleMax, scaleMax);
              break;
          }
          ctx.translate(-minX, -minY);
        }
      }, {
        key: "start",
        value: function start(element) {
          var _this = this;
          var _ref3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref3$enableRedraw = _ref3.enableRedraw, enableRedraw = _ref3$enableRedraw === void 0 ? false : _ref3$enableRedraw, _ref3$ignoreMouse = _ref3.ignoreMouse, ignoreMouse = _ref3$ignoreMouse === void 0 ? false : _ref3$ignoreMouse, _ref3$ignoreAnimation = _ref3.ignoreAnimation, ignoreAnimation = _ref3$ignoreAnimation === void 0 ? false : _ref3$ignoreAnimation, _ref3$ignoreDimension = _ref3.ignoreDimensions, ignoreDimensions = _ref3$ignoreDimension === void 0 ? false : _ref3$ignoreDimension, _ref3$ignoreClear = _ref3.ignoreClear, ignoreClear = _ref3$ignoreClear === void 0 ? false : _ref3$ignoreClear, forceRedraw = _ref3.forceRedraw, scaleWidth = _ref3.scaleWidth, scaleHeight = _ref3.scaleHeight, offsetX = _ref3.offsetX, offsetY = _ref3.offsetY;
          var FRAMERATE = this.FRAMERATE, mouse = this.mouse;
          var frameDuration = 1e3 / FRAMERATE;
          this.frameDuration = frameDuration;
          this.readyPromise = new Promise(function(resolve) {
            _this.resolveReady = resolve;
          });
          if (this.isReady()) {
            this.render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY);
          }
          if (!enableRedraw) {
            return;
          }
          var now = Date.now();
          var then = now;
          var delta = 0;
          var tick = function tick2() {
            now = Date.now();
            delta = now - then;
            if (delta >= frameDuration) {
              then = now - delta % frameDuration;
              if (_this.shouldUpdate(ignoreAnimation, forceRedraw)) {
                _this.render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY);
                mouse.runEvents();
              }
            }
            _this.intervalId = requestAnimationFrame__default["default"](tick2);
          };
          if (!ignoreMouse) {
            mouse.start();
          }
          this.intervalId = requestAnimationFrame__default["default"](tick);
        }
      }, {
        key: "stop",
        value: function stop() {
          if (this.intervalId) {
            requestAnimationFrame__default["default"].cancel(this.intervalId);
            this.intervalId = null;
          }
          this.mouse.stop();
        }
      }, {
        key: "shouldUpdate",
        value: function shouldUpdate(ignoreAnimation, forceRedraw) {
          if (!ignoreAnimation) {
            var frameDuration = this.frameDuration;
            var shouldUpdate2 = this.animations.reduce(function(shouldUpdate3, animation) {
              return animation.update(frameDuration) || shouldUpdate3;
            }, false);
            if (shouldUpdate2) {
              return true;
            }
          }
          if (typeof forceRedraw === "function" && forceRedraw()) {
            return true;
          }
          if (!this.isReadyLock && this.isReady()) {
            return true;
          }
          if (this.mouse.hasEvents()) {
            return true;
          }
          return false;
        }
      }, {
        key: "render",
        value: function render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY) {
          var CLIENT_WIDTH = this.CLIENT_WIDTH, CLIENT_HEIGHT = this.CLIENT_HEIGHT, viewPort = this.viewPort, ctx = this.ctx, isFirstRender = this.isFirstRender;
          var canvas = ctx.canvas;
          viewPort.clear();
          if (canvas.width && canvas.height) {
            viewPort.setCurrent(canvas.width, canvas.height);
          } else {
            viewPort.setCurrent(CLIENT_WIDTH, CLIENT_HEIGHT);
          }
          var widthStyle = element.getStyle("width");
          var heightStyle = element.getStyle("height");
          if (!ignoreDimensions && (isFirstRender || typeof scaleWidth !== "number" && typeof scaleHeight !== "number")) {
            if (widthStyle.hasValue()) {
              canvas.width = widthStyle.getPixels("x");
              if (canvas.style) {
                canvas.style.width = "".concat(canvas.width, "px");
              }
            }
            if (heightStyle.hasValue()) {
              canvas.height = heightStyle.getPixels("y");
              if (canvas.style) {
                canvas.style.height = "".concat(canvas.height, "px");
              }
            }
          }
          var cWidth = canvas.clientWidth || canvas.width;
          var cHeight = canvas.clientHeight || canvas.height;
          if (ignoreDimensions && widthStyle.hasValue() && heightStyle.hasValue()) {
            cWidth = widthStyle.getPixels("x");
            cHeight = heightStyle.getPixels("y");
          }
          viewPort.setCurrent(cWidth, cHeight);
          if (typeof offsetX === "number") {
            element.getAttribute("x", true).setValue(offsetX);
          }
          if (typeof offsetY === "number") {
            element.getAttribute("y", true).setValue(offsetY);
          }
          if (typeof scaleWidth === "number" || typeof scaleHeight === "number") {
            var viewBox = toNumbers(element.getAttribute("viewBox").getString());
            var xRatio = 0;
            var yRatio = 0;
            if (typeof scaleWidth === "number") {
              var _widthStyle = element.getStyle("width");
              if (_widthStyle.hasValue()) {
                xRatio = _widthStyle.getPixels("x") / scaleWidth;
              } else if (!isNaN(viewBox[2])) {
                xRatio = viewBox[2] / scaleWidth;
              }
            }
            if (typeof scaleHeight === "number") {
              var _heightStyle = element.getStyle("height");
              if (_heightStyle.hasValue()) {
                yRatio = _heightStyle.getPixels("y") / scaleHeight;
              } else if (!isNaN(viewBox[3])) {
                yRatio = viewBox[3] / scaleHeight;
              }
            }
            if (!xRatio) {
              xRatio = yRatio;
            }
            if (!yRatio) {
              yRatio = xRatio;
            }
            element.getAttribute("width", true).setValue(scaleWidth);
            element.getAttribute("height", true).setValue(scaleHeight);
            var transformStyle = element.getStyle("transform", true, true);
            transformStyle.setValue("".concat(transformStyle.getString(), " scale(").concat(1 / xRatio, ", ").concat(1 / yRatio, ")"));
          }
          if (!ignoreClear) {
            ctx.clearRect(0, 0, cWidth, cHeight);
          }
          element.render(ctx);
          if (isFirstRender) {
            this.isFirstRender = false;
          }
        }
      }]);
      return Screen2;
    })();
    Screen.defaultWindow = defaultWindow;
    Screen.defaultFetch = defaultFetch$1;
    var defaultFetch = Screen.defaultFetch;
    var DefaultDOMParser = typeof DOMParser !== "undefined" ? DOMParser : null;
    var Parser2 = /* @__PURE__ */ (function() {
      function Parser3() {
        var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$fetch = _ref.fetch, fetch2 = _ref$fetch === void 0 ? defaultFetch : _ref$fetch, _ref$DOMParser = _ref.DOMParser, DOMParser2 = _ref$DOMParser === void 0 ? DefaultDOMParser : _ref$DOMParser;
        _classCallCheck__default["default"](this, Parser3);
        this.fetch = fetch2;
        this.DOMParser = DOMParser2;
      }
      _createClass__default["default"](Parser3, [{
        key: "parse",
        value: (function() {
          var _parse = _asyncToGenerator__default["default"](/* @__PURE__ */ _regeneratorRuntime__default["default"].mark(function _callee(resource) {
            return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (!resource.startsWith("<")) {
                      _context.next = 2;
                      break;
                    }
                    return _context.abrupt("return", this.parseFromString(resource));
                  case 2:
                    return _context.abrupt("return", this.load(resource));
                  case 3:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function parse2(_x) {
            return _parse.apply(this, arguments);
          }
          return parse2;
        })()
      }, {
        key: "parseFromString",
        value: function parseFromString(xml) {
          var parser = new this.DOMParser();
          try {
            return this.checkDocument(parser.parseFromString(xml, "image/svg+xml"));
          } catch (err2) {
            return this.checkDocument(parser.parseFromString(xml, "text/xml"));
          }
        }
      }, {
        key: "checkDocument",
        value: function checkDocument(document2) {
          var parserError = document2.getElementsByTagName("parsererror")[0];
          if (parserError) {
            throw new Error(parserError.textContent);
          }
          return document2;
        }
      }, {
        key: "load",
        value: (function() {
          var _load = _asyncToGenerator__default["default"](/* @__PURE__ */ _regeneratorRuntime__default["default"].mark(function _callee2(url) {
            var response, xml;
            return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    _context2.next = 2;
                    return this.fetch(url);
                  case 2:
                    response = _context2.sent;
                    _context2.next = 5;
                    return response.text();
                  case 5:
                    xml = _context2.sent;
                    return _context2.abrupt("return", this.parseFromString(xml));
                  case 7:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
          function load(_x2) {
            return _load.apply(this, arguments);
          }
          return load;
        })()
      }]);
      return Parser3;
    })();
    var Translate = /* @__PURE__ */ (function() {
      function Translate2(_, point) {
        _classCallCheck__default["default"](this, Translate2);
        this.type = "translate";
        this.point = null;
        this.point = Point.parse(point);
      }
      _createClass__default["default"](Translate2, [{
        key: "apply",
        value: function apply(ctx) {
          var _this$point = this.point, x = _this$point.x, y = _this$point.y;
          ctx.translate(x || 0, y || 0);
        }
      }, {
        key: "unapply",
        value: function unapply(ctx) {
          var _this$point2 = this.point, x = _this$point2.x, y = _this$point2.y;
          ctx.translate(-1 * x || 0, -1 * y || 0);
        }
      }, {
        key: "applyToPoint",
        value: function applyToPoint(point) {
          var _this$point3 = this.point, x = _this$point3.x, y = _this$point3.y;
          point.applyTransform([1, 0, 0, 1, x || 0, y || 0]);
        }
      }]);
      return Translate2;
    })();
    var Rotate = /* @__PURE__ */ (function() {
      function Rotate2(document2, rotate, transformOrigin2) {
        _classCallCheck__default["default"](this, Rotate2);
        this.type = "rotate";
        this.angle = null;
        this.originX = null;
        this.originY = null;
        this.cx = 0;
        this.cy = 0;
        var numbers = toNumbers(rotate);
        this.angle = new Property(document2, "angle", numbers[0]);
        this.originX = transformOrigin2[0];
        this.originY = transformOrigin2[1];
        this.cx = numbers[1] || 0;
        this.cy = numbers[2] || 0;
      }
      _createClass__default["default"](Rotate2, [{
        key: "apply",
        value: function apply(ctx) {
          var cx = this.cx, cy = this.cy, originX = this.originX, originY = this.originY, angle2 = this.angle;
          var tx = cx + originX.getPixels("x");
          var ty = cy + originY.getPixels("y");
          ctx.translate(tx, ty);
          ctx.rotate(angle2.getRadians());
          ctx.translate(-tx, -ty);
        }
      }, {
        key: "unapply",
        value: function unapply(ctx) {
          var cx = this.cx, cy = this.cy, originX = this.originX, originY = this.originY, angle2 = this.angle;
          var tx = cx + originX.getPixels("x");
          var ty = cy + originY.getPixels("y");
          ctx.translate(tx, ty);
          ctx.rotate(-1 * angle2.getRadians());
          ctx.translate(-tx, -ty);
        }
      }, {
        key: "applyToPoint",
        value: function applyToPoint(point) {
          var cx = this.cx, cy = this.cy, angle2 = this.angle;
          var rad = angle2.getRadians();
          point.applyTransform([
            1,
            0,
            0,
            1,
            cx || 0,
            cy || 0
            // this.p.y
          ]);
          point.applyTransform([Math.cos(rad), Math.sin(rad), -Math.sin(rad), Math.cos(rad), 0, 0]);
          point.applyTransform([
            1,
            0,
            0,
            1,
            -cx || 0,
            -cy || 0
            // -this.p.y
          ]);
        }
      }]);
      return Rotate2;
    })();
    var Scale = /* @__PURE__ */ (function() {
      function Scale2(_, scale, transformOrigin2) {
        _classCallCheck__default["default"](this, Scale2);
        this.type = "scale";
        this.scale = null;
        this.originX = null;
        this.originY = null;
        var scaleSize = Point.parseScale(scale);
        if (scaleSize.x === 0 || scaleSize.y === 0) {
          scaleSize.x = PSEUDO_ZERO;
          scaleSize.y = PSEUDO_ZERO;
        }
        this.scale = scaleSize;
        this.originX = transformOrigin2[0];
        this.originY = transformOrigin2[1];
      }
      _createClass__default["default"](Scale2, [{
        key: "apply",
        value: function apply(ctx) {
          var _this$scale = this.scale, x = _this$scale.x, y = _this$scale.y, originX = this.originX, originY = this.originY;
          var tx = originX.getPixels("x");
          var ty = originY.getPixels("y");
          ctx.translate(tx, ty);
          ctx.scale(x, y || x);
          ctx.translate(-tx, -ty);
        }
      }, {
        key: "unapply",
        value: function unapply(ctx) {
          var _this$scale2 = this.scale, x = _this$scale2.x, y = _this$scale2.y, originX = this.originX, originY = this.originY;
          var tx = originX.getPixels("x");
          var ty = originY.getPixels("y");
          ctx.translate(tx, ty);
          ctx.scale(1 / x, 1 / y || x);
          ctx.translate(-tx, -ty);
        }
      }, {
        key: "applyToPoint",
        value: function applyToPoint(point) {
          var _this$scale3 = this.scale, x = _this$scale3.x, y = _this$scale3.y;
          point.applyTransform([x || 0, 0, 0, y || 0, 0, 0]);
        }
      }]);
      return Scale2;
    })();
    var Matrix = /* @__PURE__ */ (function() {
      function Matrix2(_, matrix2, transformOrigin2) {
        _classCallCheck__default["default"](this, Matrix2);
        this.type = "matrix";
        this.matrix = [];
        this.originX = null;
        this.originY = null;
        this.matrix = toNumbers(matrix2);
        this.originX = transformOrigin2[0];
        this.originY = transformOrigin2[1];
      }
      _createClass__default["default"](Matrix2, [{
        key: "apply",
        value: function apply(ctx) {
          var originX = this.originX, originY = this.originY, matrix2 = this.matrix;
          var tx = originX.getPixels("x");
          var ty = originY.getPixels("y");
          ctx.translate(tx, ty);
          ctx.transform(matrix2[0], matrix2[1], matrix2[2], matrix2[3], matrix2[4], matrix2[5]);
          ctx.translate(-tx, -ty);
        }
      }, {
        key: "unapply",
        value: function unapply(ctx) {
          var originX = this.originX, originY = this.originY, matrix2 = this.matrix;
          var a2 = matrix2[0];
          var b = matrix2[2];
          var c2 = matrix2[4];
          var d = matrix2[1];
          var e2 = matrix2[3];
          var f2 = matrix2[5];
          var g = 0;
          var h = 0;
          var i = 1;
          var det = 1 / (a2 * (e2 * i - f2 * h) - b * (d * i - f2 * g) + c2 * (d * h - e2 * g));
          var tx = originX.getPixels("x");
          var ty = originY.getPixels("y");
          ctx.translate(tx, ty);
          ctx.transform(det * (e2 * i - f2 * h), det * (f2 * g - d * i), det * (c2 * h - b * i), det * (a2 * i - c2 * g), det * (b * f2 - c2 * e2), det * (c2 * d - a2 * f2));
          ctx.translate(-tx, -ty);
        }
      }, {
        key: "applyToPoint",
        value: function applyToPoint(point) {
          point.applyTransform(this.matrix);
        }
      }]);
      return Matrix2;
    })();
    function _createSuper$M(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$M();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$M() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    var Skew = /* @__PURE__ */ (function(_Matrix) {
      _inherits__default["default"](Skew2, _Matrix);
      var _super = _createSuper$M(Skew2);
      function Skew2(document2, skew, transformOrigin2) {
        var _this;
        _classCallCheck__default["default"](this, Skew2);
        _this = _super.call(this, document2, skew, transformOrigin2);
        _this.type = "skew";
        _this.angle = null;
        _this.angle = new Property(document2, "angle", skew);
        return _this;
      }
      return Skew2;
    })(Matrix);
    function _createSuper$L(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$L();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$L() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    var SkewX = /* @__PURE__ */ (function(_Skew) {
      _inherits__default["default"](SkewX2, _Skew);
      var _super = _createSuper$L(SkewX2);
      function SkewX2(document2, skew, transformOrigin2) {
        var _this;
        _classCallCheck__default["default"](this, SkewX2);
        _this = _super.call(this, document2, skew, transformOrigin2);
        _this.type = "skewX";
        _this.matrix = [1, 0, Math.tan(_this.angle.getRadians()), 1, 0, 0];
        return _this;
      }
      return SkewX2;
    })(Skew);
    function _createSuper$K(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$K();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$K() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    var SkewY = /* @__PURE__ */ (function(_Skew) {
      _inherits__default["default"](SkewY2, _Skew);
      var _super = _createSuper$K(SkewY2);
      function SkewY2(document2, skew, transformOrigin2) {
        var _this;
        _classCallCheck__default["default"](this, SkewY2);
        _this = _super.call(this, document2, skew, transformOrigin2);
        _this.type = "skewY";
        _this.matrix = [1, Math.tan(_this.angle.getRadians()), 0, 1, 0, 0];
        return _this;
      }
      return SkewY2;
    })(Skew);
    function parseTransforms(transform2) {
      return compressSpaces(transform2).trim().replace(/\)([a-zA-Z])/g, ") $1").replace(/\)(\s?,\s?)/g, ") ").split(/\s(?=[a-z])/);
    }
    function parseTransform(transform2) {
      var _transform$split = transform2.split("("), _transform$split2 = _slicedToArray__default["default"](_transform$split, 2), type = _transform$split2[0], value = _transform$split2[1];
      return [type.trim(), value.trim().replace(")", "")];
    }
    var Transform = /* @__PURE__ */ (function() {
      function Transform2(document2, transform2, transformOrigin2) {
        var _this = this;
        _classCallCheck__default["default"](this, Transform2);
        this.document = document2;
        this.transforms = [];
        var data = parseTransforms(transform2);
        data.forEach(function(transform3) {
          if (transform3 === "none") {
            return;
          }
          var _parseTransform = parseTransform(transform3), _parseTransform2 = _slicedToArray__default["default"](_parseTransform, 2), type = _parseTransform2[0], value = _parseTransform2[1];
          var TransformType = Transform2.transformTypes[type];
          if (typeof TransformType !== "undefined") {
            _this.transforms.push(new TransformType(_this.document, value, transformOrigin2));
          }
        });
      }
      _createClass__default["default"](Transform2, [{
        key: "apply",
        value: function apply(ctx) {
          var transforms = this.transforms;
          var len = transforms.length;
          for (var i = 0; i < len; i++) {
            transforms[i].apply(ctx);
          }
        }
      }, {
        key: "unapply",
        value: function unapply(ctx) {
          var transforms = this.transforms;
          var len = transforms.length;
          for (var i = len - 1; i >= 0; i--) {
            transforms[i].unapply(ctx);
          }
        }
        // TODO: applyToPoint unused ... remove?
      }, {
        key: "applyToPoint",
        value: function applyToPoint(point) {
          var transforms = this.transforms;
          var len = transforms.length;
          for (var i = 0; i < len; i++) {
            transforms[i].applyToPoint(point);
          }
        }
      }], [{
        key: "fromElement",
        value: function fromElement(document2, element) {
          var transformStyle = element.getStyle("transform", false, true);
          var _element$getStyle$spl = element.getStyle("transform-origin", false, true).split(), _element$getStyle$spl2 = _slicedToArray__default["default"](_element$getStyle$spl, 2), transformOriginXProperty = _element$getStyle$spl2[0], _element$getStyle$spl3 = _element$getStyle$spl2[1], transformOriginYProperty = _element$getStyle$spl3 === void 0 ? transformOriginXProperty : _element$getStyle$spl3;
          var transformOrigin2 = [transformOriginXProperty, transformOriginYProperty];
          if (transformStyle.hasValue()) {
            return new Transform2(document2, transformStyle.getString(), transformOrigin2);
          }
          return null;
        }
      }]);
      return Transform2;
    })();
    Transform.transformTypes = {
      translate: Translate,
      rotate: Rotate,
      scale: Scale,
      matrix: Matrix,
      skewX: SkewX,
      skewY: SkewY
    };
    var Element = /* @__PURE__ */ (function() {
      function Element2(document2, node2) {
        var _this = this;
        var captureTextNodes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        _classCallCheck__default["default"](this, Element2);
        this.document = document2;
        this.node = node2;
        this.captureTextNodes = captureTextNodes;
        this.attributes = /* @__PURE__ */ Object.create(null);
        this.styles = /* @__PURE__ */ Object.create(null);
        this.stylesSpecificity = /* @__PURE__ */ Object.create(null);
        this.animationFrozen = false;
        this.animationFrozenValue = "";
        this.parent = null;
        this.children = [];
        if (!node2 || node2.nodeType !== 1) {
          return;
        }
        Array.from(node2.attributes).forEach(function(attribute) {
          var nodeName = normalizeAttributeName(attribute.nodeName);
          _this.attributes[nodeName] = new Property(document2, nodeName, attribute.value);
        });
        this.addStylesFromStyleDefinition();
        if (this.getAttribute("style").hasValue()) {
          var styles = this.getAttribute("style").getString().split(";").map(function(_) {
            return _.trim();
          });
          styles.forEach(function(style) {
            if (!style) {
              return;
            }
            var _style$split$map = style.split(":").map(function(_) {
              return _.trim();
            }), _style$split$map2 = _slicedToArray__default["default"](_style$split$map, 2), name = _style$split$map2[0], value = _style$split$map2[1];
            _this.styles[name] = new Property(document2, name, value);
          });
        }
        var definitions = document2.definitions;
        var id = this.getAttribute("id");
        if (id.hasValue()) {
          if (!definitions[id.getString()]) {
            definitions[id.getString()] = this;
          }
        }
        Array.from(node2.childNodes).forEach(function(childNode) {
          if (childNode.nodeType === 1) {
            _this.addChild(childNode);
          } else if (captureTextNodes && (childNode.nodeType === 3 || childNode.nodeType === 4)) {
            var textNode = document2.createTextNode(childNode);
            if (textNode.getText().length > 0) {
              _this.addChild(textNode);
            }
          }
        });
      }
      _createClass__default["default"](Element2, [{
        key: "getAttribute",
        value: function getAttribute(name) {
          var createIfNotExists = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          var attr = this.attributes[name];
          if (!attr && createIfNotExists) {
            var _attr = new Property(this.document, name, "");
            this.attributes[name] = _attr;
            return _attr;
          }
          return attr || Property.empty(this.document);
        }
      }, {
        key: "getHrefAttribute",
        value: function getHrefAttribute() {
          for (var key in this.attributes) {
            if (key === "href" || key.endsWith(":href")) {
              return this.attributes[key];
            }
          }
          return Property.empty(this.document);
        }
      }, {
        key: "getStyle",
        value: function getStyle(name) {
          var createIfNotExists = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          var skipAncestors = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
          var style = this.styles[name];
          if (style) {
            return style;
          }
          var attr = this.getAttribute(name);
          if (attr !== null && attr !== void 0 && attr.hasValue()) {
            this.styles[name] = attr;
            return attr;
          }
          if (!skipAncestors) {
            var parent = this.parent;
            if (parent) {
              var parentStyle = parent.getStyle(name);
              if (parentStyle !== null && parentStyle !== void 0 && parentStyle.hasValue()) {
                return parentStyle;
              }
            }
          }
          if (createIfNotExists) {
            var _style = new Property(this.document, name, "");
            this.styles[name] = _style;
            return _style;
          }
          return style || Property.empty(this.document);
        }
      }, {
        key: "render",
        value: function render(ctx) {
          if (this.getStyle("display").getString() === "none" || this.getStyle("visibility").getString() === "hidden") {
            return;
          }
          ctx.save();
          if (this.getStyle("mask").hasValue()) {
            var mask = this.getStyle("mask").getDefinition();
            if (mask) {
              this.applyEffects(ctx);
              mask.apply(ctx, this);
            }
          } else if (this.getStyle("filter").getValue("none") !== "none") {
            var filter = this.getStyle("filter").getDefinition();
            if (filter) {
              this.applyEffects(ctx);
              filter.apply(ctx, this);
            }
          } else {
            this.setContext(ctx);
            this.renderChildren(ctx);
            this.clearContext(ctx);
          }
          ctx.restore();
        }
      }, {
        key: "setContext",
        value: function setContext(_) {
        }
      }, {
        key: "applyEffects",
        value: function applyEffects(ctx) {
          var transform2 = Transform.fromElement(this.document, this);
          if (transform2) {
            transform2.apply(ctx);
          }
          var clipPathStyleProp = this.getStyle("clip-path", false, true);
          if (clipPathStyleProp.hasValue()) {
            var clip = clipPathStyleProp.getDefinition();
            if (clip) {
              clip.apply(ctx);
            }
          }
        }
      }, {
        key: "clearContext",
        value: function clearContext(_) {
        }
      }, {
        key: "renderChildren",
        value: function renderChildren(ctx) {
          this.children.forEach(function(child) {
            child.render(ctx);
          });
        }
      }, {
        key: "addChild",
        value: function addChild(childNode) {
          var child = childNode instanceof Element2 ? childNode : this.document.createElement(childNode);
          child.parent = this;
          if (!Element2.ignoreChildTypes.includes(child.type)) {
            this.children.push(child);
          }
        }
      }, {
        key: "matchesSelector",
        value: function matchesSelector(selector) {
          var _node$getAttribute;
          var node2 = this.node;
          if (typeof node2.matches === "function") {
            return node2.matches(selector);
          }
          var styleClasses = (_node$getAttribute = node2.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node2, "class");
          if (!styleClasses || styleClasses === "") {
            return false;
          }
          return styleClasses.split(" ").some(function(styleClass) {
            return ".".concat(styleClass) === selector;
          });
        }
      }, {
        key: "addStylesFromStyleDefinition",
        value: function addStylesFromStyleDefinition() {
          var _this$document = this.document, styles = _this$document.styles, stylesSpecificity = _this$document.stylesSpecificity;
          for (var selector in styles) {
            if (!selector.startsWith("@") && this.matchesSelector(selector)) {
              var style = styles[selector];
              var specificity = stylesSpecificity[selector];
              if (style) {
                for (var name in style) {
                  var existingSpecificity = this.stylesSpecificity[name];
                  if (typeof existingSpecificity === "undefined") {
                    existingSpecificity = "000";
                  }
                  if (specificity >= existingSpecificity) {
                    this.styles[name] = style[name];
                    this.stylesSpecificity[name] = specificity;
                  }
                }
              }
            }
          }
        }
      }, {
        key: "removeStyles",
        value: function removeStyles(element, ignoreStyles) {
          var toRestore = ignoreStyles.reduce(function(toRestore2, name) {
            var styleProp = element.getStyle(name);
            if (!styleProp.hasValue()) {
              return toRestore2;
            }
            var value = styleProp.getString();
            styleProp.setValue("");
            return [].concat(_toConsumableArray__default["default"](toRestore2), [[name, value]]);
          }, []);
          return toRestore;
        }
      }, {
        key: "restoreStyles",
        value: function restoreStyles(element, styles) {
          styles.forEach(function(_ref) {
            var _ref2 = _slicedToArray__default["default"](_ref, 2), name = _ref2[0], value = _ref2[1];
            element.getStyle(name, true).setValue(value);
          });
        }
      }, {
        key: "isFirstChild",
        value: function isFirstChild() {
          var _this$parent;
          return ((_this$parent = this.parent) === null || _this$parent === void 0 ? void 0 : _this$parent.children.indexOf(this)) === 0;
        }
      }]);
      return Element2;
    })();
    Element.ignoreChildTypes = ["title"];
    function _createSuper$J(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$J();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$J() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    var UnknownElement = /* @__PURE__ */ (function(_Element) {
      _inherits__default["default"](UnknownElement2, _Element);
      var _super = _createSuper$J(UnknownElement2);
      function UnknownElement2(document2, node2, captureTextNodes) {
        var _this;
        _classCallCheck__default["default"](this, UnknownElement2);
        _this = _super.call(this, document2, node2, captureTextNodes);
        return _this;
      }
      return UnknownElement2;
    })(Element);
    function wrapFontFamily(fontFamily2) {
      var trimmed = fontFamily2.trim();
      return /^('|")/.test(trimmed) ? trimmed : '"'.concat(trimmed, '"');
    }
    function prepareFontFamily(fontFamily2) {
      return typeof process === "undefined" ? fontFamily2 : fontFamily2.trim().split(",").map(wrapFontFamily).join(",");
    }
    function prepareFontStyle(fontStyle2) {
      if (!fontStyle2) {
        return "";
      }
      var targetFontStyle = fontStyle2.trim().toLowerCase();
      switch (targetFontStyle) {
        case "normal":
        case "italic":
        case "oblique":
        case "inherit":
        case "initial":
        case "unset":
          return targetFontStyle;
        default:
          if (/^oblique\s+(-|)\d+deg$/.test(targetFontStyle)) {
            return targetFontStyle;
          }
          return "";
      }
    }
    function prepareFontWeight(fontWeight2) {
      if (!fontWeight2) {
        return "";
      }
      var targetFontWeight = fontWeight2.trim().toLowerCase();
      switch (targetFontWeight) {
        case "normal":
        case "bold":
        case "lighter":
        case "bolder":
        case "inherit":
        case "initial":
        case "unset":
          return targetFontWeight;
        default:
          if (/^[\d.]+$/.test(targetFontWeight)) {
            return targetFontWeight;
          }
          return "";
      }
    }
    var Font = /* @__PURE__ */ (function() {
      function Font2(fontStyle2, fontVariant2, fontWeight2, fontSize2, fontFamily2, inherit) {
        _classCallCheck__default["default"](this, Font2);
        var inheritFont = inherit ? typeof inherit === "string" ? Font2.parse(inherit) : inherit : {};
        this.fontFamily = fontFamily2 || inheritFont.fontFamily;
        this.fontSize = fontSize2 || inheritFont.fontSize;
        this.fontStyle = fontStyle2 || inheritFont.fontStyle;
        this.fontWeight = fontWeight2 || inheritFont.fontWeight;
        this.fontVariant = fontVariant2 || inheritFont.fontVariant;
      }
      _createClass__default["default"](Font2, [{
        key: "toString",
        value: function toString3() {
          return [
            prepareFontStyle(this.fontStyle),
            this.fontVariant,
            prepareFontWeight(this.fontWeight),
            this.fontSize,
            // Wrap fontFamily only on nodejs and only for canvas.ctx
            prepareFontFamily(this.fontFamily)
          ].join(" ").trim();
        }
      }], [{
        key: "parse",
        value: function parse2() {
          var font = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          var inherit = arguments.length > 1 ? arguments[1] : void 0;
          var fontStyle2 = "";
          var fontVariant2 = "";
          var fontWeight2 = "";
          var fontSize2 = "";
          var fontFamily2 = "";
          var parts = compressSpaces(font).trim().split(" ");
          var set = {
            fontSize: false,
            fontStyle: false,
            fontWeight: false,
            fontVariant: false
          };
          parts.forEach(function(part) {
            switch (true) {
              case (!set.fontStyle && Font2.styles.includes(part)):
                if (part !== "inherit") {
                  fontStyle2 = part;
                }
                set.fontStyle = true;
                break;
              case (!set.fontVariant && Font2.variants.includes(part)):
                if (part !== "inherit") {
                  fontVariant2 = part;
                }
                set.fontStyle = true;
                set.fontVariant = true;
                break;
              case (!set.fontWeight && Font2.weights.includes(part)):
                if (part !== "inherit") {
                  fontWeight2 = part;
                }
                set.fontStyle = true;
                set.fontVariant = true;
                set.fontWeight = true;
                break;
              case !set.fontSize:
                if (part !== "inherit") {
                  var _part$split = part.split("/");
                  var _part$split2 = _slicedToArray__default["default"](_part$split, 1);
                  fontSize2 = _part$split2[0];
                }
                set.fontStyle = true;
                set.fontVariant = true;
                set.fontWeight = true;
                set.fontSize = true;
                break;
              default:
                if (part !== "inherit") {
                  fontFamily2 += part;
                }
            }
          });
          return new Font2(fontStyle2, fontVariant2, fontWeight2, fontSize2, fontFamily2, inherit);
        }
      }]);
      return Font2;
    })();
    Font.styles = "normal|italic|oblique|inherit";
    Font.variants = "normal|small-caps|inherit";
    Font.weights = "normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit";
    var BoundingBox = /* @__PURE__ */ (function() {
      function BoundingBox2() {
        var x1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Number.NaN;
        var y1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Number.NaN;
        var x2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Number.NaN;
        var y2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Number.NaN;
        _classCallCheck__default["default"](this, BoundingBox2);
        this.x1 = x1;
        this.y1 = y1;
        this.x2 = x2;
        this.y2 = y2;
        this.addPoint(x1, y1);
        this.addPoint(x2, y2);
      }
      _createClass__default["default"](BoundingBox2, [{
        key: "addPoint",
        value: function addPoint(x, y) {
          if (typeof x !== "undefined") {
            if (isNaN(this.x1) || isNaN(this.x2)) {
              this.x1 = x;
              this.x2 = x;
            }
            if (x < this.x1) {
              this.x1 = x;
            }
            if (x > this.x2) {
              this.x2 = x;
            }
          }
          if (typeof y !== "undefined") {
            if (isNaN(this.y1) || isNaN(this.y2)) {
              this.y1 = y;
              this.y2 = y;
            }
            if (y < this.y1) {
              this.y1 = y;
            }
            if (y > this.y2) {
              this.y2 = y;
            }
          }
        }
      }, {
        key: "addX",
        value: function addX(x) {
          this.addPoint(x, null);
        }
      }, {
        key: "addY",
        value: function addY(y) {
          this.addPoint(null, y);
        }
      }, {
        key: "addBoundingBox",
        value: function addBoundingBox(boundingBox) {
          if (!boundingBox) {
            return;
          }
          var x1 = boundingBox.x1, y1 = boundingBox.y1, x2 = boundingBox.x2, y2 = boundingBox.y2;
          this.addPoint(x1, y1);
          this.addPoint(x2, y2);
        }
      }, {
        key: "sumCubic",
        value: function sumCubic(t, p0, p1, p2, p3) {
          return Math.pow(1 - t, 3) * p0 + 3 * Math.pow(1 - t, 2) * t * p1 + 3 * (1 - t) * Math.pow(t, 2) * p2 + Math.pow(t, 3) * p3;
        }
      }, {
        key: "bezierCurveAdd",
        value: function bezierCurveAdd(forX, p0, p1, p2, p3) {
          var b = 6 * p0 - 12 * p1 + 6 * p2;
          var a2 = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;
          var c2 = 3 * p1 - 3 * p0;
          if (a2 === 0) {
            if (b === 0) {
              return;
            }
            var t = -c2 / b;
            if (0 < t && t < 1) {
              if (forX) {
                this.addX(this.sumCubic(t, p0, p1, p2, p3));
              } else {
                this.addY(this.sumCubic(t, p0, p1, p2, p3));
              }
            }
            return;
          }
          var b2ac = Math.pow(b, 2) - 4 * c2 * a2;
          if (b2ac < 0) {
            return;
          }
          var t1 = (-b + Math.sqrt(b2ac)) / (2 * a2);
          if (0 < t1 && t1 < 1) {
            if (forX) {
              this.addX(this.sumCubic(t1, p0, p1, p2, p3));
            } else {
              this.addY(this.sumCubic(t1, p0, p1, p2, p3));
            }
          }
          var t2 = (-b - Math.sqrt(b2ac)) / (2 * a2);
          if (0 < t2 && t2 < 1) {
            if (forX) {
              this.addX(this.sumCubic(t2, p0, p1, p2, p3));
            } else {
              this.addY(this.sumCubic(t2, p0, p1, p2, p3));
            }
          }
        }
        // from http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html
      }, {
        key: "addBezierCurve",
        value: function addBezierCurve(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) {
          this.addPoint(p0x, p0y);
          this.addPoint(p3x, p3y);
          this.bezierCurveAdd(true, p0x, p1x, p2x, p3x);
          this.bezierCurveAdd(false, p0y, p1y, p2y, p3y);
        }
      }, {
        key: "addQuadraticCurve",
        value: function addQuadraticCurve(p0x, p0y, p1x, p1y, p2x, p2y) {
          var cp1x = p0x + 2 / 3 * (p1x - p0x);
          var cp1y = p0y + 2 / 3 * (p1y - p0y);
          var cp2x = cp1x + 1 / 3 * (p2x - p0x);
          var cp2y = cp1y + 1 / 3 * (p2y - p0y);
          this.addBezierCurve(p0x, p0y, cp1x, cp2x, cp1y, cp2y, p2x, p2y);
        }
      }, {
        key: "isPointInBox",
        value: function isPointInBox(x, y) {
          var x1 = this.x1, y1 = this.y1, x2 = this.x2, y2 = this.y2;
          return x1 <= x && x <= x2 && y1 <= y && y <= y2;
        }
      }, {
        key: "x",
        get: function get() {
          return this.x1;
        }
      }, {
        key: "y",
        get: function get() {
          return this.y1;
        }
      }, {
        key: "width",
        get: function get() {
          return this.x2 - this.x1;
        }
      }, {
        key: "height",
        get: function get() {
          return this.y2 - this.y1;
        }
      }]);
      return BoundingBox2;
    })();
    function _createSuper$I(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$I();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$I() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    var PathParser = /* @__PURE__ */ (function(_SVGPathData) {
      _inherits__default["default"](PathParser2, _SVGPathData);
      var _super = _createSuper$I(PathParser2);
      function PathParser2(path) {
        var _this;
        _classCallCheck__default["default"](this, PathParser2);
        _this = _super.call(this, path.replace(/([+\-.])\s+/gm, "$1").replace(/[^MmZzLlHhVvCcSsQqTtAae\d\s.,+-].*/g, ""));
        _this.control = null;
        _this.start = null;
        _this.current = null;
        _this.command = null;
        _this.commands = _this.commands;
        _this.i = -1;
        _this.previousCommand = null;
        _this.points = [];
        _this.angles = [];
        return _this;
      }
      _createClass__default["default"](PathParser2, [{
        key: "reset",
        value: function reset() {
          this.i = -1;
          this.command = null;
          this.previousCommand = null;
          this.start = new Point(0, 0);
          this.control = new Point(0, 0);
          this.current = new Point(0, 0);
          this.points = [];
          this.angles = [];
        }
      }, {
        key: "isEnd",
        value: function isEnd() {
          var i = this.i, commands = this.commands;
          return i >= commands.length - 1;
        }
      }, {
        key: "next",
        value: function next() {
          var command = this.commands[++this.i];
          this.previousCommand = this.command;
          this.command = command;
          return command;
        }
      }, {
        key: "getPoint",
        value: function getPoint() {
          var xProp = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "x";
          var yProp = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "y";
          var point = new Point(this.command[xProp], this.command[yProp]);
          return this.makeAbsolute(point);
        }
      }, {
        key: "getAsControlPoint",
        value: function getAsControlPoint(xProp, yProp) {
          var point = this.getPoint(xProp, yProp);
          this.control = point;
          return point;
        }
      }, {
        key: "getAsCurrentPoint",
        value: function getAsCurrentPoint(xProp, yProp) {
          var point = this.getPoint(xProp, yProp);
          this.current = point;
          return point;
        }
      }, {
        key: "getReflectedControlPoint",
        value: function getReflectedControlPoint() {
          var previousCommand = this.previousCommand.type;
          if (previousCommand !== svgPathdata.SVGPathData.CURVE_TO && previousCommand !== svgPathdata.SVGPathData.SMOOTH_CURVE_TO && previousCommand !== svgPathdata.SVGPathData.QUAD_TO && previousCommand !== svgPathdata.SVGPathData.SMOOTH_QUAD_TO) {
            return this.current;
          }
          var _this$current = this.current, cx = _this$current.x, cy = _this$current.y, _this$control = this.control, ox = _this$control.x, oy = _this$control.y;
          var point = new Point(2 * cx - ox, 2 * cy - oy);
          return point;
        }
      }, {
        key: "makeAbsolute",
        value: function makeAbsolute(point) {
          if (this.command.relative) {
            var _this$current2 = this.current, x = _this$current2.x, y = _this$current2.y;
            point.x += x;
            point.y += y;
          }
          return point;
        }
      }, {
        key: "addMarker",
        value: function addMarker(point, from, priorTo) {
          var points = this.points, angles = this.angles;
          if (priorTo && angles.length > 0 && !angles[angles.length - 1]) {
            angles[angles.length - 1] = points[points.length - 1].angleTo(priorTo);
          }
          this.addMarkerAngle(point, from ? from.angleTo(point) : null);
        }
      }, {
        key: "addMarkerAngle",
        value: function addMarkerAngle(point, angle2) {
          this.points.push(point);
          this.angles.push(angle2);
        }
      }, {
        key: "getMarkerPoints",
        value: function getMarkerPoints() {
          return this.points;
        }
      }, {
        key: "getMarkerAngles",
        value: function getMarkerAngles() {
          var angles = this.angles;
          var len = angles.length;
          for (var i = 0; i < len; i++) {
            if (!angles[i]) {
              for (var j = i + 1; j < len; j++) {
                if (angles[j]) {
                  angles[i] = angles[j];
                  break;
                }
              }
            }
          }
          return angles;
        }
      }]);
      return PathParser2;
    })(svgPathdata.SVGPathData);
    function _createSuper$H(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$H();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$H() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    var RenderedElement = /* @__PURE__ */ (function(_Element) {
      _inherits__default["default"](RenderedElement2, _Element);
      var _super = _createSuper$H(RenderedElement2);
      function RenderedElement2() {
        var _this;
        _classCallCheck__default["default"](this, RenderedElement2);
        _this = _super.apply(this, arguments);
        _this.modifiedEmSizeStack = false;
        return _this;
      }
      _createClass__default["default"](RenderedElement2, [{
        key: "calculateOpacity",
        value: function calculateOpacity() {
          var opacity2 = 1;
          var element = this;
          while (element) {
            var opacityStyle = element.getStyle("opacity", false, true);
            if (opacityStyle.hasValue(true)) {
              opacity2 *= opacityStyle.getNumber();
            }
            element = element.parent;
          }
          return opacity2;
        }
      }, {
        key: "setContext",
        value: function setContext(ctx) {
          var fromMeasure = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          if (!fromMeasure) {
            var fillStyleProp = this.getStyle("fill");
            var fillOpacityStyleProp = this.getStyle("fill-opacity");
            var strokeStyleProp = this.getStyle("stroke");
            var strokeOpacityProp = this.getStyle("stroke-opacity");
            if (fillStyleProp.isUrlDefinition()) {
              var fillStyle = fillStyleProp.getFillStyleDefinition(this, fillOpacityStyleProp);
              if (fillStyle) {
                ctx.fillStyle = fillStyle;
              }
            } else if (fillStyleProp.hasValue()) {
              if (fillStyleProp.getString() === "currentColor") {
                fillStyleProp.setValue(this.getStyle("color").getColor());
              }
              var _fillStyle = fillStyleProp.getColor();
              if (_fillStyle !== "inherit") {
                ctx.fillStyle = _fillStyle === "none" ? "rgba(0,0,0,0)" : _fillStyle;
              }
            }
            if (fillOpacityStyleProp.hasValue()) {
              var _fillStyle2 = new Property(this.document, "fill", ctx.fillStyle).addOpacity(fillOpacityStyleProp).getColor();
              ctx.fillStyle = _fillStyle2;
            }
            if (strokeStyleProp.isUrlDefinition()) {
              var strokeStyle = strokeStyleProp.getFillStyleDefinition(this, strokeOpacityProp);
              if (strokeStyle) {
                ctx.strokeStyle = strokeStyle;
              }
            } else if (strokeStyleProp.hasValue()) {
              if (strokeStyleProp.getString() === "currentColor") {
                strokeStyleProp.setValue(this.getStyle("color").getColor());
              }
              var _strokeStyle = strokeStyleProp.getString();
              if (_strokeStyle !== "inherit") {
                ctx.strokeStyle = _strokeStyle === "none" ? "rgba(0,0,0,0)" : _strokeStyle;
              }
            }
            if (strokeOpacityProp.hasValue()) {
              var _strokeStyle2 = new Property(this.document, "stroke", ctx.strokeStyle).addOpacity(strokeOpacityProp).getString();
              ctx.strokeStyle = _strokeStyle2;
            }
            var strokeWidthStyleProp = this.getStyle("stroke-width");
            if (strokeWidthStyleProp.hasValue()) {
              var newLineWidth = strokeWidthStyleProp.getPixels();
              ctx.lineWidth = !newLineWidth ? PSEUDO_ZERO : newLineWidth;
            }
            var strokeLinecapStyleProp = this.getStyle("stroke-linecap");
            var strokeLinejoinStyleProp = this.getStyle("stroke-linejoin");
            var strokeMiterlimitProp = this.getStyle("stroke-miterlimit");
            var strokeDasharrayStyleProp = this.getStyle("stroke-dasharray");
            var strokeDashoffsetProp = this.getStyle("stroke-dashoffset");
            if (strokeLinecapStyleProp.hasValue()) {
              ctx.lineCap = strokeLinecapStyleProp.getString();
            }
            if (strokeLinejoinStyleProp.hasValue()) {
              ctx.lineJoin = strokeLinejoinStyleProp.getString();
            }
            if (strokeMiterlimitProp.hasValue()) {
              ctx.miterLimit = strokeMiterlimitProp.getNumber();
            }
            if (strokeDasharrayStyleProp.hasValue() && strokeDasharrayStyleProp.getString() !== "none") {
              var gaps = toNumbers(strokeDasharrayStyleProp.getString());
              if (typeof ctx.setLineDash !== "undefined") {
                ctx.setLineDash(gaps);
              } else if (typeof ctx.webkitLineDash !== "undefined") {
                ctx.webkitLineDash = gaps;
              } else if (typeof ctx.mozDash !== "undefined" && !(gaps.length === 1 && gaps[0] === 0)) {
                ctx.mozDash = gaps;
              }
              var offset = strokeDashoffsetProp.getPixels();
              if (typeof ctx.lineDashOffset !== "undefined") {
                ctx.lineDashOffset = offset;
              } else if (typeof ctx.webkitLineDashOffset !== "undefined") {
                ctx.webkitLineDashOffset = offset;
              } else if (typeof ctx.mozDashOffset !== "undefined") {
                ctx.mozDashOffset = offset;
              }
            }
          }
          this.modifiedEmSizeStack = false;
          if (typeof ctx.font !== "undefined") {
            var fontStyleProp = this.getStyle("font");
            var fontStyleStyleProp = this.getStyle("font-style");
            var fontVariantStyleProp = this.getStyle("font-variant");
            var fontWeightStyleProp = this.getStyle("font-weight");
            var fontSizeStyleProp = this.getStyle("font-size");
            var fontFamilyStyleProp = this.getStyle("font-family");
            var font = new Font(fontStyleStyleProp.getString(), fontVariantStyleProp.getString(), fontWeightStyleProp.getString(), fontSizeStyleProp.hasValue() ? "".concat(fontSizeStyleProp.getPixels(true), "px") : "", fontFamilyStyleProp.getString(), Font.parse(fontStyleProp.getString(), ctx.font));
            fontStyleStyleProp.setValue(font.fontStyle);
            fontVariantStyleProp.setValue(font.fontVariant);
            fontWeightStyleProp.setValue(font.fontWeight);
            fontSizeStyleProp.setValue(font.fontSize);
            fontFamilyStyleProp.setValue(font.fontFamily);
            ctx.font = font.toString();
            if (fontSizeStyleProp.isPixels()) {
              this.document.emSize = fontSizeStyleProp.getPixels();
              this.modifiedEmSizeStack = true;
            }
          }
          if (!fromMeasure) {
            this.applyEffects(ctx);
            ctx.globalAlpha = this.calculateOpacity();
          }
        }
      }, {
        key: "clearContext",
        value: function clearContext(ctx) {
          _get__default["default"](_getPrototypeOf__default["default"](RenderedElement2.prototype), "clearContext", this).call(this, ctx);
          if (this.modifiedEmSizeStack) {
            this.document.popEmSize();
          }
        }
      }]);
      return RenderedElement2;
    })(Element);
    function _createSuper$G(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$G();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$G() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    var PathElement = /* @__PURE__ */ (function(_RenderedElement) {
      _inherits__default["default"](PathElement2, _RenderedElement);
      var _super = _createSuper$G(PathElement2);
      function PathElement2(document2, node2, captureTextNodes) {
        var _this;
        _classCallCheck__default["default"](this, PathElement2);
        _this = _super.call(this, document2, node2, captureTextNodes);
        _this.type = "path";
        _this.pathParser = null;
        _this.pathParser = new PathParser(_this.getAttribute("d").getString());
        return _this;
      }
      _createClass__default["default"](PathElement2, [{
        key: "path",
        value: function path(ctx) {
          var pathParser = this.pathParser;
          var boundingBox = new BoundingBox();
          pathParser.reset();
          if (ctx) {
            ctx.beginPath();
          }
          while (!pathParser.isEnd()) {
            switch (pathParser.next().type) {
              case PathParser.MOVE_TO:
                this.pathM(ctx, boundingBox);
                break;
              case PathParser.LINE_TO:
                this.pathL(ctx, boundingBox);
                break;
              case PathParser.HORIZ_LINE_TO:
                this.pathH(ctx, boundingBox);
                break;
              case PathParser.VERT_LINE_TO:
                this.pathV(ctx, boundingBox);
                break;
              case PathParser.CURVE_TO:
                this.pathC(ctx, boundingBox);
                break;
              case PathParser.SMOOTH_CURVE_TO:
                this.pathS(ctx, boundingBox);
                break;
              case PathParser.QUAD_TO:
                this.pathQ(ctx, boundingBox);
                break;
              case PathParser.SMOOTH_QUAD_TO:
                this.pathT(ctx, boundingBox);
                break;
              case PathParser.ARC:
                this.pathA(ctx, boundingBox);
                break;
              case PathParser.CLOSE_PATH:
                this.pathZ(ctx, boundingBox);
                break;
            }
          }
          return boundingBox;
        }
      }, {
        key: "getBoundingBox",
        value: function getBoundingBox(_) {
          return this.path();
        }
      }, {
        key: "getMarkers",
        value: function getMarkers() {
          var pathParser = this.pathParser;
          var points = pathParser.getMarkerPoints();
          var angles = pathParser.getMarkerAngles();
          var markers = points.map(function(point, i) {
            return [point, angles[i]];
          });
          return markers;
        }
      }, {
        key: "renderChildren",
        value: function renderChildren(ctx) {
          this.path(ctx);
          this.document.screen.mouse.checkPath(this, ctx);
          var fillRuleStyleProp = this.getStyle("fill-rule");
          if (ctx.fillStyle !== "") {
            if (fillRuleStyleProp.getString("inherit") !== "inherit") {
              ctx.fill(fillRuleStyleProp.getString());
            } else {
              ctx.fill();
            }
          }
          if (ctx.strokeStyle !== "") {
            if (this.getAttribute("vector-effect").getString() === "non-scaling-stroke") {
              ctx.save();
              ctx.setTransform(1, 0, 0, 1, 0, 0);
              ctx.stroke();
              ctx.restore();
            } else {
              ctx.stroke();
            }
          }
          var markers = this.getMarkers();
          if (markers) {
            var markersLastIndex = markers.length - 1;
            var markerStartStyleProp = this.getStyle("marker-start");
            var markerMidStyleProp = this.getStyle("marker-mid");
            var markerEndStyleProp = this.getStyle("marker-end");
            if (markerStartStyleProp.isUrlDefinition()) {
              var marker = markerStartStyleProp.getDefinition();
              var _markers$ = _slicedToArray__default["default"](markers[0], 2), point = _markers$[0], angle2 = _markers$[1];
              marker.render(ctx, point, angle2);
            }
            if (markerMidStyleProp.isUrlDefinition()) {
              var _marker = markerMidStyleProp.getDefinition();
              for (var i = 1; i < markersLastIndex; i++) {
                var _markers$i = _slicedToArray__default["default"](markers[i], 2), _point = _markers$i[0], _angle = _markers$i[1];
                _marker.render(ctx, _point, _angle);
              }
            }
            if (markerEndStyleProp.isUrlDefinition()) {
              var _marker2 = markerEndStyleProp.getDefinition();
              var _markers$markersLastI = _slicedToArray__default["default"](markers[markersLastIndex], 2), _point2 = _markers$markersLastI[0], _angle2 = _markers$markersLastI[1];
              _marker2.render(ctx, _point2, _angle2);
            }
          }
        }
      }, {
        key: "pathM",
        value: function pathM(ctx, boundingBox) {
          var pathParser = this.pathParser;
          var _PathElement$pathM = PathElement2.pathM(pathParser), point = _PathElement$pathM.point;
          var x = point.x, y = point.y;
          pathParser.addMarker(point);
          boundingBox.addPoint(x, y);
          if (ctx) {
            ctx.moveTo(x, y);
          }
        }
      }, {
        key: "pathL",
        value: function pathL(ctx, boundingBox) {
          var pathParser = this.pathParser;
          var _PathElement$pathL = PathElement2.pathL(pathParser), current = _PathElement$pathL.current, point = _PathElement$pathL.point;
          var x = point.x, y = point.y;
          pathParser.addMarker(point, current);
          boundingBox.addPoint(x, y);
          if (ctx) {
            ctx.lineTo(x, y);
          }
        }
      }, {
        key: "pathH",
        value: function pathH(ctx, boundingBox) {
          var pathParser = this.pathParser;
          var _PathElement$pathH = PathElement2.pathH(pathParser), current = _PathElement$pathH.current, point = _PathElement$pathH.point;
          var x = point.x, y = point.y;
          pathParser.addMarker(point, current);
          boundingBox.addPoint(x, y);
          if (ctx) {
            ctx.lineTo(x, y);
          }
        }
      }, {
        key: "pathV",
        value: function pathV(ctx, boundingBox) {
          var pathParser = this.pathParser;
          var _PathElement$pathV = PathElement2.pathV(pathParser), current = _PathElement$pathV.current, point = _PathElement$pathV.point;
          var x = point.x, y = point.y;
          pathParser.addMarker(point, current);
          boundingBox.addPoint(x, y);
          if (ctx) {
            ctx.lineTo(x, y);
          }
        }
      }, {
        key: "pathC",
        value: function pathC(ctx, boundingBox) {
          var pathParser = this.pathParser;
          var _PathElement$pathC = PathElement2.pathC(pathParser), current = _PathElement$pathC.current, point = _PathElement$pathC.point, controlPoint = _PathElement$pathC.controlPoint, currentPoint = _PathElement$pathC.currentPoint;
          pathParser.addMarker(currentPoint, controlPoint, point);
          boundingBox.addBezierCurve(current.x, current.y, point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
          if (ctx) {
            ctx.bezierCurveTo(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
          }
        }
      }, {
        key: "pathS",
        value: function pathS(ctx, boundingBox) {
          var pathParser = this.pathParser;
          var _PathElement$pathS = PathElement2.pathS(pathParser), current = _PathElement$pathS.current, point = _PathElement$pathS.point, controlPoint = _PathElement$pathS.controlPoint, currentPoint = _PathElement$pathS.currentPoint;
          pathParser.addMarker(currentPoint, controlPoint, point);
          boundingBox.addBezierCurve(current.x, current.y, point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
          if (ctx) {
            ctx.bezierCurveTo(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
          }
        }
      }, {
        key: "pathQ",
        value: function pathQ(ctx, boundingBox) {
          var pathParser = this.pathParser;
          var _PathElement$pathQ = PathElement2.pathQ(pathParser), current = _PathElement$pathQ.current, controlPoint = _PathElement$pathQ.controlPoint, currentPoint = _PathElement$pathQ.currentPoint;
          pathParser.addMarker(currentPoint, controlPoint, controlPoint);
          boundingBox.addQuadraticCurve(current.x, current.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
          if (ctx) {
            ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
          }
        }
      }, {
        key: "pathT",
        value: function pathT(ctx, boundingBox) {
          var pathParser = this.pathParser;
          var _PathElement$pathT = PathElement2.pathT(pathParser), current = _PathElement$pathT.current, controlPoint = _PathElement$pathT.controlPoint, currentPoint = _PathElement$pathT.currentPoint;
          pathParser.addMarker(currentPoint, controlPoint, controlPoint);
          boundingBox.addQuadraticCurve(current.x, current.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
          if (ctx) {
            ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
          }
        }
      }, {
        key: "pathA",
        value: function pathA(ctx, boundingBox) {
          var pathParser = this.pathParser;
          var _PathElement$pathA = PathElement2.pathA(pathParser), currentPoint = _PathElement$pathA.currentPoint, rX = _PathElement$pathA.rX, rY = _PathElement$pathA.rY, sweepFlag = _PathElement$pathA.sweepFlag, xAxisRotation = _PathElement$pathA.xAxisRotation, centp = _PathElement$pathA.centp, a1 = _PathElement$pathA.a1, ad = _PathElement$pathA.ad;
          var dir = 1 - sweepFlag ? 1 : -1;
          var ah = a1 + dir * (ad / 2);
          var halfWay = new Point(centp.x + rX * Math.cos(ah), centp.y + rY * Math.sin(ah));
          pathParser.addMarkerAngle(halfWay, ah - dir * Math.PI / 2);
          pathParser.addMarkerAngle(currentPoint, ah - dir * Math.PI);
          boundingBox.addPoint(currentPoint.x, currentPoint.y);
          if (ctx && !isNaN(a1) && !isNaN(ad)) {
            var r = rX > rY ? rX : rY;
            var sx = rX > rY ? 1 : rX / rY;
            var sy = rX > rY ? rY / rX : 1;
            ctx.translate(centp.x, centp.y);
            ctx.rotate(xAxisRotation);
            ctx.scale(sx, sy);
            ctx.arc(0, 0, r, a1, a1 + ad, Boolean(1 - sweepFlag));
            ctx.scale(1 / sx, 1 / sy);
            ctx.rotate(-xAxisRotation);
            ctx.translate(-centp.x, -centp.y);
          }
        }
      }, {
        key: "pathZ",
        value: function pathZ(ctx, boundingBox) {
          PathElement2.pathZ(this.pathParser);
          if (ctx) {
            if (boundingBox.x1 !== boundingBox.x2 && boundingBox.y1 !== boundingBox.y2) {
              ctx.closePath();
            }
          }
        }
      }], [{
        key: "pathM",
        value: function pathM(pathParser) {
          var point = pathParser.getAsCurrentPoint();
          pathParser.start = pathParser.current;
          return {
            point
          };
        }
      }, {
        key: "pathL",
        value: function pathL(pathParser) {
          var current = pathParser.current;
          var point = pathParser.getAsCurrentPoint();
          return {
            current,
            point
          };
        }
      }, {
        key: "pathH",
        value: function pathH(pathParser) {
          var current = pathParser.current, command = pathParser.command;
          var point = new Point((command.relative ? current.x : 0) + command.x, current.y);
          pathParser.current = point;
          return {
            current,
            point
          };
        }
      }, {
        key: "pathV",
        value: function pathV(pathParser) {
          var current = pathParser.current, command = pathParser.command;
          var point = new Point(current.x, (command.relative ? current.y : 0) + command.y);
          pathParser.current = point;
          return {
            current,
            point
          };
        }
      }, {
        key: "pathC",
        value: function pathC(pathParser) {
          var current = pathParser.current;
          var point = pathParser.getPoint("x1", "y1");
          var controlPoint = pathParser.getAsControlPoint("x2", "y2");
          var currentPoint = pathParser.getAsCurrentPoint();
          return {
            current,
            point,
            controlPoint,
            currentPoint
          };
        }
      }, {
        key: "pathS",
        value: function pathS(pathParser) {
          var current = pathParser.current;
          var point = pathParser.getReflectedControlPoint();
          var controlPoint = pathParser.getAsControlPoint("x2", "y2");
          var currentPoint = pathParser.getAsCurrentPoint();
          return {
            current,
            point,
            controlPoint,
            currentPoint
          };
        }
      }, {
        key: "pathQ",
        value: function pathQ(pathParser) {
          var current = pathParser.current;
          var controlPoint = pathParser.getAsControlPoint("x1", "y1");
          var currentPoint = pathParser.getAsCurrentPoint();
          return {
            current,
            controlPoint,
            currentPoint
          };
        }
      }, {
        key: "pathT",
        value: function pathT(pathParser) {
          var current = pathParser.current;
          var controlPoint = pathParser.getReflectedControlPoint();
          pathParser.control = controlPoint;
          var currentPoint = pathParser.getAsCurrentPoint();
          return {
            current,
            controlPoint,
            currentPoint
          };
        }
      }, {
        key: "pathA",
        value: function pathA(pathParser) {
          var current = pathParser.current, command = pathParser.command;
          var rX = command.rX, rY = command.rY, xRot = command.xRot, lArcFlag = command.lArcFlag, sweepFlag = command.sweepFlag;
          var xAxisRotation = xRot * (Math.PI / 180);
          var currentPoint = pathParser.getAsCurrentPoint();
          var currp = new Point(Math.cos(xAxisRotation) * (current.x - currentPoint.x) / 2 + Math.sin(xAxisRotation) * (current.y - currentPoint.y) / 2, -Math.sin(xAxisRotation) * (current.x - currentPoint.x) / 2 + Math.cos(xAxisRotation) * (current.y - currentPoint.y) / 2);
          var l = Math.pow(currp.x, 2) / Math.pow(rX, 2) + Math.pow(currp.y, 2) / Math.pow(rY, 2);
          if (l > 1) {
            rX *= Math.sqrt(l);
            rY *= Math.sqrt(l);
          }
          var s = (lArcFlag === sweepFlag ? -1 : 1) * Math.sqrt((Math.pow(rX, 2) * Math.pow(rY, 2) - Math.pow(rX, 2) * Math.pow(currp.y, 2) - Math.pow(rY, 2) * Math.pow(currp.x, 2)) / (Math.pow(rX, 2) * Math.pow(currp.y, 2) + Math.pow(rY, 2) * Math.pow(currp.x, 2)));
          if (isNaN(s)) {
            s = 0;
          }
          var cpp = new Point(s * rX * currp.y / rY, s * -rY * currp.x / rX);
          var centp = new Point((current.x + currentPoint.x) / 2 + Math.cos(xAxisRotation) * cpp.x - Math.sin(xAxisRotation) * cpp.y, (current.y + currentPoint.y) / 2 + Math.sin(xAxisRotation) * cpp.x + Math.cos(xAxisRotation) * cpp.y);
          var a1 = vectorsAngle([1, 0], [(currp.x - cpp.x) / rX, (currp.y - cpp.y) / rY]);
          var u2 = [(currp.x - cpp.x) / rX, (currp.y - cpp.y) / rY];
          var v = [(-currp.x - cpp.x) / rX, (-currp.y - cpp.y) / rY];
          var ad = vectorsAngle(u2, v);
          if (vectorsRatio(u2, v) <= -1) {
            ad = Math.PI;
          }
          if (vectorsRatio(u2, v) >= 1) {
            ad = 0;
          }
          return {
            currentPoint,
            rX,
            rY,
            sweepFlag,
            xAxisRotation,
            centp,
            a1,
            ad
          };
        }
      }, {
        key: "pathZ",
        value: function pathZ(pathParser) {
          pathParser.current = pathParser.start;
        }
      }]);
      return PathElement2;
    })(RenderedElement);
    function _createSuper$F(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$F();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$F() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    var GlyphElement = /* @__PURE__ */ (function(_PathElement) {
      _inherits__default["default"](GlyphElement2, _PathElement);
      var _super = _createSuper$F(GlyphElement2);
      function GlyphElement2(document2, node2, captureTextNodes) {
        var _this;
        _classCallCheck__default["default"](this, GlyphElement2);
        _this = _super.call(this, document2, node2, captureTextNodes);
        _this.type = "glyph";
        _this.horizAdvX = _this.getAttribute("horiz-adv-x").getNumber();
        _this.unicode = _this.getAttribute("unicode").getString();
        _this.arabicForm = _this.getAttribute("arabic-form").getString();
        return _this;
      }
      return GlyphElement2;
    })(PathElement);
    function _createSuper$E(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$E();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$E() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    var TextElement = /* @__PURE__ */ (function(_RenderedElement) {
      _inherits__default["default"](TextElement2, _RenderedElement);
      var _super = _createSuper$E(TextElement2);
      function TextElement2(document2, node2, captureTextNodes) {
        var _this;
        _classCallCheck__default["default"](this, TextElement2);
        _this = _super.call(this, document2, node2, (this instanceof TextElement2 ? this.constructor : void 0) === TextElement2 ? true : captureTextNodes);
        _this.type = "text";
        _this.x = 0;
        _this.y = 0;
        _this.measureCache = -1;
        return _this;
      }
      _createClass__default["default"](TextElement2, [{
        key: "setContext",
        value: function setContext(ctx) {
          var fromMeasure = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          _get__default["default"](_getPrototypeOf__default["default"](TextElement2.prototype), "setContext", this).call(this, ctx, fromMeasure);
          var textBaseline = this.getStyle("dominant-baseline").getTextBaseline() || this.getStyle("alignment-baseline").getTextBaseline();
          if (textBaseline) {
            ctx.textBaseline = textBaseline;
          }
        }
      }, {
        key: "initializeCoordinates",
        value: function initializeCoordinates() {
          this.x = 0;
          this.y = 0;
          this.leafTexts = [];
          this.textChunkStart = 0;
          this.minX = Number.POSITIVE_INFINITY;
          this.maxX = Number.NEGATIVE_INFINITY;
        }
      }, {
        key: "getBoundingBox",
        value: function getBoundingBox(ctx) {
          var _this2 = this;
          if (this.type !== "text") {
            return this.getTElementBoundingBox(ctx);
          }
          this.initializeCoordinates();
          this.adjustChildCoordinatesRecursive(ctx);
          var boundingBox = null;
          this.children.forEach(function(_, i) {
            var childBoundingBox = _this2.getChildBoundingBox(ctx, _this2, _this2, i);
            if (!boundingBox) {
              boundingBox = childBoundingBox;
            } else {
              boundingBox.addBoundingBox(childBoundingBox);
            }
          });
          return boundingBox;
        }
      }, {
        key: "getFontSize",
        value: function getFontSize() {
          var document2 = this.document, parent = this.parent;
          var inheritFontSize = Font.parse(document2.ctx.font).fontSize;
          var fontSize2 = parent.getStyle("font-size").getNumber(inheritFontSize);
          return fontSize2;
        }
      }, {
        key: "getTElementBoundingBox",
        value: function getTElementBoundingBox(ctx) {
          var fontSize2 = this.getFontSize();
          return new BoundingBox(this.x, this.y - fontSize2, this.x + this.measureText(ctx), this.y);
        }
      }, {
        key: "getGlyph",
        value: function getGlyph(font, text, i) {
          var char = text[i];
          var glyph = null;
          if (font.isArabic) {
            var len = text.length;
            var prevChar = text[i - 1];
            var nextChar = text[i + 1];
            var arabicForm = "isolated";
            if ((i === 0 || prevChar === " ") && i < len - 1 && nextChar !== " ") {
              arabicForm = "terminal";
            }
            if (i > 0 && prevChar !== " " && i < len - 1 && nextChar !== " ") {
              arabicForm = "medial";
            }
            if (i > 0 && prevChar !== " " && (i === len - 1 || nextChar === " ")) {
              arabicForm = "initial";
            }
            if (typeof font.glyphs[char] !== "undefined") {
              var maybeGlyph = font.glyphs[char];
              glyph = maybeGlyph instanceof GlyphElement ? maybeGlyph : maybeGlyph[arabicForm];
            }
          } else {
            glyph = font.glyphs[char];
          }
          if (!glyph) {
            glyph = font.missingGlyph;
          }
          return glyph;
        }
      }, {
        key: "getText",
        value: function getText() {
          return "";
        }
      }, {
        key: "getTextFromNode",
        value: function getTextFromNode(node2) {
          var textNode = node2 || this.node;
          var childNodes = Array.from(textNode.parentNode.childNodes);
          var index2 = childNodes.indexOf(textNode);
          var lastIndex = childNodes.length - 1;
          var text = compressSpaces(
            // textNode.value
            // || textNode.text
            textNode.textContent || ""
          );
          if (index2 === 0) {
            text = trimLeft(text);
          }
          if (index2 === lastIndex) {
            text = trimRight(text);
          }
          return text;
        }
      }, {
        key: "renderChildren",
        value: function renderChildren(ctx) {
          var _this3 = this;
          if (this.type !== "text") {
            this.renderTElementChildren(ctx);
            return;
          }
          this.initializeCoordinates();
          this.adjustChildCoordinatesRecursive(ctx);
          this.children.forEach(function(_, i) {
            _this3.renderChild(ctx, _this3, _this3, i);
          });
          var mouse = this.document.screen.mouse;
          if (mouse.isWorking()) {
            mouse.checkBoundingBox(this, this.getBoundingBox(ctx));
          }
        }
      }, {
        key: "renderTElementChildren",
        value: function renderTElementChildren(ctx) {
          var document2 = this.document, parent = this.parent;
          var renderText = this.getText();
          var customFont = parent.getStyle("font-family").getDefinition();
          if (customFont) {
            var unitsPerEm = customFont.fontFace.unitsPerEm;
            var ctxFont = Font.parse(document2.ctx.font);
            var fontSize2 = parent.getStyle("font-size").getNumber(ctxFont.fontSize);
            var fontStyle2 = parent.getStyle("font-style").getString(ctxFont.fontStyle);
            var scale = fontSize2 / unitsPerEm;
            var text = customFont.isRTL ? renderText.split("").reverse().join("") : renderText;
            var dx = toNumbers(parent.getAttribute("dx").getString());
            var len = text.length;
            for (var i = 0; i < len; i++) {
              var glyph = this.getGlyph(customFont, text, i);
              ctx.translate(this.x, this.y);
              ctx.scale(scale, -scale);
              var lw = ctx.lineWidth;
              ctx.lineWidth = ctx.lineWidth * unitsPerEm / fontSize2;
              if (fontStyle2 === "italic") {
                ctx.transform(1, 0, 0.4, 1, 0, 0);
              }
              glyph.render(ctx);
              if (fontStyle2 === "italic") {
                ctx.transform(1, 0, -0.4, 1, 0, 0);
              }
              ctx.lineWidth = lw;
              ctx.scale(1 / scale, -1 / scale);
              ctx.translate(-this.x, -this.y);
              this.x += fontSize2 * (glyph.horizAdvX || customFont.horizAdvX) / unitsPerEm;
              if (typeof dx[i] !== "undefined" && !isNaN(dx[i])) {
                this.x += dx[i];
              }
            }
            return;
          }
          var x = this.x, y = this.y;
          if (ctx.fillStyle) {
            ctx.fillText(renderText, x, y);
          }
          if (ctx.strokeStyle) {
            ctx.strokeText(renderText, x, y);
          }
        }
      }, {
        key: "applyAnchoring",
        value: function applyAnchoring() {
          if (this.textChunkStart >= this.leafTexts.length) {
            return;
          }
          var firstElement = this.leafTexts[this.textChunkStart];
          var textAnchor = firstElement.getStyle("text-anchor").getString("start");
          var isRTL = false;
          var shift = 0;
          if (textAnchor === "start" && !isRTL || textAnchor === "end" && isRTL) {
            shift = firstElement.x - this.minX;
          } else if (textAnchor === "end" && !isRTL || textAnchor === "start" && isRTL) {
            shift = firstElement.x - this.maxX;
          } else {
            shift = firstElement.x - (this.minX + this.maxX) / 2;
          }
          for (var i = this.textChunkStart; i < this.leafTexts.length; i++) {
            this.leafTexts[i].x += shift;
          }
          this.minX = Number.POSITIVE_INFINITY;
          this.maxX = Number.NEGATIVE_INFINITY;
          this.textChunkStart = this.leafTexts.length;
        }
      }, {
        key: "adjustChildCoordinatesRecursive",
        value: function adjustChildCoordinatesRecursive(ctx) {
          var _this4 = this;
          this.children.forEach(function(_, i) {
            _this4.adjustChildCoordinatesRecursiveCore(ctx, _this4, _this4, i);
          });
          this.applyAnchoring();
        }
      }, {
        key: "adjustChildCoordinatesRecursiveCore",
        value: function adjustChildCoordinatesRecursiveCore(ctx, textParent, parent, i) {
          var child = parent.children[i];
          if (child.children.length > 0) {
            child.children.forEach(function(_, i2) {
              textParent.adjustChildCoordinatesRecursiveCore(ctx, textParent, child, i2);
            });
          } else {
            this.adjustChildCoordinates(ctx, textParent, parent, i);
          }
        }
      }, {
        key: "adjustChildCoordinates",
        value: function adjustChildCoordinates(ctx, textParent, parent, i) {
          var child = parent.children[i];
          if (typeof child.measureText !== "function") {
            return child;
          }
          ctx.save();
          child.setContext(ctx, true);
          var xAttr = child.getAttribute("x");
          var yAttr = child.getAttribute("y");
          var dxAttr = child.getAttribute("dx");
          var dyAttr = child.getAttribute("dy");
          var customFont = child.getStyle("font-family").getDefinition();
          var isRTL = Boolean(customFont) && customFont.isRTL;
          if (i === 0) {
            if (!xAttr.hasValue()) {
              xAttr.setValue(child.getInheritedAttribute("x"));
            }
            if (!yAttr.hasValue()) {
              yAttr.setValue(child.getInheritedAttribute("y"));
            }
            if (!dxAttr.hasValue()) {
              dxAttr.setValue(child.getInheritedAttribute("dx"));
            }
            if (!dyAttr.hasValue()) {
              dyAttr.setValue(child.getInheritedAttribute("dy"));
            }
          }
          var width = child.measureText(ctx);
          if (isRTL) {
            textParent.x -= width;
          }
          if (xAttr.hasValue()) {
            textParent.applyAnchoring();
            child.x = xAttr.getPixels("x");
            if (dxAttr.hasValue()) {
              child.x += dxAttr.getPixels("x");
            }
          } else {
            if (dxAttr.hasValue()) {
              textParent.x += dxAttr.getPixels("x");
            }
            child.x = textParent.x;
          }
          textParent.x = child.x;
          if (!isRTL) {
            textParent.x += width;
          }
          if (yAttr.hasValue()) {
            child.y = yAttr.getPixels("y");
            if (dyAttr.hasValue()) {
              child.y += dyAttr.getPixels("y");
            }
          } else {
            if (dyAttr.hasValue()) {
              textParent.y += dyAttr.getPixels("y");
            }
            child.y = textParent.y;
          }
          textParent.y = child.y;
          textParent.leafTexts.push(child);
          textParent.minX = Math.min(textParent.minX, child.x, child.x + width);
          textParent.maxX = Math.max(textParent.maxX, child.x, child.x + width);
          child.clearContext(ctx);
          ctx.restore();
          return child;
        }
      }, {
        key: "getChildBoundingBox",
        value: function getChildBoundingBox(ctx, textParent, parent, i) {
          var child = parent.children[i];
          if (typeof child.getBoundingBox !== "function") {
            return null;
          }
          var boundingBox = child.getBoundingBox(ctx);
          if (!boundingBox) {
            return null;
          }
          child.children.forEach(function(_, i2) {
            var childBoundingBox = textParent.getChildBoundingBox(ctx, textParent, child, i2);
            boundingBox.addBoundingBox(childBoundingBox);
          });
          return boundingBox;
        }
      }, {
        key: "renderChild",
        value: function renderChild(ctx, textParent, parent, i) {
          var child = parent.children[i];
          child.render(ctx);
          child.children.forEach(function(_, i2) {
            textParent.renderChild(ctx, textParent, child, i2);
          });
        }
      }, {
        key: "measureText",
        value: function measureText(ctx) {
          var measureCache = this.measureCache;
          if (~measureCache) {
            return measureCache;
          }
          var renderText = this.getText();
          var measure = this.measureTargetText(ctx, renderText);
          this.measureCache = measure;
          return measure;
        }
      }, {
        key: "measureTargetText",
        value: function measureTargetText(ctx, targetText) {
          if (!targetText.length) {
            return 0;
          }
          var parent = this.parent;
          var customFont = parent.getStyle("font-family").getDefinition();
          if (customFont) {
            var fontSize2 = this.getFontSize();
            var text = customFont.isRTL ? targetText.split("").reverse().join("") : targetText;
            var dx = toNumbers(parent.getAttribute("dx").getString());
            var len = text.length;
            var _measure = 0;
            for (var i = 0; i < len; i++) {
              var glyph = this.getGlyph(customFont, text, i);
              _measure += (glyph.horizAdvX || customFont.horizAdvX) * fontSize2 / customFont.fontFace.unitsPerEm;
              if (typeof dx[i] !== "undefined" && !isNaN(dx[i])) {
                _measure += dx[i];
              }
            }
            return _measure;
          }
          if (!ctx.measureText) {
            return targetText.length * 10;
          }
          ctx.save();
          this.setContext(ctx, true);
          var _ctx$measureText = ctx.measureText(targetText), measure = _ctx$measureText.width;
          this.clearContext(ctx);
          ctx.restore();
          return measure;
        }
        /**
         * Inherits positional attributes from {@link TextElement} parent(s). Attributes
         * are only inherited from a parent to its first child.
         * @param name - The attribute name.
         * @returns The attribute value or null.
         */
      }, {
        key: "getInheritedAttribute",
        value: function getInheritedAttribute(name) {
          var current = this;
          while (current instanceof TextElement2 && current.isFirstChild()) {
            var parentAttr = current.parent.getAttribute(name);
            if (parentAttr.hasValue(true)) {
              return parentAttr.getValue("0");
            }
            current = current.parent;
          }
          return null;
        }
      }]);
      return TextElement2;
    })(RenderedElement);
    function _createSuper$D(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$D();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$D() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    var TSpanElement = /* @__PURE__ */ (function(_TextElement) {
      _inherits__default["default"](TSpanElement2, _TextElement);
      var _super = _createSuper$D(TSpanElement2);
      function TSpanElement2(document2, node2, captureTextNodes) {
        var _this;
        _classCallCheck__default["default"](this, TSpanElement2);
        _this = _super.call(this, document2, node2, (this instanceof TSpanElement2 ? this.constructor : void 0) === TSpanElement2 ? true : captureTextNodes);
        _this.type = "tspan";
        _this.text = _this.children.length > 0 ? "" : _this.getTextFromNode();
        return _this;
      }
      _createClass__default["default"](TSpanElement2, [{
        key: "getText",
        value: function getText() {
          return this.text;
        }
      }]);
      return TSpanElement2;
    })(TextElement);
    function _createSuper$C(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$C();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$C() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    var TextNode = /* @__PURE__ */ (function(_TSpanElement) {
      _inherits__default["default"](TextNode2, _TSpanElement);
      var _super = _createSuper$C(TextNode2);
      function TextNode2() {
        var _this;
        _classCallCheck__default["default"](this, TextNode2);
        _this = _super.apply(this, arguments);
        _this.type = "textNode";
        return _this;
      }
      return TextNode2;
    })(TSpanElement);
    function _createSuper$B(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$B();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$B() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    var SVGElement = /* @__PURE__ */ (function(_RenderedElement) {
      _inherits__default["default"](SVGElement2, _RenderedElement);
      var _super = _createSuper$B(SVGElement2);
      function SVGElement2() {
        var _this;
        _classCallCheck__default["default"](this, SVGElement2);
        _this = _super.apply(this, arguments);
        _this.type = "svg";
        _this.root = false;
        return _this;
      }
      _createClass__default["default"](SVGElement2, [{
        key: "setContext",
        value: function setContext(ctx) {
          var _this$node$parentNode;
          var document2 = this.document;
          var screen = document2.screen, window2 = document2.window;
          var canvas = ctx.canvas;
          screen.setDefaults(ctx);
          if (canvas.style && typeof ctx.font !== "undefined" && window2 && typeof window2.getComputedStyle !== "undefined") {
            ctx.font = window2.getComputedStyle(canvas).getPropertyValue("font");
            var fontSizeProp = new Property(document2, "fontSize", Font.parse(ctx.font).fontSize);
            if (fontSizeProp.hasValue()) {
              document2.rootEmSize = fontSizeProp.getPixels("y");
              document2.emSize = document2.rootEmSize;
            }
          }
          if (!this.getAttribute("x").hasValue()) {
            this.getAttribute("x", true).setValue(0);
          }
          if (!this.getAttribute("y").hasValue()) {
            this.getAttribute("y", true).setValue(0);
          }
          var _screen$viewPort = screen.viewPort, width = _screen$viewPort.width, height = _screen$viewPort.height;
          if (!this.getStyle("width").hasValue()) {
            this.getStyle("width", true).setValue("100%");
          }
          if (!this.getStyle("height").hasValue()) {
            this.getStyle("height", true).setValue("100%");
          }
          if (!this.getStyle("color").hasValue()) {
            this.getStyle("color", true).setValue("black");
          }
          var refXAttr = this.getAttribute("refX");
          var refYAttr = this.getAttribute("refY");
          var viewBoxAttr = this.getAttribute("viewBox");
          var viewBox = viewBoxAttr.hasValue() ? toNumbers(viewBoxAttr.getString()) : null;
          var clip = !this.root && this.getStyle("overflow").getValue("hidden") !== "visible";
          var minX = 0;
          var minY = 0;
          var clipX = 0;
          var clipY = 0;
          if (viewBox) {
            minX = viewBox[0];
            minY = viewBox[1];
          }
          if (!this.root) {
            width = this.getStyle("width").getPixels("x");
            height = this.getStyle("height").getPixels("y");
            if (this.type === "marker") {
              clipX = minX;
              clipY = minY;
              minX = 0;
              minY = 0;
            }
          }
          screen.viewPort.setCurrent(width, height);
          if (this.node && (!this.parent || ((_this$node$parentNode = this.node.parentNode) === null || _this$node$parentNode === void 0 ? void 0 : _this$node$parentNode.nodeName) === "foreignObject") && this.getStyle("transform", false, true).hasValue() && !this.getStyle("transform-origin", false, true).hasValue()) {
            this.getStyle("transform-origin", true, true).setValue("50% 50%");
          }
          _get__default["default"](_getPrototypeOf__default["default"](SVGElement2.prototype), "setContext", this).call(this, ctx);
          ctx.translate(this.getAttribute("x").getPixels("x"), this.getAttribute("y").getPixels("y"));
          if (viewBox) {
            width = viewBox[2];
            height = viewBox[3];
          }
          document2.setViewBox({
            ctx,
            aspectRatio: this.getAttribute("preserveAspectRatio").getString(),
            width: screen.viewPort.width,
            desiredWidth: width,
            height: screen.viewPort.height,
            desiredHeight: height,
            minX,
            minY,
            refX: refXAttr.getValue(),
            refY: refYAttr.getValue(),
            clip,
            clipX,
            clipY
          });
          if (viewBox) {
            screen.viewPort.removeCurrent();
            screen.viewPort.setCurrent(width, height);
          }
        }
      }, {
        key: "clearContext",
        value: function clearContext(ctx) {
          _get__default["default"](_getPrototypeOf__default["default"](SVGElement2.prototype), "clearContext", this).call(this, ctx);
          this.document.screen.viewPort.removeCurrent();
        }
        /**
         * Resize SVG to fit in given size.
         * @param width
         * @param height
         * @param preserveAspectRatio
         */
      }, {
        key: "resize",
        value: function resize(width) {
          var height = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : width;
          var preserveAspectRatio = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
          var widthAttr = this.getAttribute("width", true);
          var heightAttr = this.getAttribute("height", true);
          var viewBoxAttr = this.getAttribute("viewBox");
          var styleAttr = this.getAttribute("style");
          var originWidth = widthAttr.getNumber(0);
          var originHeight = heightAttr.getNumber(0);
          if (preserveAspectRatio) {
            if (typeof preserveAspectRatio === "string") {
              this.getAttribute("preserveAspectRatio", true).setValue(preserveAspectRatio);
            } else {
              var preserveAspectRatioAttr = this.getAttribute("preserveAspectRatio");
              if (preserveAspectRatioAttr.hasValue()) {
                preserveAspectRatioAttr.setValue(preserveAspectRatioAttr.getString().replace(/^\s*(\S.*\S)\s*$/, "$1"));
              }
            }
          }
          widthAttr.setValue(width);
          heightAttr.setValue(height);
          if (!viewBoxAttr.hasValue()) {
            viewBoxAttr.setValue("0 0 ".concat(originWidth || width, " ").concat(originHeight || height));
          }
          if (styleAttr.hasValue()) {
            var widthStyle = this.getStyle("width");
            var heightStyle = this.getStyle("height");
            if (widthStyle.hasValue()) {
              widthStyle.setValue("".concat(width, "px"));
            }
            if (heightStyle.hasValue()) {
              heightStyle.setValue("".concat(height, "px"));
            }
          }
        }
      }]);
      return SVGElement2;
    })(RenderedElement);
    function _createSuper$A(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$A();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$A() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    var RectElement = /* @__PURE__ */ (function(_PathElement) {
      _inherits__default["default"](RectElement2, _PathElement);
      var _super = _createSuper$A(RectElement2);
      function RectElement2() {
        var _this;
        _classCallCheck__default["default"](this, RectElement2);
        _this = _super.apply(this, arguments);
        _this.type = "rect";
        return _this;
      }
      _createClass__default["default"](RectElement2, [{
        key: "path",
        value: function path(ctx) {
          var x = this.getAttribute("x").getPixels("x");
          var y = this.getAttribute("y").getPixels("y");
          var width = this.getStyle("width", false, true).getPixels("x");
          var height = this.getStyle("height", false, true).getPixels("y");
          var rxAttr = this.getAttribute("rx");
          var ryAttr = this.getAttribute("ry");
          var rx = rxAttr.getPixels("x");
          var ry = ryAttr.getPixels("y");
          if (rxAttr.hasValue() && !ryAttr.hasValue()) {
            ry = rx;
          }
          if (ryAttr.hasValue() && !rxAttr.hasValue()) {
            rx = ry;
          }
          rx = Math.min(rx, width / 2);
          ry = Math.min(ry, height / 2);
          if (ctx) {
            var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
            ctx.beginPath();
            if (height > 0 && width > 0) {
              ctx.moveTo(x + rx, y);
              ctx.lineTo(x + width - rx, y);
              ctx.bezierCurveTo(x + width - rx + KAPPA * rx, y, x + width, y + ry - KAPPA * ry, x + width, y + ry);
              ctx.lineTo(x + width, y + height - ry);
              ctx.bezierCurveTo(x + width, y + height - ry + KAPPA * ry, x + width - rx + KAPPA * rx, y + height, x + width - rx, y + height);
              ctx.lineTo(x + rx, y + height);
              ctx.bezierCurveTo(x + rx - KAPPA * rx, y + height, x, y + height - ry + KAPPA * ry, x, y + height - ry);
              ctx.lineTo(x, y + ry);
              ctx.bezierCurveTo(x, y + ry - KAPPA * ry, x + rx - KAPPA * rx, y, x + rx, y);
              ctx.closePath();
            }
          }
          return new BoundingBox(x, y, x + width, y + height);
        }
      }, {
        key: "getMarkers",
        value: function getMarkers() {
          return null;
        }
      }]);
      return RectElement2;
    })(PathElement);
    function _createSuper$z(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$z();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$z() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    var CircleElement = /* @__PURE__ */ (function(_PathElement) {
      _inherits__default["default"](CircleElement2, _PathElement);
      var _super = _createSuper$z(CircleElement2);
      function CircleElement2() {
        var _this;
        _classCallCheck__default["default"](this, CircleElement2);
        _this = _super.apply(this, arguments);
        _this.type = "circle";
        return _this;
      }
      _createClass__default["default"](CircleElement2, [{
        key: "path",
        value: function path(ctx) {
          var cx = this.getAttribute("cx").getPixels("x");
          var cy = this.getAttribute("cy").getPixels("y");
          var r = this.getAttribute("r").getPixels();
          if (ctx && r > 0) {
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, Math.PI * 2, false);
            ctx.closePath();
          }
          return new BoundingBox(cx - r, cy - r, cx + r, cy + r);
        }
      }, {
        key: "getMarkers",
        value: function getMarkers() {
          return null;
        }
      }]);
      return CircleElement2;
    })(PathElement);
    function _createSuper$y(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$y();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$y() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    var EllipseElement = /* @__PURE__ */ (function(_PathElement) {
      _inherits__default["default"](EllipseElement2, _PathElement);
      var _super = _createSuper$y(EllipseElement2);
      function EllipseElement2() {
        var _this;
        _classCallCheck__default["default"](this, EllipseElement2);
        _this = _super.apply(this, arguments);
        _this.type = "ellipse";
        return _this;
      }
      _createClass__default["default"](EllipseElement2, [{
        key: "path",
        value: function path(ctx) {
          var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
          var rx = this.getAttribute("rx").getPixels("x");
          var ry = this.getAttribute("ry").getPixels("y");
          var cx = this.getAttribute("cx").getPixels("x");
          var cy = this.getAttribute("cy").getPixels("y");
          if (ctx && rx > 0 && ry > 0) {
            ctx.beginPath();
            ctx.moveTo(cx + rx, cy);
            ctx.bezierCurveTo(cx + rx, cy + KAPPA * ry, cx + KAPPA * rx, cy + ry, cx, cy + ry);
            ctx.bezierCurveTo(cx - KAPPA * rx, cy + ry, cx - rx, cy + KAPPA * ry, cx - rx, cy);
            ctx.bezierCurveTo(cx - rx, cy - KAPPA * ry, cx - KAPPA * rx, cy - ry, cx, cy - ry);
            ctx.bezierCurveTo(cx + KAPPA * rx, cy - ry, cx + rx, cy - KAPPA * ry, cx + rx, cy);
            ctx.closePath();
          }
          return new BoundingBox(cx - rx, cy - ry, cx + rx, cy + ry);
        }
      }, {
        key: "getMarkers",
        value: function getMarkers() {
          return null;
        }
      }]);
      return EllipseElement2;
    })(PathElement);
    function _createSuper$x(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$x();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$x() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    var LineElement = /* @__PURE__ */ (function(_PathElement) {
      _inherits__default["default"](LineElement2, _PathElement);
      var _super = _createSuper$x(LineElement2);
      function LineElement2() {
        var _this;
        _classCallCheck__default["default"](this, LineElement2);
        _this = _super.apply(this, arguments);
        _this.type = "line";
        return _this;
      }
      _createClass__default["default"](LineElement2, [{
        key: "getPoints",
        value: function getPoints() {
          return [new Point(this.getAttribute("x1").getPixels("x"), this.getAttribute("y1").getPixels("y")), new Point(this.getAttribute("x2").getPixels("x"), this.getAttribute("y2").getPixels("y"))];
        }
      }, {
        key: "path",
        value: function path(ctx) {
          var _this$getPoints = this.getPoints(), _this$getPoints2 = _slicedToArray__default["default"](_this$getPoints, 2), _this$getPoints2$ = _this$getPoints2[0], x0 = _this$getPoints2$.x, y0 = _this$getPoints2$.y, _this$getPoints2$2 = _this$getPoints2[1], x1 = _this$getPoints2$2.x, y1 = _this$getPoints2$2.y;
          if (ctx) {
            ctx.beginPath();
            ctx.moveTo(x0, y0);
            ctx.lineTo(x1, y1);
          }
          return new BoundingBox(x0, y0, x1, y1);
        }
      }, {
        key: "getMarkers",
        value: function getMarkers() {
          var _this$getPoints3 = this.getPoints(), _this$getPoints4 = _slicedToArray__default["default"](_this$getPoints3, 2), p0 = _this$getPoints4[0], p1 = _this$getPoints4[1];
          var a2 = p0.angleTo(p1);
          return [[p0, a2], [p1, a2]];
        }
      }]);
      return LineElement2;
    })(PathElement);
    function _createSuper$w(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$w();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$w() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    var PolylineElement = /* @__PURE__ */ (function(_PathElement) {
      _inherits__default["default"](PolylineElement2, _PathElement);
      var _super = _createSuper$w(PolylineElement2);
      function PolylineElement2(document2, node2, captureTextNodes) {
        var _this;
        _classCallCheck__default["default"](this, PolylineElement2);
        _this = _super.call(this, document2, node2, captureTextNodes);
        _this.type = "polyline";
        _this.points = [];
        _this.points = Point.parsePath(_this.getAttribute("points").getString());
        return _this;
      }
      _createClass__default["default"](PolylineElement2, [{
        key: "path",
        value: function path(ctx) {
          var points = this.points;
          var _points = _slicedToArray__default["default"](points, 1), _points$ = _points[0], x0 = _points$.x, y0 = _points$.y;
          var boundingBox = new BoundingBox(x0, y0);
          if (ctx) {
            ctx.beginPath();
            ctx.moveTo(x0, y0);
          }
          points.forEach(function(_ref) {
            var x = _ref.x, y = _ref.y;
            boundingBox.addPoint(x, y);
            if (ctx) {
              ctx.lineTo(x, y);
            }
          });
          return boundingBox;
        }
      }, {
        key: "getMarkers",
        value: function getMarkers() {
          var points = this.points;
          var lastIndex = points.length - 1;
          var markers = [];
          points.forEach(function(point, i) {
            if (i === lastIndex) {
              return;
            }
            markers.push([point, point.angleTo(points[i + 1])]);
          });
          if (markers.length > 0) {
            markers.push([points[points.length - 1], markers[markers.length - 1][1]]);
          }
          return markers;
        }
      }]);
      return PolylineElement2;
    })(PathElement);
    function _createSuper$v(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$v();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$v() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    var PolygonElement = /* @__PURE__ */ (function(_PolylineElement) {
      _inherits__default["default"](PolygonElement2, _PolylineElement);
      var _super = _createSuper$v(PolygonElement2);
      function PolygonElement2() {
        var _this;
        _classCallCheck__default["default"](this, PolygonElement2);
        _this = _super.apply(this, arguments);
        _this.type = "polygon";
        return _this;
      }
      _createClass__default["default"](PolygonElement2, [{
        key: "path",
        value: function path(ctx) {
          var boundingBox = _get__default["default"](_getPrototypeOf__default["default"](PolygonElement2.prototype), "path", this).call(this, ctx);
          var _this$points = _slicedToArray__default["default"](this.points, 1), _this$points$ = _this$points[0], x = _this$points$.x, y = _this$points$.y;
          if (ctx) {
            ctx.lineTo(x, y);
            ctx.closePath();
          }
          return boundingBox;
        }
      }]);
      return PolygonElement2;
    })(PolylineElement);
    function _createSuper$u(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$u();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$u() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    var PatternElement = /* @__PURE__ */ (function(_Element) {
      _inherits__default["default"](PatternElement2, _Element);
      var _super = _createSuper$u(PatternElement2);
      function PatternElement2() {
        var _this;
        _classCallCheck__default["default"](this, PatternElement2);
        _this = _super.apply(this, arguments);
        _this.type = "pattern";
        return _this;
      }
      _createClass__default["default"](PatternElement2, [{
        key: "createPattern",
        value: function createPattern(ctx, _, parentOpacityProp) {
          var width = this.getStyle("width").getPixels("x", true);
          var height = this.getStyle("height").getPixels("y", true);
          var patternSvg = new SVGElement(this.document, null);
          patternSvg.attributes.viewBox = new Property(this.document, "viewBox", this.getAttribute("viewBox").getValue());
          patternSvg.attributes.width = new Property(this.document, "width", "".concat(width, "px"));
          patternSvg.attributes.height = new Property(this.document, "height", "".concat(height, "px"));
          patternSvg.attributes.transform = new Property(this.document, "transform", this.getAttribute("patternTransform").getValue());
          patternSvg.children = this.children;
          var patternCanvas = this.document.createCanvas(width, height);
          var patternCtx = patternCanvas.getContext("2d");
          var xAttr = this.getAttribute("x");
          var yAttr = this.getAttribute("y");
          if (xAttr.hasValue() && yAttr.hasValue()) {
            patternCtx.translate(xAttr.getPixels("x", true), yAttr.getPixels("y", true));
          }
          if (parentOpacityProp.hasValue()) {
            this.styles["fill-opacity"] = parentOpacityProp;
          } else {
            Reflect.deleteProperty(this.styles, "fill-opacity");
          }
          for (var x = -1; x <= 1; x++) {
            for (var y = -1; y <= 1; y++) {
              patternCtx.save();
              patternSvg.attributes.x = new Property(this.document, "x", x * patternCanvas.width);
              patternSvg.attributes.y = new Property(this.document, "y", y * patternCanvas.height);
              patternSvg.render(patternCtx);
              patternCtx.restore();
            }
          }
          var pattern = ctx.createPattern(patternCanvas, "repeat");
          return pattern;
        }
      }]);
      return PatternElement2;
    })(Element);
    function _createSuper$t(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$t();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$t() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    var MarkerElement = /* @__PURE__ */ (function(_Element) {
      _inherits__default["default"](MarkerElement2, _Element);
      var _super = _createSuper$t(MarkerElement2);
      function MarkerElement2() {
        var _this;
        _classCallCheck__default["default"](this, MarkerElement2);
        _this = _super.apply(this, arguments);
        _this.type = "marker";
        return _this;
      }
      _createClass__default["default"](MarkerElement2, [{
        key: "render",
        value: function render(ctx, point, angle2) {
          if (!point) {
            return;
          }
          var x = point.x, y = point.y;
          var orient = this.getAttribute("orient").getString("auto");
          var markerUnits = this.getAttribute("markerUnits").getString("strokeWidth");
          ctx.translate(x, y);
          if (orient === "auto") {
            ctx.rotate(angle2);
          }
          if (markerUnits === "strokeWidth") {
            ctx.scale(ctx.lineWidth, ctx.lineWidth);
          }
          ctx.save();
          var markerSvg = new SVGElement(this.document, null);
          markerSvg.type = this.type;
          markerSvg.attributes.viewBox = new Property(this.document, "viewBox", this.getAttribute("viewBox").getValue());
          markerSvg.attributes.refX = new Property(this.document, "refX", this.getAttribute("refX").getValue());
          markerSvg.attributes.refY = new Property(this.document, "refY", this.getAttribute("refY").getValue());
          markerSvg.attributes.width = new Property(this.document, "width", this.getAttribute("markerWidth").getValue());
          markerSvg.attributes.height = new Property(this.document, "height", this.getAttribute("markerHeight").getValue());
          markerSvg.attributes.overflow = new Property(this.document, "overflow", this.getAttribute("overflow").getValue());
          markerSvg.attributes.fill = new Property(this.document, "fill", this.getAttribute("fill").getColor("black"));
          markerSvg.attributes.stroke = new Property(this.document, "stroke", this.getAttribute("stroke").getValue("none"));
          markerSvg.children = this.children;
          markerSvg.render(ctx);
          ctx.restore();
          if (markerUnits === "strokeWidth") {
            ctx.scale(1 / ctx.lineWidth, 1 / ctx.lineWidth);
          }
          if (orient === "auto") {
            ctx.rotate(-angle2);
          }
          ctx.translate(-x, -y);
        }
      }]);
      return MarkerElement2;
    })(Element);
    function _createSuper$s(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$s();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$s() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    var DefsElement = /* @__PURE__ */ (function(_Element) {
      _inherits__default["default"](DefsElement2, _Element);
      var _super = _createSuper$s(DefsElement2);
      function DefsElement2() {
        var _this;
        _classCallCheck__default["default"](this, DefsElement2);
        _this = _super.apply(this, arguments);
        _this.type = "defs";
        return _this;
      }
      _createClass__default["default"](DefsElement2, [{
        key: "render",
        value: function render() {
        }
      }]);
      return DefsElement2;
    })(Element);
    function _createSuper$r(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$r();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$r() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    var GElement = /* @__PURE__ */ (function(_RenderedElement) {
      _inherits__default["default"](GElement2, _RenderedElement);
      var _super = _createSuper$r(GElement2);
      function GElement2() {
        var _this;
        _classCallCheck__default["default"](this, GElement2);
        _this = _super.apply(this, arguments);
        _this.type = "g";
        return _this;
      }
      _createClass__default["default"](GElement2, [{
        key: "getBoundingBox",
        value: function getBoundingBox(ctx) {
          var boundingBox = new BoundingBox();
          this.children.forEach(function(child) {
            boundingBox.addBoundingBox(child.getBoundingBox(ctx));
          });
          return boundingBox;
        }
      }]);
      return GElement2;
    })(RenderedElement);
    function _createSuper$q(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$q();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$q() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    var GradientElement = /* @__PURE__ */ (function(_Element) {
      _inherits__default["default"](GradientElement2, _Element);
      var _super = _createSuper$q(GradientElement2);
      function GradientElement2(document2, node2, captureTextNodes) {
        var _this;
        _classCallCheck__default["default"](this, GradientElement2);
        _this = _super.call(this, document2, node2, captureTextNodes);
        _this.attributesToInherit = ["gradientUnits"];
        _this.stops = [];
        var _assertThisInitialize = _assertThisInitialized__default["default"](_this), stops = _assertThisInitialize.stops, children = _assertThisInitialize.children;
        children.forEach(function(child) {
          if (child.type === "stop") {
            stops.push(child);
          }
        });
        return _this;
      }
      _createClass__default["default"](GradientElement2, [{
        key: "getGradientUnits",
        value: function getGradientUnits() {
          return this.getAttribute("gradientUnits").getString("objectBoundingBox");
        }
      }, {
        key: "createGradient",
        value: function createGradient(ctx, element, parentOpacityProp) {
          var _this2 = this;
          var stopsContainer = this;
          if (this.getHrefAttribute().hasValue()) {
            stopsContainer = this.getHrefAttribute().getDefinition();
            this.inheritStopContainer(stopsContainer);
          }
          var _stopsContainer = stopsContainer, stops = _stopsContainer.stops;
          var gradient = this.getGradient(ctx, element);
          if (!gradient) {
            return this.addParentOpacity(parentOpacityProp, stops[stops.length - 1].color);
          }
          stops.forEach(function(stop) {
            gradient.addColorStop(stop.offset, _this2.addParentOpacity(parentOpacityProp, stop.color));
          });
          if (this.getAttribute("gradientTransform").hasValue()) {
            var document2 = this.document;
            var _document$screen = document2.screen, MAX_VIRTUAL_PIXELS = _document$screen.MAX_VIRTUAL_PIXELS, viewPort = _document$screen.viewPort;
            var _viewPort$viewPorts = _slicedToArray__default["default"](viewPort.viewPorts, 1), rootView = _viewPort$viewPorts[0];
            var rect = new RectElement(document2, null);
            rect.attributes.x = new Property(document2, "x", -MAX_VIRTUAL_PIXELS / 3);
            rect.attributes.y = new Property(document2, "y", -MAX_VIRTUAL_PIXELS / 3);
            rect.attributes.width = new Property(document2, "width", MAX_VIRTUAL_PIXELS);
            rect.attributes.height = new Property(document2, "height", MAX_VIRTUAL_PIXELS);
            var group = new GElement(document2, null);
            group.attributes.transform = new Property(document2, "transform", this.getAttribute("gradientTransform").getValue());
            group.children = [rect];
            var patternSvg = new SVGElement(document2, null);
            patternSvg.attributes.x = new Property(document2, "x", 0);
            patternSvg.attributes.y = new Property(document2, "y", 0);
            patternSvg.attributes.width = new Property(document2, "width", rootView.width);
            patternSvg.attributes.height = new Property(document2, "height", rootView.height);
            patternSvg.children = [group];
            var patternCanvas = document2.createCanvas(rootView.width, rootView.height);
            var patternCtx = patternCanvas.getContext("2d");
            patternCtx.fillStyle = gradient;
            patternSvg.render(patternCtx);
            return patternCtx.createPattern(patternCanvas, "no-repeat");
          }
          return gradient;
        }
      }, {
        key: "inheritStopContainer",
        value: function inheritStopContainer(stopsContainer) {
          var _this3 = this;
          this.attributesToInherit.forEach(function(attributeToInherit) {
            if (!_this3.getAttribute(attributeToInherit).hasValue() && stopsContainer.getAttribute(attributeToInherit).hasValue()) {
              _this3.getAttribute(attributeToInherit, true).setValue(stopsContainer.getAttribute(attributeToInherit).getValue());
            }
          });
        }
      }, {
        key: "addParentOpacity",
        value: function addParentOpacity(parentOpacityProp, color2) {
          if (parentOpacityProp.hasValue()) {
            var colorProp = new Property(this.document, "color", color2);
            return colorProp.addOpacity(parentOpacityProp).getColor();
          }
          return color2;
        }
      }]);
      return GradientElement2;
    })(Element);
    function _createSuper$p(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$p();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$p() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    var LinearGradientElement = /* @__PURE__ */ (function(_GradientElement) {
      _inherits__default["default"](LinearGradientElement2, _GradientElement);
      var _super = _createSuper$p(LinearGradientElement2);
      function LinearGradientElement2(document2, node2, captureTextNodes) {
        var _this;
        _classCallCheck__default["default"](this, LinearGradientElement2);
        _this = _super.call(this, document2, node2, captureTextNodes);
        _this.type = "linearGradient";
        _this.attributesToInherit.push("x1", "y1", "x2", "y2");
        return _this;
      }
      _createClass__default["default"](LinearGradientElement2, [{
        key: "getGradient",
        value: function getGradient(ctx, element) {
          var isBoundingBoxUnits = this.getGradientUnits() === "objectBoundingBox";
          var boundingBox = isBoundingBoxUnits ? element.getBoundingBox(ctx) : null;
          if (isBoundingBoxUnits && !boundingBox) {
            return null;
          }
          if (!this.getAttribute("x1").hasValue() && !this.getAttribute("y1").hasValue() && !this.getAttribute("x2").hasValue() && !this.getAttribute("y2").hasValue()) {
            this.getAttribute("x1", true).setValue(0);
            this.getAttribute("y1", true).setValue(0);
            this.getAttribute("x2", true).setValue(1);
            this.getAttribute("y2", true).setValue(0);
          }
          var x1 = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute("x1").getNumber() : this.getAttribute("x1").getPixels("x");
          var y1 = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute("y1").getNumber() : this.getAttribute("y1").getPixels("y");
          var x2 = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute("x2").getNumber() : this.getAttribute("x2").getPixels("x");
          var y2 = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute("y2").getNumber() : this.getAttribute("y2").getPixels("y");
          if (x1 === x2 && y1 === y2) {
            return null;
          }
          return ctx.createLinearGradient(x1, y1, x2, y2);
        }
      }]);
      return LinearGradientElement2;
    })(GradientElement);
    function _createSuper$o(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$o();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$o() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    var RadialGradientElement = /* @__PURE__ */ (function(_GradientElement) {
      _inherits__default["default"](RadialGradientElement2, _GradientElement);
      var _super = _createSuper$o(RadialGradientElement2);
      function RadialGradientElement2(document2, node2, captureTextNodes) {
        var _this;
        _classCallCheck__default["default"](this, RadialGradientElement2);
        _this = _super.call(this, document2, node2, captureTextNodes);
        _this.type = "radialGradient";
        _this.attributesToInherit.push("cx", "cy", "r", "fx", "fy", "fr");
        return _this;
      }
      _createClass__default["default"](RadialGradientElement2, [{
        key: "getGradient",
        value: function getGradient(ctx, element) {
          var isBoundingBoxUnits = this.getGradientUnits() === "objectBoundingBox";
          var boundingBox = element.getBoundingBox(ctx);
          if (isBoundingBoxUnits && !boundingBox) {
            return null;
          }
          if (!this.getAttribute("cx").hasValue()) {
            this.getAttribute("cx", true).setValue("50%");
          }
          if (!this.getAttribute("cy").hasValue()) {
            this.getAttribute("cy", true).setValue("50%");
          }
          if (!this.getAttribute("r").hasValue()) {
            this.getAttribute("r", true).setValue("50%");
          }
          var cx = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute("cx").getNumber() : this.getAttribute("cx").getPixels("x");
          var cy = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute("cy").getNumber() : this.getAttribute("cy").getPixels("y");
          var fx = cx;
          var fy = cy;
          if (this.getAttribute("fx").hasValue()) {
            fx = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute("fx").getNumber() : this.getAttribute("fx").getPixels("x");
          }
          if (this.getAttribute("fy").hasValue()) {
            fy = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute("fy").getNumber() : this.getAttribute("fy").getPixels("y");
          }
          var r = isBoundingBoxUnits ? (boundingBox.width + boundingBox.height) / 2 * this.getAttribute("r").getNumber() : this.getAttribute("r").getPixels();
          var fr = this.getAttribute("fr").getPixels();
          return ctx.createRadialGradient(fx, fy, fr, cx, cy, r);
        }
      }]);
      return RadialGradientElement2;
    })(GradientElement);
    function _createSuper$n(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$n();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$n() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    var StopElement = /* @__PURE__ */ (function(_Element) {
      _inherits__default["default"](StopElement2, _Element);
      var _super = _createSuper$n(StopElement2);
      function StopElement2(document2, node2, captureTextNodes) {
        var _this;
        _classCallCheck__default["default"](this, StopElement2);
        _this = _super.call(this, document2, node2, captureTextNodes);
        _this.type = "stop";
        var offset = Math.max(0, Math.min(1, _this.getAttribute("offset").getNumber()));
        var stopOpacity = _this.getStyle("stop-opacity");
        var stopColor = _this.getStyle("stop-color", true);
        if (stopColor.getString() === "") {
          stopColor.setValue("#000");
        }
        if (stopOpacity.hasValue()) {
          stopColor = stopColor.addOpacity(stopOpacity);
        }
        _this.offset = offset;
        _this.color = stopColor.getColor();
        return _this;
      }
      return StopElement2;
    })(Element);
    function _createSuper$m(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$m();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$m() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    var AnimateElement = /* @__PURE__ */ (function(_Element) {
      _inherits__default["default"](AnimateElement2, _Element);
      var _super = _createSuper$m(AnimateElement2);
      function AnimateElement2(document2, node2, captureTextNodes) {
        var _this;
        _classCallCheck__default["default"](this, AnimateElement2);
        _this = _super.call(this, document2, node2, captureTextNodes);
        _this.type = "animate";
        _this.duration = 0;
        _this.initialValue = null;
        _this.initialUnits = "";
        _this.removed = false;
        _this.frozen = false;
        document2.screen.animations.push(_assertThisInitialized__default["default"](_this));
        _this.begin = _this.getAttribute("begin").getMilliseconds();
        _this.maxDuration = _this.begin + _this.getAttribute("dur").getMilliseconds();
        _this.from = _this.getAttribute("from");
        _this.to = _this.getAttribute("to");
        _this.values = new Property(document2, "values", null);
        var valuesAttr = _this.getAttribute("values");
        if (valuesAttr.hasValue()) {
          _this.values.setValue(valuesAttr.getString().split(";"));
        }
        return _this;
      }
      _createClass__default["default"](AnimateElement2, [{
        key: "getProperty",
        value: function getProperty() {
          var attributeType = this.getAttribute("attributeType").getString();
          var attributeName = this.getAttribute("attributeName").getString();
          if (attributeType === "CSS") {
            return this.parent.getStyle(attributeName, true);
          }
          return this.parent.getAttribute(attributeName, true);
        }
      }, {
        key: "calcValue",
        value: function calcValue() {
          var initialUnits = this.initialUnits;
          var _this$getProgress = this.getProgress(), progress = _this$getProgress.progress, from = _this$getProgress.from, to = _this$getProgress.to;
          var newValue = from.getNumber() + (to.getNumber() - from.getNumber()) * progress;
          if (initialUnits === "%") {
            newValue *= 100;
          }
          return "".concat(newValue).concat(initialUnits);
        }
      }, {
        key: "update",
        value: function update(delta) {
          var parent = this.parent;
          var prop = this.getProperty();
          if (!this.initialValue) {
            this.initialValue = prop.getString();
            this.initialUnits = prop.getUnits();
          }
          if (this.duration > this.maxDuration) {
            var fill = this.getAttribute("fill").getString("remove");
            if (this.getAttribute("repeatCount").getString() === "indefinite" || this.getAttribute("repeatDur").getString() === "indefinite") {
              this.duration = 0;
            } else if (fill === "freeze" && !this.frozen) {
              this.frozen = true;
              parent.animationFrozen = true;
              parent.animationFrozenValue = prop.getString();
            } else if (fill === "remove" && !this.removed) {
              this.removed = true;
              prop.setValue(parent.animationFrozen ? parent.animationFrozenValue : this.initialValue);
              return true;
            }
            return false;
          }
          this.duration += delta;
          var updated = false;
          if (this.begin < this.duration) {
            var newValue = this.calcValue();
            var typeAttr = this.getAttribute("type");
            if (typeAttr.hasValue()) {
              var type = typeAttr.getString();
              newValue = "".concat(type, "(").concat(newValue, ")");
            }
            prop.setValue(newValue);
            updated = true;
          }
          return updated;
        }
      }, {
        key: "getProgress",
        value: function getProgress() {
          var document2 = this.document, values = this.values;
          var result = {
            progress: (this.duration - this.begin) / (this.maxDuration - this.begin)
          };
          if (values.hasValue()) {
            var p = result.progress * (values.getValue().length - 1);
            var lb = Math.floor(p);
            var ub = Math.ceil(p);
            result.from = new Property(document2, "from", parseFloat(values.getValue()[lb]));
            result.to = new Property(document2, "to", parseFloat(values.getValue()[ub]));
            result.progress = (p - lb) / (ub - lb);
          } else {
            result.from = this.from;
            result.to = this.to;
          }
          return result;
        }
      }]);
      return AnimateElement2;
    })(Element);
    function _createSuper$l(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$l();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$l() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    var AnimateColorElement = /* @__PURE__ */ (function(_AnimateElement) {
      _inherits__default["default"](AnimateColorElement2, _AnimateElement);
      var _super = _createSuper$l(AnimateColorElement2);
      function AnimateColorElement2() {
        var _this;
        _classCallCheck__default["default"](this, AnimateColorElement2);
        _this = _super.apply(this, arguments);
        _this.type = "animateColor";
        return _this;
      }
      _createClass__default["default"](AnimateColorElement2, [{
        key: "calcValue",
        value: function calcValue() {
          var _this$getProgress = this.getProgress(), progress = _this$getProgress.progress, from = _this$getProgress.from, to = _this$getProgress.to;
          var colorFrom = new RGBColor__default["default"](from.getColor());
          var colorTo = new RGBColor__default["default"](to.getColor());
          if (colorFrom.ok && colorTo.ok) {
            var r = colorFrom.r + (colorTo.r - colorFrom.r) * progress;
            var g = colorFrom.g + (colorTo.g - colorFrom.g) * progress;
            var b = colorFrom.b + (colorTo.b - colorFrom.b) * progress;
            return "rgb(".concat(Math.floor(r), ", ").concat(Math.floor(g), ", ").concat(Math.floor(b), ")");
          }
          return this.getAttribute("from").getColor();
        }
      }]);
      return AnimateColorElement2;
    })(AnimateElement);
    function _createSuper$k(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$k();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$k() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    var AnimateTransformElement = /* @__PURE__ */ (function(_AnimateElement) {
      _inherits__default["default"](AnimateTransformElement2, _AnimateElement);
      var _super = _createSuper$k(AnimateTransformElement2);
      function AnimateTransformElement2() {
        var _this;
        _classCallCheck__default["default"](this, AnimateTransformElement2);
        _this = _super.apply(this, arguments);
        _this.type = "animateTransform";
        return _this;
      }
      _createClass__default["default"](AnimateTransformElement2, [{
        key: "calcValue",
        value: function calcValue() {
          var _this$getProgress = this.getProgress(), progress = _this$getProgress.progress, from = _this$getProgress.from, to = _this$getProgress.to;
          var transformFrom = toNumbers(from.getString());
          var transformTo = toNumbers(to.getString());
          var newValue = transformFrom.map(function(from2, i) {
            var to2 = transformTo[i];
            return from2 + (to2 - from2) * progress;
          }).join(" ");
          return newValue;
        }
      }]);
      return AnimateTransformElement2;
    })(AnimateElement);
    function _createForOfIteratorHelper$1(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it) o = it;
          var i = 0;
          var F2 = function F3() {
          };
          return { s: F2, n: function n() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e2(_e) {
            throw _e;
          }, f: F2 };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err2;
      return { s: function s() {
        it = it.call(o);
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e2(_e2) {
        didErr = true;
        err2 = _e2;
      }, f: function f2() {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err2;
        }
      } };
    }
    function _unsupportedIterableToArray$1(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray$1(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);
    }
    function _arrayLikeToArray$1(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _createSuper$j(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$j();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$j() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    var FontElement = /* @__PURE__ */ (function(_Element) {
      _inherits__default["default"](FontElement2, _Element);
      var _super = _createSuper$j(FontElement2);
      function FontElement2(document2, node2, captureTextNodes) {
        var _this;
        _classCallCheck__default["default"](this, FontElement2);
        _this = _super.call(this, document2, node2, captureTextNodes);
        _this.type = "font";
        _this.glyphs = /* @__PURE__ */ Object.create(null);
        _this.horizAdvX = _this.getAttribute("horiz-adv-x").getNumber();
        var definitions = document2.definitions;
        var _assertThisInitialize = _assertThisInitialized__default["default"](_this), children = _assertThisInitialize.children;
        var _iterator = _createForOfIteratorHelper$1(children), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var child = _step.value;
            switch (child.type) {
              case "font-face": {
                _this.fontFace = child;
                var fontFamilyStyle = child.getStyle("font-family");
                if (fontFamilyStyle.hasValue()) {
                  definitions[fontFamilyStyle.getString()] = _assertThisInitialized__default["default"](_this);
                }
                break;
              }
              case "missing-glyph":
                _this.missingGlyph = child;
                break;
              case "glyph": {
                var glyph = child;
                if (glyph.arabicForm) {
                  _this.isRTL = true;
                  _this.isArabic = true;
                  if (typeof _this.glyphs[glyph.unicode] === "undefined") {
                    _this.glyphs[glyph.unicode] = /* @__PURE__ */ Object.create(null);
                  }
                  _this.glyphs[glyph.unicode][glyph.arabicForm] = glyph;
                } else {
                  _this.glyphs[glyph.unicode] = glyph;
                }
                break;
              }
              default:
            }
          }
        } catch (err2) {
          _iterator.e(err2);
        } finally {
          _iterator.f();
        }
        return _this;
      }
      _createClass__default["default"](FontElement2, [{
        key: "render",
        value: function render() {
        }
      }]);
      return FontElement2;
    })(Element);
    function _createSuper$i(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$i();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$i() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    var FontFaceElement = /* @__PURE__ */ (function(_Element) {
      _inherits__default["default"](FontFaceElement2, _Element);
      var _super = _createSuper$i(FontFaceElement2);
      function FontFaceElement2(document2, node2, captureTextNodes) {
        var _this;
        _classCallCheck__default["default"](this, FontFaceElement2);
        _this = _super.call(this, document2, node2, captureTextNodes);
        _this.type = "font-face";
        _this.ascent = _this.getAttribute("ascent").getNumber();
        _this.descent = _this.getAttribute("descent").getNumber();
        _this.unitsPerEm = _this.getAttribute("units-per-em").getNumber();
        return _this;
      }
      return FontFaceElement2;
    })(Element);
    function _createSuper$h(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$h();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$h() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    var MissingGlyphElement = /* @__PURE__ */ (function(_PathElement) {
      _inherits__default["default"](MissingGlyphElement2, _PathElement);
      var _super = _createSuper$h(MissingGlyphElement2);
      function MissingGlyphElement2() {
        var _this;
        _classCallCheck__default["default"](this, MissingGlyphElement2);
        _this = _super.apply(this, arguments);
        _this.type = "missing-glyph";
        _this.horizAdvX = 0;
        return _this;
      }
      return MissingGlyphElement2;
    })(PathElement);
    function _createSuper$g(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$g();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$g() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    var TRefElement = /* @__PURE__ */ (function(_TextElement) {
      _inherits__default["default"](TRefElement2, _TextElement);
      var _super = _createSuper$g(TRefElement2);
      function TRefElement2() {
        var _this;
        _classCallCheck__default["default"](this, TRefElement2);
        _this = _super.apply(this, arguments);
        _this.type = "tref";
        return _this;
      }
      _createClass__default["default"](TRefElement2, [{
        key: "getText",
        value: function getText() {
          var element = this.getHrefAttribute().getDefinition();
          if (element) {
            var firstChild = element.children[0];
            if (firstChild) {
              return firstChild.getText();
            }
          }
          return "";
        }
      }]);
      return TRefElement2;
    })(TextElement);
    function _createSuper$f(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$f();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$f() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    var AElement = /* @__PURE__ */ (function(_TextElement) {
      _inherits__default["default"](AElement2, _TextElement);
      var _super = _createSuper$f(AElement2);
      function AElement2(document2, node2, captureTextNodes) {
        var _this;
        _classCallCheck__default["default"](this, AElement2);
        _this = _super.call(this, document2, node2, captureTextNodes);
        _this.type = "a";
        var childNodes = node2.childNodes;
        var firstChild = childNodes[0];
        var hasText = childNodes.length > 0 && Array.from(childNodes).every(function(node3) {
          return node3.nodeType === 3;
        });
        _this.hasText = hasText;
        _this.text = hasText ? _this.getTextFromNode(firstChild) : "";
        return _this;
      }
      _createClass__default["default"](AElement2, [{
        key: "getText",
        value: function getText() {
          return this.text;
        }
      }, {
        key: "renderChildren",
        value: function renderChildren(ctx) {
          if (this.hasText) {
            _get__default["default"](_getPrototypeOf__default["default"](AElement2.prototype), "renderChildren", this).call(this, ctx);
            var document2 = this.document, x = this.x, y = this.y;
            var mouse = document2.screen.mouse;
            var fontSize2 = new Property(document2, "fontSize", Font.parse(document2.ctx.font).fontSize);
            if (mouse.isWorking()) {
              mouse.checkBoundingBox(this, new BoundingBox(x, y - fontSize2.getPixels("y"), x + this.measureText(ctx), y));
            }
          } else if (this.children.length > 0) {
            var g = new GElement(this.document, null);
            g.children = this.children;
            g.parent = this;
            g.render(ctx);
          }
        }
      }, {
        key: "onClick",
        value: function onClick() {
          var window2 = this.document.window;
          if (window2) {
            window2.open(this.getHrefAttribute().getString());
          }
        }
      }, {
        key: "onMouseMove",
        value: function onMouseMove() {
          var ctx = this.document.ctx;
          ctx.canvas.style.cursor = "pointer";
        }
      }]);
      return AElement2;
    })(TextElement);
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it) o = it;
          var i = 0;
          var F2 = function F3() {
          };
          return { s: F2, n: function n() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e2(_e) {
            throw _e;
          }, f: F2 };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err2;
      return { s: function s() {
        it = it.call(o);
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e2(_e2) {
        didErr = true;
        err2 = _e2;
      }, f: function f2() {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err2;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function ownKeys$2(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        }
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread$2(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys$2(Object(source), true).forEach(function(key) {
            _defineProperty__default["default"](target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys$2(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _createSuper$e(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$e();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$e() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    var TextPathElement = /* @__PURE__ */ (function(_TextElement) {
      _inherits__default["default"](TextPathElement2, _TextElement);
      var _super = _createSuper$e(TextPathElement2);
      function TextPathElement2(document2, node2, captureTextNodes) {
        var _this;
        _classCallCheck__default["default"](this, TextPathElement2);
        _this = _super.call(this, document2, node2, captureTextNodes);
        _this.type = "textPath";
        _this.textWidth = 0;
        _this.textHeight = 0;
        _this.pathLength = -1;
        _this.glyphInfo = null;
        _this.letterSpacingCache = [];
        _this.measuresCache = /* @__PURE__ */ new Map([["", 0]]);
        var pathElement = _this.getHrefAttribute().getDefinition();
        _this.text = _this.getTextFromNode();
        _this.dataArray = _this.parsePathData(pathElement);
        return _this;
      }
      _createClass__default["default"](TextPathElement2, [{
        key: "getText",
        value: function getText() {
          return this.text;
        }
      }, {
        key: "path",
        value: function path(ctx) {
          var dataArray = this.dataArray;
          if (ctx) {
            ctx.beginPath();
          }
          dataArray.forEach(function(_ref) {
            var type = _ref.type, points = _ref.points;
            switch (type) {
              case PathParser.LINE_TO:
                if (ctx) {
                  ctx.lineTo(points[0], points[1]);
                }
                break;
              case PathParser.MOVE_TO:
                if (ctx) {
                  ctx.moveTo(points[0], points[1]);
                }
                break;
              case PathParser.CURVE_TO:
                if (ctx) {
                  ctx.bezierCurveTo(points[0], points[1], points[2], points[3], points[4], points[5]);
                }
                break;
              case PathParser.QUAD_TO:
                if (ctx) {
                  ctx.quadraticCurveTo(points[0], points[1], points[2], points[3]);
                }
                break;
              case PathParser.ARC: {
                var _points = _slicedToArray__default["default"](points, 8), cx = _points[0], cy = _points[1], rx = _points[2], ry = _points[3], theta = _points[4], dTheta = _points[5], psi = _points[6], fs = _points[7];
                var r = rx > ry ? rx : ry;
                var scaleX = rx > ry ? 1 : rx / ry;
                var scaleY = rx > ry ? ry / rx : 1;
                if (ctx) {
                  ctx.translate(cx, cy);
                  ctx.rotate(psi);
                  ctx.scale(scaleX, scaleY);
                  ctx.arc(0, 0, r, theta, theta + dTheta, Boolean(1 - fs));
                  ctx.scale(1 / scaleX, 1 / scaleY);
                  ctx.rotate(-psi);
                  ctx.translate(-cx, -cy);
                }
                break;
              }
              case PathParser.CLOSE_PATH:
                if (ctx) {
                  ctx.closePath();
                }
                break;
            }
          });
        }
      }, {
        key: "renderChildren",
        value: function renderChildren(ctx) {
          this.setTextData(ctx);
          ctx.save();
          var textDecoration = this.parent.getStyle("text-decoration").getString();
          var fontSize2 = this.getFontSize();
          var glyphInfo = this.glyphInfo;
          var fill = ctx.fillStyle;
          if (textDecoration === "underline") {
            ctx.beginPath();
          }
          glyphInfo.forEach(function(glyph, i) {
            var p0 = glyph.p0, p1 = glyph.p1, rotation = glyph.rotation, partialText = glyph.text;
            ctx.save();
            ctx.translate(p0.x, p0.y);
            ctx.rotate(rotation);
            if (ctx.fillStyle) {
              ctx.fillText(partialText, 0, 0);
            }
            if (ctx.strokeStyle) {
              ctx.strokeText(partialText, 0, 0);
            }
            ctx.restore();
            if (textDecoration === "underline") {
              if (i === 0) {
                ctx.moveTo(p0.x, p0.y + fontSize2 / 8);
              }
              ctx.lineTo(p1.x, p1.y + fontSize2 / 5);
            }
          });
          if (textDecoration === "underline") {
            ctx.lineWidth = fontSize2 / 20;
            ctx.strokeStyle = fill;
            ctx.stroke();
            ctx.closePath();
          }
          ctx.restore();
        }
      }, {
        key: "getLetterSpacingAt",
        value: function getLetterSpacingAt() {
          var idx = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
          return this.letterSpacingCache[idx] || 0;
        }
      }, {
        key: "findSegmentToFitChar",
        value: function findSegmentToFitChar(ctx, anchor, textFullWidth, fullPathWidth, spacesNumber, inputOffset, dy, c2, charI) {
          var offset = inputOffset;
          var glyphWidth = this.measureText(ctx, c2);
          if (c2 === " " && anchor === "justify" && textFullWidth < fullPathWidth) {
            glyphWidth += (fullPathWidth - textFullWidth) / spacesNumber;
          }
          if (charI > -1) {
            offset += this.getLetterSpacingAt(charI);
          }
          var splineStep = this.textHeight / 20;
          var p0 = this.getEquidistantPointOnPath(offset, splineStep, 0);
          var p1 = this.getEquidistantPointOnPath(offset + glyphWidth, splineStep, 0);
          var segment = {
            p0,
            p1
          };
          var rotation = p0 && p1 ? Math.atan2(p1.y - p0.y, p1.x - p0.x) : 0;
          if (dy) {
            var dyX = Math.cos(Math.PI / 2 + rotation) * dy;
            var dyY = Math.cos(-rotation) * dy;
            segment.p0 = _objectSpread$2(_objectSpread$2({}, p0), {}, {
              x: p0.x + dyX,
              y: p0.y + dyY
            });
            segment.p1 = _objectSpread$2(_objectSpread$2({}, p1), {}, {
              x: p1.x + dyX,
              y: p1.y + dyY
            });
          }
          offset += glyphWidth;
          return {
            offset,
            segment,
            rotation
          };
        }
      }, {
        key: "measureText",
        value: function measureText(ctx, text) {
          var measuresCache = this.measuresCache;
          var targetText = text || this.getText();
          if (measuresCache.has(targetText)) {
            return measuresCache.get(targetText);
          }
          var measure = this.measureTargetText(ctx, targetText);
          measuresCache.set(targetText, measure);
          return measure;
        }
        // This method supposes what all custom fonts already loaded.
        // If some font will be loaded after this method call, <textPath> will not be rendered correctly.
        // You need to call this method manually to update glyphs cache.
      }, {
        key: "setTextData",
        value: function setTextData(ctx) {
          var _this2 = this;
          if (this.glyphInfo) {
            return;
          }
          var renderText = this.getText();
          var chars2 = renderText.split("");
          var spacesNumber = renderText.split(" ").length - 1;
          var dx = this.parent.getAttribute("dx").split().map(function(_) {
            return _.getPixels("x");
          });
          var dy = this.parent.getAttribute("dy").getPixels("y");
          var anchor = this.parent.getStyle("text-anchor").getString("start");
          var thisSpacing = this.getStyle("letter-spacing");
          var parentSpacing = this.parent.getStyle("letter-spacing");
          var letterSpacing2 = 0;
          if (!thisSpacing.hasValue() || thisSpacing.getValue() === "inherit") {
            letterSpacing2 = parentSpacing.getPixels();
          } else if (thisSpacing.hasValue()) {
            if (thisSpacing.getValue() !== "initial" && thisSpacing.getValue() !== "unset") {
              letterSpacing2 = thisSpacing.getPixels();
            }
          }
          var letterSpacingCache = [];
          var textLen = renderText.length;
          this.letterSpacingCache = letterSpacingCache;
          for (var i = 0; i < textLen; i++) {
            letterSpacingCache.push(typeof dx[i] !== "undefined" ? dx[i] : letterSpacing2);
          }
          var dxSum = letterSpacingCache.reduce(function(acc, cur, i2) {
            return i2 === 0 ? 0 : acc + cur || 0;
          }, 0);
          var textWidth = this.measureText(ctx);
          var textFullWidth = Math.max(textWidth + dxSum, 0);
          this.textWidth = textWidth;
          this.textHeight = this.getFontSize();
          this.glyphInfo = [];
          var fullPathWidth = this.getPathLength();
          var startOffset = this.getStyle("startOffset").getNumber(0) * fullPathWidth;
          var offset = 0;
          if (anchor === "middle" || anchor === "center") {
            offset = -textFullWidth / 2;
          }
          if (anchor === "end" || anchor === "right") {
            offset = -textFullWidth;
          }
          offset += startOffset;
          chars2.forEach(function(char, i2) {
            var _this2$findSegmentToF = _this2.findSegmentToFitChar(ctx, anchor, textFullWidth, fullPathWidth, spacesNumber, offset, dy, char, i2), nextOffset = _this2$findSegmentToF.offset, segment = _this2$findSegmentToF.segment, rotation = _this2$findSegmentToF.rotation;
            offset = nextOffset;
            if (!segment.p0 || !segment.p1) {
              return;
            }
            _this2.glyphInfo.push({
              // transposeX: midpoint.x,
              // transposeY: midpoint.y,
              text: chars2[i2],
              p0: segment.p0,
              p1: segment.p1,
              rotation
            });
          });
        }
      }, {
        key: "parsePathData",
        value: function parsePathData(path) {
          this.pathLength = -1;
          if (!path) {
            return [];
          }
          var pathCommands = [];
          var pathParser = path.pathParser;
          pathParser.reset();
          while (!pathParser.isEnd()) {
            var current = pathParser.current;
            var startX = current ? current.x : 0;
            var startY = current ? current.y : 0;
            var command = pathParser.next();
            var nextCommandType = command.type;
            var points = [];
            switch (command.type) {
              case PathParser.MOVE_TO:
                this.pathM(pathParser, points);
                break;
              case PathParser.LINE_TO:
                nextCommandType = this.pathL(pathParser, points);
                break;
              case PathParser.HORIZ_LINE_TO:
                nextCommandType = this.pathH(pathParser, points);
                break;
              case PathParser.VERT_LINE_TO:
                nextCommandType = this.pathV(pathParser, points);
                break;
              case PathParser.CURVE_TO:
                this.pathC(pathParser, points);
                break;
              case PathParser.SMOOTH_CURVE_TO:
                nextCommandType = this.pathS(pathParser, points);
                break;
              case PathParser.QUAD_TO:
                this.pathQ(pathParser, points);
                break;
              case PathParser.SMOOTH_QUAD_TO:
                nextCommandType = this.pathT(pathParser, points);
                break;
              case PathParser.ARC:
                points = this.pathA(pathParser);
                break;
              case PathParser.CLOSE_PATH:
                PathElement.pathZ(pathParser);
                break;
            }
            if (command.type !== PathParser.CLOSE_PATH) {
              pathCommands.push({
                type: nextCommandType,
                points,
                start: {
                  x: startX,
                  y: startY
                },
                pathLength: this.calcLength(startX, startY, nextCommandType, points)
              });
            } else {
              pathCommands.push({
                type: PathParser.CLOSE_PATH,
                points: [],
                pathLength: 0
              });
            }
          }
          return pathCommands;
        }
      }, {
        key: "pathM",
        value: function pathM(pathParser, points) {
          var _PathElement$pathM$po = PathElement.pathM(pathParser).point, x = _PathElement$pathM$po.x, y = _PathElement$pathM$po.y;
          points.push(x, y);
        }
      }, {
        key: "pathL",
        value: function pathL(pathParser, points) {
          var _PathElement$pathL$po = PathElement.pathL(pathParser).point, x = _PathElement$pathL$po.x, y = _PathElement$pathL$po.y;
          points.push(x, y);
          return PathParser.LINE_TO;
        }
      }, {
        key: "pathH",
        value: function pathH(pathParser, points) {
          var _PathElement$pathH$po = PathElement.pathH(pathParser).point, x = _PathElement$pathH$po.x, y = _PathElement$pathH$po.y;
          points.push(x, y);
          return PathParser.LINE_TO;
        }
      }, {
        key: "pathV",
        value: function pathV(pathParser, points) {
          var _PathElement$pathV$po = PathElement.pathV(pathParser).point, x = _PathElement$pathV$po.x, y = _PathElement$pathV$po.y;
          points.push(x, y);
          return PathParser.LINE_TO;
        }
      }, {
        key: "pathC",
        value: function pathC(pathParser, points) {
          var _PathElement$pathC = PathElement.pathC(pathParser), point = _PathElement$pathC.point, controlPoint = _PathElement$pathC.controlPoint, currentPoint = _PathElement$pathC.currentPoint;
          points.push(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
        }
      }, {
        key: "pathS",
        value: function pathS(pathParser, points) {
          var _PathElement$pathS = PathElement.pathS(pathParser), point = _PathElement$pathS.point, controlPoint = _PathElement$pathS.controlPoint, currentPoint = _PathElement$pathS.currentPoint;
          points.push(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
          return PathParser.CURVE_TO;
        }
      }, {
        key: "pathQ",
        value: function pathQ(pathParser, points) {
          var _PathElement$pathQ = PathElement.pathQ(pathParser), controlPoint = _PathElement$pathQ.controlPoint, currentPoint = _PathElement$pathQ.currentPoint;
          points.push(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
        }
      }, {
        key: "pathT",
        value: function pathT(pathParser, points) {
          var _PathElement$pathT = PathElement.pathT(pathParser), controlPoint = _PathElement$pathT.controlPoint, currentPoint = _PathElement$pathT.currentPoint;
          points.push(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
          return PathParser.QUAD_TO;
        }
      }, {
        key: "pathA",
        value: function pathA(pathParser) {
          var _PathElement$pathA = PathElement.pathA(pathParser), rX = _PathElement$pathA.rX, rY = _PathElement$pathA.rY, sweepFlag = _PathElement$pathA.sweepFlag, xAxisRotation = _PathElement$pathA.xAxisRotation, centp = _PathElement$pathA.centp, a1 = _PathElement$pathA.a1, ad = _PathElement$pathA.ad;
          if (sweepFlag === 0 && ad > 0) {
            ad -= 2 * Math.PI;
          }
          if (sweepFlag === 1 && ad < 0) {
            ad += 2 * Math.PI;
          }
          return [centp.x, centp.y, rX, rY, a1, ad, xAxisRotation, sweepFlag];
        }
      }, {
        key: "calcLength",
        value: function calcLength(x, y, commandType, points) {
          var len = 0;
          var p1 = null;
          var p2 = null;
          var t = 0;
          switch (commandType) {
            case PathParser.LINE_TO:
              return this.getLineLength(x, y, points[0], points[1]);
            case PathParser.CURVE_TO:
              len = 0;
              p1 = this.getPointOnCubicBezier(0, x, y, points[0], points[1], points[2], points[3], points[4], points[5]);
              for (t = 0.01; t <= 1; t += 0.01) {
                p2 = this.getPointOnCubicBezier(t, x, y, points[0], points[1], points[2], points[3], points[4], points[5]);
                len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);
                p1 = p2;
              }
              return len;
            case PathParser.QUAD_TO:
              len = 0;
              p1 = this.getPointOnQuadraticBezier(0, x, y, points[0], points[1], points[2], points[3]);
              for (t = 0.01; t <= 1; t += 0.01) {
                p2 = this.getPointOnQuadraticBezier(t, x, y, points[0], points[1], points[2], points[3]);
                len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);
                p1 = p2;
              }
              return len;
            case PathParser.ARC: {
              len = 0;
              var start = points[4];
              var dTheta = points[5];
              var end = points[4] + dTheta;
              var inc = Math.PI / 180;
              if (Math.abs(start - end) < inc) {
                inc = Math.abs(start - end);
              }
              p1 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], start, 0);
              if (dTheta < 0) {
                for (t = start - inc; t > end; t -= inc) {
                  p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);
                  len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);
                  p1 = p2;
                }
              } else {
                for (t = start + inc; t < end; t += inc) {
                  p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);
                  len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);
                  p1 = p2;
                }
              }
              p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], end, 0);
              len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);
              return len;
            }
          }
          return 0;
        }
      }, {
        key: "getPointOnLine",
        value: function getPointOnLine(dist, p1x, p1y, p2x, p2y) {
          var fromX = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : p1x;
          var fromY = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : p1y;
          var m2 = (p2y - p1y) / (p2x - p1x + PSEUDO_ZERO);
          var run = Math.sqrt(dist * dist / (1 + m2 * m2));
          if (p2x < p1x) {
            run *= -1;
          }
          var rise = m2 * run;
          var pt = null;
          if (p2x === p1x) {
            pt = {
              x: fromX,
              y: fromY + rise
            };
          } else if ((fromY - p1y) / (fromX - p1x + PSEUDO_ZERO) === m2) {
            pt = {
              x: fromX + run,
              y: fromY + rise
            };
          } else {
            var ix = 0;
            var iy = 0;
            var len = this.getLineLength(p1x, p1y, p2x, p2y);
            if (len < PSEUDO_ZERO) {
              return null;
            }
            var u2 = (fromX - p1x) * (p2x - p1x) + (fromY - p1y) * (p2y - p1y);
            u2 /= len * len;
            ix = p1x + u2 * (p2x - p1x);
            iy = p1y + u2 * (p2y - p1y);
            var pRise = this.getLineLength(fromX, fromY, ix, iy);
            var pRun = Math.sqrt(dist * dist - pRise * pRise);
            run = Math.sqrt(pRun * pRun / (1 + m2 * m2));
            if (p2x < p1x) {
              run *= -1;
            }
            rise = m2 * run;
            pt = {
              x: ix + run,
              y: iy + rise
            };
          }
          return pt;
        }
      }, {
        key: "getPointOnPath",
        value: function getPointOnPath(distance2) {
          var fullLen = this.getPathLength();
          var cumulativePathLength = 0;
          var p = null;
          if (distance2 < -5e-5 || distance2 - 5e-5 > fullLen) {
            return null;
          }
          var dataArray = this.dataArray;
          var _iterator = _createForOfIteratorHelper(dataArray), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var command = _step.value;
              if (command && (command.pathLength < 5e-5 || cumulativePathLength + command.pathLength + 5e-5 < distance2)) {
                cumulativePathLength += command.pathLength;
                continue;
              }
              var delta = distance2 - cumulativePathLength;
              var currentT = 0;
              switch (command.type) {
                case PathParser.LINE_TO:
                  p = this.getPointOnLine(delta, command.start.x, command.start.y, command.points[0], command.points[1], command.start.x, command.start.y);
                  break;
                case PathParser.ARC: {
                  var start = command.points[4];
                  var dTheta = command.points[5];
                  var end = command.points[4] + dTheta;
                  currentT = start + delta / command.pathLength * dTheta;
                  if (dTheta < 0 && currentT < end || dTheta >= 0 && currentT > end) {
                    break;
                  }
                  p = this.getPointOnEllipticalArc(command.points[0], command.points[1], command.points[2], command.points[3], currentT, command.points[6]);
                  break;
                }
                case PathParser.CURVE_TO:
                  currentT = delta / command.pathLength;
                  if (currentT > 1) {
                    currentT = 1;
                  }
                  p = this.getPointOnCubicBezier(currentT, command.start.x, command.start.y, command.points[0], command.points[1], command.points[2], command.points[3], command.points[4], command.points[5]);
                  break;
                case PathParser.QUAD_TO:
                  currentT = delta / command.pathLength;
                  if (currentT > 1) {
                    currentT = 1;
                  }
                  p = this.getPointOnQuadraticBezier(currentT, command.start.x, command.start.y, command.points[0], command.points[1], command.points[2], command.points[3]);
                  break;
                default:
              }
              if (p) {
                return p;
              }
              break;
            }
          } catch (err2) {
            _iterator.e(err2);
          } finally {
            _iterator.f();
          }
          return null;
        }
      }, {
        key: "getLineLength",
        value: function getLineLength(x1, y1, x2, y2) {
          return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
        }
      }, {
        key: "getPathLength",
        value: function getPathLength() {
          if (this.pathLength === -1) {
            this.pathLength = this.dataArray.reduce(function(length, command) {
              return command.pathLength > 0 ? length + command.pathLength : length;
            }, 0);
          }
          return this.pathLength;
        }
      }, {
        key: "getPointOnCubicBezier",
        value: function getPointOnCubicBezier(pct, p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {
          var x = p4x * CB1(pct) + p3x * CB2(pct) + p2x * CB3(pct) + p1x * CB4(pct);
          var y = p4y * CB1(pct) + p3y * CB2(pct) + p2y * CB3(pct) + p1y * CB4(pct);
          return {
            x,
            y
          };
        }
      }, {
        key: "getPointOnQuadraticBezier",
        value: function getPointOnQuadraticBezier(pct, p1x, p1y, p2x, p2y, p3x, p3y) {
          var x = p3x * QB1(pct) + p2x * QB2(pct) + p1x * QB3(pct);
          var y = p3y * QB1(pct) + p2y * QB2(pct) + p1y * QB3(pct);
          return {
            x,
            y
          };
        }
      }, {
        key: "getPointOnEllipticalArc",
        value: function getPointOnEllipticalArc(cx, cy, rx, ry, theta, psi) {
          var cosPsi = Math.cos(psi);
          var sinPsi = Math.sin(psi);
          var pt = {
            x: rx * Math.cos(theta),
            y: ry * Math.sin(theta)
          };
          return {
            x: cx + (pt.x * cosPsi - pt.y * sinPsi),
            y: cy + (pt.x * sinPsi + pt.y * cosPsi)
          };
        }
        // TODO need some optimisations. possibly build cache only for curved segments?
      }, {
        key: "buildEquidistantCache",
        value: function buildEquidistantCache(inputStep, inputPrecision) {
          var fullLen = this.getPathLength();
          var precision = inputPrecision || 0.25;
          var step = inputStep || fullLen / 100;
          if (!this.equidistantCache || this.equidistantCache.step !== step || this.equidistantCache.precision !== precision) {
            this.equidistantCache = {
              step,
              precision,
              points: []
            };
            var s = 0;
            for (var l = 0; l <= fullLen; l += precision) {
              var p0 = this.getPointOnPath(l);
              var p1 = this.getPointOnPath(l + precision);
              if (!p0 || !p1) {
                continue;
              }
              s += this.getLineLength(p0.x, p0.y, p1.x, p1.y);
              if (s >= step) {
                this.equidistantCache.points.push({
                  x: p0.x,
                  y: p0.y,
                  distance: l
                });
                s -= step;
              }
            }
          }
        }
      }, {
        key: "getEquidistantPointOnPath",
        value: function getEquidistantPointOnPath(targetDistance, step, precision) {
          this.buildEquidistantCache(step, precision);
          if (targetDistance < 0 || targetDistance - this.getPathLength() > 5e-5) {
            return null;
          }
          var idx = Math.round(targetDistance / this.getPathLength() * (this.equidistantCache.points.length - 1));
          return this.equidistantCache.points[idx] || null;
        }
      }]);
      return TextPathElement2;
    })(TextElement);
    function _createSuper$d(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$d();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$d() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    var dataUriRegex = /^\s*data:(([^/,;]+\/[^/,;]+)(?:;([^,;=]+=[^,;=]+))?)?(?:;(base64))?,(.*)$/i;
    var ImageElement = /* @__PURE__ */ (function(_RenderedElement) {
      _inherits__default["default"](ImageElement2, _RenderedElement);
      var _super = _createSuper$d(ImageElement2);
      function ImageElement2(document2, node2, captureTextNodes) {
        var _this;
        _classCallCheck__default["default"](this, ImageElement2);
        _this = _super.call(this, document2, node2, captureTextNodes);
        _this.type = "image";
        _this.loaded = false;
        var href = _this.getHrefAttribute().getString();
        if (!href) {
          return _possibleConstructorReturn__default["default"](_this);
        }
        var isSvg = href.endsWith(".svg") || /^\s*data:image\/svg\+xml/i.test(href);
        document2.images.push(_assertThisInitialized__default["default"](_this));
        if (!isSvg) {
          void _this.loadImage(href);
        } else {
          void _this.loadSvg(href);
        }
        _this.isSvg = isSvg;
        return _this;
      }
      _createClass__default["default"](ImageElement2, [{
        key: "loadImage",
        value: (function() {
          var _loadImage = _asyncToGenerator__default["default"](/* @__PURE__ */ _regeneratorRuntime__default["default"].mark(function _callee(href) {
            var image2;
            return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.prev = 0;
                    _context.next = 3;
                    return this.document.createImage(href);
                  case 3:
                    image2 = _context.sent;
                    this.image = image2;
                    _context.next = 10;
                    break;
                  case 7:
                    _context.prev = 7;
                    _context.t0 = _context["catch"](0);
                    console.error('Error while loading image "'.concat(href, '":'), _context.t0);
                  case 10:
                    this.loaded = true;
                  case 11:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this, [[0, 7]]);
          }));
          function loadImage(_x) {
            return _loadImage.apply(this, arguments);
          }
          return loadImage;
        })()
      }, {
        key: "loadSvg",
        value: (function() {
          var _loadSvg = _asyncToGenerator__default["default"](/* @__PURE__ */ _regeneratorRuntime__default["default"].mark(function _callee2(href) {
            var match, data, response, svg;
            return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    match = dataUriRegex.exec(href);
                    if (!match) {
                      _context2.next = 6;
                      break;
                    }
                    data = match[5];
                    if (match[4] === "base64") {
                      this.image = atob(data);
                    } else {
                      this.image = decodeURIComponent(data);
                    }
                    _context2.next = 19;
                    break;
                  case 6:
                    _context2.prev = 6;
                    _context2.next = 9;
                    return this.document.fetch(href);
                  case 9:
                    response = _context2.sent;
                    _context2.next = 12;
                    return response.text();
                  case 12:
                    svg = _context2.sent;
                    this.image = svg;
                    _context2.next = 19;
                    break;
                  case 16:
                    _context2.prev = 16;
                    _context2.t0 = _context2["catch"](6);
                    console.error('Error while loading image "'.concat(href, '":'), _context2.t0);
                  case 19:
                    this.loaded = true;
                  case 20:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this, [[6, 16]]);
          }));
          function loadSvg(_x2) {
            return _loadSvg.apply(this, arguments);
          }
          return loadSvg;
        })()
      }, {
        key: "renderChildren",
        value: function renderChildren(ctx) {
          var document2 = this.document, image2 = this.image, loaded = this.loaded;
          var x = this.getAttribute("x").getPixels("x");
          var y = this.getAttribute("y").getPixels("y");
          var width = this.getStyle("width").getPixels("x");
          var height = this.getStyle("height").getPixels("y");
          if (!loaded || !image2 || !width || !height) {
            return;
          }
          ctx.save();
          ctx.translate(x, y);
          if (this.isSvg) {
            var subDocument = document2.canvg.forkString(ctx, this.image, {
              ignoreMouse: true,
              ignoreAnimation: true,
              ignoreDimensions: true,
              ignoreClear: true,
              offsetX: 0,
              offsetY: 0,
              scaleWidth: width,
              scaleHeight: height
            });
            subDocument.document.documentElement.parent = this;
            void subDocument.render();
          } else {
            var _image = this.image;
            document2.setViewBox({
              ctx,
              aspectRatio: this.getAttribute("preserveAspectRatio").getString(),
              width,
              desiredWidth: _image.width,
              height,
              desiredHeight: _image.height
            });
            if (this.loaded) {
              if (typeof _image.complete === "undefined" || _image.complete) {
                ctx.drawImage(_image, 0, 0);
              }
            }
          }
          ctx.restore();
        }
      }, {
        key: "getBoundingBox",
        value: function getBoundingBox() {
          var x = this.getAttribute("x").getPixels("x");
          var y = this.getAttribute("y").getPixels("y");
          var width = this.getStyle("width").getPixels("x");
          var height = this.getStyle("height").getPixels("y");
          return new BoundingBox(x, y, x + width, y + height);
        }
      }]);
      return ImageElement2;
    })(RenderedElement);
    function _createSuper$c(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$c();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$c() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    var SymbolElement = /* @__PURE__ */ (function(_RenderedElement) {
      _inherits__default["default"](SymbolElement2, _RenderedElement);
      var _super = _createSuper$c(SymbolElement2);
      function SymbolElement2() {
        var _this;
        _classCallCheck__default["default"](this, SymbolElement2);
        _this = _super.apply(this, arguments);
        _this.type = "symbol";
        return _this;
      }
      _createClass__default["default"](SymbolElement2, [{
        key: "render",
        value: function render(_) {
        }
      }]);
      return SymbolElement2;
    })(RenderedElement);
    var SVGFontLoader = /* @__PURE__ */ (function() {
      function SVGFontLoader2(document2) {
        _classCallCheck__default["default"](this, SVGFontLoader2);
        this.document = document2;
        this.loaded = false;
        document2.fonts.push(this);
      }
      _createClass__default["default"](SVGFontLoader2, [{
        key: "load",
        value: (function() {
          var _load = _asyncToGenerator__default["default"](/* @__PURE__ */ _regeneratorRuntime__default["default"].mark(function _callee(fontFamily2, url) {
            var document2, svgDocument, fonts;
            return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.prev = 0;
                    document2 = this.document;
                    _context.next = 4;
                    return document2.canvg.parser.load(url);
                  case 4:
                    svgDocument = _context.sent;
                    fonts = svgDocument.getElementsByTagName("font");
                    Array.from(fonts).forEach(function(fontNode) {
                      var font = document2.createElement(fontNode);
                      document2.definitions[fontFamily2] = font;
                    });
                    _context.next = 12;
                    break;
                  case 9:
                    _context.prev = 9;
                    _context.t0 = _context["catch"](0);
                    console.error('Error while loading font "'.concat(url, '":'), _context.t0);
                  case 12:
                    this.loaded = true;
                  case 13:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this, [[0, 9]]);
          }));
          function load(_x, _x2) {
            return _load.apply(this, arguments);
          }
          return load;
        })()
      }]);
      return SVGFontLoader2;
    })();
    function _createSuper$b(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$b();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$b() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    var StyleElement = /* @__PURE__ */ (function(_Element) {
      _inherits__default["default"](StyleElement2, _Element);
      var _super = _createSuper$b(StyleElement2);
      function StyleElement2(document2, node2, captureTextNodes) {
        var _this;
        _classCallCheck__default["default"](this, StyleElement2);
        _this = _super.call(this, document2, node2, captureTextNodes);
        _this.type = "style";
        var css = compressSpaces(
          Array.from(node2.childNodes).map(function(_) {
            return _.textContent;
          }).join("").replace(/(\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+\/)|(^[\s]*\/\/.*)/gm, "").replace(/@import.*;/g, "")
          // remove imports
        );
        var cssDefs = css.split("}");
        cssDefs.forEach(function(_) {
          var def = _.trim();
          if (!def) {
            return;
          }
          var cssParts = def.split("{");
          var cssClasses = cssParts[0].split(",");
          var cssProps = cssParts[1].split(";");
          cssClasses.forEach(function(_2) {
            var cssClass = _2.trim();
            if (!cssClass) {
              return;
            }
            var props = document2.styles[cssClass] || {};
            cssProps.forEach(function(cssProp) {
              var prop = cssProp.indexOf(":");
              var name = cssProp.substr(0, prop).trim();
              var value = cssProp.substr(prop + 1, cssProp.length - prop).trim();
              if (name && value) {
                props[name] = new Property(document2, name, value);
              }
            });
            document2.styles[cssClass] = props;
            document2.stylesSpecificity[cssClass] = getSelectorSpecificity(cssClass);
            if (cssClass === "@font-face") {
              var fontFamily2 = props["font-family"].getString().replace(/"|'/g, "");
              var srcs = props.src.getString().split(",");
              srcs.forEach(function(src) {
                if (src.indexOf('format("svg")') > 0) {
                  var url = parseExternalUrl(src);
                  if (url) {
                    void new SVGFontLoader(document2).load(fontFamily2, url);
                  }
                }
              });
            }
          });
        });
        return _this;
      }
      return StyleElement2;
    })(Element);
    StyleElement.parseExternalUrl = parseExternalUrl;
    function _createSuper$a(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$a();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$a() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    var UseElement = /* @__PURE__ */ (function(_RenderedElement) {
      _inherits__default["default"](UseElement2, _RenderedElement);
      var _super = _createSuper$a(UseElement2);
      function UseElement2() {
        var _this;
        _classCallCheck__default["default"](this, UseElement2);
        _this = _super.apply(this, arguments);
        _this.type = "use";
        return _this;
      }
      _createClass__default["default"](UseElement2, [{
        key: "setContext",
        value: function setContext(ctx) {
          _get__default["default"](_getPrototypeOf__default["default"](UseElement2.prototype), "setContext", this).call(this, ctx);
          var xAttr = this.getAttribute("x");
          var yAttr = this.getAttribute("y");
          if (xAttr.hasValue()) {
            ctx.translate(xAttr.getPixels("x"), 0);
          }
          if (yAttr.hasValue()) {
            ctx.translate(0, yAttr.getPixels("y"));
          }
        }
      }, {
        key: "path",
        value: function path(ctx) {
          var element = this.element;
          if (element) {
            element.path(ctx);
          }
        }
      }, {
        key: "renderChildren",
        value: function renderChildren(ctx) {
          var document2 = this.document, element = this.element;
          if (element) {
            var tempSvg = element;
            if (element.type === "symbol") {
              tempSvg = new SVGElement(document2, null);
              tempSvg.attributes.viewBox = new Property(document2, "viewBox", element.getAttribute("viewBox").getString());
              tempSvg.attributes.preserveAspectRatio = new Property(document2, "preserveAspectRatio", element.getAttribute("preserveAspectRatio").getString());
              tempSvg.attributes.overflow = new Property(document2, "overflow", element.getAttribute("overflow").getString());
              tempSvg.children = element.children;
              element.styles.opacity = new Property(document2, "opacity", this.calculateOpacity());
            }
            if (tempSvg.type === "svg") {
              var widthStyle = this.getStyle("width", false, true);
              var heightStyle = this.getStyle("height", false, true);
              if (widthStyle.hasValue()) {
                tempSvg.attributes.width = new Property(document2, "width", widthStyle.getString());
              }
              if (heightStyle.hasValue()) {
                tempSvg.attributes.height = new Property(document2, "height", heightStyle.getString());
              }
            }
            var oldParent = tempSvg.parent;
            tempSvg.parent = this;
            tempSvg.render(ctx);
            tempSvg.parent = oldParent;
          }
        }
      }, {
        key: "getBoundingBox",
        value: function getBoundingBox(ctx) {
          var element = this.element;
          if (element) {
            return element.getBoundingBox(ctx);
          }
          return null;
        }
      }, {
        key: "elementTransform",
        value: function elementTransform() {
          var document2 = this.document, element = this.element;
          return Transform.fromElement(document2, element);
        }
      }, {
        key: "element",
        get: function get() {
          if (!this.cachedElement) {
            this.cachedElement = this.getHrefAttribute().getDefinition();
          }
          return this.cachedElement;
        }
      }]);
      return UseElement2;
    })(RenderedElement);
    function _createSuper$9(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$9();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$9() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function imGet(img, x, y, width, _height, rgba) {
      return img[y * width * 4 + x * 4 + rgba];
    }
    function imSet(img, x, y, width, _height, rgba, val) {
      img[y * width * 4 + x * 4 + rgba] = val;
    }
    function m(matrix2, i, v) {
      var mi = matrix2[i];
      return mi * v;
    }
    function c(a2, m1, m2, m3) {
      return m1 + Math.cos(a2) * m2 + Math.sin(a2) * m3;
    }
    var FeColorMatrixElement = /* @__PURE__ */ (function(_Element) {
      _inherits__default["default"](FeColorMatrixElement2, _Element);
      var _super = _createSuper$9(FeColorMatrixElement2);
      function FeColorMatrixElement2(document2, node2, captureTextNodes) {
        var _this;
        _classCallCheck__default["default"](this, FeColorMatrixElement2);
        _this = _super.call(this, document2, node2, captureTextNodes);
        _this.type = "feColorMatrix";
        var matrix2 = toNumbers(_this.getAttribute("values").getString());
        switch (_this.getAttribute("type").getString("matrix")) {
          // http://www.w3.org/TR/SVG/filters.html#feColorMatrixElement
          case "saturate": {
            var s = matrix2[0];
            matrix2 = [0.213 + 0.787 * s, 0.715 - 0.715 * s, 0.072 - 0.072 * s, 0, 0, 0.213 - 0.213 * s, 0.715 + 0.285 * s, 0.072 - 0.072 * s, 0, 0, 0.213 - 0.213 * s, 0.715 - 0.715 * s, 0.072 + 0.928 * s, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1];
            break;
          }
          case "hueRotate": {
            var a2 = matrix2[0] * Math.PI / 180;
            matrix2 = [c(a2, 0.213, 0.787, -0.213), c(a2, 0.715, -0.715, -0.715), c(a2, 0.072, -0.072, 0.928), 0, 0, c(a2, 0.213, -0.213, 0.143), c(a2, 0.715, 0.285, 0.14), c(a2, 0.072, -0.072, -0.283), 0, 0, c(a2, 0.213, -0.213, -0.787), c(a2, 0.715, -0.715, 0.715), c(a2, 0.072, 0.928, 0.072), 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1];
            break;
          }
          case "luminanceToAlpha":
            matrix2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.2125, 0.7154, 0.0721, 0, 0, 0, 0, 0, 0, 1];
            break;
        }
        _this.matrix = matrix2;
        _this.includeOpacity = _this.getAttribute("includeOpacity").hasValue();
        return _this;
      }
      _createClass__default["default"](FeColorMatrixElement2, [{
        key: "apply",
        value: function apply(ctx, _x, _y, width, height) {
          var includeOpacity = this.includeOpacity, matrix2 = this.matrix;
          var srcData = ctx.getImageData(0, 0, width, height);
          for (var y = 0; y < height; y++) {
            for (var x = 0; x < width; x++) {
              var r = imGet(srcData.data, x, y, width, height, 0);
              var g = imGet(srcData.data, x, y, width, height, 1);
              var b = imGet(srcData.data, x, y, width, height, 2);
              var a2 = imGet(srcData.data, x, y, width, height, 3);
              var nr = m(matrix2, 0, r) + m(matrix2, 1, g) + m(matrix2, 2, b) + m(matrix2, 3, a2) + m(matrix2, 4, 1);
              var ng = m(matrix2, 5, r) + m(matrix2, 6, g) + m(matrix2, 7, b) + m(matrix2, 8, a2) + m(matrix2, 9, 1);
              var nb = m(matrix2, 10, r) + m(matrix2, 11, g) + m(matrix2, 12, b) + m(matrix2, 13, a2) + m(matrix2, 14, 1);
              var na = m(matrix2, 15, r) + m(matrix2, 16, g) + m(matrix2, 17, b) + m(matrix2, 18, a2) + m(matrix2, 19, 1);
              if (includeOpacity) {
                nr = 0;
                ng = 0;
                nb = 0;
                na *= a2 / 255;
              }
              imSet(srcData.data, x, y, width, height, 0, nr);
              imSet(srcData.data, x, y, width, height, 1, ng);
              imSet(srcData.data, x, y, width, height, 2, nb);
              imSet(srcData.data, x, y, width, height, 3, na);
            }
          }
          ctx.clearRect(0, 0, width, height);
          ctx.putImageData(srcData, 0, 0);
        }
      }]);
      return FeColorMatrixElement2;
    })(Element);
    function _createSuper$8(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$8();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$8() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    var MaskElement = /* @__PURE__ */ (function(_Element) {
      _inherits__default["default"](MaskElement2, _Element);
      var _super = _createSuper$8(MaskElement2);
      function MaskElement2() {
        var _this;
        _classCallCheck__default["default"](this, MaskElement2);
        _this = _super.apply(this, arguments);
        _this.type = "mask";
        return _this;
      }
      _createClass__default["default"](MaskElement2, [{
        key: "apply",
        value: function apply(ctx, element) {
          var document2 = this.document;
          var x = this.getAttribute("x").getPixels("x");
          var y = this.getAttribute("y").getPixels("y");
          var width = this.getStyle("width").getPixels("x");
          var height = this.getStyle("height").getPixels("y");
          if (!width && !height) {
            var boundingBox = new BoundingBox();
            this.children.forEach(function(child) {
              boundingBox.addBoundingBox(child.getBoundingBox(ctx));
            });
            x = Math.floor(boundingBox.x1);
            y = Math.floor(boundingBox.y1);
            width = Math.floor(boundingBox.width);
            height = Math.floor(boundingBox.height);
          }
          var ignoredStyles = this.removeStyles(element, MaskElement2.ignoreStyles);
          var maskCanvas = document2.createCanvas(x + width, y + height);
          var maskCtx = maskCanvas.getContext("2d");
          document2.screen.setDefaults(maskCtx);
          this.renderChildren(maskCtx);
          new FeColorMatrixElement(document2, {
            nodeType: 1,
            childNodes: [],
            attributes: [{
              nodeName: "type",
              value: "luminanceToAlpha"
            }, {
              nodeName: "includeOpacity",
              value: "true"
            }]
          }).apply(maskCtx, 0, 0, x + width, y + height);
          var tmpCanvas = document2.createCanvas(x + width, y + height);
          var tmpCtx = tmpCanvas.getContext("2d");
          document2.screen.setDefaults(tmpCtx);
          element.render(tmpCtx);
          tmpCtx.globalCompositeOperation = "destination-in";
          tmpCtx.fillStyle = maskCtx.createPattern(maskCanvas, "no-repeat");
          tmpCtx.fillRect(0, 0, x + width, y + height);
          ctx.fillStyle = tmpCtx.createPattern(tmpCanvas, "no-repeat");
          ctx.fillRect(0, 0, x + width, y + height);
          this.restoreStyles(element, ignoredStyles);
        }
      }, {
        key: "render",
        value: function render(_) {
        }
      }]);
      return MaskElement2;
    })(Element);
    MaskElement.ignoreStyles = ["mask", "transform", "clip-path"];
    function _createSuper$7(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$7();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$7() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    var noop = function noop2() {
    };
    var ClipPathElement = /* @__PURE__ */ (function(_Element) {
      _inherits__default["default"](ClipPathElement2, _Element);
      var _super = _createSuper$7(ClipPathElement2);
      function ClipPathElement2() {
        var _this;
        _classCallCheck__default["default"](this, ClipPathElement2);
        _this = _super.apply(this, arguments);
        _this.type = "clipPath";
        return _this;
      }
      _createClass__default["default"](ClipPathElement2, [{
        key: "apply",
        value: function apply(ctx) {
          var document2 = this.document;
          var contextProto = Reflect.getPrototypeOf(ctx);
          var beginPath = ctx.beginPath, closePath = ctx.closePath;
          if (contextProto) {
            contextProto.beginPath = noop;
            contextProto.closePath = noop;
          }
          Reflect.apply(beginPath, ctx, []);
          this.children.forEach(function(child) {
            if (typeof child.path === "undefined") {
              return;
            }
            var transform2 = typeof child.elementTransform !== "undefined" ? child.elementTransform() : null;
            if (!transform2) {
              transform2 = Transform.fromElement(document2, child);
            }
            if (transform2) {
              transform2.apply(ctx);
            }
            child.path(ctx);
            if (contextProto) {
              contextProto.closePath = closePath;
            }
            if (transform2) {
              transform2.unapply(ctx);
            }
          });
          Reflect.apply(closePath, ctx, []);
          ctx.clip();
          if (contextProto) {
            contextProto.beginPath = beginPath;
            contextProto.closePath = closePath;
          }
        }
      }, {
        key: "render",
        value: function render(_) {
        }
      }]);
      return ClipPathElement2;
    })(Element);
    function _createSuper$6(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$6();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$6() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    var FilterElement = /* @__PURE__ */ (function(_Element) {
      _inherits__default["default"](FilterElement2, _Element);
      var _super = _createSuper$6(FilterElement2);
      function FilterElement2() {
        var _this;
        _classCallCheck__default["default"](this, FilterElement2);
        _this = _super.apply(this, arguments);
        _this.type = "filter";
        return _this;
      }
      _createClass__default["default"](FilterElement2, [{
        key: "apply",
        value: function apply(ctx, element) {
          var document2 = this.document, children = this.children;
          var boundingBox = element.getBoundingBox(ctx);
          if (!boundingBox) {
            return;
          }
          var px = 0;
          var py = 0;
          children.forEach(function(child) {
            var efd = child.extraFilterDistance || 0;
            px = Math.max(px, efd);
            py = Math.max(py, efd);
          });
          var width = Math.floor(boundingBox.width);
          var height = Math.floor(boundingBox.height);
          var tmpCanvasWidth = width + 2 * px;
          var tmpCanvasHeight = height + 2 * py;
          if (tmpCanvasWidth < 1 || tmpCanvasHeight < 1) {
            return;
          }
          var x = Math.floor(boundingBox.x);
          var y = Math.floor(boundingBox.y);
          var ignoredStyles = this.removeStyles(element, FilterElement2.ignoreStyles);
          var tmpCanvas = document2.createCanvas(tmpCanvasWidth, tmpCanvasHeight);
          var tmpCtx = tmpCanvas.getContext("2d");
          document2.screen.setDefaults(tmpCtx);
          tmpCtx.translate(-x + px, -y + py);
          element.render(tmpCtx);
          children.forEach(function(child) {
            if (typeof child.apply === "function") {
              child.apply(tmpCtx, 0, 0, tmpCanvasWidth, tmpCanvasHeight);
            }
          });
          ctx.drawImage(tmpCanvas, 0, 0, tmpCanvasWidth, tmpCanvasHeight, x - px, y - py, tmpCanvasWidth, tmpCanvasHeight);
          this.restoreStyles(element, ignoredStyles);
        }
      }, {
        key: "render",
        value: function render(_) {
        }
      }]);
      return FilterElement2;
    })(Element);
    FilterElement.ignoreStyles = ["filter", "transform", "clip-path"];
    function _createSuper$5(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$5();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$5() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    var FeDropShadowElement = /* @__PURE__ */ (function(_Element) {
      _inherits__default["default"](FeDropShadowElement2, _Element);
      var _super = _createSuper$5(FeDropShadowElement2);
      function FeDropShadowElement2(document2, node2, captureTextNodes) {
        var _this;
        _classCallCheck__default["default"](this, FeDropShadowElement2);
        _this = _super.call(this, document2, node2, captureTextNodes);
        _this.type = "feDropShadow";
        _this.addStylesFromStyleDefinition();
        return _this;
      }
      _createClass__default["default"](FeDropShadowElement2, [{
        key: "apply",
        value: function apply(_, _x, _y, _width, _height) {
        }
      }]);
      return FeDropShadowElement2;
    })(Element);
    function _createSuper$4(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$4();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$4() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    var FeMorphologyElement = /* @__PURE__ */ (function(_Element) {
      _inherits__default["default"](FeMorphologyElement2, _Element);
      var _super = _createSuper$4(FeMorphologyElement2);
      function FeMorphologyElement2() {
        var _this;
        _classCallCheck__default["default"](this, FeMorphologyElement2);
        _this = _super.apply(this, arguments);
        _this.type = "feMorphology";
        return _this;
      }
      _createClass__default["default"](FeMorphologyElement2, [{
        key: "apply",
        value: function apply(_, _x, _y, _width, _height) {
        }
      }]);
      return FeMorphologyElement2;
    })(Element);
    function _createSuper$3(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$3();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$3() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    var FeCompositeElement = /* @__PURE__ */ (function(_Element) {
      _inherits__default["default"](FeCompositeElement2, _Element);
      var _super = _createSuper$3(FeCompositeElement2);
      function FeCompositeElement2() {
        var _this;
        _classCallCheck__default["default"](this, FeCompositeElement2);
        _this = _super.apply(this, arguments);
        _this.type = "feComposite";
        return _this;
      }
      _createClass__default["default"](FeCompositeElement2, [{
        key: "apply",
        value: function apply(_, _x, _y, _width, _height) {
        }
      }]);
      return FeCompositeElement2;
    })(Element);
    function _createSuper$2(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$2() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    var FeGaussianBlurElement = /* @__PURE__ */ (function(_Element) {
      _inherits__default["default"](FeGaussianBlurElement2, _Element);
      var _super = _createSuper$2(FeGaussianBlurElement2);
      function FeGaussianBlurElement2(document2, node2, captureTextNodes) {
        var _this;
        _classCallCheck__default["default"](this, FeGaussianBlurElement2);
        _this = _super.call(this, document2, node2, captureTextNodes);
        _this.type = "feGaussianBlur";
        _this.blurRadius = Math.floor(_this.getAttribute("stdDeviation").getNumber());
        _this.extraFilterDistance = _this.blurRadius;
        return _this;
      }
      _createClass__default["default"](FeGaussianBlurElement2, [{
        key: "apply",
        value: function apply(ctx, x, y, width, height) {
          var document2 = this.document, blurRadius = this.blurRadius;
          var body = document2.window ? document2.window.document.body : null;
          var canvas = ctx.canvas;
          canvas.id = document2.getUniqueId();
          if (body) {
            canvas.style.display = "none";
            body.appendChild(canvas);
          }
          stackblurCanvas.canvasRGBA(canvas, x, y, width, height, blurRadius);
          if (body) {
            body.removeChild(canvas);
          }
        }
      }]);
      return FeGaussianBlurElement2;
    })(Element);
    function _createSuper$1(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$1() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    var TitleElement = /* @__PURE__ */ (function(_Element) {
      _inherits__default["default"](TitleElement2, _Element);
      var _super = _createSuper$1(TitleElement2);
      function TitleElement2() {
        var _this;
        _classCallCheck__default["default"](this, TitleElement2);
        _this = _super.apply(this, arguments);
        _this.type = "title";
        return _this;
      }
      return TitleElement2;
    })(Element);
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    var DescElement = /* @__PURE__ */ (function(_Element) {
      _inherits__default["default"](DescElement2, _Element);
      var _super = _createSuper(DescElement2);
      function DescElement2() {
        var _this;
        _classCallCheck__default["default"](this, DescElement2);
        _this = _super.apply(this, arguments);
        _this.type = "desc";
        return _this;
      }
      return DescElement2;
    })(Element);
    var elements = {
      "svg": SVGElement,
      "rect": RectElement,
      "circle": CircleElement,
      "ellipse": EllipseElement,
      "line": LineElement,
      "polyline": PolylineElement,
      "polygon": PolygonElement,
      "path": PathElement,
      "pattern": PatternElement,
      "marker": MarkerElement,
      "defs": DefsElement,
      "linearGradient": LinearGradientElement,
      "radialGradient": RadialGradientElement,
      "stop": StopElement,
      "animate": AnimateElement,
      "animateColor": AnimateColorElement,
      "animateTransform": AnimateTransformElement,
      "font": FontElement,
      "font-face": FontFaceElement,
      "missing-glyph": MissingGlyphElement,
      "glyph": GlyphElement,
      "text": TextElement,
      "tspan": TSpanElement,
      "tref": TRefElement,
      "a": AElement,
      "textPath": TextPathElement,
      "image": ImageElement,
      "g": GElement,
      "symbol": SymbolElement,
      "style": StyleElement,
      "use": UseElement,
      "mask": MaskElement,
      "clipPath": ClipPathElement,
      "filter": FilterElement,
      "feDropShadow": FeDropShadowElement,
      "feMorphology": FeMorphologyElement,
      "feComposite": FeCompositeElement,
      "feColorMatrix": FeColorMatrixElement,
      "feGaussianBlur": FeGaussianBlurElement,
      "title": TitleElement,
      "desc": DescElement
    };
    function ownKeys$1(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        }
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread$1(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys$1(Object(source), true).forEach(function(key) {
            _defineProperty__default["default"](target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys$1(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function createCanvas(width, height) {
      var canvas = document.createElement("canvas");
      canvas.width = width;
      canvas.height = height;
      return canvas;
    }
    function createImage(_x) {
      return _createImage.apply(this, arguments);
    }
    function _createImage() {
      _createImage = _asyncToGenerator__default["default"](/* @__PURE__ */ _regeneratorRuntime__default["default"].mark(function _callee(src) {
        var anonymousCrossOrigin, image2, _args = arguments;
        return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                anonymousCrossOrigin = _args.length > 1 && _args[1] !== void 0 ? _args[1] : false;
                image2 = document.createElement("img");
                if (anonymousCrossOrigin) {
                  image2.crossOrigin = "Anonymous";
                }
                return _context.abrupt("return", new Promise(function(resolve, reject) {
                  image2.onload = function() {
                    resolve(image2);
                  };
                  image2.onerror = function(_event, _source, _lineno, _colno, error) {
                    reject(error);
                  };
                  image2.src = src;
                }));
              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));
      return _createImage.apply(this, arguments);
    }
    var Document = /* @__PURE__ */ (function() {
      function Document2(canvg) {
        var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$rootEmSize = _ref.rootEmSize, rootEmSize = _ref$rootEmSize === void 0 ? 12 : _ref$rootEmSize, _ref$emSize = _ref.emSize, emSize = _ref$emSize === void 0 ? 12 : _ref$emSize, _ref$createCanvas = _ref.createCanvas, createCanvas2 = _ref$createCanvas === void 0 ? Document2.createCanvas : _ref$createCanvas, _ref$createImage = _ref.createImage, createImage2 = _ref$createImage === void 0 ? Document2.createImage : _ref$createImage, anonymousCrossOrigin = _ref.anonymousCrossOrigin;
        _classCallCheck__default["default"](this, Document2);
        this.canvg = canvg;
        this.definitions = /* @__PURE__ */ Object.create(null);
        this.styles = /* @__PURE__ */ Object.create(null);
        this.stylesSpecificity = /* @__PURE__ */ Object.create(null);
        this.images = [];
        this.fonts = [];
        this.emSizeStack = [];
        this.uniqueId = 0;
        this.screen = canvg.screen;
        this.rootEmSize = rootEmSize;
        this.emSize = emSize;
        this.createCanvas = createCanvas2;
        this.createImage = this.bindCreateImage(createImage2, anonymousCrossOrigin);
        this.screen.wait(this.isImagesLoaded.bind(this));
        this.screen.wait(this.isFontsLoaded.bind(this));
      }
      _createClass__default["default"](Document2, [{
        key: "bindCreateImage",
        value: function bindCreateImage(createImage2, anonymousCrossOrigin) {
          if (typeof anonymousCrossOrigin === "boolean") {
            return function(source, forceAnonymousCrossOrigin) {
              return createImage2(source, typeof forceAnonymousCrossOrigin === "boolean" ? forceAnonymousCrossOrigin : anonymousCrossOrigin);
            };
          }
          return createImage2;
        }
      }, {
        key: "popEmSize",
        value: function popEmSize() {
          var emSizeStack = this.emSizeStack;
          emSizeStack.pop();
        }
      }, {
        key: "getUniqueId",
        value: function getUniqueId() {
          return "canvg".concat(++this.uniqueId);
        }
      }, {
        key: "isImagesLoaded",
        value: function isImagesLoaded() {
          return this.images.every(function(_) {
            return _.loaded;
          });
        }
      }, {
        key: "isFontsLoaded",
        value: function isFontsLoaded() {
          return this.fonts.every(function(_) {
            return _.loaded;
          });
        }
      }, {
        key: "createDocumentElement",
        value: function createDocumentElement(document2) {
          var documentElement = this.createElement(document2.documentElement);
          documentElement.root = true;
          documentElement.addStylesFromStyleDefinition();
          this.documentElement = documentElement;
          return documentElement;
        }
      }, {
        key: "createElement",
        value: function createElement(node2) {
          var elementType = node2.nodeName.replace(/^[^:]+:/, "");
          var ElementType = Document2.elementTypes[elementType];
          if (typeof ElementType !== "undefined") {
            return new ElementType(this, node2);
          }
          return new UnknownElement(this, node2);
        }
      }, {
        key: "createTextNode",
        value: function createTextNode(node2) {
          return new TextNode(this, node2);
        }
      }, {
        key: "setViewBox",
        value: function setViewBox(config) {
          this.screen.setViewBox(_objectSpread$1({
            document: this
          }, config));
        }
      }, {
        key: "window",
        get: function get() {
          return this.screen.window;
        }
      }, {
        key: "fetch",
        get: function get() {
          return this.screen.fetch;
        }
      }, {
        key: "ctx",
        get: function get() {
          return this.screen.ctx;
        }
      }, {
        key: "emSize",
        get: function get() {
          var emSizeStack = this.emSizeStack;
          return emSizeStack[emSizeStack.length - 1];
        },
        set: function set(value) {
          var emSizeStack = this.emSizeStack;
          emSizeStack.push(value);
        }
      }]);
      return Document2;
    })();
    Document.createCanvas = createCanvas;
    Document.createImage = createImage;
    Document.elementTypes = elements;
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        }
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty__default["default"](target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    var Canvg = /* @__PURE__ */ (function() {
      function Canvg2(ctx, svg) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        _classCallCheck__default["default"](this, Canvg2);
        this.parser = new Parser2(options);
        this.screen = new Screen(ctx, options);
        this.options = options;
        var document2 = new Document(this, options);
        var documentElement = document2.createDocumentElement(svg);
        this.document = document2;
        this.documentElement = documentElement;
      }
      _createClass__default["default"](Canvg2, [{
        key: "fork",
        /**
         * Create new Canvg instance with inherited options.
         * @param ctx - Rendering context.
         * @param svg - SVG source string or URL.
         * @param options - Rendering options.
         * @returns Canvg instance.
         */
        value: function fork(ctx, svg) {
          var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          return Canvg2.from(ctx, svg, _objectSpread(_objectSpread({}, this.options), options));
        }
        /**
         * Create new Canvg instance with inherited options.
         * @param ctx - Rendering context.
         * @param svg - SVG source string.
         * @param options - Rendering options.
         * @returns Canvg instance.
         */
      }, {
        key: "forkString",
        value: function forkString(ctx, svg) {
          var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          return Canvg2.fromString(ctx, svg, _objectSpread(_objectSpread({}, this.options), options));
        }
        /**
         * Document is ready promise.
         * @returns Ready promise.
         */
      }, {
        key: "ready",
        value: function ready() {
          return this.screen.ready();
        }
        /**
         * Document is ready value.
         * @returns Is ready or not.
         */
      }, {
        key: "isReady",
        value: function isReady() {
          return this.screen.isReady();
        }
        /**
         * Render only first frame, ignoring animations and mouse.
         * @param options - Rendering options.
         */
      }, {
        key: "render",
        value: (function() {
          var _render = _asyncToGenerator__default["default"](/* @__PURE__ */ _regeneratorRuntime__default["default"].mark(function _callee() {
            var options, _args = arguments;
            return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    options = _args.length > 0 && _args[0] !== void 0 ? _args[0] : {};
                    this.start(_objectSpread({
                      enableRedraw: true,
                      ignoreAnimation: true,
                      ignoreMouse: true
                    }, options));
                    _context.next = 4;
                    return this.ready();
                  case 4:
                    this.stop();
                  case 5:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function render() {
            return _render.apply(this, arguments);
          }
          return render;
        })()
        /**
         * Start rendering.
         * @param options - Render options.
         */
      }, {
        key: "start",
        value: function start() {
          var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var documentElement = this.documentElement, screen = this.screen, baseOptions = this.options;
          screen.start(documentElement, _objectSpread(_objectSpread({
            enableRedraw: true
          }, baseOptions), options));
        }
        /**
         * Stop rendering.
         */
      }, {
        key: "stop",
        value: function stop() {
          this.screen.stop();
        }
        /**
         * Resize SVG to fit in given size.
         * @param width
         * @param height
         * @param preserveAspectRatio
         */
      }, {
        key: "resize",
        value: function resize(width) {
          var height = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : width;
          var preserveAspectRatio = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
          this.documentElement.resize(width, height, preserveAspectRatio);
        }
      }], [{
        key: "from",
        value: (function() {
          var _from = _asyncToGenerator__default["default"](/* @__PURE__ */ _regeneratorRuntime__default["default"].mark(function _callee2(ctx, svg) {
            var options, parser, svgDocument, _args2 = arguments;
            return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    options = _args2.length > 2 && _args2[2] !== void 0 ? _args2[2] : {};
                    parser = new Parser2(options);
                    _context2.next = 4;
                    return parser.parse(svg);
                  case 4:
                    svgDocument = _context2.sent;
                    return _context2.abrupt("return", new Canvg2(ctx, svgDocument, options));
                  case 6:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2);
          }));
          function from(_x, _x2) {
            return _from.apply(this, arguments);
          }
          return from;
        })()
        /**
         * Create Canvg instance from SVG source string.
         * @param ctx - Rendering context.
         * @param svg - SVG source string.
         * @param options - Rendering options.
         * @returns Canvg instance.
         */
      }, {
        key: "fromString",
        value: function fromString(ctx, svg) {
          var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          var parser = new Parser2(options);
          var svgDocument = parser.parseFromString(svg);
          return new Canvg2(ctx, svgDocument, options);
        }
      }]);
      return Canvg2;
    })();
    exports.AElement = AElement;
    exports.AnimateColorElement = AnimateColorElement;
    exports.AnimateElement = AnimateElement;
    exports.AnimateTransformElement = AnimateTransformElement;
    exports.BoundingBox = BoundingBox;
    exports.CB1 = CB1;
    exports.CB2 = CB2;
    exports.CB3 = CB3;
    exports.CB4 = CB4;
    exports.Canvg = Canvg;
    exports.CircleElement = CircleElement;
    exports.ClipPathElement = ClipPathElement;
    exports.DefsElement = DefsElement;
    exports.DescElement = DescElement;
    exports.Document = Document;
    exports.Element = Element;
    exports.EllipseElement = EllipseElement;
    exports.FeColorMatrixElement = FeColorMatrixElement;
    exports.FeCompositeElement = FeCompositeElement;
    exports.FeDropShadowElement = FeDropShadowElement;
    exports.FeGaussianBlurElement = FeGaussianBlurElement;
    exports.FeMorphologyElement = FeMorphologyElement;
    exports.FilterElement = FilterElement;
    exports.Font = Font;
    exports.FontElement = FontElement;
    exports.FontFaceElement = FontFaceElement;
    exports.GElement = GElement;
    exports.GlyphElement = GlyphElement;
    exports.GradientElement = GradientElement;
    exports.ImageElement = ImageElement;
    exports.LineElement = LineElement;
    exports.LinearGradientElement = LinearGradientElement;
    exports.MarkerElement = MarkerElement;
    exports.MaskElement = MaskElement;
    exports.Matrix = Matrix;
    exports.MissingGlyphElement = MissingGlyphElement;
    exports.Mouse = Mouse;
    exports.PSEUDO_ZERO = PSEUDO_ZERO;
    exports.Parser = Parser2;
    exports.PathElement = PathElement;
    exports.PathParser = PathParser;
    exports.PatternElement = PatternElement;
    exports.Point = Point;
    exports.PolygonElement = PolygonElement;
    exports.PolylineElement = PolylineElement;
    exports.Property = Property;
    exports.QB1 = QB1;
    exports.QB2 = QB2;
    exports.QB3 = QB3;
    exports.RadialGradientElement = RadialGradientElement;
    exports.RectElement = RectElement;
    exports.RenderedElement = RenderedElement;
    exports.Rotate = Rotate;
    exports.SVGElement = SVGElement;
    exports.SVGFontLoader = SVGFontLoader;
    exports.Scale = Scale;
    exports.Screen = Screen;
    exports.Skew = Skew;
    exports.SkewX = SkewX;
    exports.SkewY = SkewY;
    exports.StopElement = StopElement;
    exports.StyleElement = StyleElement;
    exports.SymbolElement = SymbolElement;
    exports.TRefElement = TRefElement;
    exports.TSpanElement = TSpanElement;
    exports.TextElement = TextElement;
    exports.TextPathElement = TextPathElement;
    exports.TitleElement = TitleElement;
    exports.Transform = Transform;
    exports.Translate = Translate;
    exports.UnknownElement = UnknownElement;
    exports.UseElement = UseElement;
    exports.ViewPort = ViewPort;
    exports.compressSpaces = compressSpaces;
    exports["default"] = Canvg;
    exports.getSelectorSpecificity = getSelectorSpecificity;
    exports.normalizeAttributeName = normalizeAttributeName;
    exports.normalizeColor = normalizeColor;
    exports.parseExternalUrl = parseExternalUrl;
    exports.presets = index;
    exports.toNumbers = toNumbers;
    exports.trimLeft = trimLeft;
    exports.trimRight = trimRight;
    exports.vectorMagnitude = vectorMagnitude;
    exports.vectorsAngle = vectorsAngle;
    exports.vectorsRatio = vectorsRatio;
  }
});

// node_modules/jspdf/dist/jspdf.node.min.js
var require_jspdf_node_min = __commonJS({
  "node_modules/jspdf/dist/jspdf.node.min.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var t = require_node();
    var e2 = (init_lib_esm(), __toCommonJS(lib_esm_exports));
    var r = /* @__PURE__ */ (function() {
      return "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this;
    })();
    function n(t2) {
      var e3;
      t2 = t2 || "", this.ok = false, "#" == t2.charAt(0) && (t2 = t2.substr(1, 6)), t2 = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "00ffff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000000", blanchedalmond: "ffebcd", blue: "0000ff", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "00ffff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dodgerblue: "1e90ff", feldspar: "d19275", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "ff00ff", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgrey: "d3d3d3", lightgreen: "90ee90", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslateblue: "8470ff", lightslategray: "778899", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "00ff00", limegreen: "32cd32", linen: "faf0e6", magenta: "ff00ff", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370d8", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "d87093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", red: "ff0000", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", violetred: "d02090", wheat: "f5deb3", white: "ffffff", whitesmoke: "f5f5f5", yellow: "ffff00", yellowgreen: "9acd32" }[t2 = (t2 = t2.replace(/ /g, "")).toLowerCase()] || t2;
      for (var r2 = [{ re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/, example: ["rgb(123, 234, 45)", "rgb(255,234,245)"], process: function(t3) {
        return [parseInt(t3[1]), parseInt(t3[2]), parseInt(t3[3])];
      } }, { re: /^(\w{2})(\w{2})(\w{2})$/, example: ["#00ff00", "336699"], process: function(t3) {
        return [parseInt(t3[1], 16), parseInt(t3[2], 16), parseInt(t3[3], 16)];
      } }, { re: /^(\w{1})(\w{1})(\w{1})$/, example: ["#fb0", "f0f"], process: function(t3) {
        return [parseInt(t3[1] + t3[1], 16), parseInt(t3[2] + t3[2], 16), parseInt(t3[3] + t3[3], 16)];
      } }], n2 = 0; n2 < r2.length; n2++) {
        var i2 = r2[n2].re, a3 = r2[n2].process, o2 = i2.exec(t2);
        o2 && (e3 = a3(o2), this.r = e3[0], this.g = e3[1], this.b = e3[2], this.ok = true);
      }
      this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r, this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g, this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b, this.toRGB = function() {
        return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
      }, this.toHex = function() {
        var t3 = this.r.toString(16), e4 = this.g.toString(16), r3 = this.b.toString(16);
        return 1 == t3.length && (t3 = "0" + t3), 1 == e4.length && (e4 = "0" + e4), 1 == r3.length && (r3 = "0" + r3), "#" + t3 + e4 + r3;
      };
    }
    var i = r.atob.bind(r);
    var a2 = r.btoa.bind(r);
    function o() {
      r.console && "function" == typeof r.console.log && r.console.log.apply(r.console, arguments);
    }
    var s = { log: o, warn: function(t2) {
      r.console && ("function" == typeof r.console.warn ? r.console.warn.apply(r.console, arguments) : o.call(null, arguments));
    }, error: function(t2) {
      r.console && ("function" == typeof r.console.error ? r.console.error.apply(r.console, arguments) : o(t2));
    } };
    function c(t2, e3) {
      var r2 = t2[0], n2 = t2[1], i2 = t2[2], a3 = t2[3];
      r2 = l(r2, n2, i2, a3, e3[0], 7, -680876936), a3 = l(a3, r2, n2, i2, e3[1], 12, -389564586), i2 = l(i2, a3, r2, n2, e3[2], 17, 606105819), n2 = l(n2, i2, a3, r2, e3[3], 22, -1044525330), r2 = l(r2, n2, i2, a3, e3[4], 7, -176418897), a3 = l(a3, r2, n2, i2, e3[5], 12, 1200080426), i2 = l(i2, a3, r2, n2, e3[6], 17, -1473231341), n2 = l(n2, i2, a3, r2, e3[7], 22, -45705983), r2 = l(r2, n2, i2, a3, e3[8], 7, 1770035416), a3 = l(a3, r2, n2, i2, e3[9], 12, -1958414417), i2 = l(i2, a3, r2, n2, e3[10], 17, -42063), n2 = l(n2, i2, a3, r2, e3[11], 22, -1990404162), r2 = l(r2, n2, i2, a3, e3[12], 7, 1804603682), a3 = l(a3, r2, n2, i2, e3[13], 12, -40341101), i2 = l(i2, a3, r2, n2, e3[14], 17, -1502002290), r2 = h(r2, n2 = l(n2, i2, a3, r2, e3[15], 22, 1236535329), i2, a3, e3[1], 5, -165796510), a3 = h(a3, r2, n2, i2, e3[6], 9, -1069501632), i2 = h(i2, a3, r2, n2, e3[11], 14, 643717713), n2 = h(n2, i2, a3, r2, e3[0], 20, -373897302), r2 = h(r2, n2, i2, a3, e3[5], 5, -701558691), a3 = h(a3, r2, n2, i2, e3[10], 9, 38016083), i2 = h(i2, a3, r2, n2, e3[15], 14, -660478335), n2 = h(n2, i2, a3, r2, e3[4], 20, -405537848), r2 = h(r2, n2, i2, a3, e3[9], 5, 568446438), a3 = h(a3, r2, n2, i2, e3[14], 9, -1019803690), i2 = h(i2, a3, r2, n2, e3[3], 14, -187363961), n2 = h(n2, i2, a3, r2, e3[8], 20, 1163531501), r2 = h(r2, n2, i2, a3, e3[13], 5, -1444681467), a3 = h(a3, r2, n2, i2, e3[2], 9, -51403784), i2 = h(i2, a3, r2, n2, e3[7], 14, 1735328473), r2 = f2(r2, n2 = h(n2, i2, a3, r2, e3[12], 20, -1926607734), i2, a3, e3[5], 4, -378558), a3 = f2(a3, r2, n2, i2, e3[8], 11, -2022574463), i2 = f2(i2, a3, r2, n2, e3[11], 16, 1839030562), n2 = f2(n2, i2, a3, r2, e3[14], 23, -35309556), r2 = f2(r2, n2, i2, a3, e3[1], 4, -1530992060), a3 = f2(a3, r2, n2, i2, e3[4], 11, 1272893353), i2 = f2(i2, a3, r2, n2, e3[7], 16, -155497632), n2 = f2(n2, i2, a3, r2, e3[10], 23, -1094730640), r2 = f2(r2, n2, i2, a3, e3[13], 4, 681279174), a3 = f2(a3, r2, n2, i2, e3[0], 11, -358537222), i2 = f2(i2, a3, r2, n2, e3[3], 16, -722521979), n2 = f2(n2, i2, a3, r2, e3[6], 23, 76029189), r2 = f2(r2, n2, i2, a3, e3[9], 4, -640364487), a3 = f2(a3, r2, n2, i2, e3[12], 11, -421815835), i2 = f2(i2, a3, r2, n2, e3[15], 16, 530742520), r2 = d(r2, n2 = f2(n2, i2, a3, r2, e3[2], 23, -995338651), i2, a3, e3[0], 6, -198630844), a3 = d(a3, r2, n2, i2, e3[7], 10, 1126891415), i2 = d(i2, a3, r2, n2, e3[14], 15, -1416354905), n2 = d(n2, i2, a3, r2, e3[5], 21, -57434055), r2 = d(r2, n2, i2, a3, e3[12], 6, 1700485571), a3 = d(a3, r2, n2, i2, e3[3], 10, -1894986606), i2 = d(i2, a3, r2, n2, e3[10], 15, -1051523), n2 = d(n2, i2, a3, r2, e3[1], 21, -2054922799), r2 = d(r2, n2, i2, a3, e3[8], 6, 1873313359), a3 = d(a3, r2, n2, i2, e3[15], 10, -30611744), i2 = d(i2, a3, r2, n2, e3[6], 15, -1560198380), n2 = d(n2, i2, a3, r2, e3[13], 21, 1309151649), r2 = d(r2, n2, i2, a3, e3[4], 6, -145523070), a3 = d(a3, r2, n2, i2, e3[11], 10, -1120210379), i2 = d(i2, a3, r2, n2, e3[2], 15, 718787259), n2 = d(n2, i2, a3, r2, e3[9], 21, -343485551), t2[0] = N(r2, t2[0]), t2[1] = N(n2, t2[1]), t2[2] = N(i2, t2[2]), t2[3] = N(a3, t2[3]);
    }
    function u2(t2, e3, r2, n2, i2, a3) {
      return e3 = N(N(e3, t2), N(n2, a3)), N(e3 << i2 | e3 >>> 32 - i2, r2);
    }
    function l(t2, e3, r2, n2, i2, a3, o2) {
      return u2(e3 & r2 | ~e3 & n2, t2, e3, i2, a3, o2);
    }
    function h(t2, e3, r2, n2, i2, a3, o2) {
      return u2(e3 & n2 | r2 & ~n2, t2, e3, i2, a3, o2);
    }
    function f2(t2, e3, r2, n2, i2, a3, o2) {
      return u2(e3 ^ r2 ^ n2, t2, e3, i2, a3, o2);
    }
    function d(t2, e3, r2, n2, i2, a3, o2) {
      return u2(r2 ^ (e3 | ~n2), t2, e3, i2, a3, o2);
    }
    function p(t2) {
      var e3, r2 = t2.length, n2 = [1732584193, -271733879, -1732584194, 271733878];
      for (e3 = 64; e3 <= t2.length; e3 += 64) c(n2, g(t2.substring(e3 - 64, e3)));
      t2 = t2.substring(e3 - 64);
      var i2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      for (e3 = 0; e3 < t2.length; e3++) i2[e3 >> 2] |= t2.charCodeAt(e3) << (e3 % 4 << 3);
      if (i2[e3 >> 2] |= 128 << (e3 % 4 << 3), e3 > 55) for (c(n2, i2), e3 = 0; e3 < 16; e3++) i2[e3] = 0;
      return i2[14] = 8 * r2, c(n2, i2), n2;
    }
    function g(t2) {
      var e3, r2 = [];
      for (e3 = 0; e3 < 64; e3 += 4) r2[e3 >> 2] = t2.charCodeAt(e3) + (t2.charCodeAt(e3 + 1) << 8) + (t2.charCodeAt(e3 + 2) << 16) + (t2.charCodeAt(e3 + 3) << 24);
      return r2;
    }
    var m = "0123456789abcdef".split("");
    function v(t2) {
      for (var e3 = "", r2 = 0; r2 < 4; r2++) e3 += m[t2 >> 8 * r2 + 4 & 15] + m[t2 >> 8 * r2 & 15];
      return e3;
    }
    function b(t2) {
      return String.fromCharCode(255 & t2, (65280 & t2) >> 8, (16711680 & t2) >> 16, (4278190080 & t2) >> 24);
    }
    function y(t2) {
      return p(t2).map(b).join("");
    }
    var w = "5d41402abc4b2a76b9719d911017c592" != (function(t2) {
      for (var e3 = 0; e3 < t2.length; e3++) t2[e3] = v(t2[e3]);
      return t2.join("");
    })(p("hello"));
    function N(t2, e3) {
      if (w) {
        var r2 = (65535 & t2) + (65535 & e3);
        return (t2 >> 16) + (e3 >> 16) + (r2 >> 16) << 16 | 65535 & r2;
      }
      return t2 + e3 & 4294967295;
    }
    function L2(t2, e3) {
      var r2, n2, i2, a3;
      if (t2 !== r2) {
        for (var o2 = (i2 = t2, a3 = 1 + (256 / t2.length | 0), new Array(a3 + 1).join(i2)), s2 = [], c2 = 0; c2 < 256; c2++) s2[c2] = c2;
        var u3 = 0;
        for (c2 = 0; c2 < 256; c2++) {
          var l2 = s2[c2];
          u3 = (u3 + l2 + o2.charCodeAt(c2)) % 256, s2[c2] = s2[u3], s2[u3] = l2;
        }
        r2 = t2, n2 = s2;
      } else s2 = n2;
      var h2 = e3.length, f3 = 0, d2 = 0, p2 = "";
      for (c2 = 0; c2 < h2; c2++) d2 = (d2 + (l2 = s2[f3 = (f3 + 1) % 256])) % 256, s2[f3] = s2[d2], s2[d2] = l2, o2 = s2[(s2[f3] + s2[d2]) % 256], p2 += String.fromCharCode(e3.charCodeAt(c2) ^ o2);
      return p2;
    }
    var x = { print: 4, modify: 8, copy: 16, "annot-forms": 32 };
    function A2(t2, e3, r2, n2) {
      this.v = 1, this.r = 2;
      let i2 = 192;
      t2.forEach(function(t3) {
        if (void 0 !== x.perm) throw new Error("Invalid permission: " + t3);
        i2 += x[t3];
      }), this.padding = "(\xBFN^Nu\x8AAd\0NV\xFF\xFA\b..\0\xB6\xD0h>\x80/\f\xA9\xFEdSiz";
      let a3 = (e3 + this.padding).substr(0, 32), o2 = (r2 + this.padding).substr(0, 32);
      this.O = this.processOwnerPassword(a3, o2), this.P = -(1 + (255 ^ i2)), this.encryptionKey = y(a3 + this.O + this.lsbFirstWord(this.P) + this.hexToBytes(n2)).substr(0, 5), this.U = L2(this.encryptionKey, this.padding);
    }
    function S(t2) {
      if (/[^\u0000-\u00ff]/.test(t2)) throw new Error("Invalid PDF Name Object: " + t2 + ", Only accept ASCII characters.");
      for (var e3 = "", r2 = t2.length, n2 = 0; n2 < r2; n2++) {
        var i2 = t2.charCodeAt(n2);
        e3 += i2 < 33 || 35 === i2 || 37 === i2 || 40 === i2 || 41 === i2 || 47 === i2 || 60 === i2 || 62 === i2 || 91 === i2 || 93 === i2 || 123 === i2 || 125 === i2 || i2 > 126 ? "#" + ("0" + i2.toString(16)).slice(-2) : t2[n2];
      }
      return e3;
    }
    function _(t2) {
      if ("object" != typeof t2) throw new Error("Invalid Context passed to initialize PubSub (jsPDF-module)");
      var e3 = {};
      this.subscribe = function(t3, r2, n2) {
        if (n2 = n2 || false, "string" != typeof t3 || "function" != typeof r2 || "boolean" != typeof n2) throw new Error("Invalid arguments passed to PubSub.subscribe (jsPDF-module)");
        e3.hasOwnProperty(t3) || (e3[t3] = {});
        var i2 = Math.random().toString(35);
        return e3[t3][i2] = [r2, !!n2], i2;
      }, this.unsubscribe = function(t3) {
        for (var r2 in e3) if (e3[r2][t3]) return delete e3[r2][t3], 0 === Object.keys(e3[r2]).length && delete e3[r2], true;
        return false;
      }, this.publish = function(n2) {
        if (e3.hasOwnProperty(n2)) {
          var i2 = Array.prototype.slice.call(arguments, 1), a3 = [];
          for (var o2 in e3[n2]) {
            var c2 = e3[n2][o2];
            try {
              c2[0].apply(t2, i2);
            } catch (u3) {
              r.console && s.error("jsPDF PubSub Error", u3.message, u3);
            }
            c2[1] && a3.push(o2);
          }
          a3.length && a3.forEach(this.unsubscribe);
        }
      }, this.getTopics = function() {
        return e3;
      };
    }
    function P(t2) {
      if (!(this instanceof P)) return new P(t2);
      var e3 = "opacity,stroke-opacity".split(",");
      for (var r2 in t2) t2.hasOwnProperty(r2) && e3.indexOf(r2) >= 0 && (this[r2] = t2[r2]);
      this.id = "", this.objectNumber = -1;
    }
    function k(t2, e3) {
      this.gState = t2, this.matrix = e3, this.id = "", this.objectNumber = -1;
    }
    function F2(t2, e3, r2, n2, i2) {
      if (!(this instanceof F2)) return new F2(t2, e3, r2, n2, i2);
      this.type = "axial" === t2 ? 2 : 3, this.coords = e3, this.colors = r2, k.call(this, n2, i2);
    }
    function I(t2, e3, r2, n2, i2) {
      if (!(this instanceof I)) return new I(t2, e3, r2, n2, i2);
      this.boundingBox = t2, this.xStep = e3, this.yStep = r2, this.stream = "", this.cloneIndex = 0, k.call(this, n2, i2);
    }
    function j(t2) {
      var e3, i2 = "string" == typeof arguments[0] ? arguments[0] : "p", o2 = arguments[1], c2 = arguments[2], u3 = arguments[3], l2 = [], h2 = 1, f3 = 16, d2 = "S", p2 = null;
      "object" == typeof (t2 = t2 || {}) && (i2 = t2.orientation, o2 = t2.unit || o2, c2 = t2.format || c2, u3 = t2.compress || t2.compressPdf || u3, null !== (p2 = t2.encryption || null) && (p2.userPassword = p2.userPassword || "", p2.ownerPassword = p2.ownerPassword || "", p2.userPermissions = p2.userPermissions || []), h2 = "number" == typeof t2.userUnit ? Math.abs(t2.userUnit) : 1, void 0 !== t2.precision && (e3 = t2.precision), void 0 !== t2.floatPrecision && (f3 = t2.floatPrecision), d2 = t2.defaultPathOperation || "S"), l2 = t2.filters || (true === u3 ? ["FlateEncode"] : l2), o2 = o2 || "mm", i2 = ("" + (i2 || "P")).toLowerCase();
      var g2 = t2.putOnlyUsedFonts || false, m2 = {}, v2 = { internal: {}, __private__: {} };
      v2.__private__.PubSub = _;
      var b2 = "1.3", y2 = v2.__private__.getPdfVersion = function() {
        return b2;
      };
      v2.__private__.setPdfVersion = function(t3) {
        b2 = t3;
      };
      var w2 = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
      v2.__private__.getPageFormats = function() {
        return w2;
      };
      var N2 = v2.__private__.getPageFormat = function(t3) {
        return w2[t3];
      };
      c2 = c2 || "a4";
      var L3 = "compat", x2 = "advanced", k2 = L3;
      function C2() {
        this.saveGraphicsState(), ct2(new Ut2(xt2, 0, 0, -xt2, 0, xr() * xt2).toString() + " cm"), this.setFontSize(this.getFontSize() / xt2), d2 = "n", k2 = x2;
      }
      function O2() {
        this.restoreGraphicsState(), d2 = "S", k2 = L3;
      }
      var B3 = v2.__private__.combineFontStyleAndFontWeight = function(t3, e4) {
        if ("bold" == t3 && "normal" == e4 || "bold" == t3 && 400 == e4 || "normal" == t3 && "italic" == e4 || "bold" == t3 && "italic" == e4) throw new Error("Invalid Combination of fontweight and fontstyle");
        return e4 && (t3 = 400 == e4 || "normal" === e4 ? "italic" === t3 ? "italic" : "normal" : 700 != e4 && "bold" !== e4 || "normal" !== t3 ? (700 == e4 ? "bold" : e4) + "" + t3 : "bold"), t3;
      };
      v2.advancedAPI = function(t3) {
        var e4 = k2 === L3;
        return e4 && C2.call(this), "function" != typeof t3 || (t3(this), e4 && O2.call(this)), this;
      }, v2.compatAPI = function(t3) {
        var e4 = k2 === x2;
        return e4 && O2.call(this), "function" != typeof t3 || (t3(this), e4 && C2.call(this)), this;
      }, v2.isAdvancedAPI = function() {
        return k2 === x2;
      };
      var q2, M2 = function(t3) {
        if (k2 !== x2) throw new Error(t3 + " is only available in 'advanced' API mode. You need to call advancedAPI() first.");
      }, E3 = v2.roundToPrecision = v2.__private__.roundToPrecision = function(t3, r2) {
        var n2 = e3 || r2;
        if (isNaN(t3) || isNaN(n2)) throw new Error("Invalid argument passed to jsPDF.roundToPrecision");
        return t3.toFixed(n2).replace(/0+$/, "");
      };
      q2 = v2.hpf = v2.__private__.hpf = "number" == typeof f3 ? function(t3) {
        if (isNaN(t3)) throw new Error("Invalid argument passed to jsPDF.hpf");
        return E3(t3, f3);
      } : "smart" === f3 ? function(t3) {
        if (isNaN(t3)) throw new Error("Invalid argument passed to jsPDF.hpf");
        return E3(t3, t3 > -1 && t3 < 1 ? 16 : 5);
      } : function(t3) {
        if (isNaN(t3)) throw new Error("Invalid argument passed to jsPDF.hpf");
        return E3(t3, 16);
      };
      var R2 = v2.f2 = v2.__private__.f2 = function(t3) {
        if (isNaN(t3)) throw new Error("Invalid argument passed to jsPDF.f2");
        return E3(t3, 2);
      }, D2 = v2.__private__.f3 = function(t3) {
        if (isNaN(t3)) throw new Error("Invalid argument passed to jsPDF.f3");
        return E3(t3, 3);
      }, T3 = v2.scale = v2.__private__.scale = function(t3) {
        if (isNaN(t3)) throw new Error("Invalid argument passed to jsPDF.scale");
        return k2 === L3 ? t3 * xt2 : k2 === x2 ? t3 : void 0;
      }, z3 = function(t3) {
        return T3((function(t4) {
          return k2 === L3 ? xr() - t4 : k2 === x2 ? t4 : void 0;
        })(t3));
      };
      v2.__private__.setPrecision = v2.setPrecision = function(t3) {
        "number" == typeof parseInt(t3, 10) && (e3 = parseInt(t3, 10));
      };
      var U3, H4 = "00000000000000000000000000000000", W2 = v2.__private__.getFileId = function() {
        return H4;
      }, V3 = v2.__private__.setFileId = function(t3) {
        return H4 = void 0 !== t3 && /^[a-fA-F0-9]{32}$/.test(t3) ? t3.toUpperCase() : H4.split("").map(function() {
          return "ABCDEF0123456789".charAt(Math.floor(16 * Math.random()));
        }).join(""), null !== p2 && (Fe = new A2(p2.userPermissions, p2.userPassword, p2.ownerPassword, H4)), H4;
      };
      v2.setFileId = function(t3) {
        return V3(t3), this;
      }, v2.getFileId = function() {
        return W2();
      };
      var G2 = v2.__private__.convertDateToPDFDate = function(t3) {
        var e4 = t3.getTimezoneOffset(), r2 = e4 < 0 ? "+" : "-", n2 = Math.floor(Math.abs(e4 / 60)), i3 = Math.abs(e4 % 60), a3 = [r2, $2(n2), "'", $2(i3), "'"].join("");
        return ["D:", t3.getFullYear(), $2(t3.getMonth() + 1), $2(t3.getDate()), $2(t3.getHours()), $2(t3.getMinutes()), $2(t3.getSeconds()), a3].join("");
      }, Y2 = v2.__private__.convertPDFDateToDate = function(t3) {
        var e4 = parseInt(t3.substr(2, 4), 10), r2 = parseInt(t3.substr(6, 2), 10) - 1, n2 = parseInt(t3.substr(8, 2), 10), i3 = parseInt(t3.substr(10, 2), 10), a3 = parseInt(t3.substr(12, 2), 10), o3 = parseInt(t3.substr(14, 2), 10);
        return new Date(e4, r2, n2, i3, a3, o3, 0);
      }, J2 = v2.__private__.setCreationDate = function(t3) {
        var e4;
        if (void 0 === t3 && (t3 = /* @__PURE__ */ new Date()), t3 instanceof Date) e4 = G2(t3);
        else {
          if (!/^D:(20[0-2][0-9]|203[0-7]|19[7-9][0-9])(0[0-9]|1[0-2])([0-2][0-9]|3[0-1])(0[0-9]|1[0-9]|2[0-3])(0[0-9]|[1-5][0-9])(0[0-9]|[1-5][0-9])(\+0[0-9]|\+1[0-4]|-0[0-9]|-1[0-1])'(0[0-9]|[1-5][0-9])'?$/.test(t3)) throw new Error("Invalid argument passed to jsPDF.setCreationDate");
          e4 = t3;
        }
        return U3 = e4;
      }, X2 = v2.__private__.getCreationDate = function(t3) {
        var e4 = U3;
        return "jsDate" === t3 && (e4 = Y2(U3)), e4;
      };
      v2.setCreationDate = function(t3) {
        return J2(t3), this;
      }, v2.getCreationDate = function(t3) {
        return X2(t3);
      };
      var K2, $2 = v2.__private__.padd2 = function(t3) {
        return ("0" + parseInt(t3)).slice(-2);
      }, Z3 = v2.__private__.padd2Hex = function(t3) {
        return ("00" + (t3 = t3.toString())).substr(t3.length);
      }, Q2 = 0, tt2 = [], et2 = [], rt2 = 0, nt2 = [], it2 = [], at2 = false, ot2 = et2;
      v2.__private__.setCustomOutputDestination = function(t3) {
        at2 = true, ot2 = t3;
      };
      var st2 = function(t3) {
        at2 || (ot2 = t3);
      };
      v2.__private__.resetCustomOutputDestination = function() {
        at2 = false, ot2 = et2;
      };
      var ct2 = v2.__private__.out = function(t3) {
        return t3 = t3.toString(), rt2 += t3.length + 1, ot2.push(t3), ot2;
      }, ut2 = v2.__private__.write = function(t3) {
        return ct2(1 === arguments.length ? t3.toString() : Array.prototype.join.call(arguments, " "));
      }, lt2 = v2.__private__.getArrayBuffer = function(t3) {
        for (var e4 = t3.length, r2 = new ArrayBuffer(e4), n2 = new Uint8Array(r2); e4--; ) n2[e4] = t3.charCodeAt(e4);
        return r2;
      }, ht2 = [["Helvetica", "helvetica", "normal", "WinAnsiEncoding"], ["Helvetica-Bold", "helvetica", "bold", "WinAnsiEncoding"], ["Helvetica-Oblique", "helvetica", "italic", "WinAnsiEncoding"], ["Helvetica-BoldOblique", "helvetica", "bolditalic", "WinAnsiEncoding"], ["Courier", "courier", "normal", "WinAnsiEncoding"], ["Courier-Bold", "courier", "bold", "WinAnsiEncoding"], ["Courier-Oblique", "courier", "italic", "WinAnsiEncoding"], ["Courier-BoldOblique", "courier", "bolditalic", "WinAnsiEncoding"], ["Times-Roman", "times", "normal", "WinAnsiEncoding"], ["Times-Bold", "times", "bold", "WinAnsiEncoding"], ["Times-Italic", "times", "italic", "WinAnsiEncoding"], ["Times-BoldItalic", "times", "bolditalic", "WinAnsiEncoding"], ["ZapfDingbats", "zapfdingbats", "normal", null], ["Symbol", "symbol", "normal", null]];
      v2.__private__.getStandardFonts = function() {
        return ht2;
      };
      var ft2 = t2.fontSize || 16;
      v2.__private__.setFontSize = v2.setFontSize = function(t3) {
        return ft2 = k2 === x2 ? t3 / xt2 : t3, this;
      };
      var dt2, pt2 = v2.__private__.getFontSize = v2.getFontSize = function() {
        return k2 === L3 ? ft2 : ft2 * xt2;
      }, gt2 = t2.R2L || false;
      v2.__private__.setR2L = v2.setR2L = function(t3) {
        return gt2 = t3, this;
      }, v2.__private__.getR2L = v2.getR2L = function() {
        return gt2;
      };
      var mt2, vt2 = v2.__private__.setZoomMode = function(t3) {
        if (/^(?:\d+\.\d*|\d*\.\d+|\d+)%$/.test(t3)) dt2 = t3;
        else if (isNaN(t3)) {
          if (-1 === [void 0, null, "fullwidth", "fullheight", "fullpage", "original"].indexOf(t3)) throw new Error('zoom must be Integer (e.g. 2), a percentage Value (e.g. 300%) or fullwidth, fullheight, fullpage, original. "' + t3 + '" is not recognized.');
          dt2 = t3;
        } else dt2 = parseInt(t3, 10);
      };
      v2.__private__.getZoomMode = function() {
        return dt2;
      };
      var bt2, yt2 = v2.__private__.setPageMode = function(t3) {
        if (-1 == [void 0, null, "UseNone", "UseOutlines", "UseThumbs", "FullScreen"].indexOf(t3)) throw new Error('Page mode must be one of UseNone, UseOutlines, UseThumbs, or FullScreen. "' + t3 + '" is not recognized.');
        mt2 = t3;
      };
      v2.__private__.getPageMode = function() {
        return mt2;
      };
      var wt2 = v2.__private__.setLayoutMode = function(t3) {
        if (-1 == [void 0, null, "continuous", "single", "twoleft", "tworight", "two"].indexOf(t3)) throw new Error('Layout mode must be one of continuous, single, twoleft, tworight. "' + t3 + '" is not recognized.');
        bt2 = t3;
      };
      v2.__private__.getLayoutMode = function() {
        return bt2;
      }, v2.__private__.setDisplayMode = v2.setDisplayMode = function(t3, e4, r2) {
        return vt2(t3), wt2(e4), yt2(r2), this;
      };
      var Nt2 = { title: "", subject: "", author: "", keywords: "", creator: "" };
      v2.__private__.getDocumentProperty = function(t3) {
        if (-1 === Object.keys(Nt2).indexOf(t3)) throw new Error("Invalid argument passed to jsPDF.getDocumentProperty");
        return Nt2[t3];
      }, v2.__private__.getDocumentProperties = function() {
        return Nt2;
      }, v2.__private__.setDocumentProperties = v2.setProperties = v2.setDocumentProperties = function(t3) {
        for (var e4 in Nt2) Nt2.hasOwnProperty(e4) && t3[e4] && (Nt2[e4] = t3[e4]);
        return this;
      }, v2.__private__.setDocumentProperty = function(t3, e4) {
        if (-1 === Object.keys(Nt2).indexOf(t3)) throw new Error("Invalid arguments passed to jsPDF.setDocumentProperty");
        return Nt2[t3] = e4;
      };
      var Lt2, xt2, At2, St2, _t2, Pt2 = {}, kt2 = {}, Ft2 = [], It2 = {}, jt2 = {}, Ct2 = {}, Ot2 = {}, Bt2 = null, qt2 = 0, Mt2 = [], Et2 = new _(v2), Rt2 = t2.hotfixes || [], Dt2 = {}, Tt2 = {}, zt2 = [], Ut2 = function(t3, e4, r2, n2, i3, a3) {
        if (!(this instanceof Ut2)) return new Ut2(t3, e4, r2, n2, i3, a3);
        isNaN(t3) && (t3 = 1), isNaN(e4) && (e4 = 0), isNaN(r2) && (r2 = 0), isNaN(n2) && (n2 = 1), isNaN(i3) && (i3 = 0), isNaN(a3) && (a3 = 0), this._matrix = [t3, e4, r2, n2, i3, a3];
      };
      Object.defineProperty(Ut2.prototype, "sx", { get: function() {
        return this._matrix[0];
      }, set: function(t3) {
        this._matrix[0] = t3;
      } }), Object.defineProperty(Ut2.prototype, "shy", { get: function() {
        return this._matrix[1];
      }, set: function(t3) {
        this._matrix[1] = t3;
      } }), Object.defineProperty(Ut2.prototype, "shx", { get: function() {
        return this._matrix[2];
      }, set: function(t3) {
        this._matrix[2] = t3;
      } }), Object.defineProperty(Ut2.prototype, "sy", { get: function() {
        return this._matrix[3];
      }, set: function(t3) {
        this._matrix[3] = t3;
      } }), Object.defineProperty(Ut2.prototype, "tx", { get: function() {
        return this._matrix[4];
      }, set: function(t3) {
        this._matrix[4] = t3;
      } }), Object.defineProperty(Ut2.prototype, "ty", { get: function() {
        return this._matrix[5];
      }, set: function(t3) {
        this._matrix[5] = t3;
      } }), Object.defineProperty(Ut2.prototype, "a", { get: function() {
        return this._matrix[0];
      }, set: function(t3) {
        this._matrix[0] = t3;
      } }), Object.defineProperty(Ut2.prototype, "b", { get: function() {
        return this._matrix[1];
      }, set: function(t3) {
        this._matrix[1] = t3;
      } }), Object.defineProperty(Ut2.prototype, "c", { get: function() {
        return this._matrix[2];
      }, set: function(t3) {
        this._matrix[2] = t3;
      } }), Object.defineProperty(Ut2.prototype, "d", { get: function() {
        return this._matrix[3];
      }, set: function(t3) {
        this._matrix[3] = t3;
      } }), Object.defineProperty(Ut2.prototype, "e", { get: function() {
        return this._matrix[4];
      }, set: function(t3) {
        this._matrix[4] = t3;
      } }), Object.defineProperty(Ut2.prototype, "f", { get: function() {
        return this._matrix[5];
      }, set: function(t3) {
        this._matrix[5] = t3;
      } }), Object.defineProperty(Ut2.prototype, "rotation", { get: function() {
        return Math.atan2(this.shx, this.sx);
      } }), Object.defineProperty(Ut2.prototype, "scaleX", { get: function() {
        return this.decompose().scale.sx;
      } }), Object.defineProperty(Ut2.prototype, "scaleY", { get: function() {
        return this.decompose().scale.sy;
      } }), Object.defineProperty(Ut2.prototype, "isIdentity", { get: function() {
        return 1 === this.sx && 0 === this.shy && 0 === this.shx && 1 === this.sy && 0 === this.tx && 0 === this.ty;
      } }), Ut2.prototype.join = function(t3) {
        return [this.sx, this.shy, this.shx, this.sy, this.tx, this.ty].map(q2).join(t3);
      }, Ut2.prototype.multiply = function(t3) {
        var e4 = t3.sx * this.sx + t3.shy * this.shx, r2 = t3.sx * this.shy + t3.shy * this.sy, n2 = t3.shx * this.sx + t3.sy * this.shx, i3 = t3.shx * this.shy + t3.sy * this.sy, a3 = t3.tx * this.sx + t3.ty * this.shx + this.tx, o3 = t3.tx * this.shy + t3.ty * this.sy + this.ty;
        return new Ut2(e4, r2, n2, i3, a3, o3);
      }, Ut2.prototype.decompose = function() {
        var t3 = this.sx, e4 = this.shy, r2 = this.shx, n2 = this.sy, i3 = this.tx, a3 = this.ty, o3 = Math.sqrt(t3 * t3 + e4 * e4), s2 = (t3 /= o3) * r2 + (e4 /= o3) * n2;
        r2 -= t3 * s2, n2 -= e4 * s2;
        var c3 = Math.sqrt(r2 * r2 + n2 * n2);
        return s2 /= c3, t3 * (n2 /= c3) < e4 * (r2 /= c3) && (t3 = -t3, e4 = -e4, s2 = -s2, o3 = -o3), { scale: new Ut2(o3, 0, 0, c3, 0, 0), translate: new Ut2(1, 0, 0, 1, i3, a3), rotate: new Ut2(t3, e4, -e4, t3, 0, 0), skew: new Ut2(1, 0, s2, 1, 0, 0) };
      }, Ut2.prototype.toString = function(t3) {
        return this.join(" ");
      }, Ut2.prototype.inversed = function() {
        var t3 = this.sx, e4 = this.shy, r2 = this.shx, n2 = this.sy, i3 = this.tx, a3 = this.ty, o3 = 1 / (t3 * n2 - e4 * r2), s2 = n2 * o3, c3 = -e4 * o3, u4 = -r2 * o3, l3 = t3 * o3;
        return new Ut2(s2, c3, u4, l3, -s2 * i3 - u4 * a3, -c3 * i3 - l3 * a3);
      }, Ut2.prototype.applyToPoint = function(t3) {
        var e4 = t3.x * this.sx + t3.y * this.shx + this.tx, r2 = t3.x * this.shy + t3.y * this.sy + this.ty;
        return new fr(e4, r2);
      }, Ut2.prototype.applyToRectangle = function(t3) {
        var e4 = this.applyToPoint(t3), r2 = this.applyToPoint(new fr(t3.x + t3.w, t3.y + t3.h));
        return new dr(e4.x, e4.y, r2.x - e4.x, r2.y - e4.y);
      }, Ut2.prototype.clone = function() {
        var t3 = this.sx, e4 = this.shy, r2 = this.shx, n2 = this.sy, i3 = this.tx, a3 = this.ty;
        return new Ut2(t3, e4, r2, n2, i3, a3);
      }, v2.Matrix = Ut2;
      var Ht2 = v2.matrixMult = function(t3, e4) {
        return e4.multiply(t3);
      }, Wt2 = new Ut2(1, 0, 0, 1, 0, 0);
      v2.unitMatrix = v2.identityMatrix = Wt2;
      var Vt2 = function(t3, e4) {
        if (!jt2[t3]) {
          var r2 = (e4 instanceof F2 ? "Sh" : "P") + (Object.keys(It2).length + 1).toString(10);
          e4.id = r2, jt2[t3] = r2, It2[r2] = e4, Et2.publish("addPattern", e4);
        }
      };
      v2.ShadingPattern = F2, v2.TilingPattern = I, v2.addShadingPattern = function(t3, e4) {
        return M2("addShadingPattern()"), Vt2(t3, e4), this;
      }, v2.beginTilingPattern = function(t3) {
        M2("beginTilingPattern()"), gr(t3.boundingBox[0], t3.boundingBox[1], t3.boundingBox[2] - t3.boundingBox[0], t3.boundingBox[3] - t3.boundingBox[1], t3.matrix);
      }, v2.endTilingPattern = function(t3, e4) {
        M2("endTilingPattern()"), e4.stream = it2[K2].join("\n"), Vt2(t3, e4), Et2.publish("endTilingPattern", e4), zt2.pop().restore();
      };
      var Gt2, Yt2 = v2.__private__.newObject = function() {
        var t3 = Jt2();
        return Xt2(t3, true), t3;
      }, Jt2 = v2.__private__.newObjectDeferred = function() {
        return Q2++, tt2[Q2] = function() {
          return rt2;
        }, Q2;
      }, Xt2 = function(t3, e4) {
        return e4 = "boolean" == typeof e4 && e4, tt2[t3] = rt2, e4 && ct2(t3 + " 0 obj"), t3;
      }, Kt2 = v2.__private__.newAdditionalObject = function() {
        var t3 = { objId: Jt2(), content: "" };
        return nt2.push(t3), t3;
      }, $t2 = Jt2(), Zt2 = Jt2(), Qt2 = v2.__private__.decodeColorString = function(t3) {
        var e4 = t3.split(" ");
        if (2 !== e4.length || "g" !== e4[1] && "G" !== e4[1]) 5 !== e4.length || "k" !== e4[4] && "K" !== e4[4] || (e4 = [(1 - e4[0]) * (1 - e4[3]), (1 - e4[1]) * (1 - e4[3]), (1 - e4[2]) * (1 - e4[3]), "r"]);
        else {
          var r2 = parseFloat(e4[0]);
          e4 = [r2, r2, r2, "r"];
        }
        for (var n2 = "#", i3 = 0; i3 < 3; i3++) n2 += ("0" + Math.floor(255 * parseFloat(e4[i3])).toString(16)).slice(-2);
        return n2;
      }, te2 = v2.__private__.encodeColorString = function(t3) {
        var e4;
        "string" == typeof t3 && (t3 = { ch1: t3 });
        var r2 = t3.ch1, i3 = t3.ch2, a3 = t3.ch3, o3 = t3.ch4, s2 = "draw" === t3.pdfColorType ? ["G", "RG", "K"] : ["g", "rg", "k"];
        if ("string" == typeof r2 && "#" !== r2.charAt(0)) {
          var c3 = new n(r2);
          if (c3.ok) r2 = c3.toHex();
          else if (!/^\d*\.?\d*$/.test(r2)) throw new Error('Invalid color "' + r2 + '" passed to jsPDF.encodeColorString.');
        }
        if ("string" == typeof r2 && /^#[0-9A-Fa-f]{3}$/.test(r2) && (r2 = "#" + r2[1] + r2[1] + r2[2] + r2[2] + r2[3] + r2[3]), "string" == typeof r2 && /^#[0-9A-Fa-f]{6}$/.test(r2)) {
          var u4 = parseInt(r2.substr(1), 16);
          r2 = u4 >> 16 & 255, i3 = u4 >> 8 & 255, a3 = 255 & u4;
        }
        if (void 0 === i3 || void 0 === o3 && r2 === i3 && i3 === a3) e4 = "string" == typeof r2 ? r2 + " " + s2[0] : 2 === t3.precision ? R2(r2 / 255) + " " + s2[0] : D2(r2 / 255) + " " + s2[0];
        else if (void 0 === o3 || "object" == typeof o3) {
          if (o3 && !isNaN(o3.a) && 0 === o3.a) return ["1.", "1.", "1.", s2[1]].join(" ");
          e4 = "string" == typeof r2 ? [r2, i3, a3, s2[1]].join(" ") : 2 === t3.precision ? [R2(r2 / 255), R2(i3 / 255), R2(a3 / 255), s2[1]].join(" ") : [D2(r2 / 255), D2(i3 / 255), D2(a3 / 255), s2[1]].join(" ");
        } else e4 = "string" == typeof r2 ? [r2, i3, a3, o3, s2[2]].join(" ") : 2 === t3.precision ? [R2(r2), R2(i3), R2(a3), R2(o3), s2[2]].join(" ") : [D2(r2), D2(i3), D2(a3), D2(o3), s2[2]].join(" ");
        return e4;
      }, ee2 = v2.__private__.getFilters = function() {
        return l2;
      }, re2 = v2.__private__.putStream = function(t3) {
        var e4 = (t3 = t3 || {}).data || "", r2 = t3.filters || ee2(), n2 = t3.alreadyAppliedFilters || [], i3 = t3.addLength1 || false, a3 = e4.length, o3 = t3.objectId, s2 = function(t4) {
          return t4;
        };
        if (null !== p2 && void 0 === o3) throw new Error("ObjectId must be passed to putStream for file encryption");
        null !== p2 && (s2 = Fe.encryptor(o3, 0));
        var c3 = {};
        true === r2 && (r2 = ["FlateEncode"]);
        var u4 = t3.additionalKeyValues || [], l3 = (c3 = void 0 !== j.API.processDataByFilters ? j.API.processDataByFilters(e4, r2) : { data: e4, reverseChain: [] }).reverseChain + (Array.isArray(n2) ? n2.join(" ") : n2.toString());
        if (0 !== c3.data.length && (u4.push({ key: "Length", value: c3.data.length }), true === i3 && u4.push({ key: "Length1", value: a3 })), 0 != l3.length) if (l3.split("/").length - 1 == 1) u4.push({ key: "Filter", value: l3 });
        else {
          u4.push({ key: "Filter", value: "[" + l3 + "]" });
          for (var h3 = 0; h3 < u4.length; h3 += 1) if ("DecodeParms" === u4[h3].key) {
            for (var f4 = [], d3 = 0; d3 < c3.reverseChain.split("/").length - 1; d3 += 1) f4.push("null");
            f4.push(u4[h3].value), u4[h3].value = "[" + f4.join(" ") + "]";
          }
        }
        ct2("<<");
        for (var g3 = 0; g3 < u4.length; g3++) ct2("/" + u4[g3].key + " " + u4[g3].value);
        ct2(">>"), 0 !== c3.data.length && (ct2("stream"), ct2(s2(c3.data)), ct2("endstream"));
      }, ne2 = v2.__private__.putPage = function(t3) {
        var e4 = t3.number, r2 = t3.data, n2 = t3.objId, i3 = t3.contentsObjId;
        Xt2(n2, true), ct2("<</Type /Page"), ct2("/Parent " + t3.rootDictionaryObjId + " 0 R"), ct2("/Resources " + t3.resourceDictionaryObjId + " 0 R"), ct2("/MediaBox [" + parseFloat(q2(t3.mediaBox.bottomLeftX)) + " " + parseFloat(q2(t3.mediaBox.bottomLeftY)) + " " + q2(t3.mediaBox.topRightX) + " " + q2(t3.mediaBox.topRightY) + "]"), null !== t3.cropBox && ct2("/CropBox [" + q2(t3.cropBox.bottomLeftX) + " " + q2(t3.cropBox.bottomLeftY) + " " + q2(t3.cropBox.topRightX) + " " + q2(t3.cropBox.topRightY) + "]"), null !== t3.bleedBox && ct2("/BleedBox [" + q2(t3.bleedBox.bottomLeftX) + " " + q2(t3.bleedBox.bottomLeftY) + " " + q2(t3.bleedBox.topRightX) + " " + q2(t3.bleedBox.topRightY) + "]"), null !== t3.trimBox && ct2("/TrimBox [" + q2(t3.trimBox.bottomLeftX) + " " + q2(t3.trimBox.bottomLeftY) + " " + q2(t3.trimBox.topRightX) + " " + q2(t3.trimBox.topRightY) + "]"), null !== t3.artBox && ct2("/ArtBox [" + q2(t3.artBox.bottomLeftX) + " " + q2(t3.artBox.bottomLeftY) + " " + q2(t3.artBox.topRightX) + " " + q2(t3.artBox.topRightY) + "]"), "number" == typeof t3.userUnit && 1 !== t3.userUnit && ct2("/UserUnit " + t3.userUnit), Et2.publish("putPage", { objId: n2, pageContext: Mt2[e4], pageNumber: e4, page: r2 }), ct2("/Contents " + i3 + " 0 R"), ct2(">>"), ct2("endobj");
        var a3 = r2.join("\n");
        return k2 === x2 && (a3 += "\nQ"), Xt2(i3, true), re2({ data: a3, filters: ee2(), objectId: i3 }), ct2("endobj"), n2;
      }, ie2 = v2.__private__.putPages = function() {
        var t3, e4, r2 = [];
        for (t3 = 1; t3 <= qt2; t3++) Mt2[t3].objId = Jt2(), Mt2[t3].contentsObjId = Jt2();
        for (t3 = 1; t3 <= qt2; t3++) r2.push(ne2({ number: t3, data: it2[t3], objId: Mt2[t3].objId, contentsObjId: Mt2[t3].contentsObjId, mediaBox: Mt2[t3].mediaBox, cropBox: Mt2[t3].cropBox, bleedBox: Mt2[t3].bleedBox, trimBox: Mt2[t3].trimBox, artBox: Mt2[t3].artBox, userUnit: Mt2[t3].userUnit, rootDictionaryObjId: $t2, resourceDictionaryObjId: Zt2 }));
        Xt2($t2, true), ct2("<</Type /Pages");
        var n2 = "/Kids [";
        for (e4 = 0; e4 < qt2; e4++) n2 += r2[e4] + " 0 R ";
        ct2(n2 + "]"), ct2("/Count " + qt2), ct2(">>"), ct2("endobj"), Et2.publish("postPutPages");
      }, ae2 = function(t3) {
        Et2.publish("putFont", { font: t3, out: ct2, newObject: Yt2, putStream: re2 }), true !== t3.isAlreadyPutted && (t3.objectNumber = Yt2(), ct2("<<"), ct2("/Type /Font"), ct2("/BaseFont /" + S(t3.postScriptName)), ct2("/Subtype /Type1"), "string" == typeof t3.encoding && ct2("/Encoding /" + t3.encoding), ct2("/FirstChar 32"), ct2("/LastChar 255"), ct2(">>"), ct2("endobj"));
      }, oe2 = function(t3) {
        t3.objectNumber = Yt2();
        var e4 = [];
        e4.push({ key: "Type", value: "/XObject" }), e4.push({ key: "Subtype", value: "/Form" }), e4.push({ key: "BBox", value: "[" + [q2(t3.x), q2(t3.y), q2(t3.x + t3.width), q2(t3.y + t3.height)].join(" ") + "]" }), e4.push({ key: "Matrix", value: "[" + t3.matrix.toString() + "]" });
        var r2 = t3.pages[1].join("\n");
        re2({ data: r2, additionalKeyValues: e4, objectId: t3.objectNumber }), ct2("endobj");
      }, se2 = function(t3, e4) {
        e4 || (e4 = 21);
        var r2 = Yt2(), n2 = (function(t4, e5) {
          var r3, n3 = [], i4 = 1 / (e5 - 1);
          for (r3 = 0; r3 < 1; r3 += i4) n3.push(r3);
          if (n3.push(1), 0 != t4[0].offset) {
            var a4 = { offset: 0, color: t4[0].color };
            t4.unshift(a4);
          }
          if (1 != t4[t4.length - 1].offset) {
            var o3 = { offset: 1, color: t4[t4.length - 1].color };
            t4.push(o3);
          }
          for (var s2 = "", c3 = 0, u4 = 0; u4 < n3.length; u4++) {
            for (r3 = n3[u4]; r3 > t4[c3 + 1].offset; ) c3++;
            var l3 = t4[c3].offset, h3 = (r3 - l3) / (t4[c3 + 1].offset - l3), f4 = t4[c3].color, d3 = t4[c3 + 1].color;
            s2 += Z3(Math.round((1 - h3) * f4[0] + h3 * d3[0]).toString(16)) + Z3(Math.round((1 - h3) * f4[1] + h3 * d3[1]).toString(16)) + Z3(Math.round((1 - h3) * f4[2] + h3 * d3[2]).toString(16));
          }
          return s2.trim();
        })(t3.colors, e4), i3 = [];
        i3.push({ key: "FunctionType", value: "0" }), i3.push({ key: "Domain", value: "[0.0 1.0]" }), i3.push({ key: "Size", value: "[" + e4 + "]" }), i3.push({ key: "BitsPerSample", value: "8" }), i3.push({ key: "Range", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), i3.push({ key: "Decode", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), re2({ data: n2, additionalKeyValues: i3, alreadyAppliedFilters: ["/ASCIIHexDecode"], objectId: r2 }), ct2("endobj"), t3.objectNumber = Yt2(), ct2("<< /ShadingType " + t3.type), ct2("/ColorSpace /DeviceRGB");
        var a3 = "/Coords [" + q2(parseFloat(t3.coords[0])) + " " + q2(parseFloat(t3.coords[1])) + " ";
        2 === t3.type ? a3 += q2(parseFloat(t3.coords[2])) + " " + q2(parseFloat(t3.coords[3])) : a3 += q2(parseFloat(t3.coords[2])) + " " + q2(parseFloat(t3.coords[3])) + " " + q2(parseFloat(t3.coords[4])) + " " + q2(parseFloat(t3.coords[5])), ct2(a3 += "]"), t3.matrix && ct2("/Matrix [" + t3.matrix.toString() + "]"), ct2("/Function " + r2 + " 0 R"), ct2("/Extend [true true]"), ct2(">>"), ct2("endobj");
      }, ce2 = function(t3, e4) {
        var r2 = Jt2(), n2 = Yt2();
        e4.push({ resourcesOid: r2, objectOid: n2 }), t3.objectNumber = n2;
        var i3 = [];
        i3.push({ key: "Type", value: "/Pattern" }), i3.push({ key: "PatternType", value: "1" }), i3.push({ key: "PaintType", value: "1" }), i3.push({ key: "TilingType", value: "1" }), i3.push({ key: "BBox", value: "[" + t3.boundingBox.map(q2).join(" ") + "]" }), i3.push({ key: "XStep", value: q2(t3.xStep) }), i3.push({ key: "YStep", value: q2(t3.yStep) }), i3.push({ key: "Resources", value: r2 + " 0 R" }), t3.matrix && i3.push({ key: "Matrix", value: "[" + t3.matrix.toString() + "]" }), re2({ data: t3.stream, additionalKeyValues: i3, objectId: t3.objectNumber }), ct2("endobj");
      }, ue2 = function(t3) {
        for (var e4 in t3.objectNumber = Yt2(), ct2("<<"), t3) switch (e4) {
          case "opacity":
            ct2("/ca " + R2(t3[e4]));
            break;
          case "stroke-opacity":
            ct2("/CA " + R2(t3[e4]));
        }
        ct2(">>"), ct2("endobj");
      }, le2 = function(t3) {
        Xt2(t3.resourcesOid, true), ct2("<<"), ct2("/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]"), (function() {
          for (var t4 in ct2("/Font <<"), Pt2) Pt2.hasOwnProperty(t4) && (false === g2 || true === g2 && m2.hasOwnProperty(t4)) && ct2("/" + t4 + " " + Pt2[t4].objectNumber + " 0 R");
          ct2(">>");
        })(), (function() {
          if (Object.keys(It2).length > 0) {
            for (var t4 in ct2("/Shading <<"), It2) It2.hasOwnProperty(t4) && It2[t4] instanceof F2 && It2[t4].objectNumber >= 0 && ct2("/" + t4 + " " + It2[t4].objectNumber + " 0 R");
            Et2.publish("putShadingPatternDict"), ct2(">>");
          }
        })(), (function(t4) {
          if (Object.keys(It2).length > 0) {
            for (var e4 in ct2("/Pattern <<"), It2) It2.hasOwnProperty(e4) && It2[e4] instanceof v2.TilingPattern && It2[e4].objectNumber >= 0 && It2[e4].objectNumber < t4 && ct2("/" + e4 + " " + It2[e4].objectNumber + " 0 R");
            Et2.publish("putTilingPatternDict"), ct2(">>");
          }
        })(t3.objectOid), (function() {
          if (Object.keys(Ct2).length > 0) {
            var t4;
            for (t4 in ct2("/ExtGState <<"), Ct2) Ct2.hasOwnProperty(t4) && Ct2[t4].objectNumber >= 0 && ct2("/" + t4 + " " + Ct2[t4].objectNumber + " 0 R");
            Et2.publish("putGStateDict"), ct2(">>");
          }
        })(), (function() {
          for (var t4 in ct2("/XObject <<"), Dt2) Dt2.hasOwnProperty(t4) && Dt2[t4].objectNumber >= 0 && ct2("/" + t4 + " " + Dt2[t4].objectNumber + " 0 R");
          Et2.publish("putXobjectDict"), ct2(">>");
        })(), ct2(">>"), ct2("endobj");
      }, he2 = function(t3) {
        kt2[t3.fontName] = kt2[t3.fontName] || {}, kt2[t3.fontName][t3.fontStyle] = t3.id;
      }, fe2 = function(t3, e4, r2, n2, i3) {
        var a3 = { id: "F" + (Object.keys(Pt2).length + 1).toString(10), postScriptName: t3, fontName: e4, fontStyle: r2, encoding: n2, isStandardFont: i3 || false, metadata: {} };
        return Et2.publish("addFont", { font: a3, instance: this }), Pt2[a3.id] = a3, he2(a3), a3.id;
      }, de2 = v2.__private__.pdfEscape = v2.pdfEscape = function(t3, e4) {
        return (function(t4, e5) {
          var r2, n2, i3, a3, o3, s2, c3, u4, l3;
          if (i3 = (e5 = e5 || {}).sourceEncoding || "Unicode", o3 = e5.outputEncoding, (e5.autoencode || o3) && Pt2[Lt2].metadata && Pt2[Lt2].metadata[i3] && Pt2[Lt2].metadata[i3].encoding && (a3 = Pt2[Lt2].metadata[i3].encoding, !o3 && Pt2[Lt2].encoding && (o3 = Pt2[Lt2].encoding), !o3 && a3.codePages && (o3 = a3.codePages[0]), "string" == typeof o3 && (o3 = a3[o3]), o3)) {
            for (c3 = false, s2 = [], r2 = 0, n2 = t4.length; r2 < n2; r2++) (u4 = o3[t4.charCodeAt(r2)]) ? s2.push(String.fromCharCode(u4)) : s2.push(t4[r2]), s2[r2].charCodeAt(0) >> 8 && (c3 = true);
            t4 = s2.join("");
          }
          for (r2 = t4.length; void 0 === c3 && 0 !== r2; ) t4.charCodeAt(r2 - 1) >> 8 && (c3 = true), r2--;
          if (!c3) return t4;
          for (s2 = e5.noBOM ? [] : [254, 255], r2 = 0, n2 = t4.length; r2 < n2; r2++) {
            if ((l3 = (u4 = t4.charCodeAt(r2)) >> 8) >> 8) throw new Error("Character at position " + r2 + " of string '" + t4 + "' exceeds 16bits. Cannot be encoded into UCS-2 BE");
            s2.push(l3), s2.push(u4 - (l3 << 8));
          }
          return String.fromCharCode.apply(void 0, s2);
        })(t3, e4).replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
      }, pe2 = v2.__private__.beginPage = function(t3) {
        it2[++qt2] = [], Mt2[qt2] = { objId: 0, contentsObjId: 0, userUnit: Number(h2), artBox: null, bleedBox: null, cropBox: null, trimBox: null, mediaBox: { bottomLeftX: 0, bottomLeftY: 0, topRightX: Number(t3[0]), topRightY: Number(t3[1]) } }, ve2(qt2), st2(it2[K2]);
      }, ge2 = function(t3, e4) {
        var r2, n2, a3;
        switch (i2 = e4 || i2, "string" == typeof t3 && (r2 = N2(t3.toLowerCase()), Array.isArray(r2) && (n2 = r2[0], a3 = r2[1])), Array.isArray(t3) && (n2 = t3[0] * xt2, a3 = t3[1] * xt2), isNaN(n2) && (n2 = c2[0], a3 = c2[1]), (n2 > 14400 || a3 > 14400) && (s.warn("A page in a PDF can not be wider or taller than 14400 userUnit. jsPDF limits the width/height to 14400"), n2 = Math.min(14400, n2), a3 = Math.min(14400, a3)), c2 = [n2, a3], i2.substr(0, 1)) {
          case "l":
            a3 > n2 && (c2 = [a3, n2]);
            break;
          case "p":
            n2 > a3 && (c2 = [a3, n2]);
        }
        pe2(c2), Xe(Ye), ct2(nr), 0 !== ur && ct2(ur + " J"), 0 !== lr && ct2(lr + " j"), Et2.publish("addPage", { pageNumber: qt2 });
      }, me2 = function(t3) {
        t3 > 0 && t3 <= qt2 && (it2.splice(t3, 1), Mt2.splice(t3, 1), qt2--, K2 > qt2 && (K2 = qt2), this.setPage(K2));
      }, ve2 = function(t3) {
        t3 > 0 && t3 <= qt2 && (K2 = t3);
      }, be2 = v2.__private__.getNumberOfPages = v2.getNumberOfPages = function() {
        return it2.length - 1;
      }, ye2 = function(t3, e4, r2) {
        var n2, i3 = void 0;
        return r2 = r2 || {}, t3 = void 0 !== t3 ? t3 : Pt2[Lt2].fontName, e4 = void 0 !== e4 ? e4 : Pt2[Lt2].fontStyle, n2 = t3.toLowerCase(), void 0 !== kt2[n2] && void 0 !== kt2[n2][e4] ? i3 = kt2[n2][e4] : void 0 !== kt2[t3] && void 0 !== kt2[t3][e4] ? i3 = kt2[t3][e4] : false === r2.disableWarning && s.warn("Unable to look up font label for font '" + t3 + "', '" + e4 + "'. Refer to getFontList() for available fonts."), i3 || r2.noFallback || null == (i3 = kt2.times[e4]) && (i3 = kt2.times.normal), i3;
      }, we2 = v2.__private__.putInfo = function() {
        var t3 = Yt2(), e4 = function(t4) {
          return t4;
        };
        for (var r2 in null !== p2 && (e4 = Fe.encryptor(t3, 0)), ct2("<<"), ct2("/Producer (" + de2(e4("jsPDF " + j.version)) + ")"), Nt2) Nt2.hasOwnProperty(r2) && Nt2[r2] && ct2("/" + r2.substr(0, 1).toUpperCase() + r2.substr(1) + " (" + de2(e4(Nt2[r2])) + ")");
        ct2("/CreationDate (" + de2(e4(U3)) + ")"), ct2(">>"), ct2("endobj");
      }, Ne2 = v2.__private__.putCatalog = function(t3) {
        var e4 = (t3 = t3 || {}).rootDictionaryObjId || $t2;
        switch (Yt2(), ct2("<<"), ct2("/Type /Catalog"), ct2("/Pages " + e4 + " 0 R"), dt2 || (dt2 = "fullwidth"), dt2) {
          case "fullwidth":
            ct2("/OpenAction [3 0 R /FitH null]");
            break;
          case "fullheight":
            ct2("/OpenAction [3 0 R /FitV null]");
            break;
          case "fullpage":
            ct2("/OpenAction [3 0 R /Fit]");
            break;
          case "original":
            ct2("/OpenAction [3 0 R /XYZ null null 1]");
            break;
          default:
            var r2 = "" + dt2;
            "%" === r2.substr(r2.length - 1) && (dt2 = parseInt(dt2) / 100), "number" == typeof dt2 && ct2("/OpenAction [3 0 R /XYZ null null " + R2(dt2) + "]");
        }
        switch (bt2 || (bt2 = "continuous"), bt2) {
          case "continuous":
            ct2("/PageLayout /OneColumn");
            break;
          case "single":
            ct2("/PageLayout /SinglePage");
            break;
          case "two":
          case "twoleft":
            ct2("/PageLayout /TwoColumnLeft");
            break;
          case "tworight":
            ct2("/PageLayout /TwoColumnRight");
        }
        mt2 && ct2("/PageMode /" + mt2), Et2.publish("putCatalog"), ct2(">>"), ct2("endobj");
      }, Le2 = v2.__private__.putTrailer = function() {
        ct2("trailer"), ct2("<<"), ct2("/Size " + (Q2 + 1)), ct2("/Root " + Q2 + " 0 R"), ct2("/Info " + (Q2 - 1) + " 0 R"), null !== p2 && ct2("/Encrypt " + Fe.oid + " 0 R"), ct2("/ID [ <" + H4 + "> <" + H4 + "> ]"), ct2(">>");
      }, xe2 = v2.__private__.putHeader = function() {
        ct2("%PDF-" + b2), ct2("%\xBA\xDF\xAC\xE0");
      }, Ae2 = v2.__private__.putXRef = function() {
        var t3 = "0000000000";
        ct2("xref"), ct2("0 " + (Q2 + 1)), ct2("0000000000 65535 f ");
        for (var e4 = 1; e4 <= Q2; e4++) "function" == typeof tt2[e4] ? ct2((t3 + tt2[e4]()).slice(-10) + " 00000 n ") : void 0 !== tt2[e4] ? ct2((t3 + tt2[e4]).slice(-10) + " 00000 n ") : ct2("0000000000 00000 n ");
      }, Se = v2.__private__.buildDocument = function() {
        var t3;
        Q2 = 0, rt2 = 0, et2 = [], tt2 = [], nt2 = [], $t2 = Jt2(), Zt2 = Jt2(), st2(et2), Et2.publish("buildDocument"), xe2(), ie2(), (function() {
          Et2.publish("putAdditionalObjects");
          for (var t4 = 0; t4 < nt2.length; t4++) {
            var e5 = nt2[t4];
            Xt2(e5.objId, true), ct2(e5.content), ct2("endobj");
          }
          Et2.publish("postPutAdditionalObjects");
        })(), t3 = [], (function() {
          for (var t4 in Pt2) Pt2.hasOwnProperty(t4) && (false === g2 || true === g2 && m2.hasOwnProperty(t4)) && ae2(Pt2[t4]);
        })(), (function() {
          var t4;
          for (t4 in Ct2) Ct2.hasOwnProperty(t4) && ue2(Ct2[t4]);
        })(), (function() {
          for (var t4 in Dt2) Dt2.hasOwnProperty(t4) && oe2(Dt2[t4]);
        })(), (function(t4) {
          var e5;
          for (e5 in It2) It2.hasOwnProperty(e5) && (It2[e5] instanceof F2 ? se2(It2[e5]) : It2[e5] instanceof I && ce2(It2[e5], t4));
        })(t3), Et2.publish("putResources"), t3.forEach(le2), le2({ resourcesOid: Zt2, objectOid: Number.MAX_SAFE_INTEGER }), Et2.publish("postPutResources"), null !== p2 && (Fe.oid = Yt2(), ct2("<<"), ct2("/Filter /Standard"), ct2("/V " + Fe.v), ct2("/R " + Fe.r), ct2("/U <" + Fe.toHexString(Fe.U) + ">"), ct2("/O <" + Fe.toHexString(Fe.O) + ">"), ct2("/P " + Fe.P), ct2(">>"), ct2("endobj")), we2(), Ne2();
        var e4 = rt2;
        return Ae2(), Le2(), ct2("startxref"), ct2("" + e4), ct2("%%EOF"), st2(it2[K2]), et2.join("\n");
      }, _e = v2.__private__.getBlob = function(t3) {
        return new Blob([lt2(t3)], { type: "application/pdf" });
      }, Pe = v2.output = v2.__private__.output = (Gt2 = function(t3, e4) {
        switch ("string" == typeof (e4 = e4 || {}) ? e4 = { filename: e4 } : e4.filename = e4.filename || "generated.pdf", t3) {
          case void 0:
            return Se();
          case "save":
            v2.save(e4.filename);
            break;
          case "arraybuffer":
            return lt2(Se());
          case "blob":
            return _e(Se());
          case "bloburi":
          case "bloburl":
            if (void 0 !== r.URL && "function" == typeof r.URL.createObjectURL) return r.URL && r.URL.createObjectURL(_e(Se())) || void 0;
            s.warn("bloburl is not supported by your system, because URL.createObjectURL is not supported by your browser.");
            break;
          case "datauristring":
          case "dataurlstring":
            var n2 = "", i3 = Se();
            try {
              n2 = a2(i3);
            } catch (m3) {
              n2 = a2(unescape(encodeURIComponent(i3)));
            }
            return "data:application/pdf;filename=" + e4.filename + ";base64," + n2;
          case "pdfobjectnewwindow":
            if ("[object Window]" === Object.prototype.toString.call(r)) {
              var o3 = "https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.1.1/pdfobject.min.js", c3 = ' integrity="sha512-4ze/a9/4jqu+tX9dfOqJYSvyYd5M6qum/3HpCLr+/Jqf0whc37VUbkpNGHR7/8pSnCFw47T1fmIpwBV7UySh3g==" crossorigin="anonymous"';
              e4.pdfObjectUrl && (o3 = e4.pdfObjectUrl, c3 = "");
              var u4 = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><script src="' + o3 + '"' + c3 + '></script><script >PDFObject.embed("' + this.output("dataurlstring") + '", ' + JSON.stringify(e4) + ");</script></body></html>", l3 = r.open();
              return null !== l3 && l3.document.write(u4), l3;
            }
            throw new Error("The option pdfobjectnewwindow just works in a browser-environment.");
          case "pdfjsnewwindow":
            if ("[object Window]" === Object.prototype.toString.call(r)) {
              var h3 = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe id="pdfViewer" src="' + (e4.pdfJsUrl || "examples/PDF.js/web/viewer.html") + "?file=&downloadName=" + e4.filename + '" width="500px" height="400px" /></body></html>', f4 = r.open();
              if (null !== f4) {
                f4.document.write(h3);
                var d3 = this;
                f4.document.documentElement.querySelector("#pdfViewer").onload = function() {
                  f4.document.title = e4.filename, f4.document.documentElement.querySelector("#pdfViewer").contentWindow.PDFViewerApplication.open(d3.output("bloburl"));
                };
              }
              return f4;
            }
            throw new Error("The option pdfjsnewwindow just works in a browser-environment.");
          case "dataurlnewwindow":
            if ("[object Window]" !== Object.prototype.toString.call(r)) throw new Error("The option dataurlnewwindow just works in a browser-environment.");
            var p3 = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe src="' + this.output("datauristring", e4) + '"></iframe></body></html>', g3 = r.open();
            if (null !== g3 && (g3.document.write(p3), g3.document.title = e4.filename), g3 || "undefined" == typeof safari) return g3;
            break;
          case "datauri":
          case "dataurl":
            return r.document.location.href = this.output("datauristring", e4);
          default:
            return null;
        }
      }, Gt2.foo = function() {
        try {
          return Gt2.apply(this, arguments);
        } catch (n2) {
          var t3 = n2.stack || "";
          ~t3.indexOf(" at ") && (t3 = t3.split(" at ")[1]);
          var e4 = "Error in function " + t3.split("\n")[0].split("<")[0] + ": " + n2.message;
          if (!r.console) throw new Error(e4);
          r.console.error(e4, n2), r.alert && alert(e4);
        }
      }, Gt2.foo.bar = Gt2, Gt2.foo), ke = function(t3) {
        return true === Array.isArray(Rt2) && Rt2.indexOf(t3) > -1;
      };
      switch (o2) {
        case "pt":
          xt2 = 1;
          break;
        case "mm":
          xt2 = 72 / 25.4;
          break;
        case "cm":
          xt2 = 72 / 2.54;
          break;
        case "in":
          xt2 = 72;
          break;
        case "px":
          xt2 = 1 == ke("px_scaling") ? 0.75 : 96 / 72;
          break;
        case "pc":
        case "em":
          xt2 = 12;
          break;
        case "ex":
          xt2 = 6;
          break;
        default:
          if ("number" != typeof o2) throw new Error("Invalid unit: " + o2);
          xt2 = o2;
      }
      var Fe = null;
      J2(), V3();
      var Ie = v2.__private__.getPageInfo = v2.getPageInfo = function(t3) {
        if (isNaN(t3) || t3 % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfo");
        return { objId: Mt2[t3].objId, pageNumber: t3, pageContext: Mt2[t3] };
      }, je = v2.__private__.getPageInfoByObjId = function(t3) {
        if (isNaN(t3) || t3 % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfoByObjId");
        for (var e4 in Mt2) if (Mt2[e4].objId === t3) break;
        return Ie(e4);
      }, Ce = v2.__private__.getCurrentPageInfo = v2.getCurrentPageInfo = function() {
        return { objId: Mt2[K2].objId, pageNumber: K2, pageContext: Mt2[K2] };
      };
      v2.addPage = function() {
        return ge2.apply(this, arguments), this;
      }, v2.setPage = function() {
        return ve2.apply(this, arguments), st2.call(this, it2[K2]), this;
      }, v2.insertPage = function(t3) {
        return this.addPage(), this.movePage(K2, t3), this;
      }, v2.movePage = function(t3, e4) {
        var r2, n2;
        if (t3 > e4) {
          r2 = it2[t3], n2 = Mt2[t3];
          for (var i3 = t3; i3 > e4; i3--) it2[i3] = it2[i3 - 1], Mt2[i3] = Mt2[i3 - 1];
          it2[e4] = r2, Mt2[e4] = n2, this.setPage(e4);
        } else if (t3 < e4) {
          r2 = it2[t3], n2 = Mt2[t3];
          for (var a3 = t3; a3 < e4; a3++) it2[a3] = it2[a3 + 1], Mt2[a3] = Mt2[a3 + 1];
          it2[e4] = r2, Mt2[e4] = n2, this.setPage(e4);
        }
        return this;
      }, v2.deletePage = function() {
        return me2.apply(this, arguments), this;
      }, v2.__private__.text = v2.text = function(t3, e4, r2, n2, i3) {
        var a3, o3, s2, c3, u4, l3, h3, f4, d3, p3 = (n2 = n2 || {}).scope || this;
        if ("number" == typeof t3 && "number" == typeof e4 && ("string" == typeof r2 || Array.isArray(r2))) {
          var g3 = r2;
          r2 = e4, e4 = t3, t3 = g3;
        }
        if (arguments[3] instanceof Ut2 == 0 ? (s2 = arguments[4], c3 = arguments[5], "object" == typeof (h3 = arguments[3]) && null !== h3 || ("string" == typeof s2 && (c3 = s2, s2 = null), "string" == typeof h3 && (c3 = h3, h3 = null), "number" == typeof h3 && (s2 = h3, h3 = null), n2 = { flags: h3, angle: s2, align: c3 })) : (M2("The transform parameter of text() with a Matrix value"), d3 = i3), isNaN(e4) || isNaN(r2) || null == t3) throw new Error("Invalid arguments passed to jsPDF.text");
        if (0 === t3.length) return p3;
        var v3, b3 = "", y3 = "number" == typeof n2.lineHeightFactor ? n2.lineHeightFactor : Ge, w3 = p3.internal.scaleFactor;
        function N3(t4) {
          return t4 = t4.split("	").join(Array(n2.TabLen || 9).join(" ")), de2(t4, h3);
        }
        function L4(t4) {
          for (var e5, r3 = t4.concat(), n3 = [], i4 = r3.length; i4--; ) "string" == typeof (e5 = r3.shift()) ? n3.push(e5) : Array.isArray(t4) && (1 === e5.length || void 0 === e5[1] && void 0 === e5[2]) ? n3.push(e5[0]) : n3.push([e5[0], e5[1], e5[2]]);
          return n3;
        }
        function A3(t4, e5) {
          var r3;
          if ("string" == typeof t4) r3 = e5(t4)[0];
          else if (Array.isArray(t4)) {
            for (var n3, i4, a4 = t4.concat(), o4 = [], s3 = a4.length; s3--; ) "string" == typeof (n3 = a4.shift()) ? o4.push(e5(n3)[0]) : Array.isArray(n3) && "string" == typeof n3[0] && (i4 = e5(n3[0], n3[1], n3[2]), o4.push([i4[0], i4[1], i4[2]]));
            r3 = o4;
          }
          return r3;
        }
        var S2 = false, _2 = true;
        if ("string" == typeof t3) S2 = true;
        else if (Array.isArray(t3)) {
          var P2 = t3.concat();
          o3 = [];
          for (var F3, I2 = P2.length; I2--; ) ("string" != typeof (F3 = P2.shift()) || Array.isArray(F3) && "string" != typeof F3[0]) && (_2 = false);
          S2 = _2;
        }
        if (false === S2) throw new Error('Type of text must be string or Array. "' + t3 + '" is not recognized.');
        "string" == typeof t3 && (t3 = t3.match(/[\r?\n]/) ? t3.split(/\r\n|\r|\n/g) : [t3]);
        var j2 = ft2 / p3.internal.scaleFactor, C3 = j2 * (y3 - 1);
        switch (n2.baseline) {
          case "bottom":
            r2 -= C3;
            break;
          case "top":
            r2 += j2 - C3;
            break;
          case "hanging":
            r2 += j2 - 2 * C3;
            break;
          case "middle":
            r2 += j2 / 2 - C3;
        }
        if ((l3 = n2.maxWidth || 0) > 0 && ("string" == typeof t3 ? t3 = p3.splitTextToSize(t3, l3) : "[object Array]" === Object.prototype.toString.call(t3) && (t3 = t3.reduce(function(t4, e5) {
          return t4.concat(p3.splitTextToSize(e5, l3));
        }, []))), a3 = { text: t3, x: e4, y: r2, options: n2, mutex: { pdfEscape: de2, activeFontKey: Lt2, fonts: Pt2, activeFontSize: ft2 } }, Et2.publish("preProcessText", a3), t3 = a3.text, s2 = (n2 = a3.options).angle, d3 instanceof Ut2 == 0 && s2 && "number" == typeof s2) {
          s2 *= Math.PI / 180, 0 === n2.rotationDirection && (s2 = -s2), k2 === x2 && (s2 = -s2);
          var O3 = Math.cos(s2), B4 = Math.sin(s2);
          d3 = new Ut2(O3, B4, -B4, O3, 0, 0);
        } else s2 && s2 instanceof Ut2 && (d3 = s2);
        k2 !== x2 || d3 || (d3 = Wt2), void 0 !== (u4 = n2.charSpace || sr) && (b3 += q2(T3(u4)) + " Tc\n", this.setCharSpace(this.getCharSpace() || 0)), void 0 !== (f4 = n2.horizontalScale) && (b3 += q2(100 * f4) + " Tz\n"), n2.lang;
        var E4 = -1, R3 = void 0 !== n2.renderingMode ? n2.renderingMode : n2.stroke, D3 = p3.internal.getCurrentPageInfo().pageContext;
        switch (R3) {
          case 0:
          case false:
          case "fill":
            E4 = 0;
            break;
          case 1:
          case true:
          case "stroke":
            E4 = 1;
            break;
          case 2:
          case "fillThenStroke":
            E4 = 2;
            break;
          case 3:
          case "invisible":
            E4 = 3;
            break;
          case 4:
          case "fillAndAddForClipping":
            E4 = 4;
            break;
          case 5:
          case "strokeAndAddPathForClipping":
            E4 = 5;
            break;
          case 6:
          case "fillThenStrokeAndAddToPathForClipping":
            E4 = 6;
            break;
          case 7:
          case "addToPathForClipping":
            E4 = 7;
        }
        var z4 = void 0 !== D3.usedRenderingMode ? D3.usedRenderingMode : -1;
        -1 !== E4 ? b3 += E4 + " Tr\n" : -1 !== z4 && (b3 += "0 Tr\n"), -1 !== E4 && (D3.usedRenderingMode = E4), c3 = n2.align || "left";
        var U4, H5 = ft2 * y3, W3 = p3.internal.pageSize.getWidth(), V4 = Pt2[Lt2];
        u4 = n2.charSpace || sr, l3 = n2.maxWidth || 0, h3 = Object.assign({ autoencode: true, noBOM: true }, n2.flags);
        var G3 = [], Y3 = function(t4) {
          return p3.getStringUnitWidth(t4, { font: V4, charSpace: u4, fontSize: ft2, doKerning: false }) * ft2 / w3;
        };
        if ("[object Array]" === Object.prototype.toString.call(t3)) {
          var J3;
          o3 = L4(t3), "left" !== c3 && (U4 = o3.map(Y3));
          var X3, K3 = 0;
          if ("right" === c3) {
            e4 -= U4[0], t3 = [], I2 = o3.length;
            for (var $3 = 0; $3 < I2; $3++) 0 === $3 ? (X3 = Qe(e4), J3 = tr(r2)) : (X3 = T3(K3 - U4[$3]), J3 = -H5), t3.push([o3[$3], X3, J3]), K3 = U4[$3];
          } else if ("center" === c3) {
            e4 -= U4[0] / 2, t3 = [], I2 = o3.length;
            for (var Z4 = 0; Z4 < I2; Z4++) 0 === Z4 ? (X3 = Qe(e4), J3 = tr(r2)) : (X3 = T3((K3 - U4[Z4]) / 2), J3 = -H5), t3.push([o3[Z4], X3, J3]), K3 = U4[Z4];
          } else if ("left" === c3) {
            t3 = [], I2 = o3.length;
            for (var Q3 = 0; Q3 < I2; Q3++) t3.push(o3[Q3]);
          } else if ("justify" === c3 && "Identity-H" === V4.encoding) {
            t3 = [], I2 = o3.length, l3 = 0 !== l3 ? l3 : W3;
            let n3 = 0;
            for (var tt3 = 0; tt3 < I2; tt3++) if (J3 = 0 === tt3 ? tr(r2) : -H5, X3 = 0 === tt3 ? Qe(e4) : n3, tt3 < I2 - 1) {
              let e5 = T3((l3 - U4[tt3]) / (o3[tt3].split(" ").length - 1)), r3 = o3[tt3].split(" ");
              t3.push([r3[0] + " ", X3, J3]), n3 = 0;
              for (let i4 = 1; i4 < r3.length; i4++) {
                let a4 = (Y3(r3[i4 - 1] + " " + r3[i4]) - Y3(r3[i4])) * w3 + e5;
                i4 == r3.length - 1 ? t3.push([r3[i4], a4, 0]) : t3.push([r3[i4] + " ", a4, 0]), n3 -= a4;
              }
            } else t3.push([o3[tt3], X3, J3]);
            t3.push(["", n3, 0]);
          } else {
            if ("justify" !== c3) throw new Error('Unrecognized alignment option, use "left", "center", "right" or "justify".');
            for (t3 = [], I2 = o3.length, l3 = 0 !== l3 ? l3 : W3, tt3 = 0; tt3 < I2; tt3++) {
              J3 = 0 === tt3 ? tr(r2) : -H5, X3 = 0 === tt3 ? Qe(e4) : 0;
              const n3 = o3[tt3].split(" ").length - 1, i4 = n3 > 0 ? (l3 - U4[tt3]) / n3 : 0;
              tt3 < I2 - 1 ? G3.push(q2(T3(i4))) : G3.push(0), t3.push([o3[tt3], X3, J3]);
            }
          }
        }
        true === ("boolean" == typeof n2.R2L ? n2.R2L : gt2) && (t3 = A3(t3, function(t4, e5, r3) {
          return [t4.split("").reverse().join(""), e5, r3];
        })), a3 = { text: t3, x: e4, y: r2, options: n2, mutex: { pdfEscape: de2, activeFontKey: Lt2, fonts: Pt2, activeFontSize: ft2 } }, Et2.publish("postProcessText", a3), t3 = a3.text, v3 = a3.mutex.isHex || false;
        var et3 = Pt2[Lt2].encoding;
        "WinAnsiEncoding" !== et3 && "StandardEncoding" !== et3 || (t3 = A3(t3, function(t4, e5, r3) {
          return [N3(t4), e5, r3];
        })), o3 = L4(t3), t3 = [];
        for (var rt3, nt3, it3, at3 = Array.isArray(o3[0]) ? 1 : 0, ot3 = "", st3 = function(t4, e5, r3) {
          var i4 = "";
          return r3 instanceof Ut2 ? (r3 = "number" == typeof n2.angle ? Ht2(r3, new Ut2(1, 0, 0, 1, t4, e5)) : Ht2(new Ut2(1, 0, 0, 1, t4, e5), r3), k2 === x2 && (r3 = Ht2(new Ut2(1, 0, 0, -1, 0, 0), r3)), i4 = r3.join(" ") + " Tm\n") : i4 = q2(t4) + " " + q2(e5) + " Td\n", i4;
        }, ut3 = 0; ut3 < o3.length; ut3++) {
          switch (ot3 = "", at3) {
            case 1:
              it3 = (v3 ? "<" : "(") + o3[ut3][0] + (v3 ? ">" : ")"), rt3 = parseFloat(o3[ut3][1]), nt3 = parseFloat(o3[ut3][2]);
              break;
            case 0:
              it3 = (v3 ? "<" : "(") + o3[ut3] + (v3 ? ">" : ")"), rt3 = Qe(e4), nt3 = tr(r2);
          }
          void 0 !== G3 && void 0 !== G3[ut3] && (ot3 = G3[ut3] + " Tw\n"), 0 === ut3 ? t3.push(ot3 + st3(rt3, nt3, d3) + it3) : 0 === at3 ? t3.push(ot3 + it3) : 1 === at3 && t3.push(ot3 + st3(rt3, nt3, d3) + it3);
        }
        t3 = 0 === at3 ? t3.join(" Tj\nT* ") : t3.join(" Tj\n"), t3 += " Tj\n";
        var lt3 = "BT\n/";
        return lt3 += Lt2 + " " + ft2 + " Tf\n", lt3 += q2(ft2 * y3) + " TL\n", lt3 += ar + "\n", lt3 += b3, lt3 += t3, ct2(lt3 += "ET"), m2[Lt2] = true, p3;
      };
      var Oe = v2.__private__.clip = v2.clip = function(t3) {
        return ct2("evenodd" === t3 ? "W*" : "W"), this;
      };
      v2.clipEvenOdd = function() {
        return Oe("evenodd");
      }, v2.__private__.discardPath = v2.discardPath = function() {
        return ct2("n"), this;
      };
      var Be = v2.__private__.isValidStyle = function(t3) {
        var e4 = false;
        return -1 !== [void 0, null, "S", "D", "F", "DF", "FD", "f", "f*", "B", "B*", "n"].indexOf(t3) && (e4 = true), e4;
      };
      v2.__private__.setDefaultPathOperation = v2.setDefaultPathOperation = function(t3) {
        return Be(t3) && (d2 = t3), this;
      };
      var qe = v2.__private__.getStyle = v2.getStyle = function(t3) {
        var e4 = d2;
        switch (t3) {
          case "D":
          case "S":
            e4 = "S";
            break;
          case "F":
            e4 = "f";
            break;
          case "FD":
          case "DF":
            e4 = "B";
            break;
          case "f":
          case "f*":
          case "B":
          case "B*":
            e4 = t3;
        }
        return e4;
      }, Me = v2.close = function() {
        return ct2("h"), this;
      };
      v2.stroke = function() {
        return ct2("S"), this;
      }, v2.fill = function(t3) {
        return Ee("f", t3), this;
      }, v2.fillEvenOdd = function(t3) {
        return Ee("f*", t3), this;
      }, v2.fillStroke = function(t3) {
        return Ee("B", t3), this;
      }, v2.fillStrokeEvenOdd = function(t3) {
        return Ee("B*", t3), this;
      };
      var Ee = function(t3, e4) {
        "object" == typeof e4 ? Te(e4, t3) : ct2(t3);
      }, Re = function(t3) {
        null === t3 || k2 === x2 && void 0 === t3 || (t3 = qe(t3), ct2(t3));
      };
      function De(t3, e4, r2, n2, i3) {
        var a3 = new I(e4 || this.boundingBox, r2 || this.xStep, n2 || this.yStep, this.gState, i3 || this.matrix);
        a3.stream = this.stream;
        var o3 = t3 + "$$" + this.cloneIndex++ + "$$";
        return Vt2(o3, a3), a3;
      }
      var Te = function(t3, e4) {
        var r2 = jt2[t3.key], n2 = It2[r2];
        if (n2 instanceof F2) ct2("q"), ct2(ze(e4)), n2.gState && v2.setGState(n2.gState), ct2(t3.matrix.toString() + " cm"), ct2("/" + r2 + " sh"), ct2("Q");
        else if (n2 instanceof I) {
          var i3 = new Ut2(1, 0, 0, -1, 0, xr());
          t3.matrix && (i3 = i3.multiply(t3.matrix || Wt2), r2 = De.call(n2, t3.key, t3.boundingBox, t3.xStep, t3.yStep, i3).id), ct2("q"), ct2("/Pattern cs"), ct2("/" + r2 + " scn"), n2.gState && v2.setGState(n2.gState), ct2(e4), ct2("Q");
        }
      }, ze = function(t3) {
        switch (t3) {
          case "f":
          case "F":
          case "n":
            return "W n";
          case "f*":
            return "W* n";
          case "B":
          case "S":
            return "W S";
          case "B*":
            return "W* S";
        }
      }, Ue = v2.moveTo = function(t3, e4) {
        return ct2(q2(T3(t3)) + " " + q2(z3(e4)) + " m"), this;
      }, He = v2.lineTo = function(t3, e4) {
        return ct2(q2(T3(t3)) + " " + q2(z3(e4)) + " l"), this;
      }, We = v2.curveTo = function(t3, e4, r2, n2, i3, a3) {
        return ct2([q2(T3(t3)), q2(z3(e4)), q2(T3(r2)), q2(z3(n2)), q2(T3(i3)), q2(z3(a3)), "c"].join(" ")), this;
      };
      v2.__private__.line = v2.line = function(t3, e4, r2, n2, i3) {
        if (isNaN(t3) || isNaN(e4) || isNaN(r2) || isNaN(n2) || !Be(i3)) throw new Error("Invalid arguments passed to jsPDF.line");
        return k2 === L3 ? this.lines([[r2 - t3, n2 - e4]], t3, e4, [1, 1], i3 || "S") : this.lines([[r2 - t3, n2 - e4]], t3, e4, [1, 1]).stroke();
      }, v2.__private__.lines = v2.lines = function(t3, e4, r2, n2, i3, a3) {
        var o3, s2, c3, u4, l3, h3, f4, d3, p3, g3, m3, v3;
        if ("number" == typeof t3 && (v3 = r2, r2 = e4, e4 = t3, t3 = v3), n2 = n2 || [1, 1], a3 = a3 || false, isNaN(e4) || isNaN(r2) || !Array.isArray(t3) || !Array.isArray(n2) || !Be(i3) || "boolean" != typeof a3) throw new Error("Invalid arguments passed to jsPDF.lines");
        for (Ue(e4, r2), o3 = n2[0], s2 = n2[1], u4 = t3.length, g3 = e4, m3 = r2, c3 = 0; c3 < u4; c3++) 2 === (l3 = t3[c3]).length ? (g3 = l3[0] * o3 + g3, m3 = l3[1] * s2 + m3, He(g3, m3)) : (h3 = l3[0] * o3 + g3, f4 = l3[1] * s2 + m3, d3 = l3[2] * o3 + g3, p3 = l3[3] * s2 + m3, g3 = l3[4] * o3 + g3, m3 = l3[5] * s2 + m3, We(h3, f4, d3, p3, g3, m3));
        return a3 && Me(), Re(i3), this;
      }, v2.path = function(t3) {
        for (var e4 = 0; e4 < t3.length; e4++) {
          var r2 = t3[e4], n2 = r2.c;
          switch (r2.op) {
            case "m":
              Ue(n2[0], n2[1]);
              break;
            case "l":
              He(n2[0], n2[1]);
              break;
            case "c":
              We.apply(this, n2);
              break;
            case "h":
              Me();
          }
        }
        return this;
      }, v2.__private__.rect = v2.rect = function(t3, e4, r2, n2, i3) {
        if (isNaN(t3) || isNaN(e4) || isNaN(r2) || isNaN(n2) || !Be(i3)) throw new Error("Invalid arguments passed to jsPDF.rect");
        return k2 === L3 && (n2 = -n2), ct2([q2(T3(t3)), q2(z3(e4)), q2(T3(r2)), q2(T3(n2)), "re"].join(" ")), Re(i3), this;
      }, v2.__private__.triangle = v2.triangle = function(t3, e4, r2, n2, i3, a3, o3) {
        if (isNaN(t3) || isNaN(e4) || isNaN(r2) || isNaN(n2) || isNaN(i3) || isNaN(a3) || !Be(o3)) throw new Error("Invalid arguments passed to jsPDF.triangle");
        return this.lines([[r2 - t3, n2 - e4], [i3 - r2, a3 - n2], [t3 - i3, e4 - a3]], t3, e4, [1, 1], o3, true), this;
      }, v2.__private__.roundedRect = v2.roundedRect = function(t3, e4, r2, n2, i3, a3, o3) {
        if (isNaN(t3) || isNaN(e4) || isNaN(r2) || isNaN(n2) || isNaN(i3) || isNaN(a3) || !Be(o3)) throw new Error("Invalid arguments passed to jsPDF.roundedRect");
        var s2 = 4 / 3 * (Math.SQRT2 - 1);
        return i3 = Math.min(i3, 0.5 * r2), a3 = Math.min(a3, 0.5 * n2), this.lines([[r2 - 2 * i3, 0], [i3 * s2, 0, i3, a3 - a3 * s2, i3, a3], [0, n2 - 2 * a3], [0, a3 * s2, -i3 * s2, a3, -i3, a3], [2 * i3 - r2, 0], [-i3 * s2, 0, -i3, -a3 * s2, -i3, -a3], [0, 2 * a3 - n2], [0, -a3 * s2, i3 * s2, -a3, i3, -a3]], t3 + i3, e4, [1, 1], o3, true), this;
      }, v2.__private__.ellipse = v2.ellipse = function(t3, e4, r2, n2, i3) {
        if (isNaN(t3) || isNaN(e4) || isNaN(r2) || isNaN(n2) || !Be(i3)) throw new Error("Invalid arguments passed to jsPDF.ellipse");
        var a3 = 4 / 3 * (Math.SQRT2 - 1) * r2, o3 = 4 / 3 * (Math.SQRT2 - 1) * n2;
        return Ue(t3 + r2, e4), We(t3 + r2, e4 - o3, t3 + a3, e4 - n2, t3, e4 - n2), We(t3 - a3, e4 - n2, t3 - r2, e4 - o3, t3 - r2, e4), We(t3 - r2, e4 + o3, t3 - a3, e4 + n2, t3, e4 + n2), We(t3 + a3, e4 + n2, t3 + r2, e4 + o3, t3 + r2, e4), Re(i3), this;
      }, v2.__private__.circle = v2.circle = function(t3, e4, r2, n2) {
        if (isNaN(t3) || isNaN(e4) || isNaN(r2) || !Be(n2)) throw new Error("Invalid arguments passed to jsPDF.circle");
        return this.ellipse(t3, e4, r2, r2, n2);
      }, v2.setFont = function(t3, e4, r2) {
        return r2 && (e4 = B3(e4, r2)), Lt2 = ye2(t3, e4, { disableWarning: false }), this;
      };
      var Ve = v2.__private__.getFont = v2.getFont = function() {
        return Pt2[ye2.apply(v2, arguments)];
      };
      v2.__private__.getFontList = v2.getFontList = function() {
        var t3, e4, r2 = {};
        for (t3 in kt2) if (kt2.hasOwnProperty(t3)) for (e4 in r2[t3] = [], kt2[t3]) kt2[t3].hasOwnProperty(e4) && r2[t3].push(e4);
        return r2;
      }, v2.addFont = function(t3, e4, r2, n2, i3) {
        var a3 = ["StandardEncoding", "MacRomanEncoding", "Identity-H", "WinAnsiEncoding"];
        return arguments[3] && -1 !== a3.indexOf(arguments[3]) ? i3 = arguments[3] : arguments[3] && -1 == a3.indexOf(arguments[3]) && (r2 = B3(r2, n2)), fe2.call(this, t3, e4, r2, i3 = i3 || "Identity-H");
      };
      var Ge, Ye = t2.lineWidth || 0.200025, Je = v2.__private__.getLineWidth = v2.getLineWidth = function() {
        return Ye;
      }, Xe = v2.__private__.setLineWidth = v2.setLineWidth = function(t3) {
        return Ye = t3, ct2(q2(T3(t3)) + " w"), this;
      };
      v2.__private__.setLineDash = j.API.setLineDash = j.API.setLineDashPattern = function(t3, e4) {
        if (t3 = t3 || [], e4 = e4 || 0, isNaN(e4) || !Array.isArray(t3)) throw new Error("Invalid arguments passed to jsPDF.setLineDash");
        return t3 = t3.map(function(t4) {
          return q2(T3(t4));
        }).join(" "), e4 = q2(T3(e4)), ct2("[" + t3 + "] " + e4 + " d"), this;
      };
      var Ke = v2.__private__.getLineHeight = v2.getLineHeight = function() {
        return ft2 * Ge;
      };
      v2.__private__.getLineHeight = v2.getLineHeight = function() {
        return ft2 * Ge;
      };
      var $e = v2.__private__.setLineHeightFactor = v2.setLineHeightFactor = function(t3) {
        return "number" == typeof (t3 = t3 || 1.15) && (Ge = t3), this;
      }, Ze = v2.__private__.getLineHeightFactor = v2.getLineHeightFactor = function() {
        return Ge;
      };
      $e(t2.lineHeight);
      var Qe = v2.__private__.getHorizontalCoordinate = function(t3) {
        return T3(t3);
      }, tr = v2.__private__.getVerticalCoordinate = function(t3) {
        return k2 === x2 ? t3 : Mt2[K2].mediaBox.topRightY - Mt2[K2].mediaBox.bottomLeftY - T3(t3);
      }, er = v2.__private__.getHorizontalCoordinateString = v2.getHorizontalCoordinateString = function(t3) {
        return q2(Qe(t3));
      }, rr = v2.__private__.getVerticalCoordinateString = v2.getVerticalCoordinateString = function(t3) {
        return q2(tr(t3));
      }, nr = t2.strokeColor || "0 G";
      v2.__private__.getStrokeColor = v2.getDrawColor = function() {
        return Qt2(nr);
      }, v2.__private__.setStrokeColor = v2.setDrawColor = function(t3, e4, r2, n2) {
        return nr = te2({ ch1: t3, ch2: e4, ch3: r2, ch4: n2, pdfColorType: "draw", precision: 2 }), ct2(nr), this;
      };
      var ir = t2.fillColor || "0 g";
      v2.__private__.getFillColor = v2.getFillColor = function() {
        return Qt2(ir);
      }, v2.__private__.setFillColor = v2.setFillColor = function(t3, e4, r2, n2) {
        return ir = te2({ ch1: t3, ch2: e4, ch3: r2, ch4: n2, pdfColorType: "fill", precision: 2 }), ct2(ir), this;
      };
      var ar = t2.textColor || "0 g", or = v2.__private__.getTextColor = v2.getTextColor = function() {
        return Qt2(ar);
      };
      v2.__private__.setTextColor = v2.setTextColor = function(t3, e4, r2, n2) {
        return ar = te2({ ch1: t3, ch2: e4, ch3: r2, ch4: n2, pdfColorType: "text", precision: 3 }), this;
      };
      var sr = t2.charSpace, cr = v2.__private__.getCharSpace = v2.getCharSpace = function() {
        return parseFloat(sr || 0);
      };
      v2.__private__.setCharSpace = v2.setCharSpace = function(t3) {
        if (isNaN(t3)) throw new Error("Invalid argument passed to jsPDF.setCharSpace");
        return sr = t3, this;
      };
      var ur = 0;
      v2.CapJoinStyles = { 0: 0, butt: 0, but: 0, miter: 0, 1: 1, round: 1, rounded: 1, circle: 1, 2: 2, projecting: 2, project: 2, square: 2, bevel: 2 }, v2.__private__.setLineCap = v2.setLineCap = function(t3) {
        var e4 = v2.CapJoinStyles[t3];
        if (void 0 === e4) throw new Error("Line cap style of '" + t3 + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
        return ur = e4, ct2(e4 + " J"), this;
      };
      var lr = 0;
      v2.__private__.setLineJoin = v2.setLineJoin = function(t3) {
        var e4 = v2.CapJoinStyles[t3];
        if (void 0 === e4) throw new Error("Line join style of '" + t3 + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
        return lr = e4, ct2(e4 + " j"), this;
      }, v2.__private__.setLineMiterLimit = v2.__private__.setMiterLimit = v2.setLineMiterLimit = v2.setMiterLimit = function(t3) {
        if (t3 = t3 || 0, isNaN(t3)) throw new Error("Invalid argument passed to jsPDF.setLineMiterLimit");
        return ct2(q2(T3(t3)) + " M"), this;
      }, v2.GState = P, v2.setGState = function(t3) {
        (t3 = "string" == typeof t3 ? Ct2[Ot2[t3]] : hr(null, t3)).equals(Bt2) || (ct2("/" + t3.id + " gs"), Bt2 = t3);
      };
      var hr = function(t3, e4) {
        if (!t3 || !Ot2[t3]) {
          var r2 = false;
          for (var n2 in Ct2) if (Ct2.hasOwnProperty(n2) && Ct2[n2].equals(e4)) {
            r2 = true;
            break;
          }
          if (r2) e4 = Ct2[n2];
          else {
            var i3 = "GS" + (Object.keys(Ct2).length + 1).toString(10);
            Ct2[i3] = e4, e4.id = i3;
          }
          return t3 && (Ot2[t3] = e4.id), Et2.publish("addGState", e4), e4;
        }
      };
      v2.addGState = function(t3, e4) {
        return hr(t3, e4), this;
      }, v2.saveGraphicsState = function() {
        return ct2("q"), Ft2.push({ key: Lt2, size: ft2, color: ar }), this;
      }, v2.restoreGraphicsState = function() {
        ct2("Q");
        var t3 = Ft2.pop();
        return Lt2 = t3.key, ft2 = t3.size, ar = t3.color, Bt2 = null, this;
      }, v2.setCurrentTransformationMatrix = function(t3) {
        return ct2(t3.toString() + " cm"), this;
      }, v2.comment = function(t3) {
        return ct2("#" + t3), this;
      };
      var fr = function(t3, e4) {
        var r2 = t3 || 0;
        Object.defineProperty(this, "x", { enumerable: true, get: function() {
          return r2;
        }, set: function(t4) {
          isNaN(t4) || (r2 = parseFloat(t4));
        } });
        var n2 = e4 || 0;
        Object.defineProperty(this, "y", { enumerable: true, get: function() {
          return n2;
        }, set: function(t4) {
          isNaN(t4) || (n2 = parseFloat(t4));
        } });
        var i3 = "pt";
        return Object.defineProperty(this, "type", { enumerable: true, get: function() {
          return i3;
        }, set: function(t4) {
          i3 = t4.toString();
        } }), this;
      }, dr = function(t3, e4, r2, n2) {
        fr.call(this, t3, e4), this.type = "rect";
        var i3 = r2 || 0;
        Object.defineProperty(this, "w", { enumerable: true, get: function() {
          return i3;
        }, set: function(t4) {
          isNaN(t4) || (i3 = parseFloat(t4));
        } });
        var a3 = n2 || 0;
        return Object.defineProperty(this, "h", { enumerable: true, get: function() {
          return a3;
        }, set: function(t4) {
          isNaN(t4) || (a3 = parseFloat(t4));
        } }), this;
      }, pr = function() {
        this.page = qt2, this.currentPage = K2, this.pages = it2.slice(0), this.pagesContext = Mt2.slice(0), this.x = At2, this.y = St2, this.matrix = _t2, this.width = vr(K2), this.height = yr(K2), this.outputDestination = ot2, this.id = "", this.objectNumber = -1;
      };
      pr.prototype.restore = function() {
        qt2 = this.page, K2 = this.currentPage, Mt2 = this.pagesContext, it2 = this.pages, At2 = this.x, St2 = this.y, _t2 = this.matrix, br(K2, this.width), wr(K2, this.height), ot2 = this.outputDestination;
      };
      var gr = function(t3, e4, r2, n2, i3) {
        zt2.push(new pr()), qt2 = K2 = 0, it2 = [], At2 = t3, St2 = e4, _t2 = i3, pe2([r2, n2]);
      };
      for (var mr in v2.beginFormObject = function(t3, e4, r2, n2, i3) {
        return gr(t3, e4, r2, n2, i3), this;
      }, v2.endFormObject = function(t3) {
        return (function(t4) {
          if (Tt2[t4]) zt2.pop().restore();
          else {
            var e4 = new pr(), r2 = "Xo" + (Object.keys(Dt2).length + 1).toString(10);
            e4.id = r2, Tt2[t4] = r2, Dt2[r2] = e4, Et2.publish("addFormObject", e4), zt2.pop().restore();
          }
        })(t3), this;
      }, v2.doFormObject = function(t3, e4) {
        var r2 = Dt2[Tt2[t3]];
        return ct2("q"), ct2(e4.toString() + " cm"), ct2("/" + r2.id + " Do"), ct2("Q"), this;
      }, v2.getFormObject = function(t3) {
        var e4 = Dt2[Tt2[t3]];
        return { x: e4.x, y: e4.y, width: e4.width, height: e4.height, matrix: e4.matrix };
      }, v2.save = function(t3, e4) {
        t3 = t3 || "generated.pdf", (e4 = e4 || {}).returnPromise = e4.returnPromise || false;
        var r2 = __require("fs"), n2 = Buffer.from(lt2(Se()));
        if (false !== e4.returnPromise) return new Promise(function(e5, i3) {
          r2.writeFile(t3, n2, function(t4) {
            t4 ? i3(t4) : e5();
          });
        });
        r2.writeFileSync(t3, n2);
      }, j.API) j.API.hasOwnProperty(mr) && ("events" === mr && j.API.events.length ? (function(t3, e4) {
        var r2, n2, i3;
        for (i3 = e4.length - 1; -1 !== i3; i3--) r2 = e4[i3][0], n2 = e4[i3][1], t3.subscribe.apply(t3, [r2].concat("function" == typeof n2 ? [n2] : n2));
      })(Et2, j.API.events) : v2[mr] = j.API[mr]);
      function vr(t3) {
        return Mt2[t3].mediaBox.topRightX - Mt2[t3].mediaBox.bottomLeftX;
      }
      function br(t3, e4) {
        Mt2[t3].mediaBox.topRightX = e4 + Mt2[t3].mediaBox.bottomLeftX;
      }
      function yr(t3) {
        return Mt2[t3].mediaBox.topRightY - Mt2[t3].mediaBox.bottomLeftY;
      }
      function wr(t3, e4) {
        Mt2[t3].mediaBox.topRightY = e4 + Mt2[t3].mediaBox.bottomLeftY;
      }
      var Nr = v2.getPageWidth = function(t3) {
        return vr(t3 = t3 || K2) / xt2;
      }, Lr = v2.setPageWidth = function(t3, e4) {
        br(t3, e4 * xt2);
      }, xr = v2.getPageHeight = function(t3) {
        return yr(t3 = t3 || K2) / xt2;
      }, Ar = v2.setPageHeight = function(t3, e4) {
        wr(t3, e4 * xt2);
      };
      return v2.internal = { pdfEscape: de2, getStyle: qe, getFont: Ve, getFontSize: pt2, getCharSpace: cr, getTextColor: or, getLineHeight: Ke, getLineHeightFactor: Ze, getLineWidth: Je, write: ut2, getHorizontalCoordinate: Qe, getVerticalCoordinate: tr, getCoordinateString: er, getVerticalCoordinateString: rr, collections: {}, newObject: Yt2, newAdditionalObject: Kt2, newObjectDeferred: Jt2, newObjectDeferredBegin: Xt2, getFilters: ee2, putStream: re2, events: Et2, scaleFactor: xt2, pageSize: { getWidth: function() {
        return Nr(K2);
      }, setWidth: function(t3) {
        Lr(K2, t3);
      }, getHeight: function() {
        return xr(K2);
      }, setHeight: function(t3) {
        Ar(K2, t3);
      } }, encryptionOptions: p2, encryption: Fe, getEncryptor: function(t3) {
        return null !== p2 ? Fe.encryptor(t3, 0) : function(t4) {
          return t4;
        };
      }, output: Pe, getNumberOfPages: be2, get pages() {
        return it2;
      }, out: ct2, f2: R2, f3: D2, getPageInfo: Ie, getPageInfoByObjId: je, getCurrentPageInfo: Ce, getPDFVersion: y2, Point: fr, Rectangle: dr, Matrix: Ut2, hasHotfix: ke }, Object.defineProperty(v2.internal.pageSize, "width", { get: function() {
        return Nr(K2);
      }, set: function(t3) {
        Lr(K2, t3);
      }, enumerable: true, configurable: true }), Object.defineProperty(v2.internal.pageSize, "height", { get: function() {
        return xr(K2);
      }, set: function(t3) {
        Ar(K2, t3);
      }, enumerable: true, configurable: true }), function(t3) {
        for (var e4 = 0, r2 = ht2.length; e4 < r2; e4++) {
          var n2 = fe2.call(this, t3[e4][0], t3[e4][1], t3[e4][2], ht2[e4][3], true);
          false === g2 && (m2[n2] = true);
          var i3 = t3[e4][0].split("-");
          he2({ id: n2, fontName: i3[0], fontStyle: i3[1] || "" });
        }
        Et2.publish("addFonts", { fonts: Pt2, dictionary: kt2 });
      }.call(v2, ht2), Lt2 = "F1", ge2(c2, i2), Et2.publish("initialized"), v2;
    }
    A2.prototype.lsbFirstWord = function(t2) {
      return String.fromCharCode(255 & t2, t2 >> 8 & 255, t2 >> 16 & 255, t2 >> 24 & 255);
    }, A2.prototype.toHexString = function(t2) {
      return t2.split("").map(function(t3) {
        return ("0" + (255 & t3.charCodeAt(0)).toString(16)).slice(-2);
      }).join("");
    }, A2.prototype.hexToBytes = function(t2) {
      for (var e3 = [], r2 = 0; r2 < t2.length; r2 += 2) e3.push(String.fromCharCode(parseInt(t2.substr(r2, 2), 16)));
      return e3.join("");
    }, A2.prototype.processOwnerPassword = function(t2, e3) {
      return L2(y(e3).substr(0, 5), t2);
    }, A2.prototype.encryptor = function(t2, e3) {
      let r2 = y(this.encryptionKey + String.fromCharCode(255 & t2, t2 >> 8 & 255, t2 >> 16 & 255, 255 & e3, e3 >> 8 & 255)).substr(0, 10);
      return function(t3) {
        return L2(r2, t3);
      };
    }, P.prototype.equals = function(t2) {
      var e3, r2 = "id,objectNumber,equals";
      if (!t2 || typeof t2 != typeof this) return false;
      var n2 = 0;
      for (e3 in this) if (!(r2.indexOf(e3) >= 0)) {
        if (this.hasOwnProperty(e3) && !t2.hasOwnProperty(e3)) return false;
        if (this[e3] !== t2[e3]) return false;
        n2++;
      }
      for (e3 in t2) t2.hasOwnProperty(e3) && r2.indexOf(e3) < 0 && n2--;
      return 0 === n2;
    }, j.API = { events: [] }, j.version = "4.2.0";
    var C = j.API;
    var O = 1;
    var B = function(t2) {
      return t2.replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
    };
    var q = function(t2) {
      return t2.replace(/\\\\/g, "\\").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
    };
    var M = function(t2) {
      return t2.toString().replace(/#/g, "#23").replace(/[\s\n\r()<>[\]{}\/%]/g, (t3) => {
        const e3 = t3.charCodeAt(0).toString(16).toUpperCase();
        return "#" + (1 === e3.length ? "0" + e3 : e3);
      });
    };
    var E2 = function(t2) {
      return t2.toFixed(2);
    };
    var R = function(t2) {
      return t2.toFixed(5);
    };
    C.__acroform__ = {};
    var D = function(t2, e3) {
      t2.prototype = Object.create(e3.prototype), t2.prototype.constructor = t2;
    };
    var T2 = function(t2) {
      return t2 * O;
    };
    var z2 = function(t2) {
      var e3 = new nt(), r2 = vt.internal.getHeight(t2) || 0, n2 = vt.internal.getWidth(t2) || 0;
      return e3.BBox = [0, 0, Number(E2(n2)), Number(E2(r2))], e3;
    };
    var U2 = C.__acroform__.setBit = function(t2, e3) {
      if (t2 = t2 || 0, e3 = e3 || 0, isNaN(t2) || isNaN(e3)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBit");
      return t2 | 1 << e3;
    };
    var H = C.__acroform__.clearBit = function(t2, e3) {
      if (t2 = t2 || 0, e3 = e3 || 0, isNaN(t2) || isNaN(e3)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBit");
      return t2 & ~(1 << e3);
    };
    var W = C.__acroform__.getBit = function(t2, e3) {
      if (isNaN(t2) || isNaN(e3)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBit");
      return t2 & 1 << e3 ? 1 : 0;
    };
    var V2 = C.__acroform__.getBitForPdf = function(t2, e3) {
      if (isNaN(t2) || isNaN(e3)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBitForPdf");
      return W(t2, e3 - 1);
    };
    var G = C.__acroform__.setBitForPdf = function(t2, e3) {
      if (isNaN(t2) || isNaN(e3)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBitForPdf");
      return U2(t2, e3 - 1);
    };
    var Y = C.__acroform__.clearBitForPdf = function(t2, e3) {
      if (isNaN(t2) || isNaN(e3)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBitForPdf");
      return H(t2, e3 - 1);
    };
    var J = C.__acroform__.calculateCoordinates = function(t2, e3) {
      var r2 = e3.internal.getHorizontalCoordinate, n2 = e3.internal.getVerticalCoordinate, i2 = t2[0], a3 = t2[1], o2 = t2[2], s2 = t2[3], c2 = {};
      return c2.lowerLeft_X = r2(i2) || 0, c2.lowerLeft_Y = n2(a3 + s2) || 0, c2.upperRight_X = r2(i2 + o2) || 0, c2.upperRight_Y = n2(a3) || 0, [Number(E2(c2.lowerLeft_X)), Number(E2(c2.lowerLeft_Y)), Number(E2(c2.upperRight_X)), Number(E2(c2.upperRight_Y))];
    };
    var X = function(t2) {
      if (t2.appearanceStreamContent) return t2.appearanceStreamContent;
      if (t2.V || t2.DV) {
        var e3 = [], r2 = t2._V || t2.DV, n2 = K(t2, r2), i2 = t2.scope.internal.getFont(t2.fontName, t2.fontStyle).id;
        e3.push("/Tx BMC"), e3.push("q"), e3.push("BT"), e3.push(t2.scope.__private__.encodeColorString(t2.color)), e3.push("/" + i2 + " " + E2(n2.fontSize) + " Tf"), e3.push("1 0 0 1 0 0 Tm"), e3.push(n2.text), e3.push("ET"), e3.push("Q"), e3.push("EMC");
        var a3 = z2(t2);
        return a3.scope = t2.scope, a3.stream = e3.join("\n"), a3;
      }
    };
    var K = function(t2, e3) {
      var r2 = 0 === t2.fontSize ? t2.maxFontSize : t2.fontSize, n2 = { text: "", fontSize: "" }, i2 = (e3 = ")" == (e3 = "(" == e3.substr(0, 1) ? e3.substr(1) : e3).substr(e3.length - 1) ? e3.substr(0, e3.length - 1) : e3).split(" ");
      i2 = t2.multiline ? i2.map((t3) => t3.split("\n")) : i2.map((t3) => [t3]);
      var a3 = r2, o2 = vt.internal.getHeight(t2) || 0;
      o2 = o2 < 0 ? -o2 : o2;
      var s2 = vt.internal.getWidth(t2) || 0;
      s2 = s2 < 0 ? -s2 : s2;
      var c2 = function(e4, r3, n3) {
        if (e4 + 1 < i2.length) {
          var a4 = r3 + " " + i2[e4 + 1][0];
          return $(a4, t2, n3).width <= s2 - 4;
        }
        return false;
      };
      a3++;
      t: for (; a3 > 0; ) {
        e3 = "", a3--;
        var u3, l2, h2 = $("3", t2, a3).height, f3 = t2.multiline ? o2 - a3 : (o2 - h2) / 2, d2 = f3 += 2, p2 = 0, g2 = 0, m2 = 0;
        if (a3 <= 0) {
          e3 = "(...) Tj\n", e3 += "% Width of Text: " + $(e3, t2, a3 = 12).width + ", FieldWidth:" + s2 + "\n";
          break;
        }
        var v2 = "", b2 = 0;
        e: for (var y2 = 0; y2 < i2.length; y2++) if (i2.hasOwnProperty(y2)) {
          let r3 = false;
          if (1 !== i2[y2].length && m2 !== i2[y2].length - 1) {
            if ((h2 + 2) * (b2 + 2) + 2 > o2) continue t;
            v2 += i2[y2][m2], r3 = true, g2 = y2, y2--;
          } else {
            v2 = " " == (v2 += i2[y2][m2] + " ").substr(v2.length - 1) ? v2.substr(0, v2.length - 1) : v2;
            var w2 = parseInt(y2), N2 = c2(w2, v2, a3), L3 = y2 >= i2.length - 1;
            if (N2 && !L3) {
              v2 += " ", m2 = 0;
              continue;
            }
            if (N2 || L3) {
              if (L3) g2 = w2;
              else if (t2.multiline && (h2 + 2) * (b2 + 2) + 2 > o2) continue t;
            } else {
              if (!t2.multiline) continue t;
              if ((h2 + 2) * (b2 + 2) + 2 > o2) continue t;
              g2 = w2;
            }
          }
          for (var x2 = "", A3 = p2; A3 <= g2; A3++) {
            var S2 = i2[A3];
            if (t2.multiline) {
              if (A3 === g2) {
                x2 += S2[m2] + " ", m2 = (m2 + 1) % S2.length;
                continue;
              }
              if (A3 === p2) {
                x2 += S2[S2.length - 1] + " ";
                continue;
              }
            }
            x2 += S2[0] + " ";
          }
          switch (x2 = " " == x2.substr(x2.length - 1) ? x2.substr(0, x2.length - 1) : x2, l2 = $(x2, t2, a3).width, t2.textAlign) {
            case "right":
              u3 = s2 - l2 - 2;
              break;
            case "center":
              u3 = (s2 - l2) / 2;
              break;
            default:
              u3 = 2;
          }
          e3 += E2(u3) + " " + E2(d2) + " Td\n", e3 += "(" + B(x2) + ") Tj\n", e3 += -E2(u3) + " 0 Td\n", d2 = -(a3 + 2), l2 = 0, p2 = r3 ? g2 : g2 + 1, b2++, v2 = "";
          continue e;
        }
        break;
      }
      return n2.text = e3, n2.fontSize = a3, n2;
    };
    var $ = function(t2, e3, r2) {
      var n2 = e3.scope.internal.getFont(e3.fontName, e3.fontStyle), i2 = e3.scope.getStringUnitWidth(t2, { font: n2, fontSize: parseFloat(r2), charSpace: 0 }) * parseFloat(r2);
      return { height: e3.scope.getStringUnitWidth("3", { font: n2, fontSize: parseFloat(r2), charSpace: 0 }) * parseFloat(r2) * 1.5, width: i2 };
    };
    var Z2 = { fields: [], xForms: [], acroFormDictionaryRoot: null, printedOut: false, internal: null, isInitialized: false };
    var Q = function(t2, e3) {
      var r2 = { type: "reference", object: t2 };
      void 0 === e3.internal.getPageInfo(t2.page).pageContext.annotations.find(function(t3) {
        return t3.type === r2.type && t3.object === r2.object;
      }) && e3.internal.getPageInfo(t2.page).pageContext.annotations.push(r2);
    };
    var tt = C.__acroform__.arrayToPdfArray = function(t2, e3, r2) {
      var n2 = function(t3) {
        return t3;
      };
      if (Array.isArray(t2)) {
        for (var i2 = "[", a3 = 0; a3 < t2.length; a3++) switch (0 !== a3 && (i2 += " "), typeof t2[a3]) {
          case "boolean":
          case "number":
          case "object":
            i2 += t2[a3].toString();
            break;
          case "string":
            "/" === t2[a3].substr(0, 1) ? i2 += "/" + M(t2[a3].substr(1)) : (void 0 !== e3 && r2 && (n2 = r2.internal.getEncryptor(e3)), i2 += "(" + B(n2(t2[a3].toString())) + ")");
        }
        return i2 + "]";
      }
      throw new Error("Invalid argument passed to jsPDF.__acroform__.arrayToPdfArray");
    };
    var et = function(t2, e3, r2) {
      var n2 = function(t3) {
        return t3;
      };
      return void 0 !== e3 && r2 && (n2 = r2.internal.getEncryptor(e3)), (t2 = t2 || "").toString(), "(" + B(n2(t2)) + ")";
    };
    var rt = function() {
      this._objId = void 0, this._scope = void 0, Object.defineProperty(this, "objId", { get: function() {
        if (void 0 === this._objId) {
          if (void 0 === this.scope) return;
          this._objId = this.scope.internal.newObjectDeferred();
        }
        return this._objId;
      }, set: function(t2) {
        this._objId = t2;
      } }), Object.defineProperty(this, "scope", { value: this._scope, writable: true });
    };
    rt.prototype.toString = function() {
      return this.objId + " 0 R";
    }, rt.prototype.putStream = function() {
      var t2 = this.getKeyValueListForStream();
      this.scope.internal.putStream({ data: this.stream, additionalKeyValues: t2, objectId: this.objId }), this.scope.internal.out("endobj");
    }, rt.prototype.getKeyValueListForStream = function() {
      var t2 = [], e3 = Object.getOwnPropertyNames(this).filter(function(t3) {
        return "content" != t3 && "appearanceStreamContent" != t3 && "scope" != t3 && "objId" != t3 && "_" != t3.substring(0, 1);
      });
      for (var r2 in e3) if (false === Object.getOwnPropertyDescriptor(this, e3[r2]).configurable) {
        var n2 = e3[r2], i2 = this[n2];
        i2 && (Array.isArray(i2) ? t2.push({ key: n2, value: tt(i2, this.objId, this.scope) }) : i2 instanceof rt ? (i2.scope = this.scope, t2.push({ key: n2, value: i2.objId + " 0 R" })) : "function" != typeof i2 && t2.push({ key: n2, value: i2 }));
      }
      return t2;
    };
    var nt = function() {
      rt.call(this), Object.defineProperty(this, "Type", { value: "/XObject", configurable: false, writable: true }), Object.defineProperty(this, "Subtype", { value: "/Form", configurable: false, writable: true }), Object.defineProperty(this, "FormType", { value: 1, configurable: false, writable: true });
      var t2, e3 = [];
      Object.defineProperty(this, "BBox", { configurable: false, get: function() {
        return e3;
      }, set: function(t3) {
        e3 = t3;
      } }), Object.defineProperty(this, "Resources", { value: "2 0 R", configurable: false, writable: true }), Object.defineProperty(this, "stream", { enumerable: false, configurable: true, set: function(e4) {
        t2 = e4.trim();
      }, get: function() {
        return t2 || null;
      } });
    };
    D(nt, rt);
    var it = function() {
      rt.call(this);
      var t2, e3 = [];
      Object.defineProperty(this, "Kids", { enumerable: false, configurable: true, get: function() {
        return e3.length > 0 ? e3 : void 0;
      } }), Object.defineProperty(this, "Fields", { enumerable: false, configurable: false, get: function() {
        return e3;
      } }), Object.defineProperty(this, "DA", { enumerable: false, configurable: false, get: function() {
        if (t2) {
          var e4 = function(t3) {
            return t3;
          };
          return this.scope && (e4 = this.scope.internal.getEncryptor(this.objId)), "(" + B(e4(t2)) + ")";
        }
      }, set: function(e4) {
        t2 = e4;
      } });
    };
    D(it, rt);
    var at = function() {
      rt.call(this);
      var t2 = 4;
      Object.defineProperty(this, "F", { enumerable: false, configurable: false, get: function() {
        return t2;
      }, set: function(e4) {
        if (isNaN(e4)) throw new Error('Invalid value "' + e4 + '" for attribute F supplied.');
        t2 = e4;
      } }), Object.defineProperty(this, "showWhenPrinted", { enumerable: true, configurable: true, get: function() {
        return Boolean(V2(t2, 3));
      }, set: function(e4) {
        true === Boolean(e4) ? this.F = G(t2, 3) : this.F = Y(t2, 3);
      } });
      var e3 = 0;
      Object.defineProperty(this, "Ff", { enumerable: false, configurable: false, get: function() {
        return e3;
      }, set: function(t3) {
        if (isNaN(t3)) throw new Error('Invalid value "' + t3 + '" for attribute Ff supplied.');
        e3 = t3;
      } });
      var r2 = [];
      Object.defineProperty(this, "Rect", { enumerable: false, configurable: false, get: function() {
        if (0 !== r2.length) return r2;
      }, set: function(t3) {
        r2 = void 0 !== t3 ? t3 : [];
      } }), Object.defineProperty(this, "x", { enumerable: true, configurable: true, get: function() {
        return !r2 || isNaN(r2[0]) ? 0 : r2[0];
      }, set: function(t3) {
        r2[0] = t3;
      } }), Object.defineProperty(this, "y", { enumerable: true, configurable: true, get: function() {
        return !r2 || isNaN(r2[1]) ? 0 : r2[1];
      }, set: function(t3) {
        r2[1] = t3;
      } }), Object.defineProperty(this, "width", { enumerable: true, configurable: true, get: function() {
        return !r2 || isNaN(r2[2]) ? 0 : r2[2];
      }, set: function(t3) {
        r2[2] = t3;
      } }), Object.defineProperty(this, "height", { enumerable: true, configurable: true, get: function() {
        return !r2 || isNaN(r2[3]) ? 0 : r2[3];
      }, set: function(t3) {
        r2[3] = t3;
      } });
      var n2 = "";
      Object.defineProperty(this, "FT", { enumerable: true, configurable: false, get: function() {
        return n2;
      }, set: function(t3) {
        switch (t3) {
          case "/Btn":
          case "/Tx":
          case "/Ch":
          case "/Sig":
            n2 = t3;
            break;
          default:
            throw new Error('Invalid value "' + t3 + '" for attribute FT supplied.');
        }
      } });
      var i2 = null;
      Object.defineProperty(this, "T", { enumerable: true, configurable: false, get: function() {
        if (!i2 || i2.length < 1) {
          if (this instanceof dt) return;
          i2 = "FieldObject" + at.FieldNum++;
        }
        var t3 = function(t4) {
          return t4;
        };
        return this.scope && (t3 = this.scope.internal.getEncryptor(this.objId)), "(" + B(t3(i2)) + ")";
      }, set: function(t3) {
        i2 = t3.toString();
      } }), Object.defineProperty(this, "fieldName", { configurable: true, enumerable: true, get: function() {
        return i2;
      }, set: function(t3) {
        i2 = t3;
      } });
      var a3 = "helvetica";
      Object.defineProperty(this, "fontName", { enumerable: true, configurable: true, get: function() {
        return a3;
      }, set: function(t3) {
        a3 = t3;
      } });
      var o2 = "normal";
      Object.defineProperty(this, "fontStyle", { enumerable: true, configurable: true, get: function() {
        return o2;
      }, set: function(t3) {
        o2 = t3;
      } });
      var s2 = 0;
      Object.defineProperty(this, "fontSize", { enumerable: true, configurable: true, get: function() {
        return s2;
      }, set: function(t3) {
        s2 = t3;
      } });
      var c2 = void 0;
      Object.defineProperty(this, "maxFontSize", { enumerable: true, configurable: true, get: function() {
        return void 0 === c2 ? 50 / O : c2;
      }, set: function(t3) {
        c2 = t3;
      } });
      var u3 = "black";
      Object.defineProperty(this, "color", { enumerable: true, configurable: true, get: function() {
        return u3;
      }, set: function(t3) {
        u3 = t3;
      } });
      var l2 = "/F1 0 Tf 0 g";
      Object.defineProperty(this, "DA", { enumerable: true, configurable: false, get: function() {
        if (!(!l2 || this instanceof dt || this instanceof gt)) return et(l2, this.objId, this.scope);
      }, set: function(t3) {
        t3 = t3.toString(), l2 = t3;
      } });
      var h2 = null;
      Object.defineProperty(this, "DV", { enumerable: false, configurable: false, get: function() {
        if (h2) return this instanceof lt == 0 ? et(h2, this.objId, this.scope) : h2;
      }, set: function(t3) {
        t3 = t3.toString(), h2 = this instanceof lt == 0 ? "(" === t3.substr(0, 1) ? q(t3.substr(1, t3.length - 2)) : q(t3) : t3;
      } }), Object.defineProperty(this, "defaultValue", { enumerable: true, configurable: true, get: function() {
        return this instanceof lt == 1 ? q(h2.substr(1, h2.length - 1)) : h2;
      }, set: function(t3) {
        t3 = t3.toString(), h2 = this instanceof lt == 1 ? "/" + M(t3) : t3;
      } });
      var f3 = null;
      Object.defineProperty(this, "_V", { enumerable: false, configurable: false, get: function() {
        if (f3) return f3;
      }, set: function(t3) {
        this.V = t3;
      } }), Object.defineProperty(this, "V", { enumerable: false, configurable: false, get: function() {
        if (f3) return this instanceof lt == 0 ? et(f3, this.objId, this.scope) : f3;
      }, set: function(t3) {
        t3 = t3.toString(), f3 = this instanceof lt == 0 ? "(" === t3.substr(0, 1) ? q(t3.substr(1, t3.length - 2)) : q(t3) : t3;
      } }), Object.defineProperty(this, "value", { enumerable: true, configurable: true, get: function() {
        return this instanceof lt == 1 ? q(f3.substr(1, f3.length - 1)) : f3;
      }, set: function(t3) {
        t3 = t3.toString(), f3 = this instanceof lt == 1 ? "/" + M(t3) : t3;
      } }), Object.defineProperty(this, "hasAnnotation", { enumerable: true, configurable: true, get: function() {
        return this.Rect;
      } }), Object.defineProperty(this, "Type", { enumerable: true, configurable: false, get: function() {
        return this.hasAnnotation ? "/Annot" : null;
      } }), Object.defineProperty(this, "Subtype", { enumerable: true, configurable: false, get: function() {
        return this.hasAnnotation ? "/Widget" : null;
      } });
      var d2, p2 = false;
      Object.defineProperty(this, "hasAppearanceStream", { enumerable: true, configurable: true, get: function() {
        return p2;
      }, set: function(t3) {
        t3 = Boolean(t3), p2 = t3;
      } }), Object.defineProperty(this, "page", { enumerable: true, configurable: true, get: function() {
        if (d2) return d2;
      }, set: function(t3) {
        d2 = t3;
      } }), Object.defineProperty(this, "readOnly", { enumerable: true, configurable: true, get: function() {
        return Boolean(V2(this.Ff, 1));
      }, set: function(t3) {
        true === Boolean(t3) ? this.Ff = G(this.Ff, 1) : this.Ff = Y(this.Ff, 1);
      } }), Object.defineProperty(this, "required", { enumerable: true, configurable: true, get: function() {
        return Boolean(V2(this.Ff, 2));
      }, set: function(t3) {
        true === Boolean(t3) ? this.Ff = G(this.Ff, 2) : this.Ff = Y(this.Ff, 2);
      } }), Object.defineProperty(this, "noExport", { enumerable: true, configurable: true, get: function() {
        return Boolean(V2(this.Ff, 3));
      }, set: function(t3) {
        true === Boolean(t3) ? this.Ff = G(this.Ff, 3) : this.Ff = Y(this.Ff, 3);
      } });
      var g2 = null;
      Object.defineProperty(this, "Q", { enumerable: true, configurable: false, get: function() {
        if (null !== g2) return g2;
      }, set: function(t3) {
        if (-1 === [0, 1, 2].indexOf(t3)) throw new Error('Invalid value "' + t3 + '" for attribute Q supplied.');
        g2 = t3;
      } }), Object.defineProperty(this, "textAlign", { get: function() {
        var t3;
        switch (g2) {
          case 0:
          default:
            t3 = "left";
            break;
          case 1:
            t3 = "center";
            break;
          case 2:
            t3 = "right";
        }
        return t3;
      }, configurable: true, enumerable: true, set: function(t3) {
        switch (t3) {
          case "right":
          case 2:
            g2 = 2;
            break;
          case "center":
          case 1:
            g2 = 1;
            break;
          default:
            g2 = 0;
        }
      } });
    };
    D(at, rt);
    var ot = function() {
      at.call(this), this.FT = "/Ch", this.V = "()", this.fontName = "zapfdingbats";
      var t2 = 0;
      Object.defineProperty(this, "TI", { enumerable: true, configurable: false, get: function() {
        return t2;
      }, set: function(e4) {
        t2 = e4;
      } }), Object.defineProperty(this, "topIndex", { enumerable: true, configurable: true, get: function() {
        return t2;
      }, set: function(e4) {
        t2 = e4;
      } });
      var e3 = [];
      Object.defineProperty(this, "Opt", { enumerable: true, configurable: false, get: function() {
        return tt(e3, this.objId, this.scope);
      }, set: function(t3) {
        var r2, n2;
        n2 = [], "string" == typeof (r2 = t3) && (n2 = (function(t4, e4, r3) {
          r3 || (r3 = 1);
          for (var n3, i2 = []; n3 = e4.exec(t4); ) i2.push(n3[r3]);
          return i2;
        })(r2, /\((.*?)\)/g)), e3 = n2;
      } }), this.getOptions = function() {
        return e3;
      }, this.setOptions = function(t3) {
        e3 = t3, this.sort && e3.sort();
      }, this.addOption = function(t3) {
        t3 = (t3 = t3 || "").toString(), e3.push(t3), this.sort && e3.sort();
      }, this.removeOption = function(t3, r2) {
        for (r2 = r2 || false, t3 = (t3 = t3 || "").toString(); -1 !== e3.indexOf(t3) && (e3.splice(e3.indexOf(t3), 1), false !== r2); ) ;
      }, Object.defineProperty(this, "combo", { enumerable: true, configurable: true, get: function() {
        return Boolean(V2(this.Ff, 18));
      }, set: function(t3) {
        true === Boolean(t3) ? this.Ff = G(this.Ff, 18) : this.Ff = Y(this.Ff, 18);
      } }), Object.defineProperty(this, "edit", { enumerable: true, configurable: true, get: function() {
        return Boolean(V2(this.Ff, 19));
      }, set: function(t3) {
        true === this.combo && (true === Boolean(t3) ? this.Ff = G(this.Ff, 19) : this.Ff = Y(this.Ff, 19));
      } }), Object.defineProperty(this, "sort", { enumerable: true, configurable: true, get: function() {
        return Boolean(V2(this.Ff, 20));
      }, set: function(t3) {
        true === Boolean(t3) ? (this.Ff = G(this.Ff, 20), e3.sort()) : this.Ff = Y(this.Ff, 20);
      } }), Object.defineProperty(this, "multiSelect", { enumerable: true, configurable: true, get: function() {
        return Boolean(V2(this.Ff, 22));
      }, set: function(t3) {
        true === Boolean(t3) ? this.Ff = G(this.Ff, 22) : this.Ff = Y(this.Ff, 22);
      } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: true, configurable: true, get: function() {
        return Boolean(V2(this.Ff, 23));
      }, set: function(t3) {
        true === Boolean(t3) ? this.Ff = G(this.Ff, 23) : this.Ff = Y(this.Ff, 23);
      } }), Object.defineProperty(this, "commitOnSelChange", { enumerable: true, configurable: true, get: function() {
        return Boolean(V2(this.Ff, 27));
      }, set: function(t3) {
        true === Boolean(t3) ? this.Ff = G(this.Ff, 27) : this.Ff = Y(this.Ff, 27);
      } }), this.hasAppearanceStream = false;
    };
    D(ot, at);
    var st = function() {
      ot.call(this), this.fontName = "helvetica", this.combo = false;
    };
    D(st, ot);
    var ct = function() {
      st.call(this), this.combo = true;
    };
    D(ct, st);
    var ut = function() {
      ct.call(this), this.edit = true;
    };
    D(ut, ct);
    var lt = function() {
      at.call(this), this.FT = "/Btn", Object.defineProperty(this, "noToggleToOff", { enumerable: true, configurable: true, get: function() {
        return Boolean(V2(this.Ff, 15));
      }, set: function(t3) {
        true === Boolean(t3) ? this.Ff = G(this.Ff, 15) : this.Ff = Y(this.Ff, 15);
      } }), Object.defineProperty(this, "radio", { enumerable: true, configurable: true, get: function() {
        return Boolean(V2(this.Ff, 16));
      }, set: function(t3) {
        true === Boolean(t3) ? this.Ff = G(this.Ff, 16) : this.Ff = Y(this.Ff, 16);
      } }), Object.defineProperty(this, "pushButton", { enumerable: true, configurable: true, get: function() {
        return Boolean(V2(this.Ff, 17));
      }, set: function(t3) {
        true === Boolean(t3) ? this.Ff = G(this.Ff, 17) : this.Ff = Y(this.Ff, 17);
      } }), Object.defineProperty(this, "radioIsUnison", { enumerable: true, configurable: true, get: function() {
        return Boolean(V2(this.Ff, 26));
      }, set: function(t3) {
        true === Boolean(t3) ? this.Ff = G(this.Ff, 26) : this.Ff = Y(this.Ff, 26);
      } });
      var t2, e3 = {};
      Object.defineProperty(this, "MK", { enumerable: false, configurable: false, get: function() {
        var t3 = function(t4) {
          return t4;
        };
        if (this.scope && (t3 = this.scope.internal.getEncryptor(this.objId)), 0 !== Object.keys(e3).length) {
          var r2, n2 = [];
          for (r2 in n2.push("<<"), e3) n2.push("/" + r2 + " (" + B(t3(e3[r2])) + ")");
          return n2.push(">>"), n2.join("\n");
        }
      }, set: function(t3) {
        "object" == typeof t3 && (e3 = t3);
      } }), Object.defineProperty(this, "caption", { enumerable: true, configurable: true, get: function() {
        return e3.CA || "";
      }, set: function(t3) {
        "string" == typeof t3 && (e3.CA = t3);
      } }), Object.defineProperty(this, "AS", { enumerable: false, configurable: false, get: function() {
        return t2;
      }, set: function(e4) {
        var r2 = null == e4 ? "" : e4.toString();
        "/" === r2.substr(0, 1) && (r2 = r2.substr(1)), t2 = "/" + M(r2);
      } }), Object.defineProperty(this, "appearanceState", { enumerable: true, configurable: true, get: function() {
        return t2.substr(1, t2.length - 1);
      }, set: function(e4) {
        t2 = "/" + M(e4);
      } });
    };
    D(lt, at);
    var ht = function() {
      lt.call(this), this.pushButton = true;
    };
    D(ht, lt);
    var ft = function() {
      lt.call(this), this.radio = true, this.pushButton = false;
      var t2 = [];
      Object.defineProperty(this, "Kids", { enumerable: true, configurable: false, get: function() {
        return t2;
      }, set: function(e3) {
        t2 = void 0 !== e3 ? e3 : [];
      } });
    };
    D(ft, lt);
    var dt = function() {
      var t2, e3;
      at.call(this), Object.defineProperty(this, "Parent", { enumerable: false, configurable: false, get: function() {
        return t2;
      }, set: function(e4) {
        t2 = e4;
      } }), Object.defineProperty(this, "optionName", { enumerable: false, configurable: true, get: function() {
        return e3;
      }, set: function(t3) {
        e3 = t3;
      } });
      var r2, n2 = {};
      Object.defineProperty(this, "MK", { enumerable: false, configurable: false, get: function() {
        var t3 = function(t4) {
          return t4;
        };
        this.scope && (t3 = this.scope.internal.getEncryptor(this.objId));
        var e4, r3 = [];
        for (e4 in r3.push("<<"), n2) r3.push("/" + e4 + " (" + B(t3(n2[e4])) + ")");
        return r3.push(">>"), r3.join("\n");
      }, set: function(t3) {
        "object" == typeof t3 && (n2 = t3);
      } }), Object.defineProperty(this, "caption", { enumerable: true, configurable: true, get: function() {
        return n2.CA || "";
      }, set: function(t3) {
        "string" == typeof t3 && (n2.CA = t3);
      } }), Object.defineProperty(this, "AS", { enumerable: false, configurable: false, get: function() {
        return r2;
      }, set: function(t3) {
        var e4 = null == t3 ? "" : t3.toString();
        "/" === e4.substr(0, 1) && (e4 = e4.substr(1)), r2 = "/" + M(e4);
      } }), Object.defineProperty(this, "appearanceState", { enumerable: true, configurable: true, get: function() {
        return r2.substr(1, r2.length - 1);
      }, set: function(t3) {
        var e4 = null == t3 ? "" : t3.toString();
        "/" === e4.substr(0, 1) && (e4 = e4.substr(1)), r2 = "/" + M(e4);
      } }), this.caption = "l", this.appearanceState = "Off", this._AppearanceType = vt.RadioButton.Circle, this.appearanceStreamContent = this._AppearanceType.createAppearanceStream(this.optionName);
    };
    D(dt, at), ft.prototype.setAppearance = function(t2) {
      if (!("createAppearanceStream" in t2) || !("getCA" in t2)) throw new Error("Couldn't assign Appearance to RadioButton. Appearance was Invalid!");
      for (var e3 in this.Kids) if (this.Kids.hasOwnProperty(e3)) {
        var r2 = this.Kids[e3];
        r2.appearanceStreamContent = t2.createAppearanceStream(r2.optionName), r2.caption = t2.getCA();
      }
    }, ft.prototype.createOption = function(t2) {
      var e3 = new dt();
      return e3.Parent = this, e3.optionName = t2, this.Kids.push(e3), bt.call(this.scope, e3), e3;
    };
    var pt = function() {
      lt.call(this), this.fontName = "zapfdingbats", this.caption = "3", this.appearanceState = "On", this.value = "On", this.textAlign = "center", this.appearanceStreamContent = vt.CheckBox.createAppearanceStream();
    };
    D(pt, lt);
    var gt = function() {
      at.call(this), this.FT = "/Tx", Object.defineProperty(this, "multiline", { enumerable: true, configurable: true, get: function() {
        return Boolean(V2(this.Ff, 13));
      }, set: function(t3) {
        true === Boolean(t3) ? this.Ff = G(this.Ff, 13) : this.Ff = Y(this.Ff, 13);
      } }), Object.defineProperty(this, "fileSelect", { enumerable: true, configurable: true, get: function() {
        return Boolean(V2(this.Ff, 21));
      }, set: function(t3) {
        true === Boolean(t3) ? this.Ff = G(this.Ff, 21) : this.Ff = Y(this.Ff, 21);
      } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: true, configurable: true, get: function() {
        return Boolean(V2(this.Ff, 23));
      }, set: function(t3) {
        true === Boolean(t3) ? this.Ff = G(this.Ff, 23) : this.Ff = Y(this.Ff, 23);
      } }), Object.defineProperty(this, "doNotScroll", { enumerable: true, configurable: true, get: function() {
        return Boolean(V2(this.Ff, 24));
      }, set: function(t3) {
        true === Boolean(t3) ? this.Ff = G(this.Ff, 24) : this.Ff = Y(this.Ff, 24);
      } }), Object.defineProperty(this, "comb", { enumerable: true, configurable: true, get: function() {
        return Boolean(V2(this.Ff, 25));
      }, set: function(t3) {
        true === Boolean(t3) ? this.Ff = G(this.Ff, 25) : this.Ff = Y(this.Ff, 25);
      } }), Object.defineProperty(this, "richText", { enumerable: true, configurable: true, get: function() {
        return Boolean(V2(this.Ff, 26));
      }, set: function(t3) {
        true === Boolean(t3) ? this.Ff = G(this.Ff, 26) : this.Ff = Y(this.Ff, 26);
      } });
      var t2 = null;
      Object.defineProperty(this, "MaxLen", { enumerable: true, configurable: false, get: function() {
        return t2;
      }, set: function(e3) {
        t2 = e3;
      } }), Object.defineProperty(this, "maxLength", { enumerable: true, configurable: true, get: function() {
        return t2;
      }, set: function(e3) {
        Number.isInteger(e3) && (t2 = e3);
      } }), Object.defineProperty(this, "hasAppearanceStream", { enumerable: true, configurable: true, get: function() {
        return this.V || this.DV;
      } });
    };
    D(gt, at);
    var mt = function() {
      gt.call(this), Object.defineProperty(this, "password", { enumerable: true, configurable: true, get: function() {
        return Boolean(V2(this.Ff, 14));
      }, set: function(t2) {
        true === Boolean(t2) ? this.Ff = G(this.Ff, 14) : this.Ff = Y(this.Ff, 14);
      } }), this.password = true;
    };
    D(mt, gt);
    var vt = { CheckBox: { createAppearanceStream: function() {
      return { N: { On: vt.CheckBox.YesNormal }, D: { On: vt.CheckBox.YesPushDown, Off: vt.CheckBox.OffPushDown } };
    }, YesPushDown: function(t2) {
      var e3 = z2(t2);
      e3.scope = t2.scope;
      var r2 = [], n2 = t2.scope.internal.getFont(t2.fontName, t2.fontStyle).id, i2 = t2.scope.__private__.encodeColorString(t2.color), a3 = K(t2, t2.caption);
      return r2.push("0.749023 g"), r2.push("0 0 " + E2(vt.internal.getWidth(t2)) + " " + E2(vt.internal.getHeight(t2)) + " re"), r2.push("f"), r2.push("BMC"), r2.push("q"), r2.push("0 0 1 rg"), r2.push("/" + n2 + " " + E2(a3.fontSize) + " Tf " + i2), r2.push("BT"), r2.push(a3.text), r2.push("ET"), r2.push("Q"), r2.push("EMC"), e3.stream = r2.join("\n"), e3;
    }, YesNormal: function(t2) {
      var e3 = z2(t2);
      e3.scope = t2.scope;
      var r2 = t2.scope.internal.getFont(t2.fontName, t2.fontStyle).id, n2 = t2.scope.__private__.encodeColorString(t2.color), i2 = [], a3 = vt.internal.getHeight(t2), o2 = vt.internal.getWidth(t2), s2 = K(t2, t2.caption);
      return i2.push("1 g"), i2.push("0 0 " + E2(o2) + " " + E2(a3) + " re"), i2.push("f"), i2.push("q"), i2.push("0 0 1 rg"), i2.push("0 0 " + E2(o2 - 1) + " " + E2(a3 - 1) + " re"), i2.push("W"), i2.push("n"), i2.push("0 g"), i2.push("BT"), i2.push("/" + r2 + " " + E2(s2.fontSize) + " Tf " + n2), i2.push(s2.text), i2.push("ET"), i2.push("Q"), e3.stream = i2.join("\n"), e3;
    }, OffPushDown: function(t2) {
      var e3 = z2(t2);
      e3.scope = t2.scope;
      var r2 = [];
      return r2.push("0.749023 g"), r2.push("0 0 " + E2(vt.internal.getWidth(t2)) + " " + E2(vt.internal.getHeight(t2)) + " re"), r2.push("f"), e3.stream = r2.join("\n"), e3;
    } }, RadioButton: { Circle: { createAppearanceStream: function(t2) {
      var e3 = { D: { Off: vt.RadioButton.Circle.OffPushDown }, N: {} };
      return e3.N[t2] = vt.RadioButton.Circle.YesNormal, e3.D[t2] = vt.RadioButton.Circle.YesPushDown, e3;
    }, getCA: function() {
      return "l";
    }, YesNormal: function(t2) {
      var e3 = z2(t2);
      e3.scope = t2.scope;
      var r2 = [], n2 = vt.internal.getWidth(t2) <= vt.internal.getHeight(t2) ? vt.internal.getWidth(t2) / 4 : vt.internal.getHeight(t2) / 4;
      n2 = Number((0.9 * n2).toFixed(5));
      var i2 = vt.internal.Bezier_C, a3 = Number((n2 * i2).toFixed(5));
      return r2.push("q"), r2.push("1 0 0 1 " + R(vt.internal.getWidth(t2) / 2) + " " + R(vt.internal.getHeight(t2) / 2) + " cm"), r2.push(n2 + " 0 m"), r2.push(n2 + " " + a3 + " " + a3 + " " + n2 + " 0 " + n2 + " c"), r2.push("-" + a3 + " " + n2 + " -" + n2 + " " + a3 + " -" + n2 + " 0 c"), r2.push("-" + n2 + " -" + a3 + " -" + a3 + " -" + n2 + " 0 -" + n2 + " c"), r2.push(a3 + " -" + n2 + " " + n2 + " -" + a3 + " " + n2 + " 0 c"), r2.push("f"), r2.push("Q"), e3.stream = r2.join("\n"), e3;
    }, YesPushDown: function(t2) {
      var e3 = z2(t2);
      e3.scope = t2.scope;
      var r2 = [], n2 = vt.internal.getWidth(t2) <= vt.internal.getHeight(t2) ? vt.internal.getWidth(t2) / 4 : vt.internal.getHeight(t2) / 4;
      n2 = Number((0.9 * n2).toFixed(5));
      var i2 = Number((2 * n2).toFixed(5)), a3 = Number((i2 * vt.internal.Bezier_C).toFixed(5)), o2 = Number((n2 * vt.internal.Bezier_C).toFixed(5));
      return r2.push("0.749023 g"), r2.push("q"), r2.push("1 0 0 1 " + R(vt.internal.getWidth(t2) / 2) + " " + R(vt.internal.getHeight(t2) / 2) + " cm"), r2.push(i2 + " 0 m"), r2.push(i2 + " " + a3 + " " + a3 + " " + i2 + " 0 " + i2 + " c"), r2.push("-" + a3 + " " + i2 + " -" + i2 + " " + a3 + " -" + i2 + " 0 c"), r2.push("-" + i2 + " -" + a3 + " -" + a3 + " -" + i2 + " 0 -" + i2 + " c"), r2.push(a3 + " -" + i2 + " " + i2 + " -" + a3 + " " + i2 + " 0 c"), r2.push("f"), r2.push("Q"), r2.push("0 g"), r2.push("q"), r2.push("1 0 0 1 " + R(vt.internal.getWidth(t2) / 2) + " " + R(vt.internal.getHeight(t2) / 2) + " cm"), r2.push(n2 + " 0 m"), r2.push(n2 + " " + o2 + " " + o2 + " " + n2 + " 0 " + n2 + " c"), r2.push("-" + o2 + " " + n2 + " -" + n2 + " " + o2 + " -" + n2 + " 0 c"), r2.push("-" + n2 + " -" + o2 + " -" + o2 + " -" + n2 + " 0 -" + n2 + " c"), r2.push(o2 + " -" + n2 + " " + n2 + " -" + o2 + " " + n2 + " 0 c"), r2.push("f"), r2.push("Q"), e3.stream = r2.join("\n"), e3;
    }, OffPushDown: function(t2) {
      var e3 = z2(t2);
      e3.scope = t2.scope;
      var r2 = [], n2 = vt.internal.getWidth(t2) <= vt.internal.getHeight(t2) ? vt.internal.getWidth(t2) / 4 : vt.internal.getHeight(t2) / 4;
      n2 = Number((0.9 * n2).toFixed(5));
      var i2 = Number((2 * n2).toFixed(5)), a3 = Number((i2 * vt.internal.Bezier_C).toFixed(5));
      return r2.push("0.749023 g"), r2.push("q"), r2.push("1 0 0 1 " + R(vt.internal.getWidth(t2) / 2) + " " + R(vt.internal.getHeight(t2) / 2) + " cm"), r2.push(i2 + " 0 m"), r2.push(i2 + " " + a3 + " " + a3 + " " + i2 + " 0 " + i2 + " c"), r2.push("-" + a3 + " " + i2 + " -" + i2 + " " + a3 + " -" + i2 + " 0 c"), r2.push("-" + i2 + " -" + a3 + " -" + a3 + " -" + i2 + " 0 -" + i2 + " c"), r2.push(a3 + " -" + i2 + " " + i2 + " -" + a3 + " " + i2 + " 0 c"), r2.push("f"), r2.push("Q"), e3.stream = r2.join("\n"), e3;
    } }, Cross: { createAppearanceStream: function(t2) {
      var e3 = { D: { Off: vt.RadioButton.Cross.OffPushDown }, N: {} };
      return e3.N[t2] = vt.RadioButton.Cross.YesNormal, e3.D[t2] = vt.RadioButton.Cross.YesPushDown, e3;
    }, getCA: function() {
      return "8";
    }, YesNormal: function(t2) {
      var e3 = z2(t2);
      e3.scope = t2.scope;
      var r2 = [], n2 = vt.internal.calculateCross(t2);
      return r2.push("q"), r2.push("1 1 " + E2(vt.internal.getWidth(t2) - 2) + " " + E2(vt.internal.getHeight(t2) - 2) + " re"), r2.push("W"), r2.push("n"), r2.push(E2(n2.x1.x) + " " + E2(n2.x1.y) + " m"), r2.push(E2(n2.x2.x) + " " + E2(n2.x2.y) + " l"), r2.push(E2(n2.x4.x) + " " + E2(n2.x4.y) + " m"), r2.push(E2(n2.x3.x) + " " + E2(n2.x3.y) + " l"), r2.push("s"), r2.push("Q"), e3.stream = r2.join("\n"), e3;
    }, YesPushDown: function(t2) {
      var e3 = z2(t2);
      e3.scope = t2.scope;
      var r2 = vt.internal.calculateCross(t2), n2 = [];
      return n2.push("0.749023 g"), n2.push("0 0 " + E2(vt.internal.getWidth(t2)) + " " + E2(vt.internal.getHeight(t2)) + " re"), n2.push("f"), n2.push("q"), n2.push("1 1 " + E2(vt.internal.getWidth(t2) - 2) + " " + E2(vt.internal.getHeight(t2) - 2) + " re"), n2.push("W"), n2.push("n"), n2.push(E2(r2.x1.x) + " " + E2(r2.x1.y) + " m"), n2.push(E2(r2.x2.x) + " " + E2(r2.x2.y) + " l"), n2.push(E2(r2.x4.x) + " " + E2(r2.x4.y) + " m"), n2.push(E2(r2.x3.x) + " " + E2(r2.x3.y) + " l"), n2.push("s"), n2.push("Q"), e3.stream = n2.join("\n"), e3;
    }, OffPushDown: function(t2) {
      var e3 = z2(t2);
      e3.scope = t2.scope;
      var r2 = [];
      return r2.push("0.749023 g"), r2.push("0 0 " + E2(vt.internal.getWidth(t2)) + " " + E2(vt.internal.getHeight(t2)) + " re"), r2.push("f"), e3.stream = r2.join("\n"), e3;
    } } }, createDefaultAppearanceStream: function(t2) {
      var e3 = t2.scope.internal.getFont(t2.fontName, t2.fontStyle).id, r2 = t2.scope.__private__.encodeColorString(t2.color);
      return "/" + e3 + " " + t2.fontSize + " Tf " + r2;
    } };
    vt.internal = { Bezier_C: 0.551915024494, calculateCross: function(t2) {
      var e3 = vt.internal.getWidth(t2), r2 = vt.internal.getHeight(t2), n2 = Math.min(e3, r2);
      return { x1: { x: (e3 - n2) / 2, y: (r2 - n2) / 2 + n2 }, x2: { x: (e3 - n2) / 2 + n2, y: (r2 - n2) / 2 }, x3: { x: (e3 - n2) / 2, y: (r2 - n2) / 2 }, x4: { x: (e3 - n2) / 2 + n2, y: (r2 - n2) / 2 + n2 } };
    } }, vt.internal.getWidth = function(t2) {
      var e3 = 0;
      return "object" == typeof t2 && (e3 = T2(t2.Rect[2])), e3;
    }, vt.internal.getHeight = function(t2) {
      var e3 = 0;
      return "object" == typeof t2 && (e3 = T2(t2.Rect[3])), e3;
    };
    var bt = C.addField = function(t2) {
      if ((function(t3, e4) {
        if (e4.scope = t3, void 0 !== t3.internal && (void 0 === t3.internal.acroformPlugin || false === t3.internal.acroformPlugin.isInitialized)) {
          if (at.FieldNum = 0, t3.internal.acroformPlugin = JSON.parse(JSON.stringify(Z2)), t3.internal.acroformPlugin.acroFormDictionaryRoot) throw new Error("Exception while creating AcroformDictionary");
          O = t3.internal.scaleFactor, t3.internal.acroformPlugin.acroFormDictionaryRoot = new it(), t3.internal.acroformPlugin.acroFormDictionaryRoot.scope = t3, t3.internal.acroformPlugin.acroFormDictionaryRoot._eventID = t3.internal.events.subscribe("postPutResources", function() {
            !(function(t4) {
              t4.internal.events.unsubscribe(t4.internal.acroformPlugin.acroFormDictionaryRoot._eventID), delete t4.internal.acroformPlugin.acroFormDictionaryRoot._eventID, t4.internal.acroformPlugin.printedOut = true;
            })(t3);
          }), t3.internal.events.subscribe("buildDocument", function() {
            !(function(t4) {
              t4.internal.acroformPlugin.acroFormDictionaryRoot.objId = void 0;
              var e5 = t4.internal.acroformPlugin.acroFormDictionaryRoot.Fields;
              for (var r2 in e5) if (e5.hasOwnProperty(r2)) {
                var n2 = e5[r2];
                n2.objId = void 0, n2.hasAnnotation && Q(n2, t4);
              }
            })(t3);
          }), t3.internal.events.subscribe("putCatalog", function() {
            !(function(t4) {
              if (void 0 === t4.internal.acroformPlugin.acroFormDictionaryRoot) throw new Error("putCatalogCallback: Root missing.");
              t4.internal.write("/AcroForm " + t4.internal.acroformPlugin.acroFormDictionaryRoot.objId + " 0 R");
            })(t3);
          }), t3.internal.events.subscribe("postPutPages", function(e5) {
            !(function(t4, e6) {
              var r2 = !t4;
              for (var n2 in t4 || (e6.internal.newObjectDeferredBegin(e6.internal.acroformPlugin.acroFormDictionaryRoot.objId, true), e6.internal.acroformPlugin.acroFormDictionaryRoot.putStream()), t4 = t4 || e6.internal.acroformPlugin.acroFormDictionaryRoot.Kids) if (t4.hasOwnProperty(n2)) {
                var i2 = t4[n2], a3 = [], o2 = i2.Rect;
                if (i2.Rect && (i2.Rect = J(i2.Rect, e6)), e6.internal.newObjectDeferredBegin(i2.objId, true), i2.DA = vt.createDefaultAppearanceStream(i2), "object" == typeof i2 && "function" == typeof i2.getKeyValueListForStream && (a3 = i2.getKeyValueListForStream()), i2.Rect = o2, i2.hasAppearanceStream && !i2.appearanceStreamContent) {
                  var s2 = X(i2);
                  a3.push({ key: "AP", value: "<</N " + s2 + ">>" }), e6.internal.acroformPlugin.xForms.push(s2);
                }
                if (i2.appearanceStreamContent) {
                  var c2 = "";
                  for (var u3 in i2.appearanceStreamContent) if (i2.appearanceStreamContent.hasOwnProperty(u3)) {
                    var l2 = i2.appearanceStreamContent[u3];
                    if (c2 += "/" + u3 + " ", c2 += "<<", Object.keys(l2).length >= 1 || Array.isArray(l2)) {
                      for (var n2 in l2) if (l2.hasOwnProperty(n2)) {
                        var h2 = l2[n2];
                        "function" == typeof h2 && (h2 = h2.call(e6, i2)), c2 += "/" + n2 + " " + h2 + " ", e6.internal.acroformPlugin.xForms.indexOf(h2) >= 0 || e6.internal.acroformPlugin.xForms.push(h2);
                      }
                    } else "function" == typeof (h2 = l2) && (h2 = h2.call(e6, i2)), c2 += "/" + n2 + " " + h2, e6.internal.acroformPlugin.xForms.indexOf(h2) >= 0 || e6.internal.acroformPlugin.xForms.push(h2);
                    c2 += ">>";
                  }
                  a3.push({ key: "AP", value: "<<\n" + c2 + ">>" });
                }
                e6.internal.putStream({ additionalKeyValues: a3, objectId: i2.objId }), e6.internal.out("endobj");
              }
              r2 && (function(t5, e7) {
                for (var r3 in t5) if (t5.hasOwnProperty(r3)) {
                  var n3 = r3, i3 = t5[r3];
                  e7.internal.newObjectDeferredBegin(i3.objId, true), "object" == typeof i3 && "function" == typeof i3.putStream && i3.putStream(), delete t5[n3];
                }
              })(e6.internal.acroformPlugin.xForms, e6);
            })(e5, t3);
          }), t3.internal.acroformPlugin.isInitialized = true;
        }
      })(this, t2), !(t2 instanceof at)) throw new Error("Invalid argument passed to jsPDF.addField.");
      var e3;
      return (e3 = t2).scope.internal.acroformPlugin.printedOut && (e3.scope.internal.acroformPlugin.printedOut = false, e3.scope.internal.acroformPlugin.acroFormDictionaryRoot = null), e3.scope.internal.acroformPlugin.acroFormDictionaryRoot.Fields.push(e3), t2.page = t2.scope.internal.getCurrentPageInfo().pageNumber, this;
    };
    C.AcroFormChoiceField = ot, C.AcroFormListBox = st, C.AcroFormComboBox = ct, C.AcroFormEditBox = ut, C.AcroFormButton = lt, C.AcroFormPushButton = ht, C.AcroFormRadioButton = ft, C.AcroFormCheckBox = pt, C.AcroFormTextField = gt, C.AcroFormPasswordField = mt, C.AcroFormAppearance = vt, C.AcroForm = { ChoiceField: ot, ListBox: st, ComboBox: ct, EditBox: ut, Button: lt, PushButton: ht, RadioButton: ft, CheckBox: pt, TextField: gt, PasswordField: mt, Appearance: vt }, j.AcroForm = { ChoiceField: ot, ListBox: st, ComboBox: ct, EditBox: ut, Button: lt, PushButton: ht, RadioButton: ft, CheckBox: pt, TextField: gt, PasswordField: mt, Appearance: vt };
    var yt = j.AcroForm;
    function wt(t2) {
      return t2.reduce(function(t3, e3, r2) {
        return t3[e3] = r2, t3;
      }, {});
    }
    !(function(t2) {
      var e3 = "addImage_";
      t2.__addimage__ = {};
      var r2 = "UNKNOWN", n2 = { PNG: [[137, 80, 78, 71]], TIFF: [[77, 77, 0, 42], [73, 73, 42, 0]], JPEG: [[255, 216, 255, 224, void 0, void 0, 74, 70, 73, 70, 0], [255, 216, 255, 225, void 0, void 0, 69, 120, 105, 102, 0, 0], [255, 216, 255, 219], [255, 216, 255, 238]], JPEG2000: [[0, 0, 0, 12, 106, 80, 32, 32]], GIF87a: [[71, 73, 70, 56, 55, 97]], GIF89a: [[71, 73, 70, 56, 57, 97]], WEBP: [[82, 73, 70, 70, void 0, void 0, void 0, void 0, 87, 69, 66, 80]], BMP: [[66, 77], [66, 65], [67, 73], [67, 80], [73, 67], [80, 84]] }, a3 = t2.__addimage__.getImageFileTypeByImageData = function(t3, e4) {
        var i2, a4, o3, s3, c3, u4 = r2;
        if ("RGBA" === (e4 = e4 || r2) || void 0 !== t3.data && t3.data instanceof Uint8ClampedArray && "height" in t3 && "width" in t3) return "RGBA";
        if (x2(t3)) for (c3 in n2) for (o3 = n2[c3], i2 = 0; i2 < o3.length; i2 += 1) {
          for (s3 = true, a4 = 0; a4 < o3[i2].length; a4 += 1) if (void 0 !== o3[i2][a4] && o3[i2][a4] !== t3[a4]) {
            s3 = false;
            break;
          }
          if (true === s3) {
            u4 = c3;
            break;
          }
        }
        else for (c3 in n2) for (o3 = n2[c3], i2 = 0; i2 < o3.length; i2 += 1) {
          for (s3 = true, a4 = 0; a4 < o3[i2].length; a4 += 1) if (void 0 !== o3[i2][a4] && o3[i2][a4] !== t3.charCodeAt(a4)) {
            s3 = false;
            break;
          }
          if (true === s3) {
            u4 = c3;
            break;
          }
        }
        return u4 === r2 && e4 !== r2 && (u4 = e4), u4;
      }, o2 = function(t3) {
        for (var e4 = this.internal.write, r3 = this.internal.putStream, n3 = (0, this.internal.getFilters)(); -1 !== n3.indexOf("FlateEncode"); ) n3.splice(n3.indexOf("FlateEncode"), 1);
        t3.objectId = this.internal.newObject();
        var i2 = [];
        if (i2.push({ key: "Type", value: "/XObject" }), i2.push({ key: "Subtype", value: "/Image" }), i2.push({ key: "Width", value: t3.width }), i2.push({ key: "Height", value: t3.height }), t3.colorSpace === b2.INDEXED ? i2.push({ key: "ColorSpace", value: "[/Indexed /DeviceRGB " + (t3.palette.length / 3 - 1) + " " + ("sMask" in t3 && void 0 !== t3.sMask ? t3.objectId + 2 : t3.objectId + 1) + " 0 R]" }) : (i2.push({ key: "ColorSpace", value: "/" + t3.colorSpace }), t3.colorSpace === b2.DEVICE_CMYK && i2.push({ key: "Decode", value: "[1 0 1 0 1 0 1 0]" })), i2.push({ key: "BitsPerComponent", value: t3.bitsPerComponent }), "decodeParameters" in t3 && void 0 !== t3.decodeParameters && i2.push({ key: "DecodeParms", value: "<<" + t3.decodeParameters + ">>" }), "transparency" in t3 && Array.isArray(t3.transparency) && t3.transparency.length > 0) {
          for (var a4 = "", s3 = 0, c3 = t3.transparency.length; s3 < c3; s3++) a4 += t3.transparency[s3] + " " + t3.transparency[s3] + " ";
          i2.push({ key: "Mask", value: "[" + a4 + "]" });
        }
        void 0 !== t3.sMask && i2.push({ key: "SMask", value: t3.objectId + 1 + " 0 R" });
        var u4 = void 0 !== t3.filter ? ["/" + t3.filter] : void 0;
        if (r3({ data: t3.data, additionalKeyValues: i2, alreadyAppliedFilters: u4, objectId: t3.objectId }), e4("endobj"), "sMask" in t3 && void 0 !== t3.sMask) {
          const e5 = t3.sMaskBitsPerComponent ?? t3.bitsPerComponent, r4 = { width: t3.width, height: t3.height, colorSpace: "DeviceGray", bitsPerComponent: e5, data: t3.sMask };
          "filter" in t3 && (r4.decodeParameters = `/Predictor ${t3.predictor} /Colors 1 /BitsPerComponent ${e5} /Columns ${t3.width}`, r4.filter = t3.filter), o2.call(this, r4);
        }
        if (t3.colorSpace === b2.INDEXED) {
          var l3 = this.internal.newObject();
          r3({ data: S2(new Uint8Array(t3.palette)), objectId: l3 }), e4("endobj");
        }
      }, s2 = function() {
        var t3 = this.internal.collections[e3 + "images"];
        for (var r3 in t3) o2.call(this, t3[r3]);
      }, c2 = function() {
        var t3, r3 = this.internal.collections[e3 + "images"], n3 = this.internal.write;
        for (var i2 in r3) n3("/I" + (t3 = r3[i2]).index, t3.objectId, "0", "R");
      }, u3 = function() {
        this.internal.collections[e3 + "images"] || (this.internal.collections[e3 + "images"] = {}, this.internal.events.subscribe("putResources", s2), this.internal.events.subscribe("putXobjectDict", c2));
      }, l2 = function() {
        var t3 = this.internal.collections[e3 + "images"];
        return u3.call(this), t3;
      }, h2 = function() {
        return Object.keys(this.internal.collections[e3 + "images"]).length;
      }, f3 = function(e4) {
        return "function" == typeof t2["process" + e4.toUpperCase()];
      }, d2 = function(t3) {
        return "object" == typeof t3 && 1 === t3.nodeType;
      }, p2 = function(e4, r3) {
        if ("IMG" === e4.nodeName && e4.hasAttribute("src")) {
          var n3 = "" + e4.getAttribute("src");
          if (0 === n3.indexOf("data:image/")) return i(unescape(n3).split("base64,").pop());
          var a4 = t2.loadFile(n3, true);
          if (void 0 !== a4) return a4;
        }
        if ("CANVAS" === e4.nodeName) {
          if (0 === e4.width || 0 === e4.height) throw new Error("Given canvas must have data. Canvas width: " + e4.width + ", height: " + e4.height);
          var o3;
          switch (r3) {
            case "PNG":
              o3 = "image/png";
              break;
            case "WEBP":
              o3 = "image/webp";
              break;
            default:
              o3 = "image/jpeg";
          }
          return i(e4.toDataURL(o3, 1).split("base64,").pop());
        }
      }, g2 = function(t3) {
        var r3 = this.internal.collections[e3 + "images"];
        if (r3) {
          for (var n3 in r3) if (t3 === r3[n3].alias) return r3[n3];
        }
      }, m2 = function(t3, e4, r3) {
        return t3 || e4 || (t3 = -96, e4 = -96), t3 < 0 && (t3 = -1 * r3.width * 72 / t3 / this.internal.scaleFactor), e4 < 0 && (e4 = -1 * r3.height * 72 / e4 / this.internal.scaleFactor), 0 === t3 && (t3 = e4 * r3.width / r3.height), 0 === e4 && (e4 = t3 * r3.height / r3.width), [t3, e4];
      }, v2 = function(t3, e4, r3, n3, i2, a4) {
        var o3 = m2.call(this, r3, n3, i2), s3 = this.internal.getCoordinateString, c3 = this.internal.getVerticalCoordinateString, u4 = l2.call(this);
        if (r3 = o3[0], n3 = o3[1], u4[i2.index] = i2, a4) {
          a4 *= Math.PI / 180;
          var h3 = Math.cos(a4), f4 = Math.sin(a4), d3 = function(t4) {
            return t4.toFixed(4);
          }, p3 = [d3(h3), d3(f4), d3(-1 * f4), d3(h3), 0, 0, "cm"];
        }
        this.internal.write("q"), a4 ? (this.internal.write([1, "0", "0", 1, s3(t3), c3(e4 + n3), "cm"].join(" ")), this.internal.write(p3.join(" ")), this.internal.write([s3(r3), "0", "0", s3(n3), "0", "0", "cm"].join(" "))) : this.internal.write([s3(r3), "0", "0", s3(n3), s3(t3), c3(e4 + n3), "cm"].join(" ")), this.isAdvancedAPI() && this.internal.write([1, 0, 0, -1, 0, 0, "cm"].join(" ")), this.internal.write("/I" + i2.index + " Do"), this.internal.write("Q");
      }, b2 = t2.color_spaces = { DEVICE_RGB: "DeviceRGB", DEVICE_GRAY: "DeviceGray", DEVICE_CMYK: "DeviceCMYK", CAL_GREY: "CalGray", CAL_RGB: "CalRGB", LAB: "Lab", ICC_BASED: "ICCBased", INDEXED: "Indexed", PATTERN: "Pattern", SEPARATION: "Separation", DEVICE_N: "DeviceN" };
      t2.decode = { DCT_DECODE: "DCTDecode", FLATE_DECODE: "FlateDecode", LZW_DECODE: "LZWDecode", JPX_DECODE: "JPXDecode", JBIG2_DECODE: "JBIG2Decode", ASCII85_DECODE: "ASCII85Decode", ASCII_HEX_DECODE: "ASCIIHexDecode", RUN_LENGTH_DECODE: "RunLengthDecode", CCITT_FAX_DECODE: "CCITTFaxDecode" };
      var y2 = t2.image_compression = { NONE: "NONE", FAST: "FAST", MEDIUM: "MEDIUM", SLOW: "SLOW" }, w2 = t2.__addimage__.sHashCode = function(t3) {
        var e4, r3, n3 = 0;
        if ("string" == typeof t3) for (r3 = t3.length, e4 = 0; e4 < r3; e4++) n3 = (n3 << 5) - n3 + t3.charCodeAt(e4), n3 |= 0;
        else if (x2(t3)) for (r3 = t3.byteLength / 2, e4 = 0; e4 < r3; e4++) n3 = (n3 << 5) - n3 + t3[e4], n3 |= 0;
        return n3;
      }, N2 = t2.__addimage__.validateStringAsBase64 = function(t3) {
        (t3 = t3 || "").toString().trim();
        var e4 = true;
        return 0 === t3.length && (e4 = false), t3.length % 4 != 0 && (e4 = false), false === /^[A-Za-z0-9+/]+$/.test(t3.substr(0, t3.length - 2)) && (e4 = false), false === /^[A-Za-z0-9/][A-Za-z0-9+/]|[A-Za-z0-9+/]=|==$/.test(t3.substr(-2)) && (e4 = false), e4;
      }, L3 = t2.__addimage__.extractImageFromDataUrl = function(t3) {
        if (null == t3) return null;
        if (!(t3 = t3.trim()).startsWith("data:")) return null;
        const e4 = t3.indexOf(",");
        return e4 < 0 ? null : t3.substring(0, e4).trim().endsWith("base64") ? t3.substring(e4 + 1) : null;
      };
      t2.__addimage__.isArrayBuffer = function(t3) {
        return t3 instanceof ArrayBuffer;
      };
      var x2 = t2.__addimage__.isArrayBufferView = function(t3) {
        return t3 instanceof Int8Array || t3 instanceof Uint8Array || t3 instanceof Uint8ClampedArray || t3 instanceof Int16Array || t3 instanceof Uint16Array || t3 instanceof Int32Array || t3 instanceof Uint32Array || t3 instanceof Float32Array || t3 instanceof Float64Array;
      }, A3 = t2.__addimage__.binaryStringToUint8Array = function(t3) {
        for (var e4 = t3.length, r3 = new Uint8Array(e4), n3 = 0; n3 < e4; n3++) r3[n3] = t3.charCodeAt(n3);
        return r3;
      }, S2 = t2.__addimage__.arrayBufferToBinaryString = function(t3) {
        for (var e4 = "", r3 = x2(t3) ? t3 : new Uint8Array(t3), n3 = 0; n3 < r3.length; n3 += 8192) e4 += String.fromCharCode.apply(null, r3.subarray(n3, n3 + 8192));
        return e4;
      };
      t2.addImage = function() {
        var t3, e4, n3, i2, a4, o3, s3, c3, l3;
        if ("number" == typeof arguments[1] ? (e4 = r2, n3 = arguments[1], i2 = arguments[2], a4 = arguments[3], o3 = arguments[4], s3 = arguments[5], c3 = arguments[6], l3 = arguments[7]) : (e4 = arguments[1], n3 = arguments[2], i2 = arguments[3], a4 = arguments[4], o3 = arguments[5], s3 = arguments[6], c3 = arguments[7], l3 = arguments[8]), "object" == typeof (t3 = arguments[0]) && !d2(t3) && "imageData" in t3) {
          var h3 = t3;
          t3 = h3.imageData, e4 = h3.format || e4 || r2, n3 = h3.x || n3 || 0, i2 = h3.y || i2 || 0, a4 = h3.w || h3.width || a4, o3 = h3.h || h3.height || o3, s3 = h3.alias || s3, c3 = h3.compression || c3, l3 = h3.rotation || h3.angle || l3;
        }
        var f4 = this.internal.getFilters();
        if (void 0 === c3 && -1 !== f4.indexOf("FlateEncode") && (c3 = "SLOW"), isNaN(n3) || isNaN(i2)) throw new Error("Invalid coordinates passed to jsPDF.addImage");
        u3.call(this);
        var p3 = _2.call(this, t3, e4, s3, c3);
        return v2.call(this, n3, i2, a4, o3, p3, l3), this;
      };
      var _2 = function(e4, n3, i2, o3) {
        var s3, c3, u4;
        if ("string" == typeof e4 && a3(e4) === r2) {
          e4 = unescape(e4);
          var l3 = P2(e4, false);
          ("" !== l3 || void 0 !== (l3 = t2.loadFile(e4, true))) && (e4 = l3);
        }
        if (d2(e4) && (e4 = p2(e4, n3)), n3 = a3(e4, n3), !f3(n3)) throw new Error("addImage does not support files of type '" + n3 + "', please ensure that a plugin for '" + n3 + "' support is added.");
        if ((null == (u4 = i2) || 0 === u4.length) && (i2 = (function(t3) {
          return "string" == typeof t3 || x2(t3) ? w2(t3) : x2(t3.data) ? w2(t3.data) : null;
        })(e4)), (s3 = g2.call(this, i2)) || (e4 instanceof Uint8Array || "RGBA" === n3 || (c3 = e4, e4 = A3(e4)), s3 = this["process" + n3.toUpperCase()](e4, h2.call(this), i2, (function(e5) {
          return e5 && "string" == typeof e5 && (e5 = e5.toUpperCase()), e5 in t2.image_compression ? e5 : y2.NONE;
        })(o3), c3)), !s3) throw new Error("An unknown error occurred whilst processing the image.");
        return s3;
      }, P2 = t2.__addimage__.convertBase64ToBinaryString = function(t3, e4) {
        e4 = "boolean" != typeof e4 || e4;
        var r3, n3 = "";
        if ("string" == typeof t3) {
          r3 = L3(t3) ?? t3;
          try {
            n3 = i(r3);
          } catch (a4) {
            if (e4) throw N2(r3) ? new Error("atob-Error in jsPDF.convertBase64ToBinaryString " + a4.message) : new Error("Supplied Data is not a valid base64-String jsPDF.convertBase64ToBinaryString ");
          }
        }
        return n3;
      };
      t2.getImageProperties = function(e4) {
        var n3, i2, o3 = "";
        if (d2(e4) && (e4 = p2(e4)), "string" == typeof e4 && a3(e4) === r2 && ("" === (o3 = P2(e4, false)) && (o3 = t2.loadFile(e4) || ""), e4 = o3), i2 = a3(e4), !f3(i2)) throw new Error("addImage does not support files of type '" + i2 + "', please ensure that a plugin for '" + i2 + "' support is added.");
        if (e4 instanceof Uint8Array || (e4 = A3(e4)), !(n3 = this["process" + i2.toUpperCase()](e4))) throw new Error("An unknown error occurred whilst processing the image");
        return n3.fileType = i2, n3;
      };
    })(j.API), /**
     * @license
     * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
     *
     * Licensed under the MIT License.
     * http://opensource.org/licenses/mit-license
     */
    (function(t2) {
      var e3 = function(t3) {
        if (void 0 !== t3 && "" != t3) return true;
      };
      j.API.events.push(["addPage", function(t3) {
        this.internal.getPageInfo(t3.pageNumber).pageContext.annotations = [];
      }]), t2.events.push(["putPage", function(t3) {
        for (var r2, n2, i2, a3 = this.internal.getCoordinateString, o2 = this.internal.getVerticalCoordinateString, s2 = this.internal.getPageInfoByObjId(t3.objId), c2 = t3.pageContext.annotations, u3 = false, l2 = 0; l2 < c2.length && !u3; l2++) switch ((r2 = c2[l2]).type) {
          case "link":
            (e3(r2.options.url) || e3(r2.options.pageNumber)) && (u3 = true);
            break;
          case "reference":
          case "text":
          case "freetext":
            u3 = true;
        }
        if (0 != u3) {
          this.internal.write("/Annots [");
          for (var h2 = 0; h2 < c2.length; h2++) {
            r2 = c2[h2];
            var f3 = this.internal.pdfEscape, d2 = this.internal.getEncryptor(t3.objId);
            switch (r2.type) {
              case "reference":
                this.internal.write(" " + r2.object.objId + " 0 R ");
                break;
              case "text":
                var p2 = this.internal.newAdditionalObject(), g2 = this.internal.newAdditionalObject(), m2 = this.internal.getEncryptor(p2.objId), v2 = r2.title || "Note";
                i2 = "<</Type /Annot /Subtype /Text " + (n2 = "/Rect [" + a3(r2.bounds.x) + " " + o2(r2.bounds.y + r2.bounds.h) + " " + a3(r2.bounds.x + r2.bounds.w) + " " + o2(r2.bounds.y) + "] ") + "/Contents (" + f3(m2(r2.contents)) + ")", i2 += " /Popup " + g2.objId + " 0 R", i2 += " /P " + s2.objId + " 0 R", i2 += " /T (" + f3(m2(v2)) + ") >>", p2.content = i2;
                var b2 = p2.objId + " 0 R";
                i2 = "<</Type /Annot /Subtype /Popup " + (n2 = "/Rect [" + a3(r2.bounds.x + 30) + " " + o2(r2.bounds.y + r2.bounds.h) + " " + a3(r2.bounds.x + r2.bounds.w + 30) + " " + o2(r2.bounds.y) + "] ") + " /Parent " + b2, r2.open && (i2 += " /Open true"), i2 += " >>", g2.content = i2, this.internal.write(p2.objId, "0 R", g2.objId, "0 R");
                break;
              case "freetext":
                n2 = "/Rect [" + a3(r2.bounds.x) + " " + o2(r2.bounds.y) + " " + a3(r2.bounds.x + r2.bounds.w) + " " + o2(r2.bounds.y + r2.bounds.h) + "] ";
                var y2 = r2.color || "#000000";
                i2 = "<</Type /Annot /Subtype /FreeText " + n2 + "/Contents (" + f3(d2(r2.contents)) + ")", i2 += " /DS(font: Helvetica,sans-serif 12.0pt; text-align:left; color:#" + y2 + ")", i2 += " /Border [0 0 0]", i2 += " >>", this.internal.write(i2);
                break;
              case "link":
                if (r2.options.name) {
                  var w2 = this.annotations._nameMap[r2.options.name];
                  r2.options.pageNumber = w2.page, r2.options.top = w2.y;
                } else r2.options.top || (r2.options.top = 0);
                if (n2 = "/Rect [" + r2.finalBounds.x + " " + r2.finalBounds.y + " " + r2.finalBounds.w + " " + r2.finalBounds.h + "] ", i2 = "", r2.options.url) i2 = "<</Type /Annot /Subtype /Link " + n2 + "/Border [0 0 0] /A <</S /URI /URI (" + f3(d2(r2.options.url)) + ") >>";
                else if (r2.options.pageNumber) switch (i2 = "<</Type /Annot /Subtype /Link " + n2 + "/Border [0 0 0] /Dest [" + this.internal.getPageInfo(r2.options.pageNumber).objId + " 0 R", r2.options.magFactor = r2.options.magFactor || "XYZ", r2.options.magFactor) {
                  case "Fit":
                    i2 += " /Fit]";
                    break;
                  case "FitH":
                    i2 += " /FitH " + r2.options.top + "]";
                    break;
                  case "FitV":
                    r2.options.left = r2.options.left || 0, i2 += " /FitV " + r2.options.left + "]";
                    break;
                  default:
                    var N2 = o2(r2.options.top);
                    r2.options.left = r2.options.left || 0, void 0 === r2.options.zoom && (r2.options.zoom = 0), i2 += " /XYZ " + r2.options.left + " " + N2 + " " + r2.options.zoom + "]";
                }
                "" != i2 && (i2 += " >>", this.internal.write(i2));
            }
          }
          this.internal.write("]");
        }
      }]), t2.createAnnotation = function(t3) {
        var e4 = this.internal.getCurrentPageInfo();
        switch (t3.type) {
          case "link":
            this.link(t3.bounds.x, t3.bounds.y, t3.bounds.w, t3.bounds.h, t3);
            break;
          case "text":
          case "freetext":
            e4.pageContext.annotations.push(t3);
        }
      }, t2.link = function(t3, e4, r2, n2, i2) {
        var a3 = this.internal.getCurrentPageInfo(), o2 = this.internal.getCoordinateString, s2 = this.internal.getVerticalCoordinateString;
        a3.pageContext.annotations.push({ finalBounds: { x: o2(t3), y: s2(e4), w: o2(t3 + r2), h: s2(e4 + n2) }, options: i2, type: "link" });
      }, t2.textWithLink = function(t3, e4, r2, n2) {
        var i2, a3, o2 = this.getTextWidth(t3), s2 = this.internal.getLineHeight() / this.internal.scaleFactor;
        if (void 0 !== n2.maxWidth) {
          var { maxWidth: c2 } = n2;
          a3 = c2;
          var u3 = this.splitTextToSize(t3, a3).length;
          i2 = Math.ceil(s2 * u3);
        } else a3 = o2, i2 = s2;
        return this.text(t3, e4, r2, n2), r2 += 0.2 * s2, "center" === n2.align && (e4 -= o2 / 2), "right" === n2.align && (e4 -= o2), this.link(e4, r2 - s2, a3, i2, n2), o2;
      }, t2.getTextWidth = function(t3) {
        var e4 = this.internal.getFontSize();
        return this.getStringUnitWidth(t3) * e4 / this.internal.scaleFactor;
      };
    })(j.API), /**
     * @license
     * Copyright (c) 2017 Aras Abbasi
     *
     * Licensed under the MIT License.
     * http://opensource.org/licenses/mit-license
     */
    (function(t2) {
      var e3 = { 1569: [65152], 1570: [65153, 65154], 1571: [65155, 65156], 1572: [65157, 65158], 1573: [65159, 65160], 1574: [65161, 65162, 65163, 65164], 1575: [65165, 65166], 1576: [65167, 65168, 65169, 65170], 1577: [65171, 65172], 1578: [65173, 65174, 65175, 65176], 1579: [65177, 65178, 65179, 65180], 1580: [65181, 65182, 65183, 65184], 1581: [65185, 65186, 65187, 65188], 1582: [65189, 65190, 65191, 65192], 1583: [65193, 65194], 1584: [65195, 65196], 1585: [65197, 65198], 1586: [65199, 65200], 1587: [65201, 65202, 65203, 65204], 1588: [65205, 65206, 65207, 65208], 1589: [65209, 65210, 65211, 65212], 1590: [65213, 65214, 65215, 65216], 1591: [65217, 65218, 65219, 65220], 1592: [65221, 65222, 65223, 65224], 1593: [65225, 65226, 65227, 65228], 1594: [65229, 65230, 65231, 65232], 1601: [65233, 65234, 65235, 65236], 1602: [65237, 65238, 65239, 65240], 1603: [65241, 65242, 65243, 65244], 1604: [65245, 65246, 65247, 65248], 1605: [65249, 65250, 65251, 65252], 1606: [65253, 65254, 65255, 65256], 1607: [65257, 65258, 65259, 65260], 1608: [65261, 65262], 1609: [65263, 65264, 64488, 64489], 1610: [65265, 65266, 65267, 65268], 1649: [64336, 64337], 1655: [64477], 1657: [64358, 64359, 64360, 64361], 1658: [64350, 64351, 64352, 64353], 1659: [64338, 64339, 64340, 64341], 1662: [64342, 64343, 64344, 64345], 1663: [64354, 64355, 64356, 64357], 1664: [64346, 64347, 64348, 64349], 1667: [64374, 64375, 64376, 64377], 1668: [64370, 64371, 64372, 64373], 1670: [64378, 64379, 64380, 64381], 1671: [64382, 64383, 64384, 64385], 1672: [64392, 64393], 1676: [64388, 64389], 1677: [64386, 64387], 1678: [64390, 64391], 1681: [64396, 64397], 1688: [64394, 64395], 1700: [64362, 64363, 64364, 64365], 1702: [64366, 64367, 64368, 64369], 1705: [64398, 64399, 64400, 64401], 1709: [64467, 64468, 64469, 64470], 1711: [64402, 64403, 64404, 64405], 1713: [64410, 64411, 64412, 64413], 1715: [64406, 64407, 64408, 64409], 1722: [64414, 64415], 1723: [64416, 64417, 64418, 64419], 1726: [64426, 64427, 64428, 64429], 1728: [64420, 64421], 1729: [64422, 64423, 64424, 64425], 1733: [64480, 64481], 1734: [64473, 64474], 1735: [64471, 64472], 1736: [64475, 64476], 1737: [64482, 64483], 1739: [64478, 64479], 1740: [64508, 64509, 64510, 64511], 1744: [64484, 64485, 64486, 64487], 1746: [64430, 64431], 1747: [64432, 64433] }, r2 = { 65247: { 65154: 65269, 65156: 65271, 65160: 65273, 65166: 65275 }, 65248: { 65154: 65270, 65156: 65272, 65160: 65274, 65166: 65276 }, 65165: { 65247: { 65248: { 65258: 65010 } } }, 1617: { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 } }, n2 = { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 }, i2 = [1570, 1571, 1573, 1575];
      t2.__arabicParser__ = {};
      var a3 = t2.__arabicParser__.isInArabicSubstitutionA = function(t3) {
        return void 0 !== e3[t3.charCodeAt(0)];
      }, o2 = t2.__arabicParser__.isArabicLetter = function(t3) {
        return "string" == typeof t3 && /^[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]+$/.test(t3);
      }, s2 = t2.__arabicParser__.isArabicEndLetter = function(t3) {
        return o2(t3) && a3(t3) && e3[t3.charCodeAt(0)].length <= 2;
      }, c2 = t2.__arabicParser__.isArabicAlfLetter = function(t3) {
        return o2(t3) && i2.indexOf(t3.charCodeAt(0)) >= 0;
      };
      t2.__arabicParser__.arabicLetterHasIsolatedForm = function(t3) {
        return o2(t3) && a3(t3) && e3[t3.charCodeAt(0)].length >= 1;
      };
      var u3 = t2.__arabicParser__.arabicLetterHasFinalForm = function(t3) {
        return o2(t3) && a3(t3) && e3[t3.charCodeAt(0)].length >= 2;
      };
      t2.__arabicParser__.arabicLetterHasInitialForm = function(t3) {
        return o2(t3) && a3(t3) && e3[t3.charCodeAt(0)].length >= 3;
      };
      var l2 = t2.__arabicParser__.arabicLetterHasMedialForm = function(t3) {
        return o2(t3) && a3(t3) && 4 == e3[t3.charCodeAt(0)].length;
      }, h2 = t2.__arabicParser__.resolveLigatures = function(t3) {
        var e4 = 0, n3 = r2, i3 = "", a4 = 0;
        for (e4 = 0; e4 < t3.length; e4 += 1) void 0 !== n3[t3.charCodeAt(e4)] ? (a4++, "number" == typeof (n3 = n3[t3.charCodeAt(e4)]) && (i3 += String.fromCharCode(n3), n3 = r2, a4 = 0), e4 === t3.length - 1 && (n3 = r2, i3 += t3.charAt(e4 - (a4 - 1)), e4 -= a4 - 1, a4 = 0)) : (n3 = r2, i3 += t3.charAt(e4 - a4), e4 -= a4, a4 = 0);
        return i3;
      };
      t2.__arabicParser__.isArabicDiacritic = function(t3) {
        return void 0 !== t3 && void 0 !== n2[t3.charCodeAt(0)];
      };
      var f3 = t2.__arabicParser__.getCorrectForm = function(t3, e4, r3) {
        return o2(t3) ? false === a3(t3) ? -1 : !u3(t3) || !o2(e4) && !o2(r3) || !o2(r3) && s2(e4) || s2(t3) && !o2(e4) || s2(t3) && c2(e4) || s2(t3) && s2(e4) ? 0 : l2(t3) && o2(e4) && !s2(e4) && o2(r3) && u3(r3) ? 3 : s2(t3) || !o2(r3) ? 1 : 2 : -1;
      }, d2 = function(t3) {
        var r3 = 0, n3 = 0, i3 = 0, a4 = "", s3 = "", c3 = "", u4 = (t3 = t3 || "").split("\\s+"), l3 = [];
        for (r3 = 0; r3 < u4.length; r3 += 1) {
          for (l3.push(""), n3 = 0; n3 < u4[r3].length; n3 += 1) a4 = u4[r3][n3], s3 = u4[r3][n3 - 1], c3 = u4[r3][n3 + 1], o2(a4) ? (i3 = f3(a4, s3, c3), l3[r3] += -1 !== i3 ? String.fromCharCode(e3[a4.charCodeAt(0)][i3]) : a4) : l3[r3] += a4;
          l3[r3] = h2(l3[r3]);
        }
        return l3.join(" ");
      }, p2 = t2.__arabicParser__.processArabic = t2.processArabic = function() {
        var t3, e4 = "string" == typeof arguments[0] ? arguments[0] : arguments[0].text, r3 = [];
        if (Array.isArray(e4)) {
          var n3 = 0;
          for (r3 = [], n3 = 0; n3 < e4.length; n3 += 1) Array.isArray(e4[n3]) ? r3.push([d2(e4[n3][0]), e4[n3][1], e4[n3][2]]) : r3.push([d2(e4[n3])]);
          t3 = r3;
        } else t3 = d2(e4);
        return "string" == typeof arguments[0] ? t3 : (arguments[0].text = t3, arguments[0]);
      };
      t2.events.push(["preProcessText", p2]);
    })(j.API), j.API.autoPrint = function(t2) {
      var e3;
      return (t2 = t2 || {}).variant = t2.variant || "non-conform", "javascript" === t2.variant ? this.addJS("print({});") : (this.internal.events.subscribe("postPutResources", function() {
        e3 = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /Named"), this.internal.out("/Type /Action"), this.internal.out("/N /Print"), this.internal.out(">>"), this.internal.out("endobj");
      }), this.internal.events.subscribe("putCatalog", function() {
        this.internal.out("/OpenAction " + e3 + " 0 R");
      })), this;
    }, /**
     * @license
     * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
     *
     * Licensed under the MIT License.
     * http://opensource.org/licenses/mit-license
     */
    (function(t2) {
      var e3 = function() {
        var t3 = void 0;
        Object.defineProperty(this, "pdf", { get: function() {
          return t3;
        }, set: function(e5) {
          t3 = e5;
        } });
        var e4 = 150;
        Object.defineProperty(this, "width", { get: function() {
          return e4;
        }, set: function(t4) {
          e4 = isNaN(t4) || false === Number.isInteger(t4) || t4 < 0 ? 150 : t4, this.getContext("2d").pageWrapXEnabled && (this.getContext("2d").pageWrapX = e4 + 1);
        } });
        var r2 = 300;
        Object.defineProperty(this, "height", { get: function() {
          return r2;
        }, set: function(t4) {
          r2 = isNaN(t4) || false === Number.isInteger(t4) || t4 < 0 ? 300 : t4, this.getContext("2d").pageWrapYEnabled && (this.getContext("2d").pageWrapY = r2 + 1);
        } });
        var n2 = [];
        Object.defineProperty(this, "childNodes", { get: function() {
          return n2;
        }, set: function(t4) {
          n2 = t4;
        } });
        var i2 = {};
        Object.defineProperty(this, "style", { get: function() {
          return i2;
        }, set: function(t4) {
          i2 = t4;
        } }), Object.defineProperty(this, "parentNode", {});
      };
      e3.prototype.getContext = function(t3, e4) {
        var r2;
        if ("2d" !== (t3 = t3 || "2d")) return null;
        for (r2 in e4) this.pdf.context2d.hasOwnProperty(r2) && (this.pdf.context2d[r2] = e4[r2]);
        return this.pdf.context2d._canvas = this, this.pdf.context2d;
      }, e3.prototype.toDataURL = function() {
        throw new Error("toDataURL is not implemented.");
      }, t2.events.push(["initialized", function() {
        this.canvas = new e3(), this.canvas.pdf = this;
      }]);
    })(j.API), /**
     * @license
     * ====================================================================
     * Copyright (c) 2013 Youssef Beddad, youssef.beddad@gmail.com
     *               2013 Eduardo Menezes de Morais, eduardo.morais@usp.br
     *               2013 Lee Driscoll, https://github.com/lsdriscoll
     *               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria
     *               2014 James Hall, james@parall.ax
     *               2014 Diego Casorran, https://github.com/diegocr
     *
     * Permission is hereby granted, free of charge, to any person obtaining
     * a copy of this software and associated documentation files (the
     * "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish,
     * distribute, sublicense, and/or sell copies of the Software, and to
     * permit persons to whom the Software is furnished to do so, subject to
     * the following conditions:
     *
     * The above copyright notice and this permission notice shall be
     * included in all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
     * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
     * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
     * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
     * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     * ====================================================================
     */
    (function(t2) {
      var e3 = { left: 0, top: 0, bottom: 0, right: 0 }, r2 = false, n2 = function() {
        void 0 === this.internal.__cell__ && (this.internal.__cell__ = {}, this.internal.__cell__.padding = 3, this.internal.__cell__.headerFunction = void 0, this.internal.__cell__.margins = Object.assign({}, e3), this.internal.__cell__.margins.width = this.getPageWidth(), i2.call(this));
      }, i2 = function() {
        this.internal.__cell__.lastCell = new a3(), this.internal.__cell__.pages = 1;
      }, a3 = function() {
        var t3 = arguments[0];
        Object.defineProperty(this, "x", { enumerable: true, get: function() {
          return t3;
        }, set: function(e5) {
          t3 = e5;
        } });
        var e4 = arguments[1];
        Object.defineProperty(this, "y", { enumerable: true, get: function() {
          return e4;
        }, set: function(t4) {
          e4 = t4;
        } });
        var r3 = arguments[2];
        Object.defineProperty(this, "width", { enumerable: true, get: function() {
          return r3;
        }, set: function(t4) {
          r3 = t4;
        } });
        var n3 = arguments[3];
        Object.defineProperty(this, "height", { enumerable: true, get: function() {
          return n3;
        }, set: function(t4) {
          n3 = t4;
        } });
        var i3 = arguments[4];
        Object.defineProperty(this, "text", { enumerable: true, get: function() {
          return i3;
        }, set: function(t4) {
          i3 = t4;
        } });
        var a4 = arguments[5];
        Object.defineProperty(this, "lineNumber", { enumerable: true, get: function() {
          return a4;
        }, set: function(t4) {
          a4 = t4;
        } });
        var o3 = arguments[6];
        return Object.defineProperty(this, "align", { enumerable: true, get: function() {
          return o3;
        }, set: function(t4) {
          o3 = t4;
        } }), this;
      };
      a3.prototype.clone = function() {
        return new a3(this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align);
      }, a3.prototype.toArray = function() {
        return [this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align];
      }, t2.setHeaderFunction = function(t3) {
        return n2.call(this), this.internal.__cell__.headerFunction = "function" == typeof t3 ? t3 : void 0, this;
      }, t2.getTextDimensions = function(t3, e4) {
        n2.call(this);
        var r3 = (e4 = e4 || {}).fontSize || this.getFontSize(), i3 = e4.font || this.getFont(), a4 = e4.scaleFactor || this.internal.scaleFactor, o3 = 0, s3 = 0, c2 = 0, u3 = this;
        if (!Array.isArray(t3) && "string" != typeof t3) {
          if ("number" != typeof t3) throw new Error("getTextDimensions expects text-parameter to be of type String or type Number or an Array of Strings.");
          t3 = String(t3);
        }
        const l2 = e4.maxWidth;
        l2 > 0 ? "string" == typeof t3 ? t3 = this.splitTextToSize(t3, l2) : "[object Array]" === Object.prototype.toString.call(t3) && (t3 = t3.reduce(function(t4, e5) {
          return t4.concat(u3.splitTextToSize(e5, l2));
        }, [])) : t3 = Array.isArray(t3) ? t3 : [t3];
        for (var h2 = 0; h2 < t3.length; h2++) o3 < (c2 = this.getStringUnitWidth(t3[h2], { font: i3 }) * r3) && (o3 = c2);
        return 0 !== o3 && (s3 = t3.length), { w: o3 /= a4, h: Math.max((s3 * r3 * this.getLineHeightFactor() - r3 * (this.getLineHeightFactor() - 1)) / a4, 0) };
      }, t2.cellAddPage = function() {
        n2.call(this), this.addPage();
        var t3 = this.internal.__cell__.margins || e3;
        return this.internal.__cell__.lastCell = new a3(t3.left, t3.top, void 0, void 0), this.internal.__cell__.pages += 1, this;
      };
      var o2 = t2.cell = function() {
        var t3;
        t3 = arguments[0] instanceof a3 ? arguments[0] : new a3(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6]), n2.call(this);
        var i3 = this.internal.__cell__.lastCell, o3 = this.internal.__cell__.padding, s3 = this.internal.__cell__.margins || e3, c2 = this.internal.__cell__.tableHeaderRow, u3 = this.internal.__cell__.printHeaders;
        return void 0 !== i3.lineNumber && (i3.lineNumber === t3.lineNumber ? (t3.x = (i3.x || 0) + (i3.width || 0), t3.y = i3.y || 0) : i3.y + i3.height + t3.height + s3.bottom > this.getPageHeight() ? (this.cellAddPage(), t3.y = s3.top, u3 && c2 && (this.printHeaderRow(t3.lineNumber, true), t3.y += c2[0].height)) : t3.y = i3.y + i3.height || t3.y), void 0 !== t3.text[0] && (this.rect(t3.x, t3.y, t3.width, t3.height, true === r2 ? "FD" : void 0), "right" === t3.align ? this.text(t3.text, t3.x + t3.width - o3, t3.y + o3, { align: "right", baseline: "top" }) : "center" === t3.align ? this.text(t3.text, t3.x + t3.width / 2, t3.y + o3, { align: "center", baseline: "top", maxWidth: t3.width - o3 - o3 }) : this.text(t3.text, t3.x + o3, t3.y + o3, { align: "left", baseline: "top", maxWidth: t3.width - o3 - o3 })), this.internal.__cell__.lastCell = t3, this;
      };
      t2.table = function(t3, r3, c2, u3, l2) {
        if (n2.call(this), !c2) throw new Error("No data for PDF table.");
        var h2, f3, d2, p2, g2 = [], m2 = [], v2 = [], b2 = {}, y2 = {}, w2 = [], N2 = [], L3 = (l2 = l2 || {}).autoSize || false, x2 = false !== l2.printHeaders, A3 = l2.css && void 0 !== l2.css["font-size"] ? 16 * l2.css["font-size"] : l2.fontSize || 12, S2 = l2.margins || Object.assign({ width: this.getPageWidth() }, e3), _2 = "number" == typeof l2.padding ? l2.padding : 3, P2 = l2.headerBackgroundColor || "#c8c8c8", k2 = l2.headerTextColor || "#000";
        if (i2.call(this), this.internal.__cell__.printHeaders = x2, this.internal.__cell__.margins = S2, this.internal.__cell__.table_font_size = A3, this.internal.__cell__.padding = _2, this.internal.__cell__.headerBackgroundColor = P2, this.internal.__cell__.headerTextColor = k2, this.setFontSize(A3), null == u3) m2 = g2 = Object.keys(c2[0]), v2 = g2.map(function() {
          return "left";
        });
        else if (Array.isArray(u3) && "object" == typeof u3[0]) for (g2 = u3.map(function(t4) {
          return t4.name;
        }), m2 = u3.map(function(t4) {
          return t4.prompt || t4.name || "";
        }), v2 = u3.map(function(t4) {
          return t4.align || "left";
        }), h2 = 0; h2 < u3.length; h2 += 1) y2[u3[h2].name] = 0.7499990551181103 * u3[h2].width;
        else Array.isArray(u3) && "string" == typeof u3[0] && (m2 = g2 = u3, v2 = g2.map(function() {
          return "left";
        }));
        if (L3 || Array.isArray(u3) && "string" == typeof u3[0]) for (h2 = 0; h2 < g2.length; h2 += 1) {
          for (b2[p2 = g2[h2]] = c2.map(function(t4) {
            return t4[p2];
          }), this.setFont(void 0, "bold"), w2.push(this.getTextDimensions(m2[h2], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w), f3 = b2[p2], this.setFont(void 0, "normal"), d2 = 0; d2 < f3.length; d2 += 1) w2.push(this.getTextDimensions(f3[d2], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w);
          y2[p2] = Math.max.apply(null, w2) + _2 + _2, w2 = [];
        }
        if (x2) {
          var F3 = {};
          for (h2 = 0; h2 < g2.length; h2 += 1) F3[g2[h2]] = {}, F3[g2[h2]].text = m2[h2], F3[g2[h2]].align = v2[h2];
          var I2 = s2.call(this, F3, y2);
          N2 = g2.map(function(e4) {
            return new a3(t3, r3, y2[e4], I2, F3[e4].text, void 0, F3[e4].align);
          }), this.setTableHeaderRow(N2), this.printHeaderRow(1, false);
        }
        var j2 = u3.reduce(function(t4, e4) {
          return t4[e4.name] = e4.align, t4;
        }, {});
        for (h2 = 0; h2 < c2.length; h2 += 1) {
          "rowStart" in l2 && l2.rowStart instanceof Function && l2.rowStart({ row: h2, data: c2[h2] }, this);
          var C2 = s2.call(this, c2[h2], y2);
          for (d2 = 0; d2 < g2.length; d2 += 1) {
            var O2 = c2[h2][g2[d2]];
            "cellStart" in l2 && l2.cellStart instanceof Function && l2.cellStart({ row: h2, col: d2, data: O2 }, this), o2.call(this, new a3(t3, r3, y2[g2[d2]], C2, O2, h2 + 2, j2[g2[d2]]));
          }
        }
        return this.internal.__cell__.table_x = t3, this.internal.__cell__.table_y = r3, this;
      };
      var s2 = function(t3, e4) {
        var r3 = this.internal.__cell__.padding, n3 = this.internal.__cell__.table_font_size, i3 = this.internal.scaleFactor;
        return Object.keys(t3).map(function(n4) {
          var i4 = t3[n4];
          return this.splitTextToSize(i4.hasOwnProperty("text") ? i4.text : i4, e4[n4] - r3 - r3);
        }, this).map(function(t4) {
          return this.getLineHeightFactor() * t4.length * n3 / i3 + r3 + r3;
        }, this).reduce(function(t4, e5) {
          return Math.max(t4, e5);
        }, 0);
      };
      t2.setTableHeaderRow = function(t3) {
        n2.call(this), this.internal.__cell__.tableHeaderRow = t3;
      }, t2.printHeaderRow = function(t3, e4) {
        if (n2.call(this), !this.internal.__cell__.tableHeaderRow) throw new Error("Property tableHeaderRow does not exist.");
        var i3;
        if (r2 = true, "function" == typeof this.internal.__cell__.headerFunction) {
          var s3 = this.internal.__cell__.headerFunction(this, this.internal.__cell__.pages);
          this.internal.__cell__.lastCell = new a3(s3[0], s3[1], s3[2], s3[3], void 0, -1);
        }
        this.setFont(void 0, "bold");
        for (var c2 = [], u3 = 0; u3 < this.internal.__cell__.tableHeaderRow.length; u3 += 1) {
          i3 = this.internal.__cell__.tableHeaderRow[u3].clone(), e4 && (i3.y = this.internal.__cell__.margins.top || 0, c2.push(i3)), i3.lineNumber = t3;
          var l2 = this.getTextColor();
          this.setTextColor(this.internal.__cell__.headerTextColor), this.setFillColor(this.internal.__cell__.headerBackgroundColor), o2.call(this, i3), this.setTextColor(l2);
        }
        c2.length > 0 && this.setTableHeaderRow(c2), this.setFont(void 0, "normal"), r2 = false;
      };
    })(j.API);
    var Nt = { italic: ["italic", "oblique", "normal"], oblique: ["oblique", "italic", "normal"], normal: ["normal", "oblique", "italic"] };
    var Lt = ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded"];
    var xt = wt(Lt);
    var At = [100, 200, 300, 400, 500, 600, 700, 800, 900];
    var St = wt(At);
    function _t(t2) {
      var e3 = t2.family.replace(/"|'/g, "").toLowerCase(), r2 = (function(t3) {
        return Nt[t3 = t3 || "normal"] ? t3 : "normal";
      })(t2.style), n2 = (function(t3) {
        return t3 ? "number" == typeof t3 ? t3 >= 100 && t3 <= 900 && t3 % 100 == 0 ? t3 : 400 : /^\d00$/.test(t3) ? parseInt(t3) : "bold" === t3 ? 700 : 400 : 400;
      })(t2.weight), i2 = (function(t3) {
        return "number" == typeof xt[t3 = t3 || "normal"] ? t3 : "normal";
      })(t2.stretch);
      return { family: e3, style: r2, weight: n2, stretch: i2, src: t2.src || [], ref: t2.ref || { name: e3, style: [i2, r2, n2].join(" ") } };
    }
    function Pt(t2, e3, r2, n2) {
      var i2;
      for (i2 = r2; i2 >= 0 && i2 < e3.length; i2 += n2) if (t2[e3[i2]]) return t2[e3[i2]];
      for (i2 = r2; i2 >= 0 && i2 < e3.length; i2 -= n2) if (t2[e3[i2]]) return t2[e3[i2]];
    }
    var kt = { "sans-serif": "helvetica", fixed: "courier", monospace: "courier", terminal: "courier", cursive: "times", fantasy: "times", serif: "times" };
    var Ft = { caption: "times", icon: "times", menu: "times", "message-box": "times", "small-caption": "times", "status-bar": "times" };
    function It(t2) {
      return [t2.stretch, t2.style, t2.weight, t2.family].join(" ");
    }
    function jt(t2) {
      return t2.trimLeft();
    }
    function Ct(t2, e3) {
      for (var r2 = 0; r2 < t2.length; ) {
        if (t2.charAt(r2) === e3) return [t2.substring(0, r2), t2.substring(r2 + 1)];
        r2 += 1;
      }
      return null;
    }
    function Ot(t2) {
      var e3 = t2.match(/^(-[a-z_]|[a-z_])[a-z0-9_-]*/i);
      return null === e3 ? null : [e3[0], t2.substring(e3[0].length)];
    }
    var Bt;
    var qt;
    var Mt;
    var Et;
    var Rt;
    var Dt = ["times"];
    function Tt(e3, r2, n2, i2, a3) {
      let o2 = 4, s2 = Ht;
      switch (a3) {
        case j.API.image_compression.FAST:
          o2 = 1, s2 = Ut;
          break;
        case j.API.image_compression.MEDIUM:
          o2 = 6, s2 = Wt;
          break;
        case j.API.image_compression.SLOW:
          o2 = 9, s2 = Vt;
      }
      e3 = (function(t2, e4, r3, n3) {
        const i3 = t2.length / e4, a4 = new Uint8Array(t2.length + i3), o3 = [zt, Ut, Ht, Wt, Vt];
        let s3;
        for (let c3 = 0; c3 < i3; c3 += 1) {
          const i4 = c3 * e4, u3 = t2.subarray(i4, i4 + e4);
          if (n3) a4.set(n3(u3, r3, s3), i4 + c3);
          else {
            const t3 = o3.length, e5 = [];
            for (let i5 = 0; i5 < t3; i5 += 1) e5[i5] = o3[i5](u3, r3, s3);
            const n4 = Yt(e5.concat());
            a4.set(e5[n4], i4 + c3);
          }
          s3 = u3;
        }
        return a4;
      })(e3, r2, Math.ceil(n2 * i2 / 8), s2);
      const c2 = t.zlibSync(e3, { level: o2 });
      return j.API.__addimage__.arrayBufferToBinaryString(c2);
    }
    function zt(t2) {
      const e3 = Array.apply([], t2);
      return e3.unshift(0), e3;
    }
    function Ut(t2, e3) {
      const r2 = t2.length, n2 = [];
      n2[0] = 1;
      for (let i2 = 0; i2 < r2; i2 += 1) {
        const r3 = t2[i2 - e3] || 0;
        n2[i2 + 1] = t2[i2] - r3 + 256 & 255;
      }
      return n2;
    }
    function Ht(t2, e3, r2) {
      const n2 = t2.length, i2 = [];
      i2[0] = 2;
      for (let a3 = 0; a3 < n2; a3 += 1) {
        const e4 = r2 && r2[a3] || 0;
        i2[a3 + 1] = t2[a3] - e4 + 256 & 255;
      }
      return i2;
    }
    function Wt(t2, e3, r2) {
      const n2 = t2.length, i2 = [];
      i2[0] = 3;
      for (let a3 = 0; a3 < n2; a3 += 1) {
        const n3 = t2[a3 - e3] || 0, o2 = r2 && r2[a3] || 0;
        i2[a3 + 1] = t2[a3] + 256 - (n3 + o2 >>> 1) & 255;
      }
      return i2;
    }
    function Vt(t2, e3, r2) {
      const n2 = t2.length, i2 = [];
      i2[0] = 4;
      for (let a3 = 0; a3 < n2; a3 += 1) {
        const n3 = Gt(t2[a3 - e3] || 0, r2 && r2[a3] || 0, r2 && r2[a3 - e3] || 0);
        i2[a3 + 1] = t2[a3] - n3 + 256 & 255;
      }
      return i2;
    }
    function Gt(t2, e3, r2) {
      if (t2 === e3 && e3 === r2) return t2;
      const n2 = Math.abs(e3 - r2), i2 = Math.abs(t2 - r2), a3 = Math.abs(t2 + e3 - r2 - r2);
      return n2 <= i2 && n2 <= a3 ? t2 : i2 <= a3 ? e3 : r2;
    }
    function Yt(t2) {
      const e3 = t2.map(function(t3) {
        return t3.reduce(function(t4, e4) {
          return t4 + Math.abs(e4);
        }, 0);
      });
      return e3.indexOf(Math.min.apply(null, e3));
    }
    function Jt(t2, e3, r2) {
      const n2 = e3 * r2, i2 = Math.floor(n2 / 8), a3 = 16 - (n2 - 8 * i2 + r2), o2 = (1 << r2) - 1;
      return Kt(t2, i2) >> a3 & o2;
    }
    function Xt(t2, e3, r2, n2) {
      const i2 = r2 * n2, a3 = Math.floor(i2 / 8), o2 = 16 - (i2 - 8 * a3 + n2), s2 = (1 << n2) - 1, c2 = (e3 & s2) << o2;
      !(function(t3, e4, r3) {
        if (e4 + 1 < t3.byteLength) return void t3.setUint16(e4, r3, false);
        const n3 = r3 >> 8 & 255;
        t3.setUint8(e4, n3);
      })(t2, a3, Kt(t2, a3) & ~(s2 << o2) & 65535 | c2);
    }
    function Kt(t2, e3) {
      return e3 + 1 < t2.byteLength ? t2.getUint16(e3, false) : t2.getUint8(e3) << 8;
    }
    function $t(t2) {
      var e3 = 0;
      if (71 !== t2[e3++] || 73 !== t2[e3++] || 70 !== t2[e3++] || 56 !== t2[e3++] || 56 != (t2[e3++] + 1 & 253) || 97 !== t2[e3++]) throw new Error("Invalid GIF 87a/89a header.");
      var r2 = t2[e3++] | t2[e3++] << 8, n2 = t2[e3++] | t2[e3++] << 8, i2 = t2[e3++], a3 = i2 >> 7, o2 = 1 << 1 + (7 & i2);
      t2[e3++], t2[e3++];
      var s2 = null, c2 = null;
      a3 && (s2 = e3, c2 = o2, e3 += 3 * o2);
      var u3 = true, l2 = [], h2 = 0, f3 = null, d2 = 0, p2 = null;
      for (this.width = r2, this.height = n2; u3 && e3 < t2.length; ) switch (t2[e3++]) {
        case 33:
          switch (t2[e3++]) {
            case 255:
              if (11 !== t2[e3] || 78 == t2[e3 + 1] && 69 == t2[e3 + 2] && 84 == t2[e3 + 3] && 83 == t2[e3 + 4] && 67 == t2[e3 + 5] && 65 == t2[e3 + 6] && 80 == t2[e3 + 7] && 69 == t2[e3 + 8] && 50 == t2[e3 + 9] && 46 == t2[e3 + 10] && 48 == t2[e3 + 11] && 3 == t2[e3 + 12] && 1 == t2[e3 + 13] && 0 == t2[e3 + 16]) e3 += 14, p2 = t2[e3++] | t2[e3++] << 8, e3++;
              else for (e3 += 12; ; ) {
                if (!((P2 = t2[e3++]) >= 0)) throw Error("Invalid block size");
                if (0 === P2) break;
                e3 += P2;
              }
              break;
            case 249:
              if (4 !== t2[e3++] || 0 !== t2[e3 + 4]) throw new Error("Invalid graphics extension block.");
              var g2 = t2[e3++];
              h2 = t2[e3++] | t2[e3++] << 8, f3 = t2[e3++], 1 & g2 || (f3 = null), d2 = g2 >> 2 & 7, e3++;
              break;
            case 254:
              for (; ; ) {
                if (!((P2 = t2[e3++]) >= 0)) throw Error("Invalid block size");
                if (0 === P2) break;
                e3 += P2;
              }
              break;
            default:
              throw new Error("Unknown graphic control label: 0x" + t2[e3 - 1].toString(16));
          }
          break;
        case 44:
          var m2 = t2[e3++] | t2[e3++] << 8, v2 = t2[e3++] | t2[e3++] << 8, b2 = t2[e3++] | t2[e3++] << 8, y2 = t2[e3++] | t2[e3++] << 8, w2 = t2[e3++], N2 = w2 >> 6 & 1, L3 = 1 << 1 + (7 & w2), x2 = s2, A3 = c2, S2 = false;
          w2 >> 7 && (S2 = true, x2 = e3, A3 = L3, e3 += 3 * L3);
          var _2 = e3;
          for (e3++; ; ) {
            var P2;
            if (!((P2 = t2[e3++]) >= 0)) throw Error("Invalid block size");
            if (0 === P2) break;
            e3 += P2;
          }
          l2.push({ x: m2, y: v2, width: b2, height: y2, has_local_palette: S2, palette_offset: x2, palette_size: A3, data_offset: _2, data_length: e3 - _2, transparent_index: f3, interlaced: !!N2, delay: h2, disposal: d2 });
          break;
        case 59:
          u3 = false;
          break;
        default:
          throw new Error("Unknown gif block: 0x" + t2[e3 - 1].toString(16));
      }
      this.numFrames = function() {
        return l2.length;
      }, this.loopCount = function() {
        return p2;
      }, this.frameInfo = function(t3) {
        if (t3 < 0 || t3 >= l2.length) throw new Error("Frame index out of range.");
        return l2[t3];
      }, this.decodeAndBlitFrameBGRA = function(e4, n3) {
        var i3 = this.frameInfo(e4), a4 = i3.width * i3.height;
        if (a4 > 536870912) throw new Error("Image dimensions exceed 512MB, which is too large.");
        var o3 = new Uint8Array(a4);
        Zt(t2, i3.data_offset, o3, a4);
        var s3 = i3.palette_offset, c3 = i3.transparent_index;
        null === c3 && (c3 = 256);
        var u4 = i3.width, l3 = r2 - u4, h3 = u4, f4 = 4 * (i3.y * r2 + i3.x), d3 = 4 * ((i3.y + i3.height) * r2 + i3.x), p3 = f4, g3 = 4 * l3;
        true === i3.interlaced && (g3 += 4 * r2 * 7);
        for (var m3 = 8, v3 = 0, b3 = o3.length; v3 < b3; ++v3) {
          var y3 = o3[v3];
          if (0 === h3 && (h3 = u4, (p3 += g3) >= d3 && (g3 = 4 * l3 + 4 * r2 * (m3 - 1), p3 = f4 + (u4 + l3) * (m3 << 1), m3 >>= 1)), y3 === c3) p3 += 4;
          else {
            var w3 = t2[s3 + 3 * y3], N3 = t2[s3 + 3 * y3 + 1], L4 = t2[s3 + 3 * y3 + 2];
            n3[p3++] = L4, n3[p3++] = N3, n3[p3++] = w3, n3[p3++] = 255;
          }
          --h3;
        }
      }, this.decodeAndBlitFrameRGBA = function(e4, n3) {
        var i3 = this.frameInfo(e4), a4 = i3.width * i3.height;
        if (a4 > 536870912) throw new Error("Image dimensions exceed 512MB, which is too large.");
        var o3 = new Uint8Array(a4);
        Zt(t2, i3.data_offset, o3, a4);
        var s3 = i3.palette_offset, c3 = i3.transparent_index;
        null === c3 && (c3 = 256);
        var u4 = i3.width, l3 = r2 - u4, h3 = u4, f4 = 4 * (i3.y * r2 + i3.x), d3 = 4 * ((i3.y + i3.height) * r2 + i3.x), p3 = f4, g3 = 4 * l3;
        true === i3.interlaced && (g3 += 4 * r2 * 7);
        for (var m3 = 8, v3 = 0, b3 = o3.length; v3 < b3; ++v3) {
          var y3 = o3[v3];
          if (0 === h3 && (h3 = u4, (p3 += g3) >= d3 && (g3 = 4 * l3 + 4 * r2 * (m3 - 1), p3 = f4 + (u4 + l3) * (m3 << 1), m3 >>= 1)), y3 === c3) p3 += 4;
          else {
            var w3 = t2[s3 + 3 * y3], N3 = t2[s3 + 3 * y3 + 1], L4 = t2[s3 + 3 * y3 + 2];
            n3[p3++] = w3, n3[p3++] = N3, n3[p3++] = L4, n3[p3++] = 255;
          }
          --h3;
        }
      };
    }
    function Zt(t2, e3, r2, n2) {
      for (var i2 = t2[e3++], a3 = 1 << i2, o2 = a3 + 1, c2 = o2 + 1, u3 = i2 + 1, l2 = (1 << u3) - 1, h2 = 0, f3 = 0, d2 = 0, p2 = t2[e3++], g2 = new Int32Array(4096), m2 = null; ; ) {
        for (; h2 < 16 && 0 !== p2; ) f3 |= t2[e3++] << h2, h2 += 8, 1 === p2 ? p2 = t2[e3++] : --p2;
        if (h2 < u3) break;
        var v2 = f3 & l2;
        if (f3 >>= u3, h2 -= u3, v2 !== a3) {
          if (v2 === o2) break;
          for (var b2 = v2 < c2 ? v2 : m2, y2 = 0, w2 = b2; w2 > a3; ) w2 = g2[w2] >> 8, ++y2;
          var N2 = w2;
          if (d2 + y2 + (b2 !== v2 ? 1 : 0) > n2) return void s.log("Warning, gif stream longer than expected.");
          r2[d2++] = N2;
          var L3 = d2 += y2;
          for (b2 !== v2 && (r2[d2++] = N2), w2 = b2; y2--; ) w2 = g2[w2], r2[--L3] = 255 & w2, w2 >>= 8;
          null !== m2 && c2 < 4096 && (g2[c2++] = m2 << 8 | N2, c2 >= l2 + 1 && u3 < 12 && (++u3, l2 = l2 << 1 | 1)), m2 = v2;
        } else c2 = o2 + 1, l2 = (1 << (u3 = i2 + 1)) - 1, m2 = null;
      }
      return d2 !== n2 && s.log("Warning, gif stream shorter than expected."), r2;
    }
    function Qt(t2) {
      var e3, r2, n2, i2, a3, o2 = Math.floor, s2 = new Array(64), c2 = new Array(64), u3 = new Array(64), l2 = new Array(64), h2 = new Array(65535), f3 = new Array(65535), d2 = new Array(64), p2 = new Array(64), g2 = [], m2 = 0, v2 = 7, b2 = new Array(64), y2 = new Array(64), w2 = new Array(64), N2 = new Array(256), L3 = new Array(2048), x2 = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63], A3 = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], S2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], _2 = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125], P2 = [1, 2, 3, 0, 4, 17, 5, 18, 33, 49, 65, 6, 19, 81, 97, 7, 34, 113, 20, 50, 129, 145, 161, 8, 35, 66, 177, 193, 21, 82, 209, 240, 36, 51, 98, 114, 130, 9, 10, 22, 23, 24, 25, 26, 37, 38, 39, 40, 41, 42, 52, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250], k2 = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], F3 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], I2 = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119], j2 = [0, 1, 2, 3, 17, 4, 5, 33, 49, 6, 18, 65, 81, 7, 97, 113, 19, 34, 50, 129, 8, 20, 66, 145, 161, 177, 193, 9, 35, 51, 82, 240, 21, 98, 114, 209, 10, 22, 36, 52, 225, 37, 241, 23, 24, 25, 26, 38, 39, 40, 41, 42, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 130, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 226, 227, 228, 229, 230, 231, 232, 233, 234, 242, 243, 244, 245, 246, 247, 248, 249, 250];
      function C2(t3, e4) {
        for (var r3 = 0, n3 = 0, i3 = new Array(), a4 = 1; a4 <= 16; a4++) {
          for (var o3 = 1; o3 <= t3[a4]; o3++) i3[e4[n3]] = [], i3[e4[n3]][0] = r3, i3[e4[n3]][1] = a4, n3++, r3++;
          r3 *= 2;
        }
        return i3;
      }
      function O2(t3) {
        for (var e4 = t3[0], r3 = t3[1] - 1; r3 >= 0; ) e4 & 1 << r3 && (m2 |= 1 << v2), r3--, --v2 < 0 && (255 == m2 ? (B3(255), B3(0)) : B3(m2), v2 = 7, m2 = 0);
      }
      function B3(t3) {
        g2.push(t3);
      }
      function q2(t3) {
        B3(t3 >> 8 & 255), B3(255 & t3);
      }
      function M2(t3, e4, r3, n3, i3) {
        for (var a4, o3 = i3[0], s3 = i3[240], c3 = (function(t4, e5) {
          var r4, n4, i4, a5, o4, s4, c4, u5, l4, h3, f4 = 0;
          for (l4 = 0; l4 < 8; ++l4) {
            r4 = t4[f4], n4 = t4[f4 + 1], i4 = t4[f4 + 2], a5 = t4[f4 + 3], o4 = t4[f4 + 4], s4 = t4[f4 + 5], c4 = t4[f4 + 6];
            var p3 = r4 + (u5 = t4[f4 + 7]), g4 = r4 - u5, m4 = n4 + c4, v4 = n4 - c4, b4 = i4 + s4, y4 = i4 - s4, w4 = a5 + o4, N3 = a5 - o4, L4 = p3 + w4, x3 = p3 - w4, A4 = m4 + b4, S3 = m4 - b4;
            t4[f4] = L4 + A4, t4[f4 + 4] = L4 - A4;
            var _3 = 0.707106781 * (S3 + x3);
            t4[f4 + 2] = x3 + _3, t4[f4 + 6] = x3 - _3;
            var P3 = 0.382683433 * ((L4 = N3 + y4) - (S3 = v4 + g4)), k3 = 0.5411961 * L4 + P3, F4 = 1.306562965 * S3 + P3, I3 = 0.707106781 * (A4 = y4 + v4), j3 = g4 + I3, C3 = g4 - I3;
            t4[f4 + 5] = C3 + k3, t4[f4 + 3] = C3 - k3, t4[f4 + 1] = j3 + F4, t4[f4 + 7] = j3 - F4, f4 += 8;
          }
          for (f4 = 0, l4 = 0; l4 < 8; ++l4) {
            r4 = t4[f4], n4 = t4[f4 + 8], i4 = t4[f4 + 16], a5 = t4[f4 + 24], o4 = t4[f4 + 32], s4 = t4[f4 + 40], c4 = t4[f4 + 48];
            var O3 = r4 + (u5 = t4[f4 + 56]), B4 = r4 - u5, q3 = n4 + c4, M3 = n4 - c4, E4 = i4 + s4, R2 = i4 - s4, D2 = a5 + o4, T3 = a5 - o4, z3 = O3 + D2, U3 = O3 - D2, H4 = q3 + E4, W2 = q3 - E4;
            t4[f4] = z3 + H4, t4[f4 + 32] = z3 - H4;
            var V3 = 0.707106781 * (W2 + U3);
            t4[f4 + 16] = U3 + V3, t4[f4 + 48] = U3 - V3;
            var G2 = 0.382683433 * ((z3 = T3 + R2) - (W2 = M3 + B4)), Y2 = 0.5411961 * z3 + G2, J2 = 1.306562965 * W2 + G2, X2 = 0.707106781 * (H4 = R2 + M3), K2 = B4 + X2, $2 = B4 - X2;
            t4[f4 + 40] = $2 + Y2, t4[f4 + 24] = $2 - Y2, t4[f4 + 8] = K2 + J2, t4[f4 + 56] = K2 - J2, f4++;
          }
          for (l4 = 0; l4 < 64; ++l4) h3 = t4[l4] * e5[l4], d2[l4] = h3 > 0 ? h3 + 0.5 | 0 : h3 - 0.5 | 0;
          return d2;
        })(t3, e4), u4 = 0; u4 < 64; ++u4) p2[x2[u4]] = c3[u4];
        var l3 = p2[0] - r3;
        r3 = p2[0], 0 == l3 ? O2(n3[0]) : (O2(n3[f3[a4 = 32767 + l3]]), O2(h2[a4]));
        for (var g3 = 63; g3 > 0 && 0 == p2[g3]; ) g3--;
        if (0 == g3) return O2(o3), r3;
        for (var m3, v3 = 1; v3 <= g3; ) {
          for (var b3 = v3; 0 == p2[v3] && v3 <= g3; ) ++v3;
          var y3 = v3 - b3;
          if (y3 >= 16) {
            m3 = y3 >> 4;
            for (var w3 = 1; w3 <= m3; ++w3) O2(s3);
            y3 &= 15;
          }
          a4 = 32767 + p2[v3], O2(i3[(y3 << 4) + f3[a4]]), O2(h2[a4]), v3++;
        }
        return 63 != g3 && O2(o3), r3;
      }
      function E3(t3) {
        t3 = Math.min(Math.max(t3, 1), 100), a3 != t3 && ((function(t4) {
          for (var e4 = [16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99], r3 = 0; r3 < 64; r3++) {
            var n3 = o2((e4[r3] * t4 + 50) / 100);
            n3 = Math.min(Math.max(n3, 1), 255), s2[x2[r3]] = n3;
          }
          for (var i3 = [17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99], a4 = 0; a4 < 64; a4++) {
            var h3 = o2((i3[a4] * t4 + 50) / 100);
            h3 = Math.min(Math.max(h3, 1), 255), c2[x2[a4]] = h3;
          }
          for (var f4 = [1, 1.387039845, 1.306562965, 1.175875602, 1, 0.785694958, 0.5411961, 0.275899379], d3 = 0, p3 = 0; p3 < 8; p3++) for (var g3 = 0; g3 < 8; g3++) u3[d3] = 1 / (s2[x2[d3]] * f4[p3] * f4[g3] * 8), l2[d3] = 1 / (c2[x2[d3]] * f4[p3] * f4[g3] * 8), d3++;
        })(t3 < 50 ? Math.floor(5e3 / t3) : Math.floor(200 - 2 * t3)), a3 = t3);
      }
      this.encode = function(t3, a4) {
        a4 && E3(a4), g2 = new Array(), m2 = 0, v2 = 7, q2(65496), q2(65504), q2(16), B3(74), B3(70), B3(73), B3(70), B3(0), B3(1), B3(1), B3(0), q2(1), q2(1), B3(0), B3(0), (function() {
          q2(65499), q2(132), B3(0);
          for (var t4 = 0; t4 < 64; t4++) B3(s2[t4]);
          B3(1);
          for (var e4 = 0; e4 < 64; e4++) B3(c2[e4]);
        })(), (function(t4, e4) {
          q2(65472), q2(17), B3(8), q2(e4), q2(t4), B3(3), B3(1), B3(17), B3(0), B3(2), B3(17), B3(1), B3(3), B3(17), B3(1);
        })(t3.width, t3.height), (function() {
          q2(65476), q2(418), B3(0);
          for (var t4 = 0; t4 < 16; t4++) B3(A3[t4 + 1]);
          for (var e4 = 0; e4 <= 11; e4++) B3(S2[e4]);
          B3(16);
          for (var r3 = 0; r3 < 16; r3++) B3(_2[r3 + 1]);
          for (var n3 = 0; n3 <= 161; n3++) B3(P2[n3]);
          B3(1);
          for (var i3 = 0; i3 < 16; i3++) B3(k2[i3 + 1]);
          for (var a5 = 0; a5 <= 11; a5++) B3(F3[a5]);
          B3(17);
          for (var o4 = 0; o4 < 16; o4++) B3(I2[o4 + 1]);
          for (var s3 = 0; s3 <= 161; s3++) B3(j2[s3]);
        })(), q2(65498), q2(12), B3(3), B3(1), B3(0), B3(2), B3(17), B3(3), B3(17), B3(0), B3(63), B3(0);
        var o3 = 0, h3 = 0, f4 = 0;
        m2 = 0, v2 = 7, this.encode.displayName = "_encode_";
        for (var d3, p3, N3, x3, C3, R2, D2, T3, z3, U3 = t3.data, H4 = t3.width, W2 = t3.height, V3 = 4 * H4, G2 = 0; G2 < W2; ) {
          for (d3 = 0; d3 < V3; ) {
            for (C3 = V3 * G2 + d3, D2 = -1, T3 = 0, z3 = 0; z3 < 64; z3++) R2 = C3 + (T3 = z3 >> 3) * V3 + (D2 = 4 * (7 & z3)), G2 + T3 >= W2 && (R2 -= V3 * (G2 + 1 + T3 - W2)), d3 + D2 >= V3 && (R2 -= d3 + D2 - V3 + 4), p3 = U3[R2++], N3 = U3[R2++], x3 = U3[R2++], b2[z3] = (L3[p3] + L3[N3 + 256 | 0] + L3[x3 + 512 | 0] >> 16) - 128, y2[z3] = (L3[p3 + 768 | 0] + L3[N3 + 1024 | 0] + L3[x3 + 1280 | 0] >> 16) - 128, w2[z3] = (L3[p3 + 1280 | 0] + L3[N3 + 1536 | 0] + L3[x3 + 1792 | 0] >> 16) - 128;
            o3 = M2(b2, u3, o3, e3, n2), h3 = M2(y2, l2, h3, r2, i2), f4 = M2(w2, l2, f4, r2, i2), d3 += 32;
          }
          G2 += 8;
        }
        if (v2 >= 0) {
          var Y2 = [];
          Y2[1] = v2 + 1, Y2[0] = (1 << v2 + 1) - 1, O2(Y2);
        }
        return q2(65497), new Uint8Array(g2);
      }, t2 = t2 || 50, (function() {
        for (var t3 = String.fromCharCode, e4 = 0; e4 < 256; e4++) N2[e4] = t3(e4);
      })(), e3 = C2(A3, S2), r2 = C2(k2, F3), n2 = C2(_2, P2), i2 = C2(I2, j2), (function() {
        for (var t3 = 1, e4 = 2, r3 = 1; r3 <= 15; r3++) {
          for (var n3 = t3; n3 < e4; n3++) f3[32767 + n3] = r3, h2[32767 + n3] = [], h2[32767 + n3][1] = r3, h2[32767 + n3][0] = n3;
          for (var i3 = -(e4 - 1); i3 <= -t3; i3++) f3[32767 + i3] = r3, h2[32767 + i3] = [], h2[32767 + i3][1] = r3, h2[32767 + i3][0] = e4 - 1 + i3;
          t3 <<= 1, e4 <<= 1;
        }
      })(), (function() {
        for (var t3 = 0; t3 < 256; t3++) L3[t3] = 19595 * t3, L3[t3 + 256 | 0] = 38470 * t3, L3[t3 + 512 | 0] = 7471 * t3 + 32768, L3[t3 + 768 | 0] = -11059 * t3, L3[t3 + 1024 | 0] = -21709 * t3, L3[t3 + 1280 | 0] = 32768 * t3 + 8421375, L3[t3 + 1536 | 0] = -27439 * t3, L3[t3 + 1792 | 0] = -5329 * t3;
      })(), E3(t2);
    }
    function te(t2, e3) {
      if (this.pos = 0, this.buffer = t2, this.datav = new DataView(t2.buffer), this.is_with_alpha = !!e3, this.bottom_up = true, this.flag = String.fromCharCode(this.buffer[0]) + String.fromCharCode(this.buffer[1]), this.pos += 2, -1 === ["BM", "BA", "CI", "CP", "IC", "PT"].indexOf(this.flag)) throw new Error("Invalid BMP File");
      this.parseHeader(), this.parseBGR();
    }
    function ee(t2) {
      function e3(t3) {
        if (!t3) throw Error("assert :P");
      }
      function r2(t3, e4, r3) {
        for (var n3 = 0; 4 > n3; n3++) if (t3[e4 + n3] != r3.charCodeAt(n3)) return true;
        return false;
      }
      function n2(t3, e4, r3, n3, i3) {
        for (var a4 = 0; a4 < i3; a4++) t3[e4 + a4] = r3[n3 + a4];
      }
      function i2(t3, e4, r3, n3) {
        for (var i3 = 0; i3 < n3; i3++) t3[e4 + i3] = r3;
      }
      function a3(t3) {
        return new Int32Array(t3);
      }
      function o2(t3, e4) {
        for (var r3 = [], n3 = 0; n3 < t3; n3++) r3.push(new e4());
        return r3;
      }
      function s2(t3, e4) {
        var r3 = [];
        return (function t4(r4, n3, i3) {
          for (var a4 = i3[n3], o3 = 0; o3 < a4 && (r4.push(i3.length > n3 + 1 ? [] : new e4()), !(i3.length < n3 + 1)); o3++) t4(r4[o3], n3 + 1, i3);
        })(r3, 0, t3), r3;
      }
      var c2 = function() {
        var t3 = this;
        function c3(t4, e4) {
          for (var r3 = 1 << e4 - 1 >>> 0; t4 & r3; ) r3 >>>= 1;
          return r3 ? (t4 & r3 - 1) + r3 : t4;
        }
        function u4(t4, r3, n3, i3, a4) {
          e3(!(i3 % n3));
          do {
            t4[r3 + (i3 -= n3)] = a4;
          } while (0 < i3);
        }
        function l3(t4, r3, n3, i3, o3) {
          if (e3(2328 >= o3), 512 >= o3) var s3 = a3(512);
          else if (null == (s3 = a3(o3))) return 0;
          return (function(t5, r4, n4, i4, o4, s4) {
            var l4, f5, d4 = r4, p4 = 1 << n4, g4 = a3(16), m4 = a3(16);
            for (e3(0 != o4), e3(null != i4), e3(null != t5), e3(0 < n4), f5 = 0; f5 < o4; ++f5) {
              if (15 < i4[f5]) return 0;
              ++g4[i4[f5]];
            }
            if (g4[0] == o4) return 0;
            for (m4[1] = 0, l4 = 1; 15 > l4; ++l4) {
              if (g4[l4] > 1 << l4) return 0;
              m4[l4 + 1] = m4[l4] + g4[l4];
            }
            for (f5 = 0; f5 < o4; ++f5) l4 = i4[f5], 0 < i4[f5] && (s4[m4[l4]++] = f5);
            if (1 == m4[15]) return (i4 = new h3()).g = 0, i4.value = s4[0], u4(t5, d4, 1, p4, i4), p4;
            var v4, b4 = -1, y4 = p4 - 1, w4 = 0, N4 = 1, L5 = 1, x4 = 1 << n4;
            for (f5 = 0, l4 = 1, o4 = 2; l4 <= n4; ++l4, o4 <<= 1) {
              if (N4 += L5 <<= 1, 0 > (L5 -= g4[l4])) return 0;
              for (; 0 < g4[l4]; --g4[l4]) (i4 = new h3()).g = l4, i4.value = s4[f5++], u4(t5, d4 + w4, o4, x4, i4), w4 = c3(w4, l4);
            }
            for (l4 = n4 + 1, o4 = 2; 15 >= l4; ++l4, o4 <<= 1) {
              if (N4 += L5 <<= 1, 0 > (L5 -= g4[l4])) return 0;
              for (; 0 < g4[l4]; --g4[l4]) {
                if (i4 = new h3(), (w4 & y4) != b4) {
                  for (d4 += x4, v4 = 1 << (b4 = l4) - n4; 15 > b4 && !(0 >= (v4 -= g4[b4])); ) ++b4, v4 <<= 1;
                  p4 += x4 = 1 << (v4 = b4 - n4), t5[r4 + (b4 = w4 & y4)].g = v4 + n4, t5[r4 + b4].value = d4 - r4 - b4;
                }
                i4.g = l4 - n4, i4.value = s4[f5++], u4(t5, d4 + (w4 >> n4), o4, x4, i4), w4 = c3(w4, l4);
              }
            }
            return N4 != 2 * m4[15] - 1 ? 0 : p4;
          })(t4, r3, n3, i3, o3, s3);
        }
        function h3() {
          this.value = this.g = 0;
        }
        function f4() {
          this.value = this.g = 0;
        }
        function d3() {
          this.G = o2(5, h3), this.H = a3(5), this.jc = this.Qb = this.qb = this.nd = 0, this.pd = o2(Er, f4);
        }
        function p3(t4, r3, n3, i3) {
          e3(null != t4), e3(null != r3), e3(2147483648 > i3), t4.Ca = 254, t4.I = 0, t4.b = -8, t4.Ka = 0, t4.oa = r3, t4.pa = n3, t4.Jd = r3, t4.Yc = n3 + i3, t4.Zc = 4 <= i3 ? n3 + i3 - 4 + 1 : n3, _2(t4);
        }
        function g3(t4, e4) {
          for (var r3 = 0; 0 < e4--; ) r3 |= k2(t4, 128) << e4;
          return r3;
        }
        function m3(t4, e4) {
          var r3 = g3(t4, e4);
          return P2(t4) ? -r3 : r3;
        }
        function v3(t4, r3, n3, i3) {
          var a4, o3 = 0;
          for (e3(null != t4), e3(null != r3), e3(4294967288 > i3), t4.Sb = i3, t4.Ra = 0, t4.u = 0, t4.h = 0, 4 < i3 && (i3 = 4), a4 = 0; a4 < i3; ++a4) o3 += r3[n3 + a4] << 8 * a4;
          t4.Ra = o3, t4.bb = i3, t4.oa = r3, t4.pa = n3;
        }
        function b3(t4) {
          for (; 8 <= t4.u && t4.bb < t4.Sb; ) t4.Ra >>>= 8, t4.Ra += t4.oa[t4.pa + t4.bb] << Tr - 8 >>> 0, ++t4.bb, t4.u -= 8;
          x3(t4) && (t4.h = 1, t4.u = 0);
        }
        function y3(t4, r3) {
          if (e3(0 <= r3), !t4.h && r3 <= Dr) {
            var n3 = L4(t4) & Rr[r3];
            return t4.u += r3, b3(t4), n3;
          }
          return t4.h = 1, t4.u = 0;
        }
        function w3() {
          this.b = this.Ca = this.I = 0, this.oa = [], this.pa = 0, this.Jd = [], this.Yc = 0, this.Zc = [], this.Ka = 0;
        }
        function N3() {
          this.Ra = 0, this.oa = [], this.h = this.u = this.bb = this.Sb = this.pa = 0;
        }
        function L4(t4) {
          return t4.Ra >>> (t4.u & Tr - 1) >>> 0;
        }
        function x3(t4) {
          return e3(t4.bb <= t4.Sb), t4.h || t4.bb == t4.Sb && t4.u > Tr;
        }
        function A4(t4, e4) {
          t4.u = e4, t4.h = x3(t4);
        }
        function S2(t4) {
          t4.u >= zr && (e3(t4.u >= zr), b3(t4));
        }
        function _2(t4) {
          e3(null != t4 && null != t4.oa), t4.pa < t4.Zc ? (t4.I = (t4.oa[t4.pa++] | t4.I << 8) >>> 0, t4.b += 8) : (e3(null != t4 && null != t4.oa), t4.pa < t4.Yc ? (t4.b += 8, t4.I = t4.oa[t4.pa++] | t4.I << 8) : t4.Ka ? t4.b = 0 : (t4.I <<= 8, t4.b += 8, t4.Ka = 1));
        }
        function P2(t4) {
          return g3(t4, 1);
        }
        function k2(t4, e4) {
          var r3 = t4.Ca;
          0 > t4.b && _2(t4);
          var n3 = t4.b, i3 = r3 * e4 >>> 8, a4 = (t4.I >>> n3 > i3) + 0;
          for (a4 ? (r3 -= i3, t4.I -= i3 + 1 << n3 >>> 0) : r3 = i3 + 1, n3 = r3, i3 = 0; 256 <= n3; ) i3 += 8, n3 >>= 8;
          return n3 = 7 ^ i3 + Ur[n3], t4.b -= n3, t4.Ca = (r3 << n3) - 1, a4;
        }
        function F3(t4, e4, r3) {
          t4[e4 + 0] = r3 >> 24 & 255, t4[e4 + 1] = r3 >> 16 & 255, t4[e4 + 2] = r3 >> 8 & 255, t4[e4 + 3] = 255 & r3;
        }
        function I2(t4, e4) {
          return t4[e4 + 0] | t4[e4 + 1] << 8;
        }
        function j2(t4, e4) {
          return I2(t4, e4) | t4[e4 + 2] << 16;
        }
        function C2(t4, e4) {
          return I2(t4, e4) | I2(t4, e4 + 2) << 16;
        }
        function O2(t4, r3) {
          var n3 = 1 << r3;
          return e3(null != t4), e3(0 < r3), t4.X = a3(n3), null == t4.X ? 0 : (t4.Mb = 32 - r3, t4.Xa = r3, 1);
        }
        function B3(t4, r3) {
          e3(null != t4), e3(null != r3), e3(t4.Xa == r3.Xa), n2(r3.X, 0, t4.X, 0, 1 << r3.Xa);
        }
        function q2() {
          this.X = [], this.Xa = this.Mb = 0;
        }
        function M2(t4, r3, n3, i3) {
          e3(null != n3), e3(null != i3);
          var a4 = n3[0], o3 = i3[0];
          return 0 == a4 && (a4 = (t4 * o3 + r3 / 2) / r3), 0 == o3 && (o3 = (r3 * a4 + t4 / 2) / t4), 0 >= a4 || 0 >= o3 ? 0 : (n3[0] = a4, i3[0] = o3, 1);
        }
        function E3(t4, e4) {
          return t4 + (1 << e4) - 1 >>> e4;
        }
        function R2(t4, e4) {
          return ((4278255360 & t4) + (4278255360 & e4) >>> 0 & 4278255360) + ((16711935 & t4) + (16711935 & e4) >>> 0 & 16711935) >>> 0;
        }
        function D2(e4, r3) {
          t3[r3] = function(r4, n3, i3, a4, o3, s3, c4) {
            var u5;
            for (u5 = 0; u5 < o3; ++u5) {
              var l4 = t3[e4](s3[c4 + u5 - 1], i3, a4 + u5);
              s3[c4 + u5] = R2(r4[n3 + u5], l4);
            }
          };
        }
        function T3() {
          this.ud = this.hd = this.jd = 0;
        }
        function z3(t4, e4) {
          return ((4278124286 & (t4 ^ e4)) >>> 1) + (t4 & e4) >>> 0;
        }
        function U3(t4) {
          return 0 <= t4 && 256 > t4 ? t4 : 0 > t4 ? 0 : 255 < t4 ? 255 : void 0;
        }
        function H4(t4, e4) {
          return U3(t4 + (t4 - e4 + 0.5 >> 1));
        }
        function W2(t4, e4, r3) {
          return Math.abs(e4 - r3) - Math.abs(t4 - r3);
        }
        function V3(t4, e4, r3, n3, i3, a4, o3) {
          for (n3 = a4[o3 - 1], r3 = 0; r3 < i3; ++r3) a4[o3 + r3] = n3 = R2(t4[e4 + r3], n3);
        }
        function G2(t4, e4, r3, n3, i3) {
          var a4;
          for (a4 = 0; a4 < r3; ++a4) {
            var o3 = t4[e4 + a4], s3 = o3 >> 8 & 255, c4 = 16711935 & (c4 = (c4 = 16711935 & o3) + ((s3 << 16) + s3));
            n3[i3 + a4] = (4278255360 & o3) + c4 >>> 0;
          }
        }
        function Y2(t4, e4) {
          e4.jd = 255 & t4, e4.hd = t4 >> 8 & 255, e4.ud = t4 >> 16 & 255;
        }
        function J2(t4, e4, r3, n3, i3, a4) {
          var o3;
          for (o3 = 0; o3 < n3; ++o3) {
            var s3 = e4[r3 + o3], c4 = s3 >>> 8, u5 = s3, l4 = 255 & (l4 = (l4 = s3 >>> 16) + ((t4.jd << 24 >> 24) * (c4 << 24 >> 24) >>> 5));
            u5 = 255 & (u5 = (u5 += (t4.hd << 24 >> 24) * (c4 << 24 >> 24) >>> 5) + ((t4.ud << 24 >> 24) * (l4 << 24 >> 24) >>> 5)), i3[a4 + o3] = (4278255360 & s3) + (l4 << 16) + u5;
          }
        }
        function X2(e4, r3, n3, i3, a4) {
          t3[r3] = function(t4, e5, r4, n4, o3, s3, c4, u5, l4) {
            for (n4 = c4; n4 < u5; ++n4) for (c4 = 0; c4 < l4; ++c4) o3[s3++] = a4(r4[i3(t4[e5++])]);
          }, t3[e4] = function(e5, r4, o3, s3, c4, u5, l4) {
            var h4 = 8 >> e5.b, f5 = e5.Ea, d4 = e5.K[0], p4 = e5.w;
            if (8 > h4) for (e5 = (1 << e5.b) - 1, p4 = (1 << h4) - 1; r4 < o3; ++r4) {
              var g4, m4 = 0;
              for (g4 = 0; g4 < f5; ++g4) g4 & e5 || (m4 = i3(s3[c4++])), u5[l4++] = a4(d4[m4 & p4]), m4 >>= h4;
            }
            else t3["VP8LMapColor" + n3](s3, c4, d4, p4, u5, l4, r4, o3, f5);
          };
        }
        function K2(t4, e4, r3, n3, i3) {
          for (r3 = e4 + r3; e4 < r3; ) {
            var a4 = t4[e4++];
            n3[i3++] = a4 >> 16 & 255, n3[i3++] = a4 >> 8 & 255, n3[i3++] = 255 & a4;
          }
        }
        function $2(t4, e4, r3, n3, i3) {
          for (r3 = e4 + r3; e4 < r3; ) {
            var a4 = t4[e4++];
            n3[i3++] = a4 >> 16 & 255, n3[i3++] = a4 >> 8 & 255, n3[i3++] = 255 & a4, n3[i3++] = a4 >> 24 & 255;
          }
        }
        function Z3(t4, e4, r3, n3, i3) {
          for (r3 = e4 + r3; e4 < r3; ) {
            var a4 = (o3 = t4[e4++]) >> 16 & 240 | o3 >> 12 & 15, o3 = 240 & o3 | o3 >> 28 & 15;
            n3[i3++] = a4, n3[i3++] = o3;
          }
        }
        function Q2(t4, e4, r3, n3, i3) {
          for (r3 = e4 + r3; e4 < r3; ) {
            var a4 = (o3 = t4[e4++]) >> 16 & 248 | o3 >> 13 & 7, o3 = o3 >> 5 & 224 | o3 >> 3 & 31;
            n3[i3++] = a4, n3[i3++] = o3;
          }
        }
        function tt2(t4, e4, r3, n3, i3) {
          for (r3 = e4 + r3; e4 < r3; ) {
            var a4 = t4[e4++];
            n3[i3++] = 255 & a4, n3[i3++] = a4 >> 8 & 255, n3[i3++] = a4 >> 16 & 255;
          }
        }
        function et2(t4, e4, r3, i3, a4, o3) {
          if (0 == o3) for (r3 = e4 + r3; e4 < r3; ) F3(i3, ((o3 = t4[e4++])[0] >> 24 | o3[1] >> 8 & 65280 | o3[2] << 8 & 16711680 | o3[3] << 24) >>> 0), a4 += 32;
          else n2(i3, a4, t4, e4, r3);
        }
        function rt2(e4, r3) {
          t3[r3][0] = t3[e4 + "0"], t3[r3][1] = t3[e4 + "1"], t3[r3][2] = t3[e4 + "2"], t3[r3][3] = t3[e4 + "3"], t3[r3][4] = t3[e4 + "4"], t3[r3][5] = t3[e4 + "5"], t3[r3][6] = t3[e4 + "6"], t3[r3][7] = t3[e4 + "7"], t3[r3][8] = t3[e4 + "8"], t3[r3][9] = t3[e4 + "9"], t3[r3][10] = t3[e4 + "10"], t3[r3][11] = t3[e4 + "11"], t3[r3][12] = t3[e4 + "12"], t3[r3][13] = t3[e4 + "13"], t3[r3][14] = t3[e4 + "0"], t3[r3][15] = t3[e4 + "0"];
        }
        function nt2(t4) {
          return t4 == Un || t4 == Hn || t4 == Wn || t4 == Vn;
        }
        function it2() {
          this.eb = [], this.size = this.A = this.fb = 0;
        }
        function at2() {
          this.y = [], this.f = [], this.ea = [], this.F = [], this.Tc = this.Ed = this.Cd = this.Fd = this.lb = this.Db = this.Ab = this.fa = this.J = this.W = this.N = this.O = 0;
        }
        function ot2() {
          this.Rd = this.height = this.width = this.S = 0, this.f = {}, this.f.RGBA = new it2(), this.f.kb = new at2(), this.sd = null;
        }
        function st2() {
          this.width = [0], this.height = [0], this.Pd = [0], this.Qd = [0], this.format = [0];
        }
        function ct2() {
          this.Id = this.fd = this.Md = this.hb = this.ib = this.da = this.bd = this.cd = this.j = this.v = this.Da = this.Sd = this.ob = 0;
        }
        function ut2(t4) {
          return alert("todo:WebPSamplerProcessPlane"), t4.T;
        }
        function lt2(t4, e4) {
          var r3 = t4.T, i3 = e4.ba.f.RGBA, a4 = i3.eb, o3 = i3.fb + t4.ka * i3.A, s3 = mi[e4.ba.S], c4 = t4.y, u5 = t4.O, l4 = t4.f, h4 = t4.N, f5 = t4.ea, d4 = t4.W, p4 = e4.cc, g4 = e4.dc, m4 = e4.Mc, v4 = e4.Nc, b4 = t4.ka, y4 = t4.ka + t4.T, w4 = t4.U, N4 = w4 + 1 >> 1;
          for (0 == b4 ? s3(c4, u5, null, null, l4, h4, f5, d4, l4, h4, f5, d4, a4, o3, null, null, w4) : (s3(e4.ec, e4.fc, c4, u5, p4, g4, m4, v4, l4, h4, f5, d4, a4, o3 - i3.A, a4, o3, w4), ++r3); b4 + 2 < y4; b4 += 2) p4 = l4, g4 = h4, m4 = f5, v4 = d4, h4 += t4.Rc, d4 += t4.Rc, o3 += 2 * i3.A, s3(c4, (u5 += 2 * t4.fa) - t4.fa, c4, u5, p4, g4, m4, v4, l4, h4, f5, d4, a4, o3 - i3.A, a4, o3, w4);
          return u5 += t4.fa, t4.j + y4 < t4.o ? (n2(e4.ec, e4.fc, c4, u5, w4), n2(e4.cc, e4.dc, l4, h4, N4), n2(e4.Mc, e4.Nc, f5, d4, N4), r3--) : 1 & y4 || s3(c4, u5, null, null, l4, h4, f5, d4, l4, h4, f5, d4, a4, o3 + i3.A, null, null, w4), r3;
        }
        function ht2(t4, r3, n3) {
          var i3 = t4.F, a4 = [t4.J];
          if (null != i3) {
            var o3 = t4.U, s3 = r3.ba.S, c4 = s3 == Dn || s3 == Wn;
            r3 = r3.ba.f.RGBA;
            var u5 = [0], l4 = t4.ka;
            u5[0] = t4.T, t4.Kb && (0 == l4 ? --u5[0] : (--l4, a4[0] -= t4.width), t4.j + t4.ka + t4.T == t4.o && (u5[0] = t4.o - t4.j - l4));
            var h4 = r3.eb;
            l4 = r3.fb + l4 * r3.A, t4 = An(i3, a4[0], t4.width, o3, u5, h4, l4 + (c4 ? 0 : 3), r3.A), e3(n3 == u5), t4 && nt2(s3) && Ln(h4, l4, c4, o3, u5, r3.A);
          }
          return 0;
        }
        function ft2(t4) {
          var e4 = t4.ma, r3 = e4.ba.S, n3 = 11 > r3, i3 = r3 == Mn || r3 == Rn || r3 == Dn || r3 == Tn || 12 == r3 || nt2(r3);
          if (e4.memory = null, e4.Ib = null, e4.Jb = null, e4.Nd = null, !Br(e4.Oa, t4, i3 ? 11 : 12)) return 0;
          if (i3 && nt2(r3) && vr(), t4.da) alert("todo:use_scaling");
          else {
            if (n3) {
              if (e4.Ib = ut2, t4.Kb) {
                if (r3 = t4.U + 1 >> 1, e4.memory = a3(t4.U + 2 * r3), null == e4.memory) return 0;
                e4.ec = e4.memory, e4.fc = 0, e4.cc = e4.ec, e4.dc = e4.fc + t4.U, e4.Mc = e4.cc, e4.Nc = e4.dc + r3, e4.Ib = lt2, vr();
              }
            } else alert("todo:EmitYUV");
            i3 && (e4.Jb = ht2, n3 && gr());
          }
          if (n3 && !Ii) {
            for (t4 = 0; 256 > t4; ++t4) ji[t4] = 89858 * (t4 - 128) + Si >> Ai, Bi[t4] = -22014 * (t4 - 128) + Si, Oi[t4] = -45773 * (t4 - 128), Ci[t4] = 113618 * (t4 - 128) + Si >> Ai;
            for (t4 = _i; t4 < Pi; ++t4) e4 = 76283 * (t4 - 16) + Si >> Ai, qi[t4 - _i] = Vt2(e4, 255), Mi[t4 - _i] = Vt2(e4 + 8 >> 4, 15);
            Ii = 1;
          }
          return 1;
        }
        function dt2(t4) {
          var r3 = t4.ma, n3 = t4.U, i3 = t4.T;
          return e3(!(1 & t4.ka)), 0 >= n3 || 0 >= i3 ? 0 : (n3 = r3.Ib(t4, r3), null != r3.Jb && r3.Jb(t4, r3, n3), r3.Dc += n3, 1);
        }
        function pt2(t4) {
          t4.ma.memory = null;
        }
        function gt2(t4, e4, r3, n3) {
          return 47 != y3(t4, 8) ? 0 : (e4[0] = y3(t4, 14) + 1, r3[0] = y3(t4, 14) + 1, n3[0] = y3(t4, 1), 0 != y3(t4, 3) ? 0 : !t4.h);
        }
        function mt2(t4, e4) {
          if (4 > t4) return t4 + 1;
          var r3 = t4 - 2 >> 1;
          return (2 + (1 & t4) << r3) + y3(e4, r3) + 1;
        }
        function vt2(t4, e4) {
          return 120 < e4 ? e4 - 120 : 1 <= (r3 = ((r3 = $n[e4 - 1]) >> 4) * t4 + (8 - (15 & r3))) ? r3 : 1;
          var r3;
        }
        function bt2(t4, e4, r3) {
          var n3 = L4(r3), i3 = t4[e4 += 255 & n3].g - 8;
          return 0 < i3 && (A4(r3, r3.u + 8), n3 = L4(r3), e4 += t4[e4].value, e4 += n3 & (1 << i3) - 1), A4(r3, r3.u + t4[e4].g), t4[e4].value;
        }
        function yt2(t4, r3, n3) {
          return n3.g += t4.g, n3.value += t4.value << r3 >>> 0, e3(8 >= n3.g), t4.g;
        }
        function wt2(t4, r3, n3) {
          var i3 = t4.xc;
          return e3((r3 = 0 == i3 ? 0 : t4.vc[t4.md * (n3 >> i3) + (r3 >> i3)]) < t4.Wb), t4.Ya[r3];
        }
        function Nt2(t4, r3, i3, a4) {
          var o3 = t4.ab, s3 = t4.c * r3, c4 = t4.C;
          r3 = c4 + r3;
          var u5 = i3, l4 = a4;
          for (a4 = t4.Ta, i3 = t4.Ua; 0 < o3--; ) {
            var h4 = t4.gc[o3], f5 = c4, d4 = r3, p4 = u5, g4 = l4, m4 = (l4 = a4, u5 = i3, h4.Ea);
            switch (e3(f5 < d4), e3(d4 <= h4.nc), h4.hc) {
              case 2:
                Vr(p4, g4, (d4 - f5) * m4, l4, u5);
                break;
              case 0:
                var v4 = f5, b4 = d4, y4 = l4, w4 = u5, N4 = (_3 = h4).Ea;
                0 == v4 && (Hr(p4, g4, null, null, 1, y4, w4), V3(p4, g4 + 1, 0, 0, N4 - 1, y4, w4 + 1), g4 += N4, w4 += N4, ++v4);
                for (var L5 = 1 << _3.b, x4 = L5 - 1, A5 = E3(N4, _3.b), S3 = _3.K, _3 = _3.w + (v4 >> _3.b) * A5; v4 < b4; ) {
                  var P3 = S3, k3 = _3, F4 = 1;
                  for (Wr(p4, g4, y4, w4 - N4, 1, y4, w4); F4 < N4; ) {
                    var I3 = (F4 & ~x4) + L5;
                    I3 > N4 && (I3 = N4), (0, Kr[P3[k3++] >> 8 & 15])(p4, g4 + +F4, y4, w4 + F4 - N4, I3 - F4, y4, w4 + F4), F4 = I3;
                  }
                  g4 += N4, w4 += N4, ++v4 & x4 || (_3 += A5);
                }
                d4 != h4.nc && n2(l4, u5 - m4, l4, u5 + (d4 - f5 - 1) * m4, m4);
                break;
              case 1:
                for (m4 = p4, b4 = g4, N4 = (p4 = h4.Ea) - (w4 = p4 & ~(y4 = (g4 = 1 << h4.b) - 1)), v4 = E3(p4, h4.b), L5 = h4.K, h4 = h4.w + (f5 >> h4.b) * v4; f5 < d4; ) {
                  for (x4 = L5, A5 = h4, S3 = new T3(), _3 = b4 + w4, P3 = b4 + p4; b4 < _3; ) Y2(x4[A5++], S3), $r(S3, m4, b4, g4, l4, u5), b4 += g4, u5 += g4;
                  b4 < P3 && (Y2(x4[A5++], S3), $r(S3, m4, b4, N4, l4, u5), b4 += N4, u5 += N4), ++f5 & y4 || (h4 += v4);
                }
                break;
              case 3:
                if (p4 == l4 && g4 == u5 && 0 < h4.b) {
                  for (b4 = l4, p4 = m4 = u5 + (d4 - f5) * m4 - (w4 = (d4 - f5) * E3(h4.Ea, h4.b)), g4 = l4, y4 = u5, v4 = [], w4 = (N4 = w4) - 1; 0 <= w4; --w4) v4[w4] = g4[y4 + w4];
                  for (w4 = N4 - 1; 0 <= w4; --w4) b4[p4 + w4] = v4[w4];
                  Gr(h4, f5, d4, l4, m4, l4, u5);
                } else Gr(h4, f5, d4, p4, g4, l4, u5);
            }
            u5 = a4, l4 = i3;
          }
          l4 != i3 && n2(a4, i3, u5, l4, s3);
        }
        function Lt2(t4, r3) {
          var n3 = t4.V, i3 = t4.Ba + t4.c * t4.C, a4 = r3 - t4.C;
          if (e3(r3 <= t4.l.o), e3(16 >= a4), 0 < a4) {
            var o3 = t4.l, s3 = t4.Ta, c4 = t4.Ua, u5 = o3.width;
            if (Nt2(t4, a4, n3, i3), a4 = c4 = [c4], e3((n3 = t4.C) < (i3 = r3)), e3(o3.v < o3.va), i3 > o3.o && (i3 = o3.o), n3 < o3.j) {
              var l4 = o3.j - n3;
              n3 = o3.j, a4[0] += l4 * u5;
            }
            if (n3 >= i3 ? n3 = 0 : (a4[0] += 4 * o3.v, o3.ka = n3 - o3.j, o3.U = o3.va - o3.v, o3.T = i3 - n3, n3 = 1), n3) {
              if (c4 = c4[0], 11 > (n3 = t4.ca).S) {
                var h4 = n3.f.RGBA, f5 = (i3 = n3.S, a4 = o3.U, o3 = o3.T, l4 = h4.eb, h4.A), d4 = o3;
                for (h4 = h4.fb + t4.Ma * h4.A; 0 < d4--; ) {
                  var p4 = s3, g4 = c4, m4 = a4, v4 = l4, b4 = h4;
                  switch (i3) {
                    case qn:
                      Zr(p4, g4, m4, v4, b4);
                      break;
                    case Mn:
                      Qr(p4, g4, m4, v4, b4);
                      break;
                    case Un:
                      Qr(p4, g4, m4, v4, b4), Ln(v4, b4, 0, m4, 1, 0);
                      break;
                    case En:
                      rn(p4, g4, m4, v4, b4);
                      break;
                    case Rn:
                      et2(p4, g4, m4, v4, b4, 1);
                      break;
                    case Hn:
                      et2(p4, g4, m4, v4, b4, 1), Ln(v4, b4, 0, m4, 1, 0);
                      break;
                    case Dn:
                      et2(p4, g4, m4, v4, b4, 0);
                      break;
                    case Wn:
                      et2(p4, g4, m4, v4, b4, 0), Ln(v4, b4, 1, m4, 1, 0);
                      break;
                    case Tn:
                      tn(p4, g4, m4, v4, b4);
                      break;
                    case Vn:
                      tn(p4, g4, m4, v4, b4), xn(v4, b4, m4, 1, 0);
                      break;
                    case zn:
                      en(p4, g4, m4, v4, b4);
                      break;
                    default:
                      e3(0);
                  }
                  c4 += u5, h4 += f5;
                }
                t4.Ma += o3;
              } else alert("todo:EmitRescaledRowsYUVA");
              e3(t4.Ma <= n3.height);
            }
          }
          t4.C = r3, e3(t4.C <= t4.i);
        }
        function xt2(t4) {
          var e4;
          if (0 < t4.ua) return 0;
          for (e4 = 0; e4 < t4.Wb; ++e4) {
            var r3 = t4.Ya[e4].G, n3 = t4.Ya[e4].H;
            if (0 < r3[1][n3[1] + 0].g || 0 < r3[2][n3[2] + 0].g || 0 < r3[3][n3[3] + 0].g) return 0;
          }
          return 1;
        }
        function At2(t4, r3, n3, i3, a4, o3) {
          if (0 != t4.Z) {
            var s3 = t4.qd, c4 = t4.rd;
            for (e3(null != gi[t4.Z]); r3 < n3; ++r3) gi[t4.Z](s3, c4, i3, a4, i3, a4, o3), s3 = i3, c4 = a4, a4 += o3;
            t4.qd = s3, t4.rd = c4;
          }
        }
        function St2(t4, r3) {
          var n3 = t4.l.ma, i3 = 0 == n3.Z || 1 == n3.Z ? t4.l.j : t4.C;
          if (i3 = t4.C < i3 ? i3 : t4.C, e3(r3 <= t4.l.o), r3 > i3) {
            var a4 = t4.l.width, o3 = n3.ca, s3 = n3.tb + a4 * i3, c4 = t4.V, u5 = t4.Ba + t4.c * i3, l4 = t4.gc;
            e3(1 == t4.ab), e3(3 == l4[0].hc), Jr(l4[0], i3, r3, c4, u5, o3, s3), At2(n3, i3, r3, o3, s3, a4);
          }
          t4.C = t4.Ma = r3;
        }
        function _t2(t4, r3, n3, i3, a4, o3, s3) {
          var c4 = t4.$ / i3, u5 = t4.$ % i3, l4 = t4.m, h4 = t4.s, f5 = n3 + t4.$, d4 = f5;
          a4 = n3 + i3 * a4;
          var p4 = n3 + i3 * o3, g4 = 280 + h4.ua, m4 = t4.Pb ? c4 : 16777216, v4 = 0 < h4.ua ? h4.Wa : null, b4 = h4.wc, y4 = f5 < p4 ? wt2(h4, u5, c4) : null;
          e3(t4.C < o3), e3(p4 <= a4);
          var w4 = false;
          t: for (; ; ) {
            for (; w4 || f5 < p4; ) {
              var N4 = 0;
              if (c4 >= m4) {
                var _3 = f5 - n3;
                e3((m4 = t4).Pb), m4.wd = m4.m, m4.xd = _3, 0 < m4.s.ua && B3(m4.s.Wa, m4.s.vb), m4 = c4 + Qn;
              }
              if (u5 & b4 || (y4 = wt2(h4, u5, c4)), e3(null != y4), y4.Qb && (r3[f5] = y4.qb, w4 = true), !w4) if (S2(l4), y4.jc) {
                N4 = l4, _3 = r3;
                var P3 = f5, k3 = y4.pd[L4(N4) & Er - 1];
                e3(y4.jc), 256 > k3.g ? (A4(N4, N4.u + k3.g), _3[P3] = k3.value, N4 = 0) : (A4(N4, N4.u + k3.g - 256), e3(256 <= k3.value), N4 = k3.value), 0 == N4 && (w4 = true);
              } else N4 = bt2(y4.G[0], y4.H[0], l4);
              if (l4.h) break;
              if (w4 || 256 > N4) {
                if (!w4) if (y4.nd) r3[f5] = (y4.qb | N4 << 8) >>> 0;
                else {
                  if (S2(l4), w4 = bt2(y4.G[1], y4.H[1], l4), S2(l4), _3 = bt2(y4.G[2], y4.H[2], l4), P3 = bt2(y4.G[3], y4.H[3], l4), l4.h) break;
                  r3[f5] = (P3 << 24 | w4 << 16 | N4 << 8 | _3) >>> 0;
                }
                if (w4 = false, ++f5, ++u5 >= i3 && (u5 = 0, ++c4, null != s3 && c4 <= o3 && !(c4 % 16) && s3(t4, c4), null != v4)) for (; d4 < f5; ) N4 = r3[d4++], v4.X[(506832829 * N4 & 4294967295) >>> v4.Mb] = N4;
              } else if (280 > N4) {
                if (N4 = mt2(N4 - 256, l4), _3 = bt2(y4.G[4], y4.H[4], l4), S2(l4), _3 = vt2(i3, _3 = mt2(_3, l4)), l4.h) break;
                if (f5 - n3 < _3 || a4 - f5 < N4) break t;
                for (P3 = 0; P3 < N4; ++P3) r3[f5 + P3] = r3[f5 + P3 - _3];
                for (f5 += N4, u5 += N4; u5 >= i3; ) u5 -= i3, ++c4, null != s3 && c4 <= o3 && !(c4 % 16) && s3(t4, c4);
                if (e3(f5 <= a4), u5 & b4 && (y4 = wt2(h4, u5, c4)), null != v4) for (; d4 < f5; ) N4 = r3[d4++], v4.X[(506832829 * N4 & 4294967295) >>> v4.Mb] = N4;
              } else {
                if (!(N4 < g4)) break t;
                for (w4 = N4 - 280, e3(null != v4); d4 < f5; ) N4 = r3[d4++], v4.X[(506832829 * N4 & 4294967295) >>> v4.Mb] = N4;
                N4 = f5, e3(!(w4 >>> (_3 = v4).Xa)), r3[N4] = _3.X[w4], w4 = true;
              }
              w4 || e3(l4.h == x3(l4));
            }
            if (t4.Pb && l4.h && f5 < a4) e3(t4.m.h), t4.a = 5, t4.m = t4.wd, t4.$ = t4.xd, 0 < t4.s.ua && B3(t4.s.vb, t4.s.Wa);
            else {
              if (l4.h) break t;
              null != s3 && s3(t4, c4 > o3 ? o3 : c4), t4.a = 0, t4.$ = f5 - n3;
            }
            return 1;
          }
          return t4.a = 3, 0;
        }
        function Pt2(t4) {
          e3(null != t4), t4.vc = null, t4.yc = null, t4.Ya = null;
          var r3 = t4.Wa;
          null != r3 && (r3.X = null), t4.vb = null, e3(null != t4);
        }
        function kt2() {
          var e4 = new ar();
          return null == e4 ? null : (e4.a = 0, e4.xb = pi, rt2("Predictor", "VP8LPredictors"), rt2("Predictor", "VP8LPredictors_C"), rt2("PredictorAdd", "VP8LPredictorsAdd"), rt2("PredictorAdd", "VP8LPredictorsAdd_C"), Vr = G2, $r = J2, Zr = K2, Qr = $2, tn = Z3, en = Q2, rn = tt2, t3.VP8LMapColor32b = Yr, t3.VP8LMapColor8b = Xr, e4);
        }
        function Ft2(t4, r3, n3, s3, c4) {
          var u5 = 1, f5 = [t4], p4 = [r3], g4 = s3.m, m4 = s3.s, v4 = null, b4 = 0;
          t: for (; ; ) {
            if (n3) for (; u5 && y3(g4, 1); ) {
              var w4 = f5, N4 = p4, x4 = s3, _3 = 1, P3 = x4.m, k3 = x4.gc[x4.ab], F4 = y3(P3, 2);
              if (x4.Oc & 1 << F4) u5 = 0;
              else {
                switch (x4.Oc |= 1 << F4, k3.hc = F4, k3.Ea = w4[0], k3.nc = N4[0], k3.K = [null], ++x4.ab, e3(4 >= x4.ab), F4) {
                  case 0:
                  case 1:
                    k3.b = y3(P3, 3) + 2, _3 = Ft2(E3(k3.Ea, k3.b), E3(k3.nc, k3.b), 0, x4, k3.K), k3.K = k3.K[0];
                    break;
                  case 3:
                    var I3, j3 = y3(P3, 8) + 1, C3 = 16 < j3 ? 0 : 4 < j3 ? 1 : 2 < j3 ? 2 : 3;
                    if (w4[0] = E3(k3.Ea, C3), k3.b = C3, I3 = _3 = Ft2(j3, 1, 0, x4, k3.K)) {
                      var B4, q3 = j3, M3 = k3, D3 = 1 << (8 >> M3.b), T4 = a3(D3);
                      if (null == T4) I3 = 0;
                      else {
                        var z4 = M3.K[0], U4 = M3.w;
                        for (T4[0] = M3.K[0][0], B4 = 1; B4 < 1 * q3; ++B4) T4[B4] = R2(z4[U4 + B4], T4[B4 - 1]);
                        for (; B4 < 4 * D3; ++B4) T4[B4] = 0;
                        M3.K[0] = null, M3.K[0] = T4, I3 = 1;
                      }
                    }
                    _3 = I3;
                    break;
                  case 2:
                    break;
                  default:
                    e3(0);
                }
                u5 = _3;
              }
            }
            if (f5 = f5[0], p4 = p4[0], u5 && y3(g4, 1) && !(u5 = 1 <= (b4 = y3(g4, 4)) && 11 >= b4)) {
              s3.a = 3;
              break t;
            }
            var H5;
            if (H5 = u5) e: {
              var W3, V4, G3, Y3 = s3, J3 = f5, X3 = p4, K3 = b4, $3 = n3, Z4 = Y3.m, Q3 = Y3.s, tt3 = [null], et3 = 1, rt3 = 0, nt3 = Zn[K3];
              r: for (; ; ) {
                if ($3 && y3(Z4, 1)) {
                  var it3 = y3(Z4, 3) + 2, at3 = E3(J3, it3), ot3 = E3(X3, it3), st3 = at3 * ot3;
                  if (!Ft2(at3, ot3, 0, Y3, tt3)) break r;
                  for (tt3 = tt3[0], Q3.xc = it3, W3 = 0; W3 < st3; ++W3) {
                    var ct3 = tt3[W3] >> 8 & 65535;
                    tt3[W3] = ct3, ct3 >= et3 && (et3 = ct3 + 1);
                  }
                }
                if (Z4.h) break r;
                for (V4 = 0; 5 > V4; ++V4) {
                  var ut3 = Jn[V4];
                  !V4 && 0 < K3 && (ut3 += 1 << K3), rt3 < ut3 && (rt3 = ut3);
                }
                var lt3 = o2(et3 * nt3, h3), ht3 = et3, ft3 = o2(ht3, d3);
                if (null == ft3) var dt3 = null;
                else e3(65536 >= ht3), dt3 = ft3;
                var pt3 = a3(rt3);
                if (null == dt3 || null == pt3 || null == lt3) {
                  Y3.a = 1;
                  break r;
                }
                var gt3 = lt3;
                for (W3 = G3 = 0; W3 < et3; ++W3) {
                  var mt3 = dt3[W3], vt3 = mt3.G, bt3 = mt3.H, wt3 = 0, Nt3 = 1, Lt3 = 0;
                  for (V4 = 0; 5 > V4; ++V4) {
                    ut3 = Jn[V4], vt3[V4] = gt3, bt3[V4] = G3, !V4 && 0 < K3 && (ut3 += 1 << K3);
                    n: {
                      var xt3, At3 = ut3, St3 = Y3, kt3 = pt3, It3 = gt3, jt3 = G3, Ct3 = 0, Ot3 = St3.m, Bt3 = y3(Ot3, 1);
                      if (i2(kt3, 0, 0, At3), Bt3) {
                        var qt3 = y3(Ot3, 1) + 1, Mt3 = y3(Ot3, 1), Et3 = y3(Ot3, 0 == Mt3 ? 1 : 8);
                        kt3[Et3] = 1, 2 == qt3 && (kt3[Et3 = y3(Ot3, 8)] = 1);
                        var Rt3 = 1;
                      } else {
                        var Dt3 = a3(19), Tt3 = y3(Ot3, 4) + 4;
                        if (19 < Tt3) {
                          St3.a = 3;
                          var zt3 = 0;
                          break n;
                        }
                        for (xt3 = 0; xt3 < Tt3; ++xt3) Dt3[Kn[xt3]] = y3(Ot3, 3);
                        var Ut3 = void 0, Ht3 = void 0, Wt3 = St3, Vt3 = Dt3, Gt3 = At3, Yt3 = kt3, Jt3 = 0, Xt3 = Wt3.m, Kt3 = 8, $t3 = o2(128, h3);
                        i: for (; l3($t3, 0, 7, Vt3, 19); ) {
                          if (y3(Xt3, 1)) {
                            var Zt3 = 2 + 2 * y3(Xt3, 3);
                            if ((Ut3 = 2 + y3(Xt3, Zt3)) > Gt3) break i;
                          } else Ut3 = Gt3;
                          for (Ht3 = 0; Ht3 < Gt3 && Ut3--; ) {
                            S2(Xt3);
                            var Qt3 = $t3[0 + (127 & L4(Xt3))];
                            A4(Xt3, Xt3.u + Qt3.g);
                            var te3 = Qt3.value;
                            if (16 > te3) Yt3[Ht3++] = te3, 0 != te3 && (Kt3 = te3);
                            else {
                              var ee3 = 16 == te3, re3 = te3 - 16, ne3 = Yn[re3], ie3 = y3(Xt3, Gn[re3]) + ne3;
                              if (Ht3 + ie3 > Gt3) break i;
                              for (var ae3 = ee3 ? Kt3 : 0; 0 < ie3--; ) Yt3[Ht3++] = ae3;
                            }
                          }
                          Jt3 = 1;
                          break i;
                        }
                        Jt3 || (Wt3.a = 3), Rt3 = Jt3;
                      }
                      (Rt3 = Rt3 && !Ot3.h) && (Ct3 = l3(It3, jt3, 8, kt3, At3)), Rt3 && 0 != Ct3 ? zt3 = Ct3 : (St3.a = 3, zt3 = 0);
                    }
                    if (0 == zt3) break r;
                    if (Nt3 && 1 == Xn[V4] && (Nt3 = 0 == gt3[G3].g), wt3 += gt3[G3].g, G3 += zt3, 3 >= V4) {
                      var oe3, se3 = pt3[0];
                      for (oe3 = 1; oe3 < ut3; ++oe3) pt3[oe3] > se3 && (se3 = pt3[oe3]);
                      Lt3 += se3;
                    }
                  }
                  if (mt3.nd = Nt3, mt3.Qb = 0, Nt3 && (mt3.qb = (vt3[3][bt3[3] + 0].value << 24 | vt3[1][bt3[1] + 0].value << 16 | vt3[2][bt3[2] + 0].value) >>> 0, 0 == wt3 && 256 > vt3[0][bt3[0] + 0].value && (mt3.Qb = 1, mt3.qb += vt3[0][bt3[0] + 0].value << 8)), mt3.jc = !mt3.Qb && 6 > Lt3, mt3.jc) {
                    var ce3, ue3 = mt3;
                    for (ce3 = 0; ce3 < Er; ++ce3) {
                      var le3 = ce3, he3 = ue3.pd[le3], fe3 = ue3.G[0][ue3.H[0] + le3];
                      256 <= fe3.value ? (he3.g = fe3.g + 256, he3.value = fe3.value) : (he3.g = 0, he3.value = 0, le3 >>= yt2(fe3, 8, he3), le3 >>= yt2(ue3.G[1][ue3.H[1] + le3], 16, he3), le3 >>= yt2(ue3.G[2][ue3.H[2] + le3], 0, he3), yt2(ue3.G[3][ue3.H[3] + le3], 24, he3));
                    }
                  }
                }
                Q3.vc = tt3, Q3.Wb = et3, Q3.Ya = dt3, Q3.yc = lt3, H5 = 1;
                break e;
              }
              H5 = 0;
            }
            if (!(u5 = H5)) {
              s3.a = 3;
              break t;
            }
            if (0 < b4) {
              if (m4.ua = 1 << b4, !O2(m4.Wa, b4)) {
                s3.a = 1, u5 = 0;
                break t;
              }
            } else m4.ua = 0;
            var de3 = s3, pe3 = f5, ge3 = p4, me3 = de3.s, ve3 = me3.xc;
            if (de3.c = pe3, de3.i = ge3, me3.md = E3(pe3, ve3), me3.wc = 0 == ve3 ? -1 : (1 << ve3) - 1, n3) {
              s3.xb = di;
              break t;
            }
            if (null == (v4 = a3(f5 * p4))) {
              s3.a = 1, u5 = 0;
              break t;
            }
            u5 = (u5 = _t2(s3, v4, 0, f5, p4, p4, null)) && !g4.h;
            break t;
          }
          return u5 ? (null != c4 ? c4[0] = v4 : (e3(null == v4), e3(n3)), s3.$ = 0, n3 || Pt2(m4)) : Pt2(m4), u5;
        }
        function It2(t4, r3) {
          var n3 = t4.c * t4.i, i3 = n3 + r3 + 16 * r3;
          return e3(t4.c <= r3), t4.V = a3(i3), null == t4.V ? (t4.Ta = null, t4.Ua = 0, t4.a = 1, 0) : (t4.Ta = t4.V, t4.Ua = t4.Ba + n3 + r3, 1);
        }
        function jt2(t4, r3) {
          var n3 = t4.C, i3 = r3 - n3, a4 = t4.V, o3 = t4.Ba + t4.c * n3;
          for (e3(r3 <= t4.l.o); 0 < i3; ) {
            var s3 = 16 < i3 ? 16 : i3, c4 = t4.l.ma, u5 = t4.l.width, l4 = u5 * s3, h4 = c4.ca, f5 = c4.tb + u5 * n3, d4 = t4.Ta, p4 = t4.Ua;
            Nt2(t4, s3, a4, o3), Sn(d4, p4, h4, f5, l4), At2(c4, n3, n3 + s3, h4, f5, u5), i3 -= s3, a4 += s3 * t4.c, n3 += s3;
          }
          e3(n3 == r3), t4.C = t4.Ma = r3;
        }
        function Ct2() {
          this.ub = this.yd = this.td = this.Rb = 0;
        }
        function Ot2() {
          this.Kd = this.Ld = this.Ud = this.Td = this.i = this.c = 0;
        }
        function Bt2() {
          this.Fb = this.Bb = this.Cb = 0, this.Zb = a3(4), this.Lb = a3(4);
        }
        function qt2() {
          this.Yb = (function() {
            var t4 = [];
            return (function t5(e4, r3, n3) {
              for (var i3 = n3[r3], a4 = 0; a4 < i3 && (e4.push(n3.length > r3 + 1 ? [] : 0), !(n3.length < r3 + 1)); a4++) t5(e4[a4], r3 + 1, n3);
            })(t4, 0, [3, 11]), t4;
          })();
        }
        function Mt2() {
          this.jb = a3(3), this.Wc = s2([4, 8], qt2), this.Xc = s2([4, 17], qt2);
        }
        function Et2() {
          this.Pc = this.wb = this.Tb = this.zd = 0, this.vd = new a3(4), this.od = new a3(4);
        }
        function Rt2() {
          this.ld = this.La = this.dd = this.tc = 0;
        }
        function Dt2() {
          this.Na = this.la = 0;
        }
        function Tt2() {
          this.Sc = [0, 0], this.Eb = [0, 0], this.Qc = [0, 0], this.ia = this.lc = 0;
        }
        function zt2() {
          this.ad = a3(384), this.Za = 0, this.Ob = a3(16), this.$b = this.Ad = this.ia = this.Gc = this.Hc = this.Dd = 0;
        }
        function Ut2() {
          this.uc = this.M = this.Nb = 0, this.wa = Array(new Rt2()), this.Y = 0, this.ya = Array(new zt2()), this.aa = 0, this.l = new Gt2();
        }
        function Ht2() {
          this.y = a3(16), this.f = a3(8), this.ea = a3(8);
        }
        function Wt2() {
          this.cb = this.a = 0, this.sc = "", this.m = new w3(), this.Od = new Ct2(), this.Kc = new Ot2(), this.ed = new Et2(), this.Qa = new Bt2(), this.Ic = this.$c = this.Aa = 0, this.D = new Ut2(), this.Xb = this.Va = this.Hb = this.zb = this.yb = this.Ub = this.za = 0, this.Jc = o2(8, w3), this.ia = 0, this.pb = o2(4, Tt2), this.Pa = new Mt2(), this.Bd = this.kc = 0, this.Ac = [], this.Bc = 0, this.zc = [0, 0, 0, 0], this.Gd = Array(new Ht2()), this.Hd = 0, this.rb = Array(new Dt2()), this.sb = 0, this.wa = Array(new Rt2()), this.Y = 0, this.oc = [], this.pc = 0, this.sa = [], this.ta = 0, this.qa = [], this.ra = 0, this.Ha = [], this.B = this.R = this.Ia = 0, this.Ec = [], this.M = this.ja = this.Vb = this.Fc = 0, this.ya = Array(new zt2()), this.L = this.aa = 0, this.gd = s2([4, 2], Rt2), this.ga = null, this.Fa = [], this.Cc = this.qc = this.P = 0, this.Gb = [], this.Uc = 0, this.mb = [], this.nb = 0, this.rc = [], this.Ga = this.Vc = 0;
        }
        function Vt2(t4, e4) {
          return 0 > t4 ? 0 : t4 > e4 ? e4 : t4;
        }
        function Gt2() {
          this.T = this.U = this.ka = this.height = this.width = 0, this.y = [], this.f = [], this.ea = [], this.Rc = this.fa = this.W = this.N = this.O = 0, this.ma = "void", this.put = "VP8IoPutHook", this.ac = "VP8IoSetupHook", this.bc = "VP8IoTeardownHook", this.ha = this.Kb = 0, this.data = [], this.hb = this.ib = this.da = this.o = this.j = this.va = this.v = this.Da = this.ob = this.w = 0, this.F = [], this.J = 0;
        }
        function Yt2() {
          var t4 = new Wt2();
          return null != t4 && (t4.a = 0, t4.sc = "OK", t4.cb = 0, t4.Xb = 0, ri || (ri = $t2)), t4;
        }
        function Jt2(t4, e4, r3) {
          return 0 == t4.a && (t4.a = e4, t4.sc = r3, t4.cb = 0), 0;
        }
        function Xt2(t4, e4, r3) {
          return 3 <= r3 && 157 == t4[e4 + 0] && 1 == t4[e4 + 1] && 42 == t4[e4 + 2];
        }
        function Kt2(t4, r3) {
          if (null == t4) return 0;
          if (t4.a = 0, t4.sc = "OK", null == r3) return Jt2(t4, 2, "null VP8Io passed to VP8GetHeaders()");
          var n3 = r3.data, a4 = r3.w, o3 = r3.ha;
          if (4 > o3) return Jt2(t4, 7, "Truncated header.");
          var s3 = n3[a4 + 0] | n3[a4 + 1] << 8 | n3[a4 + 2] << 16, c4 = t4.Od;
          if (c4.Rb = !(1 & s3), c4.td = s3 >> 1 & 7, c4.yd = s3 >> 4 & 1, c4.ub = s3 >> 5, 3 < c4.td) return Jt2(t4, 3, "Incorrect keyframe parameters.");
          if (!c4.yd) return Jt2(t4, 4, "Frame not displayable.");
          a4 += 3, o3 -= 3;
          var u5 = t4.Kc;
          if (c4.Rb) {
            if (7 > o3) return Jt2(t4, 7, "cannot parse picture header");
            if (!Xt2(n3, a4, o3)) return Jt2(t4, 3, "Bad code word");
            u5.c = 16383 & (n3[a4 + 4] << 8 | n3[a4 + 3]), u5.Td = n3[a4 + 4] >> 6, u5.i = 16383 & (n3[a4 + 6] << 8 | n3[a4 + 5]), u5.Ud = n3[a4 + 6] >> 6, a4 += 7, o3 -= 7, t4.za = u5.c + 15 >> 4, t4.Ub = u5.i + 15 >> 4, r3.width = u5.c, r3.height = u5.i, r3.Da = 0, r3.j = 0, r3.v = 0, r3.va = r3.width, r3.o = r3.height, r3.da = 0, r3.ib = r3.width, r3.hb = r3.height, r3.U = r3.width, r3.T = r3.height, i2((s3 = t4.Pa).jb, 0, 255, s3.jb.length), e3(null != (s3 = t4.Qa)), s3.Cb = 0, s3.Bb = 0, s3.Fb = 1, i2(s3.Zb, 0, 0, s3.Zb.length), i2(s3.Lb, 0, 0, s3.Lb);
          }
          if (c4.ub > o3) return Jt2(t4, 7, "bad partition length");
          p3(s3 = t4.m, n3, a4, c4.ub), a4 += c4.ub, o3 -= c4.ub, c4.Rb && (u5.Ld = P2(s3), u5.Kd = P2(s3)), u5 = t4.Qa;
          var l4, h4 = t4.Pa;
          if (e3(null != s3), e3(null != u5), u5.Cb = P2(s3), u5.Cb) {
            if (u5.Bb = P2(s3), P2(s3)) {
              for (u5.Fb = P2(s3), l4 = 0; 4 > l4; ++l4) u5.Zb[l4] = P2(s3) ? m3(s3, 7) : 0;
              for (l4 = 0; 4 > l4; ++l4) u5.Lb[l4] = P2(s3) ? m3(s3, 6) : 0;
            }
            if (u5.Bb) for (l4 = 0; 3 > l4; ++l4) h4.jb[l4] = P2(s3) ? g3(s3, 8) : 255;
          } else u5.Bb = 0;
          if (s3.Ka) return Jt2(t4, 3, "cannot parse segment header");
          if ((u5 = t4.ed).zd = P2(s3), u5.Tb = g3(s3, 6), u5.wb = g3(s3, 3), u5.Pc = P2(s3), u5.Pc && P2(s3)) {
            for (h4 = 0; 4 > h4; ++h4) P2(s3) && (u5.vd[h4] = m3(s3, 6));
            for (h4 = 0; 4 > h4; ++h4) P2(s3) && (u5.od[h4] = m3(s3, 6));
          }
          if (t4.L = 0 == u5.Tb ? 0 : u5.zd ? 1 : 2, s3.Ka) return Jt2(t4, 3, "cannot parse filter header");
          var f5 = o3;
          if (o3 = l4 = a4, a4 = l4 + f5, u5 = f5, t4.Xb = (1 << g3(t4.m, 2)) - 1, f5 < 3 * (h4 = t4.Xb)) n3 = 7;
          else {
            for (l4 += 3 * h4, u5 -= 3 * h4, f5 = 0; f5 < h4; ++f5) {
              var d4 = n3[o3 + 0] | n3[o3 + 1] << 8 | n3[o3 + 2] << 16;
              d4 > u5 && (d4 = u5), p3(t4.Jc[+f5], n3, l4, d4), l4 += d4, u5 -= d4, o3 += 3;
            }
            p3(t4.Jc[+h4], n3, l4, u5), n3 = l4 < a4 ? 0 : 5;
          }
          if (0 != n3) return Jt2(t4, n3, "cannot parse partitions");
          for (n3 = g3(l4 = t4.m, 7), o3 = P2(l4) ? m3(l4, 4) : 0, a4 = P2(l4) ? m3(l4, 4) : 0, u5 = P2(l4) ? m3(l4, 4) : 0, h4 = P2(l4) ? m3(l4, 4) : 0, l4 = P2(l4) ? m3(l4, 4) : 0, f5 = t4.Qa, d4 = 0; 4 > d4; ++d4) {
            if (f5.Cb) {
              var v4 = f5.Zb[d4];
              f5.Fb || (v4 += n3);
            } else {
              if (0 < d4) {
                t4.pb[d4] = t4.pb[0];
                continue;
              }
              v4 = n3;
            }
            var b4 = t4.pb[d4];
            b4.Sc[0] = ti[Vt2(v4 + o3, 127)], b4.Sc[1] = ei[Vt2(v4 + 0, 127)], b4.Eb[0] = 2 * ti[Vt2(v4 + a4, 127)], b4.Eb[1] = 101581 * ei[Vt2(v4 + u5, 127)] >> 16, 8 > b4.Eb[1] && (b4.Eb[1] = 8), b4.Qc[0] = ti[Vt2(v4 + h4, 117)], b4.Qc[1] = ei[Vt2(v4 + l4, 127)], b4.lc = v4 + l4;
          }
          if (!c4.Rb) return Jt2(t4, 4, "Not a key frame.");
          for (P2(s3), c4 = t4.Pa, n3 = 0; 4 > n3; ++n3) {
            for (o3 = 0; 8 > o3; ++o3) for (a4 = 0; 3 > a4; ++a4) for (u5 = 0; 11 > u5; ++u5) h4 = k2(s3, ci[n3][o3][a4][u5]) ? g3(s3, 8) : oi[n3][o3][a4][u5], c4.Wc[n3][o3].Yb[a4][u5] = h4;
            for (o3 = 0; 17 > o3; ++o3) c4.Xc[n3][o3] = c4.Wc[n3][ui[o3]];
          }
          return t4.kc = P2(s3), t4.kc && (t4.Bd = g3(s3, 8)), t4.cb = 1;
        }
        function $t2(t4, e4, r3, n3, i3, a4, o3) {
          var s3 = e4[i3].Yb[r3];
          for (r3 = 0; 16 > i3; ++i3) {
            if (!k2(t4, s3[r3 + 0])) return i3;
            for (; !k2(t4, s3[r3 + 1]); ) if (s3 = e4[++i3].Yb[0], r3 = 0, 16 == i3) return 16;
            var c4 = e4[i3 + 1].Yb;
            if (k2(t4, s3[r3 + 2])) {
              var u5 = t4, l4 = 0;
              if (k2(u5, (f5 = s3)[(h4 = r3) + 3])) if (k2(u5, f5[h4 + 6])) {
                for (s3 = 0, h4 = 2 * (l4 = k2(u5, f5[h4 + 8])) + (f5 = k2(u5, f5[h4 + 9 + l4])), l4 = 0, f5 = ni[h4]; f5[s3]; ++s3) l4 += l4 + k2(u5, f5[s3]);
                l4 += 3 + (8 << h4);
              } else k2(u5, f5[h4 + 7]) ? (l4 = 7 + 2 * k2(u5, 165), l4 += k2(u5, 145)) : l4 = 5 + k2(u5, 159);
              else l4 = k2(u5, f5[h4 + 4]) ? 3 + k2(u5, f5[h4 + 5]) : 2;
              s3 = c4[2];
            } else l4 = 1, s3 = c4[1];
            c4 = o3 + ii[i3], 0 > (u5 = t4).b && _2(u5);
            var h4, f5 = u5.b, d4 = (h4 = u5.Ca >> 1) - (u5.I >> f5) >> 31;
            --u5.b, u5.Ca += d4, u5.Ca |= 1, u5.I -= (h4 + 1 & d4) << f5, a4[c4] = ((l4 ^ d4) - d4) * n3[(0 < i3) + 0];
          }
          return 16;
        }
        function Zt2(t4) {
          var e4 = t4.rb[t4.sb - 1];
          e4.la = 0, e4.Na = 0, i2(t4.zc, 0, 0, t4.zc.length), t4.ja = 0;
        }
        function Qt2(t4, e4, r3, n3, i3) {
          i3 = t4[e4 + r3 + 32 * n3] + (i3 >> 3), t4[e4 + r3 + 32 * n3] = -256 & i3 ? 0 > i3 ? 0 : 255 : i3;
        }
        function te2(t4, e4, r3, n3, i3, a4) {
          Qt2(t4, e4, 0, r3, n3 + i3), Qt2(t4, e4, 1, r3, n3 + a4), Qt2(t4, e4, 2, r3, n3 - a4), Qt2(t4, e4, 3, r3, n3 - i3);
        }
        function ee2(t4) {
          return (20091 * t4 >> 16) + t4;
        }
        function re2(t4, e4, r3, n3) {
          var i3, o3 = 0, s3 = a3(16);
          for (i3 = 0; 4 > i3; ++i3) {
            var c4 = t4[e4 + 0] + t4[e4 + 8], u5 = t4[e4 + 0] - t4[e4 + 8], l4 = (35468 * t4[e4 + 4] >> 16) - ee2(t4[e4 + 12]), h4 = ee2(t4[e4 + 4]) + (35468 * t4[e4 + 12] >> 16);
            s3[o3 + 0] = c4 + h4, s3[o3 + 1] = u5 + l4, s3[o3 + 2] = u5 - l4, s3[o3 + 3] = c4 - h4, o3 += 4, e4++;
          }
          for (i3 = o3 = 0; 4 > i3; ++i3) c4 = (t4 = s3[o3 + 0] + 4) + s3[o3 + 8], u5 = t4 - s3[o3 + 8], l4 = (35468 * s3[o3 + 4] >> 16) - ee2(s3[o3 + 12]), Qt2(r3, n3, 0, 0, c4 + (h4 = ee2(s3[o3 + 4]) + (35468 * s3[o3 + 12] >> 16))), Qt2(r3, n3, 1, 0, u5 + l4), Qt2(r3, n3, 2, 0, u5 - l4), Qt2(r3, n3, 3, 0, c4 - h4), o3++, n3 += 32;
        }
        function ne2(t4, e4, r3, n3) {
          var i3 = t4[e4 + 0] + 4, a4 = 35468 * t4[e4 + 4] >> 16, o3 = ee2(t4[e4 + 4]), s3 = 35468 * t4[e4 + 1] >> 16;
          te2(r3, n3, 0, i3 + o3, t4 = ee2(t4[e4 + 1]), s3), te2(r3, n3, 1, i3 + a4, t4, s3), te2(r3, n3, 2, i3 - a4, t4, s3), te2(r3, n3, 3, i3 - o3, t4, s3);
        }
        function ie2(t4, e4, r3, n3, i3) {
          re2(t4, e4, r3, n3), i3 && re2(t4, e4 + 16, r3, n3 + 4);
        }
        function ae2(t4, e4, r3, n3) {
          an(t4, e4 + 0, r3, n3, 1), an(t4, e4 + 32, r3, n3 + 128, 1);
        }
        function oe2(t4, e4, r3, n3) {
          var i3;
          for (t4 = t4[e4 + 0] + 4, i3 = 0; 4 > i3; ++i3) for (e4 = 0; 4 > e4; ++e4) Qt2(r3, n3, e4, i3, t4);
        }
        function se2(t4, e4, r3, n3) {
          t4[e4 + 0] && cn(t4, e4 + 0, r3, n3), t4[e4 + 16] && cn(t4, e4 + 16, r3, n3 + 4), t4[e4 + 32] && cn(t4, e4 + 32, r3, n3 + 128), t4[e4 + 48] && cn(t4, e4 + 48, r3, n3 + 128 + 4);
        }
        function ce2(t4, e4, r3, n3) {
          var i3, o3 = a3(16);
          for (i3 = 0; 4 > i3; ++i3) {
            var s3 = t4[e4 + 0 + i3] + t4[e4 + 12 + i3], c4 = t4[e4 + 4 + i3] + t4[e4 + 8 + i3], u5 = t4[e4 + 4 + i3] - t4[e4 + 8 + i3], l4 = t4[e4 + 0 + i3] - t4[e4 + 12 + i3];
            o3[0 + i3] = s3 + c4, o3[8 + i3] = s3 - c4, o3[4 + i3] = l4 + u5, o3[12 + i3] = l4 - u5;
          }
          for (i3 = 0; 4 > i3; ++i3) s3 = (t4 = o3[0 + 4 * i3] + 3) + o3[3 + 4 * i3], c4 = o3[1 + 4 * i3] + o3[2 + 4 * i3], u5 = o3[1 + 4 * i3] - o3[2 + 4 * i3], l4 = t4 - o3[3 + 4 * i3], r3[n3 + 0] = s3 + c4 >> 3, r3[n3 + 16] = l4 + u5 >> 3, r3[n3 + 32] = s3 - c4 >> 3, r3[n3 + 48] = l4 - u5 >> 3, n3 += 64;
        }
        function ue2(t4, e4, r3) {
          var n3, i3 = e4 - 32, a4 = On, o3 = 255 - t4[i3 - 1];
          for (n3 = 0; n3 < r3; ++n3) {
            var s3, c4 = a4, u5 = o3 + t4[e4 - 1];
            for (s3 = 0; s3 < r3; ++s3) t4[e4 + s3] = c4[u5 + t4[i3 + s3]];
            e4 += 32;
          }
        }
        function le2(t4, e4) {
          ue2(t4, e4, 4);
        }
        function he2(t4, e4) {
          ue2(t4, e4, 8);
        }
        function fe2(t4, e4) {
          ue2(t4, e4, 16);
        }
        function de2(t4, e4) {
          var r3;
          for (r3 = 0; 16 > r3; ++r3) n2(t4, e4 + 32 * r3, t4, e4 - 32, 16);
        }
        function pe2(t4, e4) {
          var r3;
          for (r3 = 16; 0 < r3; --r3) i2(t4, e4, t4[e4 - 1], 16), e4 += 32;
        }
        function ge2(t4, e4, r3) {
          var n3;
          for (n3 = 0; 16 > n3; ++n3) i2(e4, r3 + 32 * n3, t4, 16);
        }
        function me2(t4, e4) {
          var r3, n3 = 16;
          for (r3 = 0; 16 > r3; ++r3) n3 += t4[e4 - 1 + 32 * r3] + t4[e4 + r3 - 32];
          ge2(n3 >> 5, t4, e4);
        }
        function ve2(t4, e4) {
          var r3, n3 = 8;
          for (r3 = 0; 16 > r3; ++r3) n3 += t4[e4 - 1 + 32 * r3];
          ge2(n3 >> 4, t4, e4);
        }
        function be2(t4, e4) {
          var r3, n3 = 8;
          for (r3 = 0; 16 > r3; ++r3) n3 += t4[e4 + r3 - 32];
          ge2(n3 >> 4, t4, e4);
        }
        function ye2(t4, e4) {
          ge2(128, t4, e4);
        }
        function we2(t4, e4, r3) {
          return t4 + 2 * e4 + r3 + 2 >> 2;
        }
        function Ne2(t4, e4) {
          var r3, i3 = e4 - 32;
          for (i3 = new Uint8Array([we2(t4[i3 - 1], t4[i3 + 0], t4[i3 + 1]), we2(t4[i3 + 0], t4[i3 + 1], t4[i3 + 2]), we2(t4[i3 + 1], t4[i3 + 2], t4[i3 + 3]), we2(t4[i3 + 2], t4[i3 + 3], t4[i3 + 4])]), r3 = 0; 4 > r3; ++r3) n2(t4, e4 + 32 * r3, i3, 0, i3.length);
        }
        function Le2(t4, e4) {
          var r3 = t4[e4 - 1], n3 = t4[e4 - 1 + 32], i3 = t4[e4 - 1 + 64], a4 = t4[e4 - 1 + 96];
          F3(t4, e4 + 0, 16843009 * we2(t4[e4 - 1 - 32], r3, n3)), F3(t4, e4 + 32, 16843009 * we2(r3, n3, i3)), F3(t4, e4 + 64, 16843009 * we2(n3, i3, a4)), F3(t4, e4 + 96, 16843009 * we2(i3, a4, a4));
        }
        function xe2(t4, e4) {
          var r3, n3 = 4;
          for (r3 = 0; 4 > r3; ++r3) n3 += t4[e4 + r3 - 32] + t4[e4 - 1 + 32 * r3];
          for (n3 >>= 3, r3 = 0; 4 > r3; ++r3) i2(t4, e4 + 32 * r3, n3, 4);
        }
        function Ae2(t4, e4) {
          var r3 = t4[e4 - 1 + 0], n3 = t4[e4 - 1 + 32], i3 = t4[e4 - 1 + 64], a4 = t4[e4 - 1 - 32], o3 = t4[e4 + 0 - 32], s3 = t4[e4 + 1 - 32], c4 = t4[e4 + 2 - 32], u5 = t4[e4 + 3 - 32];
          t4[e4 + 0 + 96] = we2(n3, i3, t4[e4 - 1 + 96]), t4[e4 + 1 + 96] = t4[e4 + 0 + 64] = we2(r3, n3, i3), t4[e4 + 2 + 96] = t4[e4 + 1 + 64] = t4[e4 + 0 + 32] = we2(a4, r3, n3), t4[e4 + 3 + 96] = t4[e4 + 2 + 64] = t4[e4 + 1 + 32] = t4[e4 + 0 + 0] = we2(o3, a4, r3), t4[e4 + 3 + 64] = t4[e4 + 2 + 32] = t4[e4 + 1 + 0] = we2(s3, o3, a4), t4[e4 + 3 + 32] = t4[e4 + 2 + 0] = we2(c4, s3, o3), t4[e4 + 3 + 0] = we2(u5, c4, s3);
        }
        function Se(t4, e4) {
          var r3 = t4[e4 + 1 - 32], n3 = t4[e4 + 2 - 32], i3 = t4[e4 + 3 - 32], a4 = t4[e4 + 4 - 32], o3 = t4[e4 + 5 - 32], s3 = t4[e4 + 6 - 32], c4 = t4[e4 + 7 - 32];
          t4[e4 + 0 + 0] = we2(t4[e4 + 0 - 32], r3, n3), t4[e4 + 1 + 0] = t4[e4 + 0 + 32] = we2(r3, n3, i3), t4[e4 + 2 + 0] = t4[e4 + 1 + 32] = t4[e4 + 0 + 64] = we2(n3, i3, a4), t4[e4 + 3 + 0] = t4[e4 + 2 + 32] = t4[e4 + 1 + 64] = t4[e4 + 0 + 96] = we2(i3, a4, o3), t4[e4 + 3 + 32] = t4[e4 + 2 + 64] = t4[e4 + 1 + 96] = we2(a4, o3, s3), t4[e4 + 3 + 64] = t4[e4 + 2 + 96] = we2(o3, s3, c4), t4[e4 + 3 + 96] = we2(s3, c4, c4);
        }
        function _e(t4, e4) {
          var r3 = t4[e4 - 1 + 0], n3 = t4[e4 - 1 + 32], i3 = t4[e4 - 1 + 64], a4 = t4[e4 - 1 - 32], o3 = t4[e4 + 0 - 32], s3 = t4[e4 + 1 - 32], c4 = t4[e4 + 2 - 32], u5 = t4[e4 + 3 - 32];
          t4[e4 + 0 + 0] = t4[e4 + 1 + 64] = a4 + o3 + 1 >> 1, t4[e4 + 1 + 0] = t4[e4 + 2 + 64] = o3 + s3 + 1 >> 1, t4[e4 + 2 + 0] = t4[e4 + 3 + 64] = s3 + c4 + 1 >> 1, t4[e4 + 3 + 0] = c4 + u5 + 1 >> 1, t4[e4 + 0 + 96] = we2(i3, n3, r3), t4[e4 + 0 + 64] = we2(n3, r3, a4), t4[e4 + 0 + 32] = t4[e4 + 1 + 96] = we2(r3, a4, o3), t4[e4 + 1 + 32] = t4[e4 + 2 + 96] = we2(a4, o3, s3), t4[e4 + 2 + 32] = t4[e4 + 3 + 96] = we2(o3, s3, c4), t4[e4 + 3 + 32] = we2(s3, c4, u5);
        }
        function Pe(t4, e4) {
          var r3 = t4[e4 + 0 - 32], n3 = t4[e4 + 1 - 32], i3 = t4[e4 + 2 - 32], a4 = t4[e4 + 3 - 32], o3 = t4[e4 + 4 - 32], s3 = t4[e4 + 5 - 32], c4 = t4[e4 + 6 - 32], u5 = t4[e4 + 7 - 32];
          t4[e4 + 0 + 0] = r3 + n3 + 1 >> 1, t4[e4 + 1 + 0] = t4[e4 + 0 + 64] = n3 + i3 + 1 >> 1, t4[e4 + 2 + 0] = t4[e4 + 1 + 64] = i3 + a4 + 1 >> 1, t4[e4 + 3 + 0] = t4[e4 + 2 + 64] = a4 + o3 + 1 >> 1, t4[e4 + 0 + 32] = we2(r3, n3, i3), t4[e4 + 1 + 32] = t4[e4 + 0 + 96] = we2(n3, i3, a4), t4[e4 + 2 + 32] = t4[e4 + 1 + 96] = we2(i3, a4, o3), t4[e4 + 3 + 32] = t4[e4 + 2 + 96] = we2(a4, o3, s3), t4[e4 + 3 + 64] = we2(o3, s3, c4), t4[e4 + 3 + 96] = we2(s3, c4, u5);
        }
        function ke(t4, e4) {
          var r3 = t4[e4 - 1 + 0], n3 = t4[e4 - 1 + 32], i3 = t4[e4 - 1 + 64], a4 = t4[e4 - 1 + 96];
          t4[e4 + 0 + 0] = r3 + n3 + 1 >> 1, t4[e4 + 2 + 0] = t4[e4 + 0 + 32] = n3 + i3 + 1 >> 1, t4[e4 + 2 + 32] = t4[e4 + 0 + 64] = i3 + a4 + 1 >> 1, t4[e4 + 1 + 0] = we2(r3, n3, i3), t4[e4 + 3 + 0] = t4[e4 + 1 + 32] = we2(n3, i3, a4), t4[e4 + 3 + 32] = t4[e4 + 1 + 64] = we2(i3, a4, a4), t4[e4 + 3 + 64] = t4[e4 + 2 + 64] = t4[e4 + 0 + 96] = t4[e4 + 1 + 96] = t4[e4 + 2 + 96] = t4[e4 + 3 + 96] = a4;
        }
        function Fe(t4, e4) {
          var r3 = t4[e4 - 1 + 0], n3 = t4[e4 - 1 + 32], i3 = t4[e4 - 1 + 64], a4 = t4[e4 - 1 + 96], o3 = t4[e4 - 1 - 32], s3 = t4[e4 + 0 - 32], c4 = t4[e4 + 1 - 32], u5 = t4[e4 + 2 - 32];
          t4[e4 + 0 + 0] = t4[e4 + 2 + 32] = r3 + o3 + 1 >> 1, t4[e4 + 0 + 32] = t4[e4 + 2 + 64] = n3 + r3 + 1 >> 1, t4[e4 + 0 + 64] = t4[e4 + 2 + 96] = i3 + n3 + 1 >> 1, t4[e4 + 0 + 96] = a4 + i3 + 1 >> 1, t4[e4 + 3 + 0] = we2(s3, c4, u5), t4[e4 + 2 + 0] = we2(o3, s3, c4), t4[e4 + 1 + 0] = t4[e4 + 3 + 32] = we2(r3, o3, s3), t4[e4 + 1 + 32] = t4[e4 + 3 + 64] = we2(n3, r3, o3), t4[e4 + 1 + 64] = t4[e4 + 3 + 96] = we2(i3, n3, r3), t4[e4 + 1 + 96] = we2(a4, i3, n3);
        }
        function Ie(t4, e4) {
          var r3;
          for (r3 = 0; 8 > r3; ++r3) n2(t4, e4 + 32 * r3, t4, e4 - 32, 8);
        }
        function je(t4, e4) {
          var r3;
          for (r3 = 0; 8 > r3; ++r3) i2(t4, e4, t4[e4 - 1], 8), e4 += 32;
        }
        function Ce(t4, e4, r3) {
          var n3;
          for (n3 = 0; 8 > n3; ++n3) i2(e4, r3 + 32 * n3, t4, 8);
        }
        function Oe(t4, e4) {
          var r3, n3 = 8;
          for (r3 = 0; 8 > r3; ++r3) n3 += t4[e4 + r3 - 32] + t4[e4 - 1 + 32 * r3];
          Ce(n3 >> 4, t4, e4);
        }
        function Be(t4, e4) {
          var r3, n3 = 4;
          for (r3 = 0; 8 > r3; ++r3) n3 += t4[e4 + r3 - 32];
          Ce(n3 >> 3, t4, e4);
        }
        function qe(t4, e4) {
          var r3, n3 = 4;
          for (r3 = 0; 8 > r3; ++r3) n3 += t4[e4 - 1 + 32 * r3];
          Ce(n3 >> 3, t4, e4);
        }
        function Me(t4, e4) {
          Ce(128, t4, e4);
        }
        function Ee(t4, e4, r3) {
          var n3 = t4[e4 - r3], i3 = t4[e4 + 0], a4 = 3 * (i3 - n3) + jn[1020 + t4[e4 - 2 * r3] - t4[e4 + r3]], o3 = Cn[112 + (a4 + 4 >> 3)];
          t4[e4 - r3] = On[255 + n3 + Cn[112 + (a4 + 3 >> 3)]], t4[e4 + 0] = On[255 + i3 - o3];
        }
        function Re(t4, e4, r3, n3) {
          var i3 = t4[e4 + 0], a4 = t4[e4 + r3];
          return Bn[255 + t4[e4 - 2 * r3] - t4[e4 - r3]] > n3 || Bn[255 + a4 - i3] > n3;
        }
        function De(t4, e4, r3, n3) {
          return 4 * Bn[255 + t4[e4 - r3] - t4[e4 + 0]] + Bn[255 + t4[e4 - 2 * r3] - t4[e4 + r3]] <= n3;
        }
        function Te(t4, e4, r3, n3, i3) {
          var a4 = t4[e4 - 3 * r3], o3 = t4[e4 - 2 * r3], s3 = t4[e4 - r3], c4 = t4[e4 + 0], u5 = t4[e4 + r3], l4 = t4[e4 + 2 * r3], h4 = t4[e4 + 3 * r3];
          return 4 * Bn[255 + s3 - c4] + Bn[255 + o3 - u5] > n3 ? 0 : Bn[255 + t4[e4 - 4 * r3] - a4] <= i3 && Bn[255 + a4 - o3] <= i3 && Bn[255 + o3 - s3] <= i3 && Bn[255 + h4 - l4] <= i3 && Bn[255 + l4 - u5] <= i3 && Bn[255 + u5 - c4] <= i3;
        }
        function ze(t4, e4, r3, n3) {
          var i3 = 2 * n3 + 1;
          for (n3 = 0; 16 > n3; ++n3) De(t4, e4 + n3, r3, i3) && Ee(t4, e4 + n3, r3);
        }
        function Ue(t4, e4, r3, n3) {
          var i3 = 2 * n3 + 1;
          for (n3 = 0; 16 > n3; ++n3) De(t4, e4 + n3 * r3, 1, i3) && Ee(t4, e4 + n3 * r3, 1);
        }
        function He(t4, e4, r3, n3) {
          var i3;
          for (i3 = 3; 0 < i3; --i3) ze(t4, e4 += 4 * r3, r3, n3);
        }
        function We(t4, e4, r3, n3) {
          var i3;
          for (i3 = 3; 0 < i3; --i3) Ue(t4, e4 += 4, r3, n3);
        }
        function Ve(t4, e4, r3, n3, i3, a4, o3, s3) {
          for (a4 = 2 * a4 + 1; 0 < i3--; ) {
            if (Te(t4, e4, r3, a4, o3)) if (Re(t4, e4, r3, s3)) Ee(t4, e4, r3);
            else {
              var c4 = t4, u5 = e4, l4 = r3, h4 = c4[u5 - 2 * l4], f5 = c4[u5 - l4], d4 = c4[u5 + 0], p4 = c4[u5 + l4], g4 = c4[u5 + 2 * l4], m4 = 27 * (b4 = jn[1020 + 3 * (d4 - f5) + jn[1020 + h4 - p4]]) + 63 >> 7, v4 = 18 * b4 + 63 >> 7, b4 = 9 * b4 + 63 >> 7;
              c4[u5 - 3 * l4] = On[255 + c4[u5 - 3 * l4] + b4], c4[u5 - 2 * l4] = On[255 + h4 + v4], c4[u5 - l4] = On[255 + f5 + m4], c4[u5 + 0] = On[255 + d4 - m4], c4[u5 + l4] = On[255 + p4 - v4], c4[u5 + 2 * l4] = On[255 + g4 - b4];
            }
            e4 += n3;
          }
        }
        function Ge(t4, e4, r3, n3, i3, a4, o3, s3) {
          for (a4 = 2 * a4 + 1; 0 < i3--; ) {
            if (Te(t4, e4, r3, a4, o3)) if (Re(t4, e4, r3, s3)) Ee(t4, e4, r3);
            else {
              var c4 = t4, u5 = e4, l4 = r3, h4 = c4[u5 - l4], f5 = c4[u5 + 0], d4 = c4[u5 + l4], p4 = Cn[112 + (4 + (g4 = 3 * (f5 - h4)) >> 3)], g4 = Cn[112 + (g4 + 3 >> 3)], m4 = p4 + 1 >> 1;
              c4[u5 - 2 * l4] = On[255 + c4[u5 - 2 * l4] + m4], c4[u5 - l4] = On[255 + h4 + g4], c4[u5 + 0] = On[255 + f5 - p4], c4[u5 + l4] = On[255 + d4 - m4];
            }
            e4 += n3;
          }
        }
        function Ye(t4, e4, r3, n3, i3, a4) {
          Ve(t4, e4, r3, 1, 16, n3, i3, a4);
        }
        function Je(t4, e4, r3, n3, i3, a4) {
          Ve(t4, e4, 1, r3, 16, n3, i3, a4);
        }
        function Xe(t4, e4, r3, n3, i3, a4) {
          var o3;
          for (o3 = 3; 0 < o3; --o3) Ge(t4, e4 += 4 * r3, r3, 1, 16, n3, i3, a4);
        }
        function Ke(t4, e4, r3, n3, i3, a4) {
          var o3;
          for (o3 = 3; 0 < o3; --o3) Ge(t4, e4 += 4, 1, r3, 16, n3, i3, a4);
        }
        function $e(t4, e4, r3, n3, i3, a4, o3, s3) {
          Ve(t4, e4, i3, 1, 8, a4, o3, s3), Ve(r3, n3, i3, 1, 8, a4, o3, s3);
        }
        function Ze(t4, e4, r3, n3, i3, a4, o3, s3) {
          Ve(t4, e4, 1, i3, 8, a4, o3, s3), Ve(r3, n3, 1, i3, 8, a4, o3, s3);
        }
        function Qe(t4, e4, r3, n3, i3, a4, o3, s3) {
          Ge(t4, e4 + 4 * i3, i3, 1, 8, a4, o3, s3), Ge(r3, n3 + 4 * i3, i3, 1, 8, a4, o3, s3);
        }
        function tr(t4, e4, r3, n3, i3, a4, o3, s3) {
          Ge(t4, e4 + 4, 1, i3, 8, a4, o3, s3), Ge(r3, n3 + 4, 1, i3, 8, a4, o3, s3);
        }
        function er() {
          this.ba = new ot2(), this.ec = [], this.cc = [], this.Mc = [], this.Dc = this.Nc = this.dc = this.fc = 0, this.Oa = new ct2(), this.memory = 0, this.Ib = "OutputFunc", this.Jb = "OutputAlphaFunc", this.Nd = "OutputRowFunc";
        }
        function rr() {
          this.data = [], this.offset = this.kd = this.ha = this.w = 0, this.na = [], this.xa = this.gb = this.Ja = this.Sa = this.P = 0;
        }
        function nr() {
          this.nc = this.Ea = this.b = this.hc = 0, this.K = [], this.w = 0;
        }
        function ir() {
          this.ua = 0, this.Wa = new q2(), this.vb = new q2(), this.md = this.xc = this.wc = 0, this.vc = [], this.Wb = 0, this.Ya = new d3(), this.yc = new h3();
        }
        function ar() {
          this.xb = this.a = 0, this.l = new Gt2(), this.ca = new ot2(), this.V = [], this.Ba = 0, this.Ta = [], this.Ua = 0, this.m = new N3(), this.Pb = 0, this.wd = new N3(), this.Ma = this.$ = this.C = this.i = this.c = this.xd = 0, this.s = new ir(), this.ab = 0, this.gc = o2(4, nr), this.Oc = 0;
        }
        function or() {
          this.Lc = this.Z = this.$a = this.i = this.c = 0, this.l = new Gt2(), this.ic = 0, this.ca = [], this.tb = 0, this.qd = null, this.rd = 0;
        }
        function sr(t4, e4, r3, n3, i3, a4, o3) {
          for (t4 = null == t4 ? 0 : t4[e4 + 0], e4 = 0; e4 < o3; ++e4) i3[a4 + e4] = t4 + r3[n3 + e4] & 255, t4 = i3[a4 + e4];
        }
        function cr(t4, e4, r3, n3, i3, a4, o3) {
          var s3;
          if (null == t4) sr(null, null, r3, n3, i3, a4, o3);
          else for (s3 = 0; s3 < o3; ++s3) i3[a4 + s3] = t4[e4 + s3] + r3[n3 + s3] & 255;
        }
        function ur(t4, e4, r3, n3, i3, a4, o3) {
          if (null == t4) sr(null, null, r3, n3, i3, a4, o3);
          else {
            var s3, c4 = t4[e4 + 0], u5 = c4, l4 = c4;
            for (s3 = 0; s3 < o3; ++s3) u5 = l4 + (c4 = t4[e4 + s3]) - u5, l4 = r3[n3 + s3] + (-256 & u5 ? 0 > u5 ? 0 : 255 : u5) & 255, u5 = c4, i3[a4 + s3] = l4;
          }
        }
        function lr(t4, r3, i3, o3) {
          var s3 = r3.width, c4 = r3.o;
          if (e3(null != t4 && null != r3), 0 > i3 || 0 >= o3 || i3 + o3 > c4) return null;
          if (!t4.Cc) {
            if (null == t4.ga) {
              var u5;
              if (t4.ga = new or(), (u5 = null == t4.ga) || (u5 = r3.width * r3.o, e3(0 == t4.Gb.length), t4.Gb = a3(u5), t4.Uc = 0, null == t4.Gb ? u5 = 0 : (t4.mb = t4.Gb, t4.nb = t4.Uc, t4.rc = null, u5 = 1), u5 = !u5), !u5) {
                u5 = t4.ga;
                var l4 = t4.Fa, h4 = t4.P, f5 = t4.qc, d4 = t4.mb, p4 = t4.nb, g4 = h4 + 1, m4 = f5 - 1, b4 = u5.l;
                if (e3(null != l4 && null != d4 && null != r3), gi[0] = null, gi[1] = sr, gi[2] = cr, gi[3] = ur, u5.ca = d4, u5.tb = p4, u5.c = r3.width, u5.i = r3.height, e3(0 < u5.c && 0 < u5.i), 1 >= f5) r3 = 0;
                else if (u5.$a = 3 & l4[h4 + 0], u5.Z = l4[h4 + 0] >> 2 & 3, u5.Lc = l4[h4 + 0] >> 4 & 3, h4 = l4[h4 + 0] >> 6 & 3, 0 > u5.$a || 1 < u5.$a || 4 <= u5.Z || 1 < u5.Lc || h4) r3 = 0;
                else if (b4.put = dt2, b4.ac = ft2, b4.bc = pt2, b4.ma = u5, b4.width = r3.width, b4.height = r3.height, b4.Da = r3.Da, b4.v = r3.v, b4.va = r3.va, b4.j = r3.j, b4.o = r3.o, u5.$a) t: {
                  e3(1 == u5.$a), r3 = kt2();
                  e: for (; ; ) {
                    if (null == r3) {
                      r3 = 0;
                      break t;
                    }
                    if (e3(null != u5), u5.mc = r3, r3.c = u5.c, r3.i = u5.i, r3.l = u5.l, r3.l.ma = u5, r3.l.width = u5.c, r3.l.height = u5.i, r3.a = 0, v3(r3.m, l4, g4, m4), !Ft2(u5.c, u5.i, 1, r3, null)) break e;
                    if (1 == r3.ab && 3 == r3.gc[0].hc && xt2(r3.s) ? (u5.ic = 1, l4 = r3.c * r3.i, r3.Ta = null, r3.Ua = 0, r3.V = a3(l4), r3.Ba = 0, null == r3.V ? (r3.a = 1, r3 = 0) : r3 = 1) : (u5.ic = 0, r3 = It2(r3, u5.c)), !r3) break e;
                    r3 = 1;
                    break t;
                  }
                  u5.mc = null, r3 = 0;
                }
                else r3 = m4 >= u5.c * u5.i;
                u5 = !r3;
              }
              if (u5) return null;
              1 != t4.ga.Lc ? t4.Ga = 0 : o3 = c4 - i3;
            }
            e3(null != t4.ga), e3(i3 + o3 <= c4);
            t: {
              if (r3 = (l4 = t4.ga).c, c4 = l4.l.o, 0 == l4.$a) {
                if (g4 = t4.rc, m4 = t4.Vc, b4 = t4.Fa, h4 = t4.P + 1 + i3 * r3, f5 = t4.mb, d4 = t4.nb + i3 * r3, e3(h4 <= t4.P + t4.qc), 0 != l4.Z) for (e3(null != gi[l4.Z]), u5 = 0; u5 < o3; ++u5) gi[l4.Z](g4, m4, b4, h4, f5, d4, r3), g4 = f5, m4 = d4, d4 += r3, h4 += r3;
                else for (u5 = 0; u5 < o3; ++u5) n2(f5, d4, b4, h4, r3), g4 = f5, m4 = d4, d4 += r3, h4 += r3;
                t4.rc = g4, t4.Vc = m4;
              } else {
                if (e3(null != l4.mc), r3 = i3 + o3, e3(null != (u5 = l4.mc)), e3(r3 <= u5.i), u5.C >= r3) r3 = 1;
                else if (l4.ic || gr(), l4.ic) {
                  l4 = u5.V, g4 = u5.Ba, m4 = u5.c;
                  var y4 = u5.i, w4 = (b4 = 1, h4 = u5.$ / m4, f5 = u5.$ % m4, d4 = u5.m, p4 = u5.s, u5.$), N4 = m4 * y4, L5 = m4 * r3, A5 = p4.wc, _3 = w4 < L5 ? wt2(p4, f5, h4) : null;
                  e3(w4 <= N4), e3(r3 <= y4), e3(xt2(p4));
                  e: for (; ; ) {
                    for (; !d4.h && w4 < L5; ) {
                      if (f5 & A5 || (_3 = wt2(p4, f5, h4)), e3(null != _3), S2(d4), 256 > (y4 = bt2(_3.G[0], _3.H[0], d4))) l4[g4 + w4] = y4, ++w4, ++f5 >= m4 && (f5 = 0, ++h4 <= r3 && !(h4 % 16) && St2(u5, h4));
                      else {
                        if (!(280 > y4)) {
                          b4 = 0;
                          break e;
                        }
                        y4 = mt2(y4 - 256, d4);
                        var P3, k3 = bt2(_3.G[4], _3.H[4], d4);
                        if (S2(d4), !(w4 >= (k3 = vt2(m4, k3 = mt2(k3, d4))) && N4 - w4 >= y4)) {
                          b4 = 0;
                          break e;
                        }
                        for (P3 = 0; P3 < y4; ++P3) l4[g4 + w4 + P3] = l4[g4 + w4 + P3 - k3];
                        for (w4 += y4, f5 += y4; f5 >= m4; ) f5 -= m4, ++h4 <= r3 && !(h4 % 16) && St2(u5, h4);
                        w4 < L5 && f5 & A5 && (_3 = wt2(p4, f5, h4));
                      }
                      e3(d4.h == x3(d4));
                    }
                    St2(u5, h4 > r3 ? r3 : h4);
                    break e;
                  }
                  !b4 || d4.h && w4 < N4 ? (b4 = 0, u5.a = d4.h ? 5 : 3) : u5.$ = w4, r3 = b4;
                } else r3 = _t2(u5, u5.V, u5.Ba, u5.c, u5.i, r3, jt2);
                if (!r3) {
                  o3 = 0;
                  break t;
                }
              }
              i3 + o3 >= c4 && (t4.Cc = 1), o3 = 1;
            }
            if (!o3) return null;
            if (t4.Cc && (null != (o3 = t4.ga) && (o3.mc = null), t4.ga = null, 0 < t4.Ga)) return alert("todo:WebPDequantizeLevels"), null;
          }
          return t4.nb + i3 * s3;
        }
        function hr(t4, e4, r3, n3, i3, a4) {
          for (; 0 < i3--; ) {
            var o3, s3 = t4, c4 = e4 + (r3 ? 1 : 0), u5 = t4, l4 = e4 + (r3 ? 0 : 3);
            for (o3 = 0; o3 < n3; ++o3) {
              var h4 = u5[l4 + 4 * o3];
              255 != h4 && (h4 *= 32897, s3[c4 + 4 * o3 + 0] = s3[c4 + 4 * o3 + 0] * h4 >> 23, s3[c4 + 4 * o3 + 1] = s3[c4 + 4 * o3 + 1] * h4 >> 23, s3[c4 + 4 * o3 + 2] = s3[c4 + 4 * o3 + 2] * h4 >> 23);
            }
            e4 += a4;
          }
        }
        function fr(t4, e4, r3, n3, i3) {
          for (; 0 < n3--; ) {
            var a4;
            for (a4 = 0; a4 < r3; ++a4) {
              var o3 = t4[e4 + 2 * a4 + 0], s3 = 15 & (u5 = t4[e4 + 2 * a4 + 1]), c4 = 4369 * s3, u5 = (240 & u5 | u5 >> 4) * c4 >> 16;
              t4[e4 + 2 * a4 + 0] = (240 & o3 | o3 >> 4) * c4 >> 16 & 240 | (15 & o3 | o3 << 4) * c4 >> 16 >> 4 & 15, t4[e4 + 2 * a4 + 1] = 240 & u5 | s3;
            }
            e4 += i3;
          }
        }
        function dr(t4, e4, r3, n3, i3, a4, o3, s3) {
          var c4, u5, l4 = 255;
          for (u5 = 0; u5 < i3; ++u5) {
            for (c4 = 0; c4 < n3; ++c4) {
              var h4 = t4[e4 + c4];
              a4[o3 + 4 * c4] = h4, l4 &= h4;
            }
            e4 += r3, o3 += s3;
          }
          return 255 != l4;
        }
        function pr(t4, e4, r3, n3, i3) {
          var a4;
          for (a4 = 0; a4 < i3; ++a4) r3[n3 + a4] = t4[e4 + a4] >> 8;
        }
        function gr() {
          Ln = hr, xn = fr, An = dr, Sn = pr;
        }
        function mr(r3, n3, i3) {
          t3[r3] = function(t4, r4, a4, o3, s3, c4, u5, l4, h4, f5, d4, p4, g4, m4, v4, b4, y4) {
            var w4, N4 = y4 - 1 >> 1, L5 = s3[c4 + 0] | u5[l4 + 0] << 16, x4 = h4[f5 + 0] | d4[p4 + 0] << 16;
            e3(null != t4);
            var A5 = 3 * L5 + x4 + 131074 >> 2;
            for (n3(t4[r4 + 0], 255 & A5, A5 >> 16, g4, m4), null != a4 && (A5 = 3 * x4 + L5 + 131074 >> 2, n3(a4[o3 + 0], 255 & A5, A5 >> 16, v4, b4)), w4 = 1; w4 <= N4; ++w4) {
              var S3 = s3[c4 + w4] | u5[l4 + w4] << 16, _3 = h4[f5 + w4] | d4[p4 + w4] << 16, P3 = L5 + S3 + x4 + _3 + 524296, k3 = P3 + 2 * (S3 + x4) >> 3;
              A5 = k3 + L5 >> 1, L5 = (P3 = P3 + 2 * (L5 + _3) >> 3) + S3 >> 1, n3(t4[r4 + 2 * w4 - 1], 255 & A5, A5 >> 16, g4, m4 + (2 * w4 - 1) * i3), n3(t4[r4 + 2 * w4 - 0], 255 & L5, L5 >> 16, g4, m4 + (2 * w4 - 0) * i3), null != a4 && (A5 = P3 + x4 >> 1, L5 = k3 + _3 >> 1, n3(a4[o3 + 2 * w4 - 1], 255 & A5, A5 >> 16, v4, b4 + (2 * w4 - 1) * i3), n3(a4[o3 + 2 * w4 + 0], 255 & L5, L5 >> 16, v4, b4 + (2 * w4 + 0) * i3)), L5 = S3, x4 = _3;
            }
            1 & y4 || (A5 = 3 * L5 + x4 + 131074 >> 2, n3(t4[r4 + y4 - 1], 255 & A5, A5 >> 16, g4, m4 + (y4 - 1) * i3), null != a4 && (A5 = 3 * x4 + L5 + 131074 >> 2, n3(a4[o3 + y4 - 1], 255 & A5, A5 >> 16, v4, b4 + (y4 - 1) * i3)));
          };
        }
        function vr() {
          mi[qn] = vi, mi[Mn] = yi, mi[En] = bi, mi[Rn] = wi, mi[Dn] = Ni, mi[Tn] = Li, mi[zn] = xi, mi[Un] = yi, mi[Hn] = wi, mi[Wn] = Ni, mi[Vn] = Li;
        }
        function br(t4) {
          return t4 & ~Fi ? 0 > t4 ? 0 : 255 : t4 >> ki;
        }
        function yr(t4, e4) {
          return br((19077 * t4 >> 8) + (26149 * e4 >> 8) - 14234);
        }
        function wr(t4, e4, r3) {
          return br((19077 * t4 >> 8) - (6419 * e4 >> 8) - (13320 * r3 >> 8) + 8708);
        }
        function Nr(t4, e4) {
          return br((19077 * t4 >> 8) + (33050 * e4 >> 8) - 17685);
        }
        function Lr(t4, e4, r3, n3, i3) {
          n3[i3 + 0] = yr(t4, r3), n3[i3 + 1] = wr(t4, e4, r3), n3[i3 + 2] = Nr(t4, e4);
        }
        function xr(t4, e4, r3, n3, i3) {
          n3[i3 + 0] = Nr(t4, e4), n3[i3 + 1] = wr(t4, e4, r3), n3[i3 + 2] = yr(t4, r3);
        }
        function Ar(t4, e4, r3, n3, i3) {
          var a4 = wr(t4, e4, r3);
          e4 = a4 << 3 & 224 | Nr(t4, e4) >> 3, n3[i3 + 0] = 248 & yr(t4, r3) | a4 >> 5, n3[i3 + 1] = e4;
        }
        function Sr(t4, e4, r3, n3, i3) {
          var a4 = 240 & Nr(t4, e4) | 15;
          n3[i3 + 0] = 240 & yr(t4, r3) | wr(t4, e4, r3) >> 4, n3[i3 + 1] = a4;
        }
        function _r(t4, e4, r3, n3, i3) {
          n3[i3 + 0] = 255, Lr(t4, e4, r3, n3, i3 + 1);
        }
        function Pr(t4, e4, r3, n3, i3) {
          xr(t4, e4, r3, n3, i3), n3[i3 + 3] = 255;
        }
        function kr(t4, e4, r3, n3, i3) {
          Lr(t4, e4, r3, n3, i3), n3[i3 + 3] = 255;
        }
        function Fr(e4, r3, n3) {
          t3[e4] = function(t4, e5, i3, a4, o3, s3, c4, u5, l4) {
            for (var h4 = u5 + (-2 & l4) * n3; u5 != h4; ) r3(t4[e5 + 0], i3[a4 + 0], o3[s3 + 0], c4, u5), r3(t4[e5 + 1], i3[a4 + 0], o3[s3 + 0], c4, u5 + n3), e5 += 2, ++a4, ++s3, u5 += 2 * n3;
            1 & l4 && r3(t4[e5 + 0], i3[a4 + 0], o3[s3 + 0], c4, u5);
          };
        }
        function Ir(t4, e4, r3) {
          return 0 == r3 ? 0 == t4 ? 0 == e4 ? 6 : 5 : 0 == e4 ? 4 : 0 : r3;
        }
        function jr(t4, e4, r3, n3, i3) {
          switch (t4 >>> 30) {
            case 3:
              an(e4, r3, n3, i3, 0);
              break;
            case 2:
              on(e4, r3, n3, i3);
              break;
            case 1:
              cn(e4, r3, n3, i3);
          }
        }
        function Cr(t4, e4) {
          var r3, a4, o3 = e4.M, s3 = e4.Nb, c4 = t4.oc, u5 = t4.pc + 40, l4 = t4.oc, h4 = t4.pc + 584, f5 = t4.oc, d4 = t4.pc + 600;
          for (r3 = 0; 16 > r3; ++r3) c4[u5 + 32 * r3 - 1] = 129;
          for (r3 = 0; 8 > r3; ++r3) l4[h4 + 32 * r3 - 1] = 129, f5[d4 + 32 * r3 - 1] = 129;
          for (0 < o3 ? c4[u5 - 1 - 32] = l4[h4 - 1 - 32] = f5[d4 - 1 - 32] = 129 : (i2(c4, u5 - 32 - 1, 127, 21), i2(l4, h4 - 32 - 1, 127, 9), i2(f5, d4 - 32 - 1, 127, 9)), a4 = 0; a4 < t4.za; ++a4) {
            var p4 = e4.ya[e4.aa + a4];
            if (0 < a4) {
              for (r3 = -1; 16 > r3; ++r3) n2(c4, u5 + 32 * r3 - 4, c4, u5 + 32 * r3 + 12, 4);
              for (r3 = -1; 8 > r3; ++r3) n2(l4, h4 + 32 * r3 - 4, l4, h4 + 32 * r3 + 4, 4), n2(f5, d4 + 32 * r3 - 4, f5, d4 + 32 * r3 + 4, 4);
            }
            var g4 = t4.Gd, m4 = t4.Hd + a4, v4 = p4.ad, b4 = p4.Hc;
            if (0 < o3 && (n2(c4, u5 - 32, g4[m4].y, 0, 16), n2(l4, h4 - 32, g4[m4].f, 0, 8), n2(f5, d4 - 32, g4[m4].ea, 0, 8)), p4.Za) {
              var y4 = c4, w4 = u5 - 32 + 16;
              for (0 < o3 && (a4 >= t4.za - 1 ? i2(y4, w4, g4[m4].y[15], 4) : n2(y4, w4, g4[m4 + 1].y, 0, 4)), r3 = 0; 4 > r3; r3++) y4[w4 + 128 + r3] = y4[w4 + 256 + r3] = y4[w4 + 384 + r3] = y4[w4 + 0 + r3];
              for (r3 = 0; 16 > r3; ++r3, b4 <<= 2) y4 = c4, w4 = u5 + Ei[r3], hi[p4.Ob[r3]](y4, w4), jr(b4, v4, 16 * +r3, y4, w4);
            } else if (y4 = Ir(a4, o3, p4.Ob[0]), li[y4](c4, u5), 0 != b4) for (r3 = 0; 16 > r3; ++r3, b4 <<= 2) jr(b4, v4, 16 * +r3, c4, u5 + Ei[r3]);
            for (r3 = p4.Gc, y4 = Ir(a4, o3, p4.Dd), fi[y4](l4, h4), fi[y4](f5, d4), b4 = v4, y4 = l4, w4 = h4, 255 & (p4 = 0 | r3) && (170 & p4 ? sn(b4, 256, y4, w4) : un(b4, 256, y4, w4)), p4 = f5, b4 = d4, 255 & (r3 >>= 8) && (170 & r3 ? sn(v4, 320, p4, b4) : un(v4, 320, p4, b4)), o3 < t4.Ub - 1 && (n2(g4[m4].y, 0, c4, u5 + 480, 16), n2(g4[m4].f, 0, l4, h4 + 224, 8), n2(g4[m4].ea, 0, f5, d4 + 224, 8)), r3 = 8 * s3 * t4.B, g4 = t4.sa, m4 = t4.ta + 16 * a4 + 16 * s3 * t4.R, v4 = t4.qa, p4 = t4.ra + 8 * a4 + r3, b4 = t4.Ha, y4 = t4.Ia + 8 * a4 + r3, r3 = 0; 16 > r3; ++r3) n2(g4, m4 + r3 * t4.R, c4, u5 + 32 * r3, 16);
            for (r3 = 0; 8 > r3; ++r3) n2(v4, p4 + r3 * t4.B, l4, h4 + 32 * r3, 8), n2(b4, y4 + r3 * t4.B, f5, d4 + 32 * r3, 8);
          }
        }
        function Or(t4, n3, i3, a4, o3, s3, c4, u5, l4) {
          var h4 = [0], f5 = [0], d4 = 0, p4 = null != l4 ? l4.kd : 0, g4 = null != l4 ? l4 : new rr();
          if (null == t4 || 12 > i3) return 7;
          g4.data = t4, g4.w = n3, g4.ha = i3, n3 = [n3], i3 = [i3], g4.gb = [g4.gb];
          t: {
            var m4 = n3, b4 = i3, y4 = g4.gb;
            if (e3(null != t4), e3(null != b4), e3(null != y4), y4[0] = 0, 12 <= b4[0] && !r2(t4, m4[0], "RIFF")) {
              if (r2(t4, m4[0] + 8, "WEBP")) {
                y4 = 3;
                break t;
              }
              var w4 = C2(t4, m4[0] + 4);
              if (12 > w4 || 4294967286 < w4) {
                y4 = 3;
                break t;
              }
              if (p4 && w4 > b4[0] - 8) {
                y4 = 7;
                break t;
              }
              y4[0] = w4, m4[0] += 12, b4[0] -= 12;
            }
            y4 = 0;
          }
          if (0 != y4) return y4;
          for (w4 = 0 < g4.gb[0], i3 = i3[0]; ; ) {
            t: {
              var L5 = t4;
              b4 = n3, y4 = i3;
              var x4 = h4, A5 = f5, S3 = m4 = [0];
              if ((k3 = d4 = [d4])[0] = 0, 8 > y4[0]) y4 = 7;
              else {
                if (!r2(L5, b4[0], "VP8X")) {
                  if (10 != C2(L5, b4[0] + 4)) {
                    y4 = 3;
                    break t;
                  }
                  if (18 > y4[0]) {
                    y4 = 7;
                    break t;
                  }
                  var _3 = C2(L5, b4[0] + 8), P3 = 1 + j2(L5, b4[0] + 12);
                  if (2147483648 <= P3 * (L5 = 1 + j2(L5, b4[0] + 15))) {
                    y4 = 3;
                    break t;
                  }
                  null != S3 && (S3[0] = _3), null != x4 && (x4[0] = P3), null != A5 && (A5[0] = L5), b4[0] += 18, y4[0] -= 18, k3[0] = 1;
                }
                y4 = 0;
              }
            }
            if (d4 = d4[0], m4 = m4[0], 0 != y4) return y4;
            if (b4 = !!(2 & m4), !w4 && d4) return 3;
            if (null != s3 && (s3[0] = !!(16 & m4)), null != c4 && (c4[0] = b4), null != u5 && (u5[0] = 0), c4 = h4[0], m4 = f5[0], d4 && b4 && null == l4) {
              y4 = 0;
              break;
            }
            if (4 > i3) {
              y4 = 7;
              break;
            }
            if (w4 && d4 || !w4 && !d4 && !r2(t4, n3[0], "ALPH")) {
              i3 = [i3], g4.na = [g4.na], g4.P = [g4.P], g4.Sa = [g4.Sa];
              t: {
                _3 = t4, y4 = n3, w4 = i3;
                var k3 = g4.gb;
                x4 = g4.na, A5 = g4.P, S3 = g4.Sa, P3 = 22, e3(null != _3), e3(null != w4), L5 = y4[0];
                var F4 = w4[0];
                for (e3(null != x4), e3(null != S3), x4[0] = null, A5[0] = null, S3[0] = 0; ; ) {
                  if (y4[0] = L5, w4[0] = F4, 8 > F4) {
                    y4 = 7;
                    break t;
                  }
                  var I3 = C2(_3, L5 + 4);
                  if (4294967286 < I3) {
                    y4 = 3;
                    break t;
                  }
                  var O3 = 8 + I3 + 1 & -2;
                  if (P3 += O3, 0 < k3 && P3 > k3) {
                    y4 = 3;
                    break t;
                  }
                  if (!r2(_3, L5, "VP8 ") || !r2(_3, L5, "VP8L")) {
                    y4 = 0;
                    break t;
                  }
                  if (F4[0] < O3) {
                    y4 = 7;
                    break t;
                  }
                  r2(_3, L5, "ALPH") || (x4[0] = _3, A5[0] = L5 + 8, S3[0] = I3), L5 += O3, F4 -= O3;
                }
              }
              if (i3 = i3[0], g4.na = g4.na[0], g4.P = g4.P[0], g4.Sa = g4.Sa[0], 0 != y4) break;
            }
            i3 = [i3], g4.Ja = [g4.Ja], g4.xa = [g4.xa];
            t: if (k3 = t4, y4 = n3, w4 = i3, x4 = g4.gb[0], A5 = g4.Ja, S3 = g4.xa, _3 = y4[0], L5 = !r2(k3, _3, "VP8 "), P3 = !r2(k3, _3, "VP8L"), e3(null != k3), e3(null != w4), e3(null != A5), e3(null != S3), 8 > w4[0]) y4 = 7;
            else {
              if (L5 || P3) {
                if (k3 = C2(k3, _3 + 4), 12 <= x4 && k3 > x4 - 12) {
                  y4 = 3;
                  break t;
                }
                if (p4 && k3 > w4[0] - 8) {
                  y4 = 7;
                  break t;
                }
                A5[0] = k3, y4[0] += 8, w4[0] -= 8, S3[0] = P3;
              } else S3[0] = 5 <= w4[0] && 47 == k3[_3 + 0] && !(k3[_3 + 4] >> 5), A5[0] = w4[0];
              y4 = 0;
            }
            if (i3 = i3[0], g4.Ja = g4.Ja[0], g4.xa = g4.xa[0], n3 = n3[0], 0 != y4) break;
            if (4294967286 < g4.Ja) return 3;
            if (null == u5 || b4 || (u5[0] = g4.xa ? 2 : 1), c4 = [c4], m4 = [m4], g4.xa) {
              if (5 > i3) {
                y4 = 7;
                break;
              }
              u5 = c4, p4 = m4, b4 = s3, null == t4 || 5 > i3 ? t4 = 0 : 5 <= i3 && 47 == t4[n3 + 0] && !(t4[n3 + 4] >> 5) ? (w4 = [0], k3 = [0], x4 = [0], v3(A5 = new N3(), t4, n3, i3), gt2(A5, w4, k3, x4) ? (null != u5 && (u5[0] = w4[0]), null != p4 && (p4[0] = k3[0]), null != b4 && (b4[0] = x4[0]), t4 = 1) : t4 = 0) : t4 = 0;
            } else {
              if (10 > i3) {
                y4 = 7;
                break;
              }
              u5 = m4, null == t4 || 10 > i3 || !Xt2(t4, n3 + 3, i3 - 3) ? t4 = 0 : (p4 = t4[n3 + 0] | t4[n3 + 1] << 8 | t4[n3 + 2] << 16, b4 = 16383 & (t4[n3 + 7] << 8 | t4[n3 + 6]), t4 = 16383 & (t4[n3 + 9] << 8 | t4[n3 + 8]), 1 & p4 || 3 < (p4 >> 1 & 7) || !(p4 >> 4 & 1) || p4 >> 5 >= g4.Ja || !b4 || !t4 ? t4 = 0 : (c4 && (c4[0] = b4), u5 && (u5[0] = t4), t4 = 1));
            }
            if (!t4) return 3;
            if (c4 = c4[0], m4 = m4[0], d4 && (h4[0] != c4 || f5[0] != m4)) return 3;
            null != l4 && (l4[0] = g4, l4.offset = n3 - l4.w, e3(4294967286 > n3 - l4.w), e3(l4.offset == l4.ha - i3));
            break;
          }
          return 0 == y4 || 7 == y4 && d4 && null == l4 ? (null != s3 && (s3[0] |= null != g4.na && 0 < g4.na.length), null != a4 && (a4[0] = c4), null != o3 && (o3[0] = m4), 0) : y4;
        }
        function Br(t4, e4, r3) {
          var n3 = e4.width, i3 = e4.height, a4 = 0, o3 = 0, s3 = n3, c4 = i3;
          if (e4.Da = null != t4 && 0 < t4.Da, e4.Da && (s3 = t4.cd, c4 = t4.bd, a4 = t4.v, o3 = t4.j, 11 > r3 || (a4 &= -2, o3 &= -2), 0 > a4 || 0 > o3 || 0 >= s3 || 0 >= c4 || a4 + s3 > n3 || o3 + c4 > i3)) return 0;
          if (e4.v = a4, e4.j = o3, e4.va = a4 + s3, e4.o = o3 + c4, e4.U = s3, e4.T = c4, e4.da = null != t4 && 0 < t4.da, e4.da) {
            if (!M2(s3, c4, r3 = [t4.ib], a4 = [t4.hb])) return 0;
            e4.ib = r3[0], e4.hb = a4[0];
          }
          return e4.ob = null != t4 && t4.ob, e4.Kb = null == t4 || !t4.Sd, e4.da && (e4.ob = e4.ib < 3 * n3 / 4 && e4.hb < 3 * i3 / 4, e4.Kb = 0), 1;
        }
        function qr(t4) {
          if (null == t4) return 2;
          if (11 > t4.S) {
            var e4 = t4.f.RGBA;
            e4.fb += (t4.height - 1) * e4.A, e4.A = -e4.A;
          } else e4 = t4.f.kb, t4 = t4.height, e4.O += (t4 - 1) * e4.fa, e4.fa = -e4.fa, e4.N += (t4 - 1 >> 1) * e4.Ab, e4.Ab = -e4.Ab, e4.W += (t4 - 1 >> 1) * e4.Db, e4.Db = -e4.Db, null != e4.F && (e4.J += (t4 - 1) * e4.lb, e4.lb = -e4.lb);
          return 0;
        }
        function Mr(t4, e4, r3, n3) {
          if (null == n3 || 0 >= t4 || 0 >= e4) return 2;
          if (null != r3) {
            if (r3.Da) {
              var i3 = r3.cd, o3 = r3.bd, s3 = -2 & r3.v, c4 = -2 & r3.j;
              if (0 > s3 || 0 > c4 || 0 >= i3 || 0 >= o3 || s3 + i3 > t4 || c4 + o3 > e4) return 2;
              t4 = i3, e4 = o3;
            }
            if (r3.da) {
              if (!M2(t4, e4, i3 = [r3.ib], o3 = [r3.hb])) return 2;
              t4 = i3[0], e4 = o3[0];
            }
          }
          n3.width = t4, n3.height = e4;
          t: {
            var u5 = n3.width, l4 = n3.height;
            if (t4 = n3.S, 0 >= u5 || 0 >= l4 || !(t4 >= qn && 13 > t4)) t4 = 2;
            else {
              if (0 >= n3.Rd && null == n3.sd) {
                s3 = o3 = i3 = e4 = 0;
                var h4 = (c4 = u5 * zi[t4]) * l4;
                if (11 > t4 || (o3 = (l4 + 1) / 2 * (e4 = (u5 + 1) / 2), 12 == t4 && (s3 = (i3 = u5) * l4)), null == (l4 = a3(h4 + 2 * o3 + s3))) {
                  t4 = 1;
                  break t;
                }
                n3.sd = l4, 11 > t4 ? ((u5 = n3.f.RGBA).eb = l4, u5.fb = 0, u5.A = c4, u5.size = h4) : ((u5 = n3.f.kb).y = l4, u5.O = 0, u5.fa = c4, u5.Fd = h4, u5.f = l4, u5.N = 0 + h4, u5.Ab = e4, u5.Cd = o3, u5.ea = l4, u5.W = 0 + h4 + o3, u5.Db = e4, u5.Ed = o3, 12 == t4 && (u5.F = l4, u5.J = 0 + h4 + 2 * o3), u5.Tc = s3, u5.lb = i3);
              }
              if (e4 = 1, i3 = n3.S, o3 = n3.width, s3 = n3.height, i3 >= qn && 13 > i3) if (11 > i3) t4 = n3.f.RGBA, e4 &= (c4 = Math.abs(t4.A)) * (s3 - 1) + o3 <= t4.size, e4 &= c4 >= o3 * zi[i3], e4 &= null != t4.eb;
              else {
                t4 = n3.f.kb, c4 = (o3 + 1) / 2, h4 = (s3 + 1) / 2, u5 = Math.abs(t4.fa), l4 = Math.abs(t4.Ab);
                var f5 = Math.abs(t4.Db), d4 = Math.abs(t4.lb), p4 = d4 * (s3 - 1) + o3;
                e4 &= u5 * (s3 - 1) + o3 <= t4.Fd, e4 &= l4 * (h4 - 1) + c4 <= t4.Cd, e4 = (e4 &= f5 * (h4 - 1) + c4 <= t4.Ed) & u5 >= o3 & l4 >= c4 & f5 >= c4, e4 &= null != t4.y, e4 &= null != t4.f, e4 &= null != t4.ea, 12 == i3 && (e4 &= d4 >= o3, e4 &= p4 <= t4.Tc, e4 &= null != t4.F);
              }
              else e4 = 0;
              t4 = e4 ? 0 : 2;
            }
          }
          return 0 != t4 || null != r3 && r3.fd && (t4 = qr(n3)), t4;
        }
        var Er = 64, Rr = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215], Dr = 24, Tr = 32, zr = 8, Ur = [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7];
        D2("Predictor0", "PredictorAdd0"), t3.Predictor0 = function() {
          return 4278190080;
        }, t3.Predictor1 = function(t4) {
          return t4;
        }, t3.Predictor2 = function(t4, e4, r3) {
          return e4[r3 + 0];
        }, t3.Predictor3 = function(t4, e4, r3) {
          return e4[r3 + 1];
        }, t3.Predictor4 = function(t4, e4, r3) {
          return e4[r3 - 1];
        }, t3.Predictor5 = function(t4, e4, r3) {
          return z3(z3(t4, e4[r3 + 1]), e4[r3 + 0]);
        }, t3.Predictor6 = function(t4, e4, r3) {
          return z3(t4, e4[r3 - 1]);
        }, t3.Predictor7 = function(t4, e4, r3) {
          return z3(t4, e4[r3 + 0]);
        }, t3.Predictor8 = function(t4, e4, r3) {
          return z3(e4[r3 - 1], e4[r3 + 0]);
        }, t3.Predictor9 = function(t4, e4, r3) {
          return z3(e4[r3 + 0], e4[r3 + 1]);
        }, t3.Predictor10 = function(t4, e4, r3) {
          return z3(z3(t4, e4[r3 - 1]), z3(e4[r3 + 0], e4[r3 + 1]));
        }, t3.Predictor11 = function(t4, e4, r3) {
          var n3 = e4[r3 + 0];
          return 0 >= W2(n3 >> 24 & 255, t4 >> 24 & 255, (e4 = e4[r3 - 1]) >> 24 & 255) + W2(n3 >> 16 & 255, t4 >> 16 & 255, e4 >> 16 & 255) + W2(n3 >> 8 & 255, t4 >> 8 & 255, e4 >> 8 & 255) + W2(255 & n3, 255 & t4, 255 & e4) ? n3 : t4;
        }, t3.Predictor12 = function(t4, e4, r3) {
          var n3 = e4[r3 + 0];
          return (U3((t4 >> 24 & 255) + (n3 >> 24 & 255) - ((e4 = e4[r3 - 1]) >> 24 & 255)) << 24 | U3((t4 >> 16 & 255) + (n3 >> 16 & 255) - (e4 >> 16 & 255)) << 16 | U3((t4 >> 8 & 255) + (n3 >> 8 & 255) - (e4 >> 8 & 255)) << 8 | U3((255 & t4) + (255 & n3) - (255 & e4))) >>> 0;
        }, t3.Predictor13 = function(t4, e4, r3) {
          var n3 = e4[r3 - 1];
          return (H4((t4 = z3(t4, e4[r3 + 0])) >> 24 & 255, n3 >> 24 & 255) << 24 | H4(t4 >> 16 & 255, n3 >> 16 & 255) << 16 | H4(t4 >> 8 & 255, n3 >> 8 & 255) << 8 | H4(255 & t4, 255 & n3)) >>> 0;
        };
        var Hr = t3.PredictorAdd0;
        t3.PredictorAdd1 = V3, D2("Predictor2", "PredictorAdd2"), D2("Predictor3", "PredictorAdd3"), D2("Predictor4", "PredictorAdd4"), D2("Predictor5", "PredictorAdd5"), D2("Predictor6", "PredictorAdd6"), D2("Predictor7", "PredictorAdd7"), D2("Predictor8", "PredictorAdd8"), D2("Predictor9", "PredictorAdd9"), D2("Predictor10", "PredictorAdd10"), D2("Predictor11", "PredictorAdd11"), D2("Predictor12", "PredictorAdd12"), D2("Predictor13", "PredictorAdd13");
        var Wr = t3.PredictorAdd2;
        X2("ColorIndexInverseTransform", "MapARGB", "32b", function(t4) {
          return t4 >> 8 & 255;
        }, function(t4) {
          return t4;
        }), X2("VP8LColorIndexInverseTransformAlpha", "MapAlpha", "8b", function(t4) {
          return t4;
        }, function(t4) {
          return t4 >> 8 & 255;
        });
        var Vr, Gr = t3.ColorIndexInverseTransform, Yr = t3.MapARGB, Jr = t3.VP8LColorIndexInverseTransformAlpha, Xr = t3.MapAlpha, Kr = t3.VP8LPredictorsAdd = [];
        Kr.length = 16, (t3.VP8LPredictors = []).length = 16, (t3.VP8LPredictorsAdd_C = []).length = 16, (t3.VP8LPredictors_C = []).length = 16;
        var $r, Zr, Qr, tn, en, rn, nn, an, on, sn, cn, un, ln, hn, fn, dn, pn, gn, mn, vn, bn, yn, wn, Nn, Ln, xn, An, Sn, _n = a3(511), Pn = a3(2041), kn = a3(225), Fn = a3(767), In = 0, jn = Pn, Cn = kn, On = Fn, Bn = _n, qn = 0, Mn = 1, En = 2, Rn = 3, Dn = 4, Tn = 5, zn = 6, Un = 7, Hn = 8, Wn = 9, Vn = 10, Gn = [2, 3, 7], Yn = [3, 3, 11], Jn = [280, 256, 256, 256, 40], Xn = [0, 1, 1, 1, 0], Kn = [17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], $n = [24, 7, 23, 25, 40, 6, 39, 41, 22, 26, 38, 42, 56, 5, 55, 57, 21, 27, 54, 58, 37, 43, 72, 4, 71, 73, 20, 28, 53, 59, 70, 74, 36, 44, 88, 69, 75, 52, 60, 3, 87, 89, 19, 29, 86, 90, 35, 45, 68, 76, 85, 91, 51, 61, 104, 2, 103, 105, 18, 30, 102, 106, 34, 46, 84, 92, 67, 77, 101, 107, 50, 62, 120, 1, 119, 121, 83, 93, 17, 31, 100, 108, 66, 78, 118, 122, 33, 47, 117, 123, 49, 63, 99, 109, 82, 94, 0, 116, 124, 65, 79, 16, 32, 98, 110, 48, 115, 125, 81, 95, 64, 114, 126, 97, 111, 80, 113, 127, 96, 112], Zn = [2954, 2956, 2958, 2962, 2970, 2986, 3018, 3082, 3212, 3468, 3980, 5004], Qn = 8, ti = [4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 91, 93, 95, 96, 98, 100, 101, 102, 104, 106, 108, 110, 112, 114, 116, 118, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 143, 145, 148, 151, 154, 157], ei = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 149, 152, 155, 158, 161, 164, 167, 170, 173, 177, 181, 185, 189, 193, 197, 201, 205, 209, 213, 217, 221, 225, 229, 234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284], ri = null, ni = [[173, 148, 140, 0], [176, 155, 140, 135, 0], [180, 157, 141, 134, 130, 0], [254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 0]], ii = [0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15], ai = [-0, 1, -1, 2, -2, 3, 4, 6, -3, 5, -4, -5, -6, 7, -7, 8, -8, -9], oi = [[[[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]], [[253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128], [189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128], [106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128]], [[1, 98, 248, 255, 236, 226, 255, 255, 128, 128, 128], [181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128], [78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128]], [[1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128], [184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128], [77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128]], [[1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128], [170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128], [37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128]], [[1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128], [207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128], [102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128]], [[1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128], [177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128], [80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [246, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[198, 35, 237, 223, 193, 187, 162, 160, 145, 155, 62], [131, 45, 198, 221, 172, 176, 220, 157, 252, 221, 1], [68, 47, 146, 208, 149, 167, 221, 162, 255, 223, 128]], [[1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128], [184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128], [81, 99, 181, 242, 176, 190, 249, 202, 255, 255, 128]], [[1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128], [99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128], [23, 91, 163, 242, 170, 187, 247, 210, 255, 255, 128]], [[1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128], [109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128], [44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128]], [[1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128], [94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128], [22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128]], [[1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128], [124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128], [35, 77, 181, 251, 193, 211, 255, 205, 128, 128, 128]], [[1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128], [121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128], [45, 99, 188, 251, 195, 217, 255, 224, 128, 128, 128]], [[1, 1, 251, 255, 213, 255, 128, 128, 128, 128, 128], [203, 1, 248, 255, 255, 128, 128, 128, 128, 128, 128], [137, 1, 177, 255, 224, 255, 128, 128, 128, 128, 128]]], [[[253, 9, 248, 251, 207, 208, 255, 192, 128, 128, 128], [175, 13, 224, 243, 193, 185, 249, 198, 255, 255, 128], [73, 17, 171, 221, 161, 179, 236, 167, 255, 234, 128]], [[1, 95, 247, 253, 212, 183, 255, 255, 128, 128, 128], [239, 90, 244, 250, 211, 209, 255, 255, 128, 128, 128], [155, 77, 195, 248, 188, 195, 255, 255, 128, 128, 128]], [[1, 24, 239, 251, 218, 219, 255, 205, 128, 128, 128], [201, 51, 219, 255, 196, 186, 128, 128, 128, 128, 128], [69, 46, 190, 239, 201, 218, 255, 228, 128, 128, 128]], [[1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128], [223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128], [141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128]], [[1, 16, 248, 255, 255, 128, 128, 128, 128, 128, 128], [190, 36, 230, 255, 236, 255, 128, 128, 128, 128, 128], [149, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128], [247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128], [240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128], [213, 62, 250, 255, 255, 128, 128, 128, 128, 128, 128], [55, 93, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[202, 24, 213, 235, 186, 191, 220, 160, 240, 175, 255], [126, 38, 182, 232, 169, 184, 228, 174, 255, 187, 128], [61, 46, 138, 219, 151, 178, 240, 170, 255, 216, 128]], [[1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128], [166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128], [39, 77, 162, 232, 172, 180, 245, 178, 255, 255, 128]], [[1, 52, 220, 246, 198, 199, 249, 220, 255, 255, 128], [124, 74, 191, 243, 183, 193, 250, 221, 255, 255, 128], [24, 71, 130, 219, 154, 170, 243, 182, 255, 255, 128]], [[1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128], [149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128], [28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128]], [[1, 81, 230, 252, 204, 203, 255, 192, 128, 128, 128], [123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128], [20, 95, 153, 243, 164, 173, 255, 203, 128, 128, 128]], [[1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128], [168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128], [47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128]], [[1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128], [141, 84, 213, 252, 201, 202, 255, 219, 128, 128, 128], [42, 80, 160, 240, 162, 185, 255, 205, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [244, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [238, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]]]], si = [[[231, 120, 48, 89, 115, 113, 120, 152, 112], [152, 179, 64, 126, 170, 118, 46, 70, 95], [175, 69, 143, 80, 85, 82, 72, 155, 103], [56, 58, 10, 171, 218, 189, 17, 13, 152], [114, 26, 17, 163, 44, 195, 21, 10, 173], [121, 24, 80, 195, 26, 62, 44, 64, 85], [144, 71, 10, 38, 171, 213, 144, 34, 26], [170, 46, 55, 19, 136, 160, 33, 206, 71], [63, 20, 8, 114, 114, 208, 12, 9, 226], [81, 40, 11, 96, 182, 84, 29, 16, 36]], [[134, 183, 89, 137, 98, 101, 106, 165, 148], [72, 187, 100, 130, 157, 111, 32, 75, 80], [66, 102, 167, 99, 74, 62, 40, 234, 128], [41, 53, 9, 178, 241, 141, 26, 8, 107], [74, 43, 26, 146, 73, 166, 49, 23, 157], [65, 38, 105, 160, 51, 52, 31, 115, 128], [104, 79, 12, 27, 217, 255, 87, 17, 7], [87, 68, 71, 44, 114, 51, 15, 186, 23], [47, 41, 14, 110, 182, 183, 21, 17, 194], [66, 45, 25, 102, 197, 189, 23, 18, 22]], [[88, 88, 147, 150, 42, 46, 45, 196, 205], [43, 97, 183, 117, 85, 38, 35, 179, 61], [39, 53, 200, 87, 26, 21, 43, 232, 171], [56, 34, 51, 104, 114, 102, 29, 93, 77], [39, 28, 85, 171, 58, 165, 90, 98, 64], [34, 22, 116, 206, 23, 34, 43, 166, 73], [107, 54, 32, 26, 51, 1, 81, 43, 31], [68, 25, 106, 22, 64, 171, 36, 225, 114], [34, 19, 21, 102, 132, 188, 16, 76, 124], [62, 18, 78, 95, 85, 57, 50, 48, 51]], [[193, 101, 35, 159, 215, 111, 89, 46, 111], [60, 148, 31, 172, 219, 228, 21, 18, 111], [112, 113, 77, 85, 179, 255, 38, 120, 114], [40, 42, 1, 196, 245, 209, 10, 25, 109], [88, 43, 29, 140, 166, 213, 37, 43, 154], [61, 63, 30, 155, 67, 45, 68, 1, 209], [100, 80, 8, 43, 154, 1, 51, 26, 71], [142, 78, 78, 16, 255, 128, 34, 197, 171], [41, 40, 5, 102, 211, 183, 4, 1, 221], [51, 50, 17, 168, 209, 192, 23, 25, 82]], [[138, 31, 36, 171, 27, 166, 38, 44, 229], [67, 87, 58, 169, 82, 115, 26, 59, 179], [63, 59, 90, 180, 59, 166, 93, 73, 154], [40, 40, 21, 116, 143, 209, 34, 39, 175], [47, 15, 16, 183, 34, 223, 49, 45, 183], [46, 17, 33, 183, 6, 98, 15, 32, 183], [57, 46, 22, 24, 128, 1, 54, 17, 37], [65, 32, 73, 115, 28, 128, 23, 128, 205], [40, 3, 9, 115, 51, 192, 18, 6, 223], [87, 37, 9, 115, 59, 77, 64, 21, 47]], [[104, 55, 44, 218, 9, 54, 53, 130, 226], [64, 90, 70, 205, 40, 41, 23, 26, 57], [54, 57, 112, 184, 5, 41, 38, 166, 213], [30, 34, 26, 133, 152, 116, 10, 32, 134], [39, 19, 53, 221, 26, 114, 32, 73, 255], [31, 9, 65, 234, 2, 15, 1, 118, 73], [75, 32, 12, 51, 192, 255, 160, 43, 51], [88, 31, 35, 67, 102, 85, 55, 186, 85], [56, 21, 23, 111, 59, 205, 45, 37, 192], [55, 38, 70, 124, 73, 102, 1, 34, 98]], [[125, 98, 42, 88, 104, 85, 117, 175, 82], [95, 84, 53, 89, 128, 100, 113, 101, 45], [75, 79, 123, 47, 51, 128, 81, 171, 1], [57, 17, 5, 71, 102, 57, 53, 41, 49], [38, 33, 13, 121, 57, 73, 26, 1, 85], [41, 10, 67, 138, 77, 110, 90, 47, 114], [115, 21, 2, 10, 102, 255, 166, 23, 6], [101, 29, 16, 10, 85, 128, 101, 196, 26], [57, 18, 10, 102, 102, 213, 34, 20, 43], [117, 20, 15, 36, 163, 128, 68, 1, 26]], [[102, 61, 71, 37, 34, 53, 31, 243, 192], [69, 60, 71, 38, 73, 119, 28, 222, 37], [68, 45, 128, 34, 1, 47, 11, 245, 171], [62, 17, 19, 70, 146, 85, 55, 62, 70], [37, 43, 37, 154, 100, 163, 85, 160, 1], [63, 9, 92, 136, 28, 64, 32, 201, 85], [75, 15, 9, 9, 64, 255, 184, 119, 16], [86, 6, 28, 5, 64, 255, 25, 248, 1], [56, 8, 17, 132, 137, 255, 55, 116, 128], [58, 15, 20, 82, 135, 57, 26, 121, 40]], [[164, 50, 31, 137, 154, 133, 25, 35, 218], [51, 103, 44, 131, 131, 123, 31, 6, 158], [86, 40, 64, 135, 148, 224, 45, 183, 128], [22, 26, 17, 131, 240, 154, 14, 1, 209], [45, 16, 21, 91, 64, 222, 7, 1, 197], [56, 21, 39, 155, 60, 138, 23, 102, 213], [83, 12, 13, 54, 192, 255, 68, 47, 28], [85, 26, 85, 85, 128, 128, 32, 146, 171], [18, 11, 7, 63, 144, 171, 4, 4, 246], [35, 27, 10, 146, 174, 171, 12, 26, 128]], [[190, 80, 35, 99, 180, 80, 126, 54, 45], [85, 126, 47, 87, 176, 51, 41, 20, 32], [101, 75, 128, 139, 118, 146, 116, 128, 85], [56, 41, 15, 176, 236, 85, 37, 9, 62], [71, 30, 17, 119, 118, 255, 17, 18, 138], [101, 38, 60, 138, 55, 70, 43, 26, 142], [146, 36, 19, 30, 171, 255, 97, 27, 20], [138, 45, 61, 62, 219, 1, 81, 188, 64], [32, 41, 20, 117, 151, 142, 20, 21, 163], [112, 19, 12, 61, 195, 128, 48, 4, 24]]], ci = [[[[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255], [249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255], [234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255], [239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255], [250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255], [234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255], [247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255], [234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255], [251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255], [248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255], [248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255], [249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]]], ui = [0, 1, 2, 3, 6, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7, 0], li = [], hi = [], fi = [], di = 1, pi = 2, gi = [], mi = [];
        mr("UpsampleRgbLinePair", Lr, 3), mr("UpsampleBgrLinePair", xr, 3), mr("UpsampleRgbaLinePair", kr, 4), mr("UpsampleBgraLinePair", Pr, 4), mr("UpsampleArgbLinePair", _r, 4), mr("UpsampleRgba4444LinePair", Sr, 2), mr("UpsampleRgb565LinePair", Ar, 2);
        var vi = t3.UpsampleRgbLinePair, bi = t3.UpsampleBgrLinePair, yi = t3.UpsampleRgbaLinePair, wi = t3.UpsampleBgraLinePair, Ni = t3.UpsampleArgbLinePair, Li = t3.UpsampleRgba4444LinePair, xi = t3.UpsampleRgb565LinePair, Ai = 16, Si = 1 << Ai - 1, _i = -227, Pi = 482, ki = 6, Fi = (256 << ki) - 1, Ii = 0, ji = a3(256), Ci = a3(256), Oi = a3(256), Bi = a3(256), qi = a3(Pi - _i), Mi = a3(Pi - _i);
        Fr("YuvToRgbRow", Lr, 3), Fr("YuvToBgrRow", xr, 3), Fr("YuvToRgbaRow", kr, 4), Fr("YuvToBgraRow", Pr, 4), Fr("YuvToArgbRow", _r, 4), Fr("YuvToRgba4444Row", Sr, 2), Fr("YuvToRgb565Row", Ar, 2);
        var Ei = [0, 4, 8, 12, 128, 132, 136, 140, 256, 260, 264, 268, 384, 388, 392, 396], Ri = [0, 2, 8], Di = [8, 7, 6, 4, 4, 2, 2, 2, 1, 1, 1, 1], Ti = 1;
        this.WebPDecodeRGBA = function(t4, r3, s3, c4, u5) {
          var l4 = Mn, h4 = new er(), f5 = new ot2();
          h4.ba = f5, f5.S = l4, f5.width = [f5.width], f5.height = [f5.height];
          var d4 = f5.width, p4 = f5.height, g4 = new st2();
          if (null == g4 || null == t4) var m4 = 2;
          else e3(null != g4), m4 = Or(t4, r3, s3, g4.width, g4.height, g4.Pd, g4.Qd, g4.format, null);
          if (0 != m4 ? d4 = 0 : (null != d4 && (d4[0] = g4.width[0]), null != p4 && (p4[0] = g4.height[0]), d4 = 1), d4) {
            f5.width = f5.width[0], f5.height = f5.height[0], null != c4 && (c4[0] = f5.width), null != u5 && (u5[0] = f5.height);
            t: {
              if (c4 = new Gt2(), (u5 = new rr()).data = t4, u5.w = r3, u5.ha = s3, u5.kd = 1, r3 = [0], e3(null != u5), (0 == (t4 = Or(u5.data, u5.w, u5.ha, null, null, null, r3, null, u5)) || 7 == t4) && r3[0] && (t4 = 4), 0 == (r3 = t4)) {
                if (e3(null != h4), c4.data = u5.data, c4.w = u5.w + u5.offset, c4.ha = u5.ha - u5.offset, c4.put = dt2, c4.ac = ft2, c4.bc = pt2, c4.ma = h4, u5.xa) {
                  if (null == (t4 = kt2())) {
                    h4 = 1;
                    break t;
                  }
                  if ((function(t5, r4) {
                    var n3 = [0], i3 = [0], a4 = [0];
                    e: for (; ; ) {
                      if (null == t5) return 0;
                      if (null == r4) return t5.a = 2, 0;
                      if (t5.l = r4, t5.a = 0, v3(t5.m, r4.data, r4.w, r4.ha), !gt2(t5.m, n3, i3, a4)) {
                        t5.a = 3;
                        break e;
                      }
                      if (t5.xb = pi, r4.width = n3[0], r4.height = i3[0], !Ft2(n3[0], i3[0], 1, t5, null)) break e;
                      return 1;
                    }
                    return e3(0 != t5.a), 0;
                  })(t4, c4)) {
                    if (c4 = 0 == (r3 = Mr(c4.width, c4.height, h4.Oa, h4.ba))) {
                      e: {
                        c4 = t4;
                        r: for (; ; ) {
                          if (null == c4) {
                            c4 = 0;
                            break e;
                          }
                          if (e3(null != c4.s.yc), e3(null != c4.s.Ya), e3(0 < c4.s.Wb), e3(null != (s3 = c4.l)), e3(null != (u5 = s3.ma)), 0 != c4.xb) {
                            if (c4.ca = u5.ba, c4.tb = u5.tb, e3(null != c4.ca), !Br(u5.Oa, s3, Rn)) {
                              c4.a = 2;
                              break r;
                            }
                            if (!It2(c4, s3.width)) break r;
                            if (s3.da) break r;
                            if ((s3.da || nt2(c4.ca.S)) && gr(), 11 > c4.ca.S || (alert("todo:WebPInitConvertARGBToYUV"), null != c4.ca.f.kb.F && gr()), c4.Pb && 0 < c4.s.ua && null == c4.s.vb.X && !O2(c4.s.vb, c4.s.Wa.Xa)) {
                              c4.a = 1;
                              break r;
                            }
                            c4.xb = 0;
                          }
                          if (!_t2(c4, c4.V, c4.Ba, c4.c, c4.i, s3.o, Lt2)) break r;
                          u5.Dc = c4.Ma, c4 = 1;
                          break e;
                        }
                        e3(0 != c4.a), c4 = 0;
                      }
                      c4 = !c4;
                    }
                    c4 && (r3 = t4.a);
                  } else r3 = t4.a;
                } else {
                  if (null == (t4 = new Yt2())) {
                    h4 = 1;
                    break t;
                  }
                  if (t4.Fa = u5.na, t4.P = u5.P, t4.qc = u5.Sa, Kt2(t4, c4)) {
                    if (0 == (r3 = Mr(c4.width, c4.height, h4.Oa, h4.ba))) {
                      if (t4.Aa = 0, s3 = h4.Oa, e3(null != (u5 = t4)), null != s3) {
                        if (0 < (d4 = 0 > (d4 = s3.Md) ? 0 : 100 < d4 ? 255 : 255 * d4 / 100)) {
                          for (p4 = g4 = 0; 4 > p4; ++p4) 12 > (m4 = u5.pb[p4]).lc && (m4.ia = d4 * Di[0 > m4.lc ? 0 : m4.lc] >> 3), g4 |= m4.ia;
                          g4 && (alert("todo:VP8InitRandom"), u5.ia = 1);
                        }
                        u5.Ga = s3.Id, 100 < u5.Ga ? u5.Ga = 100 : 0 > u5.Ga && (u5.Ga = 0);
                      }
                      (function(t5, r4) {
                        if (null == t5) return 0;
                        if (null == r4) return Jt2(t5, 2, "NULL VP8Io parameter in VP8Decode().");
                        if (!t5.cb && !Kt2(t5, r4)) return 0;
                        if (e3(t5.cb), null == r4.ac || r4.ac(r4)) {
                          r4.ob && (t5.L = 0);
                          var s4 = Ri[t5.L];
                          if (2 == t5.L ? (t5.yb = 0, t5.zb = 0) : (t5.yb = r4.v - s4 >> 4, t5.zb = r4.j - s4 >> 4, 0 > t5.yb && (t5.yb = 0), 0 > t5.zb && (t5.zb = 0)), t5.Va = r4.o + 15 + s4 >> 4, t5.Hb = r4.va + 15 + s4 >> 4, t5.Hb > t5.za && (t5.Hb = t5.za), t5.Va > t5.Ub && (t5.Va = t5.Ub), 0 < t5.L) {
                            var c5 = t5.ed;
                            for (s4 = 0; 4 > s4; ++s4) {
                              var u6;
                              if (t5.Qa.Cb) {
                                var l5 = t5.Qa.Lb[s4];
                                t5.Qa.Fb || (l5 += c5.Tb);
                              } else l5 = c5.Tb;
                              for (u6 = 0; 1 >= u6; ++u6) {
                                var h5 = t5.gd[s4][u6], f6 = l5;
                                if (c5.Pc && (f6 += c5.vd[0], u6 && (f6 += c5.od[0])), 0 < (f6 = 0 > f6 ? 0 : 63 < f6 ? 63 : f6)) {
                                  var d5 = f6;
                                  0 < c5.wb && (d5 = 4 < c5.wb ? d5 >> 2 : d5 >> 1) > 9 - c5.wb && (d5 = 9 - c5.wb), 1 > d5 && (d5 = 1), h5.dd = d5, h5.tc = 2 * f6 + d5, h5.ld = 40 <= f6 ? 2 : 15 <= f6 ? 1 : 0;
                                } else h5.tc = 0;
                                h5.La = u6;
                              }
                            }
                          }
                          s4 = 0;
                        } else Jt2(t5, 6, "Frame setup failed"), s4 = t5.a;
                        if (s4 = 0 == s4) {
                          if (s4) {
                            t5.$c = 0, 0 < t5.Aa || (t5.Ic = Ti);
                            e: {
                              s4 = t5.Ic, c5 = 4 * (d5 = t5.za);
                              var p5 = 32 * d5, g5 = d5 + 1, m5 = 0 < t5.L ? d5 * (0 < t5.Aa ? 2 : 1) : 0, v4 = (2 == t5.Aa ? 2 : 1) * d5;
                              if ((h5 = c5 + 832 + (u6 = 3 * (16 * s4 + Ri[t5.L]) / 2 * p5) + (l5 = null != t5.Fa && 0 < t5.Fa.length ? t5.Kc.c * t5.Kc.i : 0)) != h5) s4 = 0;
                              else {
                                if (h5 > t5.Vb) {
                                  if (t5.Vb = 0, t5.Ec = a3(h5), t5.Fc = 0, null == t5.Ec) {
                                    s4 = Jt2(t5, 1, "no memory during frame initialization.");
                                    break e;
                                  }
                                  t5.Vb = h5;
                                }
                                h5 = t5.Ec, f6 = t5.Fc, t5.Ac = h5, t5.Bc = f6, f6 += c5, t5.Gd = o2(p5, Ht2), t5.Hd = 0, t5.rb = o2(g5 + 1, Dt2), t5.sb = 1, t5.wa = m5 ? o2(m5, Rt2) : null, t5.Y = 0, t5.D.Nb = 0, t5.D.wa = t5.wa, t5.D.Y = t5.Y, 0 < t5.Aa && (t5.D.Y += d5), e3(true), t5.oc = h5, t5.pc = f6, f6 += 832, t5.ya = o2(v4, zt2), t5.aa = 0, t5.D.ya = t5.ya, t5.D.aa = t5.aa, 2 == t5.Aa && (t5.D.aa += d5), t5.R = 16 * d5, t5.B = 8 * d5, d5 = (p5 = Ri[t5.L]) * t5.R, p5 = p5 / 2 * t5.B, t5.sa = h5, t5.ta = f6 + d5, t5.qa = t5.sa, t5.ra = t5.ta + 16 * s4 * t5.R + p5, t5.Ha = t5.qa, t5.Ia = t5.ra + 8 * s4 * t5.B + p5, t5.$c = 0, f6 += u6, t5.mb = l5 ? h5 : null, t5.nb = l5 ? f6 : null, e3(f6 + l5 <= t5.Fc + t5.Vb), Zt2(t5), i2(t5.Ac, t5.Bc, 0, c5), s4 = 1;
                              }
                            }
                            if (s4) {
                              if (r4.ka = 0, r4.y = t5.sa, r4.O = t5.ta, r4.f = t5.qa, r4.N = t5.ra, r4.ea = t5.Ha, r4.Vd = t5.Ia, r4.fa = t5.R, r4.Rc = t5.B, r4.F = null, r4.J = 0, !In) {
                                for (s4 = -255; 255 >= s4; ++s4) _n[255 + s4] = 0 > s4 ? -s4 : s4;
                                for (s4 = -1020; 1020 >= s4; ++s4) Pn[1020 + s4] = -128 > s4 ? -128 : 127 < s4 ? 127 : s4;
                                for (s4 = -112; 112 >= s4; ++s4) kn[112 + s4] = -16 > s4 ? -16 : 15 < s4 ? 15 : s4;
                                for (s4 = -255; 510 >= s4; ++s4) Fn[255 + s4] = 0 > s4 ? 0 : 255 < s4 ? 255 : s4;
                                In = 1;
                              }
                              nn = ce2, an = ie2, sn = ae2, cn = oe2, un = se2, on = ne2, ln = Ye, hn = Je, fn = $e, dn = Ze, pn = Xe, gn = Ke, mn = Qe, vn = tr, bn = ze, yn = Ue, wn = He, Nn = We, hi[0] = xe2, hi[1] = le2, hi[2] = Ne2, hi[3] = Le2, hi[4] = Ae2, hi[5] = _e, hi[6] = Se, hi[7] = Pe, hi[8] = Fe, hi[9] = ke, li[0] = me2, li[1] = fe2, li[2] = de2, li[3] = pe2, li[4] = ve2, li[5] = be2, li[6] = ye2, fi[0] = Oe, fi[1] = he2, fi[2] = Ie, fi[3] = je, fi[4] = qe, fi[5] = Be, fi[6] = Me, s4 = 1;
                            } else s4 = 0;
                          }
                          s4 && (s4 = (function(t6, r5) {
                            for (t6.M = 0; t6.M < t6.Va; ++t6.M) {
                              var o3, s5 = t6.Jc[t6.M & t6.Xb], c6 = t6.m, u7 = t6;
                              for (o3 = 0; o3 < u7.za; ++o3) {
                                var l6 = c6, h6 = u7, f7 = h6.Ac, d6 = h6.Bc + 4 * o3, p6 = h6.zc, g6 = h6.ya[h6.aa + o3];
                                if (h6.Qa.Bb ? g6.$b = k2(l6, h6.Pa.jb[0]) ? 2 + k2(l6, h6.Pa.jb[2]) : k2(l6, h6.Pa.jb[1]) : g6.$b = 0, h6.kc && (g6.Ad = k2(l6, h6.Bd)), g6.Za = !k2(l6, 145) + 0, g6.Za) {
                                  var m6 = g6.Ob, v5 = 0;
                                  for (h6 = 0; 4 > h6; ++h6) {
                                    var b4, y4 = p6[0 + h6];
                                    for (b4 = 0; 4 > b4; ++b4) {
                                      y4 = si[f7[d6 + b4]][y4];
                                      for (var w4 = ai[k2(l6, y4[0])]; 0 < w4; ) w4 = ai[2 * w4 + k2(l6, y4[w4])];
                                      y4 = -w4, f7[d6 + b4] = y4;
                                    }
                                    n2(m6, v5, f7, d6, 4), v5 += 4, p6[0 + h6] = y4;
                                  }
                                } else y4 = k2(l6, 156) ? k2(l6, 128) ? 1 : 3 : k2(l6, 163) ? 2 : 0, g6.Ob[0] = y4, i2(f7, d6, y4, 4), i2(p6, 0, y4, 4);
                                g6.Dd = k2(l6, 142) ? k2(l6, 114) ? k2(l6, 183) ? 1 : 3 : 2 : 0;
                              }
                              if (u7.m.Ka) return Jt2(t6, 7, "Premature end-of-partition0 encountered.");
                              for (; t6.ja < t6.za; ++t6.ja) {
                                if (u7 = s5, l6 = (c6 = t6).rb[c6.sb - 1], f7 = c6.rb[c6.sb + c6.ja], o3 = c6.ya[c6.aa + c6.ja], d6 = c6.kc ? o3.Ad : 0) l6.la = f7.la = 0, o3.Za || (l6.Na = f7.Na = 0), o3.Hc = 0, o3.Gc = 0, o3.ia = 0;
                                else {
                                  var N4, L5;
                                  if (l6 = f7, f7 = u7, d6 = c6.Pa.Xc, p6 = c6.ya[c6.aa + c6.ja], g6 = c6.pb[p6.$b], h6 = p6.ad, m6 = 0, v5 = c6.rb[c6.sb - 1], y4 = b4 = 0, i2(h6, m6, 0, 384), p6.Za) var x4 = 0, A5 = d6[3];
                                  else {
                                    w4 = a3(16);
                                    var S3 = l6.Na + v5.Na;
                                    if (S3 = ri(f7, d6[1], S3, g6.Eb, 0, w4, 0), l6.Na = v5.Na = (0 < S3) + 0, 1 < S3) nn(w4, 0, h6, m6);
                                    else {
                                      var _3 = w4[0] + 3 >> 3;
                                      for (w4 = 0; 256 > w4; w4 += 16) h6[m6 + w4] = _3;
                                    }
                                    x4 = 1, A5 = d6[0];
                                  }
                                  var P3 = 15 & l6.la, F4 = 15 & v5.la;
                                  for (w4 = 0; 4 > w4; ++w4) {
                                    var I3 = 1 & F4;
                                    for (_3 = L5 = 0; 4 > _3; ++_3) P3 = P3 >> 1 | (I3 = (S3 = ri(f7, A5, S3 = I3 + (1 & P3), g6.Sc, x4, h6, m6)) > x4) << 7, L5 = L5 << 2 | (3 < S3 ? 3 : 1 < S3 ? 2 : 0 != h6[m6 + 0]), m6 += 16;
                                    P3 >>= 4, F4 = F4 >> 1 | I3 << 7, b4 = (b4 << 8 | L5) >>> 0;
                                  }
                                  for (A5 = P3, x4 = F4 >> 4, N4 = 0; 4 > N4; N4 += 2) {
                                    for (L5 = 0, P3 = l6.la >> 4 + N4, F4 = v5.la >> 4 + N4, w4 = 0; 2 > w4; ++w4) {
                                      for (I3 = 1 & F4, _3 = 0; 2 > _3; ++_3) S3 = I3 + (1 & P3), P3 = P3 >> 1 | (I3 = 0 < (S3 = ri(f7, d6[2], S3, g6.Qc, 0, h6, m6))) << 3, L5 = L5 << 2 | (3 < S3 ? 3 : 1 < S3 ? 2 : 0 != h6[m6 + 0]), m6 += 16;
                                      P3 >>= 2, F4 = F4 >> 1 | I3 << 5;
                                    }
                                    y4 |= L5 << 4 * N4, A5 |= P3 << 4 << N4, x4 |= (240 & F4) << N4;
                                  }
                                  l6.la = A5, v5.la = x4, p6.Hc = b4, p6.Gc = y4, p6.ia = 43690 & y4 ? 0 : g6.ia, d6 = !(b4 | y4);
                                }
                                if (0 < c6.L && (c6.wa[c6.Y + c6.ja] = c6.gd[o3.$b][o3.Za], c6.wa[c6.Y + c6.ja].La |= !d6), u7.Ka) return Jt2(t6, 7, "Premature end-of-file encountered.");
                              }
                              if (Zt2(t6), c6 = r5, u7 = 1, o3 = (s5 = t6).D, l6 = 0 < s5.L && s5.M >= s5.zb && s5.M <= s5.Va, 0 == s5.Aa) e: {
                                if (o3.M = s5.M, o3.uc = l6, Cr(s5, o3), u7 = 1, o3 = (L5 = s5.D).Nb, l6 = (y4 = Ri[s5.L]) * s5.R, f7 = y4 / 2 * s5.B, w4 = 16 * o3 * s5.R, _3 = 8 * o3 * s5.B, d6 = s5.sa, p6 = s5.ta - l6 + w4, g6 = s5.qa, h6 = s5.ra - f7 + _3, m6 = s5.Ha, v5 = s5.Ia - f7 + _3, F4 = 0 == (P3 = L5.M), b4 = P3 >= s5.Va - 1, 2 == s5.Aa && Cr(s5, L5), L5.uc) for (I3 = (S3 = s5).D.M, e3(S3.D.uc), L5 = S3.yb; L5 < S3.Hb; ++L5) {
                                  x4 = L5, A5 = I3;
                                  var j3 = (C3 = (z4 = S3).D).Nb;
                                  N4 = z4.R;
                                  var C3 = C3.wa[C3.Y + x4], O3 = z4.sa, B4 = z4.ta + 16 * j3 * N4 + 16 * x4, q3 = C3.dd, M3 = C3.tc;
                                  if (0 != M3) if (e3(3 <= M3), 1 == z4.L) 0 < x4 && yn(O3, B4, N4, M3 + 4), C3.La && Nn(O3, B4, N4, M3), 0 < A5 && bn(O3, B4, N4, M3 + 4), C3.La && wn(O3, B4, N4, M3);
                                  else {
                                    var E4 = z4.B, R3 = z4.qa, D3 = z4.ra + 8 * j3 * E4 + 8 * x4, T4 = z4.Ha, z4 = z4.Ia + 8 * j3 * E4 + 8 * x4;
                                    j3 = C3.ld, 0 < x4 && (hn(O3, B4, N4, M3 + 4, q3, j3), dn(R3, D3, T4, z4, E4, M3 + 4, q3, j3)), C3.La && (gn(O3, B4, N4, M3, q3, j3), vn(R3, D3, T4, z4, E4, M3, q3, j3)), 0 < A5 && (ln(O3, B4, N4, M3 + 4, q3, j3), fn(R3, D3, T4, z4, E4, M3 + 4, q3, j3)), C3.La && (pn(O3, B4, N4, M3, q3, j3), mn(R3, D3, T4, z4, E4, M3, q3, j3));
                                  }
                                }
                                if (s5.ia && alert("todo:DitherRow"), null != c6.put) {
                                  if (L5 = 16 * P3, P3 = 16 * (P3 + 1), F4 ? (c6.y = s5.sa, c6.O = s5.ta + w4, c6.f = s5.qa, c6.N = s5.ra + _3, c6.ea = s5.Ha, c6.W = s5.Ia + _3) : (L5 -= y4, c6.y = d6, c6.O = p6, c6.f = g6, c6.N = h6, c6.ea = m6, c6.W = v5), b4 || (P3 -= y4), P3 > c6.o && (P3 = c6.o), c6.F = null, c6.J = null, null != s5.Fa && 0 < s5.Fa.length && L5 < P3 && (c6.J = lr(s5, c6, L5, P3 - L5), c6.F = s5.mb, null == c6.F && 0 == c6.F.length)) {
                                    u7 = Jt2(s5, 3, "Could not decode alpha data.");
                                    break e;
                                  }
                                  L5 < c6.j && (y4 = c6.j - L5, L5 = c6.j, e3(!(1 & y4)), c6.O += s5.R * y4, c6.N += s5.B * (y4 >> 1), c6.W += s5.B * (y4 >> 1), null != c6.F && (c6.J += c6.width * y4)), L5 < P3 && (c6.O += c6.v, c6.N += c6.v >> 1, c6.W += c6.v >> 1, null != c6.F && (c6.J += c6.v), c6.ka = L5 - c6.j, c6.U = c6.va - c6.v, c6.T = P3 - L5, u7 = c6.put(c6));
                                }
                                o3 + 1 != s5.Ic || b4 || (n2(s5.sa, s5.ta - l6, d6, p6 + 16 * s5.R, l6), n2(s5.qa, s5.ra - f7, g6, h6 + 8 * s5.B, f7), n2(s5.Ha, s5.Ia - f7, m6, v5 + 8 * s5.B, f7));
                              }
                              if (!u7) return Jt2(t6, 6, "Output aborted.");
                            }
                            return 1;
                          })(t5, r4)), null != r4.bc && r4.bc(r4), s4 &= 1;
                        }
                        return s4 ? (t5.cb = 0, s4) : 0;
                      })(t4, c4) || (r3 = t4.a);
                    }
                  } else r3 = t4.a;
                }
                0 == r3 && null != h4.Oa && h4.Oa.fd && (r3 = qr(h4.ba));
              }
              h4 = r3;
            }
            l4 = 0 != h4 ? null : 11 > l4 ? f5.f.RGBA.eb : f5.f.kb.y;
          } else l4 = null;
          return l4;
        };
        var zi = [3, 4, 3, 4, 4, 2, 2, 4, 4, 4, 2, 1, 1];
      };
      function u3(t3, e4) {
        for (var r3 = "", n3 = 0; n3 < 4; n3++) r3 += String.fromCharCode(t3[e4++]);
        return r3;
      }
      function l2(t3, e4) {
        return t3[e4 + 0] | t3[e4 + 1] << 8;
      }
      function h2(t3, e4) {
        return (t3[e4 + 0] | t3[e4 + 1] << 8 | t3[e4 + 2] << 16) >>> 0;
      }
      function f3(t3, e4) {
        return (t3[e4 + 0] | t3[e4 + 1] << 8 | t3[e4 + 2] << 16 | t3[e4 + 3] << 24) >>> 0;
      }
      new c2();
      var d2 = [0], p2 = [0], g2 = [], m2 = new c2(), v2 = t2, b2 = (function(t3, e4) {
        var r3 = {}, n3 = 0, i3 = false, a4 = 0, o3 = 0;
        if (r3.frames = [], !/** @license
           * Copyright (c) 2017 Dominik Homberger
        
        Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
        
        The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
        
        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
        
        https://webpjs.appspot.com
        WebPRiffParser dominikhlbg@gmail.com
        */
        (function(t4, e5) {
          for (var r4 = 0; r4 < 4; r4++) if (t4[e5 + r4] != "RIFF".charCodeAt(r4)) return true;
          return false;
        })(t3, e4)) {
          for (f3(t3, e4 += 4), e4 += 8; e4 < t3.length; ) {
            var s3 = u3(t3, e4), c3 = f3(t3, e4 += 4);
            e4 += 4;
            var d3 = c3 + (1 & c3);
            switch (s3) {
              case "VP8 ":
              case "VP8L":
                void 0 === r3.frames[n3] && (r3.frames[n3] = {}), (m3 = r3.frames[n3]).src_off = i3 ? o3 : e4 - 8, m3.src_size = a4 + c3 + 8, n3++, i3 && (i3 = false, a4 = 0, o3 = 0);
                break;
              case "VP8X":
                (m3 = r3.header = {}).feature_flags = t3[e4];
                var p3 = e4 + 4;
                m3.canvas_width = 1 + h2(t3, p3), p3 += 3, m3.canvas_height = 1 + h2(t3, p3), p3 += 3;
                break;
              case "ALPH":
                i3 = true, a4 = d3 + 8, o3 = e4 - 8;
                break;
              case "ANIM":
                (m3 = r3.header).bgcolor = f3(t3, e4), p3 = e4 + 4, m3.loop_count = l2(t3, p3), p3 += 2;
                break;
              case "ANMF":
                var g3, m3;
                (m3 = r3.frames[n3] = {}).offset_x = 2 * h2(t3, e4), e4 += 3, m3.offset_y = 2 * h2(t3, e4), e4 += 3, m3.width = 1 + h2(t3, e4), e4 += 3, m3.height = 1 + h2(t3, e4), e4 += 3, m3.duration = h2(t3, e4), e4 += 3, g3 = t3[e4++], m3.dispose = 1 & g3, m3.blend = g3 >> 1 & 1;
            }
            "ANMF" != s3 && (e4 += d3);
          }
          return r3;
        }
      })(v2, 0);
      b2.response = v2, b2.rgbaoutput = true, b2.dataurl = false;
      var y2 = b2.header ? b2.header : null, w2 = b2.frames ? b2.frames : null;
      if (y2) {
        y2.loop_counter = y2.loop_count, d2 = [y2.canvas_height], p2 = [y2.canvas_width];
        for (var N2 = 0; N2 < w2.length && 0 != w2[N2].blend; N2++) ;
      }
      var L3 = w2[0], x2 = m2.WebPDecodeRGBA(v2, L3.src_off, L3.src_size, p2, d2);
      L3.rgba = x2, L3.imgwidth = p2[0], L3.imgheight = d2[0];
      for (var A3 = 0; A3 < p2[0] * d2[0] * 4; A3++) g2[A3] = x2[A3];
      return this.width = p2, this.height = d2, this.data = g2, this;
    }
    function re() {
      const t2 = this.internal.__metadata__.metadata, e3 = unescape(encodeURIComponent(t2));
      let r2;
      if (this.internal.__metadata__.rawXml) r2 = e3;
      else {
        const t3 = "</jspdf:metadata></rdf:Description></rdf:RDF>", n2 = "</x:xmpmeta>";
        r2 = '<x:xmpmeta xmlns:x="adobe:ns:meta/"><rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"><rdf:Description rdf:about="" xmlns:jspdf="' + this.internal.__metadata__.namespaceUri + '"><jspdf:metadata>' + e3.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;") + t3 + n2;
      }
      this.internal.__metadata__.metadataObjectNumber = this.internal.newObject(), this.internal.write("<< /Type /Metadata /Subtype /XML /Length " + r2.length + " >>"), this.internal.write("stream"), this.internal.write(r2), this.internal.write("endstream"), this.internal.write("endobj");
    }
    function ne() {
      this.internal.__metadata__.metadataObjectNumber && this.internal.write("/Metadata " + this.internal.__metadata__.metadataObjectNumber + " 0 R");
    }
    !(function(t2) {
      var e3, r2, i2, a3, o2, c2, u3, l2, h2, f3 = function(t3) {
        return t3 = t3 || {}, this.isStrokeTransparent = t3.isStrokeTransparent || false, this.strokeOpacity = t3.strokeOpacity || 1, this.strokeStyle = t3.strokeStyle || "#000000", this.fillStyle = t3.fillStyle || "#000000", this.isFillTransparent = t3.isFillTransparent || false, this.fillOpacity = t3.fillOpacity || 1, this.font = t3.font || "10px sans-serif", this.textBaseline = t3.textBaseline || "alphabetic", this.textAlign = t3.textAlign || "left", this.lineWidth = t3.lineWidth || 1, this.lineJoin = t3.lineJoin || "miter", this.lineCap = t3.lineCap || "butt", this.path = t3.path || [], this.transform = void 0 !== t3.transform ? t3.transform.clone() : new l2(), this.globalCompositeOperation = t3.globalCompositeOperation || "normal", this.globalAlpha = t3.globalAlpha || 1, this.clip_path = t3.clip_path || [], this.currentPoint = t3.currentPoint || new c2(), this.miterLimit = t3.miterLimit || 10, this.lastPoint = t3.lastPoint || new c2(), this.lineDashOffset = t3.lineDashOffset || 0, this.lineDash = t3.lineDash || [], this.margin = t3.margin || [0, 0, 0, 0], this.prevPageLastElemOffset = t3.prevPageLastElemOffset || 0, this.ignoreClearRect = "boolean" != typeof t3.ignoreClearRect || t3.ignoreClearRect, this;
      };
      t2.events.push(["initialized", function() {
        this.context2d = new d2(this), e3 = this.internal.f2, r2 = this.internal.getCoordinateString, i2 = this.internal.getVerticalCoordinateString, a3 = this.internal.getHorizontalCoordinate, o2 = this.internal.getVerticalCoordinate, c2 = this.internal.Point, u3 = this.internal.Rectangle, l2 = this.internal.Matrix, h2 = new f3();
      }]);
      var d2 = function(t3) {
        Object.defineProperty(this, "canvas", { get: function() {
          return { parentNode: false, style: false };
        } });
        var e4 = t3;
        Object.defineProperty(this, "pdf", { get: function() {
          return e4;
        } });
        var r3 = false;
        Object.defineProperty(this, "pageWrapXEnabled", { get: function() {
          return r3;
        }, set: function(t4) {
          r3 = Boolean(t4);
        } });
        var n2 = false;
        Object.defineProperty(this, "pageWrapYEnabled", { get: function() {
          return n2;
        }, set: function(t4) {
          n2 = Boolean(t4);
        } });
        var i3 = 0;
        Object.defineProperty(this, "posX", { get: function() {
          return i3;
        }, set: function(t4) {
          isNaN(t4) || (i3 = t4);
        } });
        var a4 = 0;
        Object.defineProperty(this, "posY", { get: function() {
          return a4;
        }, set: function(t4) {
          isNaN(t4) || (a4 = t4);
        } }), Object.defineProperty(this, "margin", { get: function() {
          return h2.margin;
        }, set: function(t4) {
          var e5;
          "number" == typeof t4 ? e5 = [t4, t4, t4, t4] : ((e5 = new Array(4))[0] = t4[0], e5[1] = t4.length >= 2 ? t4[1] : e5[0], e5[2] = t4.length >= 3 ? t4[2] : e5[0], e5[3] = t4.length >= 4 ? t4[3] : e5[1]), h2.margin = e5;
        } });
        var o3 = false;
        Object.defineProperty(this, "autoPaging", { get: function() {
          return o3;
        }, set: function(t4) {
          o3 = t4;
        } });
        var s2 = 0;
        Object.defineProperty(this, "lastBreak", { get: function() {
          return s2;
        }, set: function(t4) {
          s2 = t4;
        } });
        var c3 = [];
        Object.defineProperty(this, "pageBreaks", { get: function() {
          return c3;
        }, set: function(t4) {
          c3 = t4;
        } }), Object.defineProperty(this, "ctx", { get: function() {
          return h2;
        }, set: function(t4) {
          t4 instanceof f3 && (h2 = t4);
        } }), Object.defineProperty(this, "path", { get: function() {
          return h2.path;
        }, set: function(t4) {
          h2.path = t4;
        } });
        var u4 = [];
        Object.defineProperty(this, "ctxStack", { get: function() {
          return u4;
        }, set: function(t4) {
          u4 = t4;
        } }), Object.defineProperty(this, "fillStyle", { get: function() {
          return this.ctx.fillStyle;
        }, set: function(t4) {
          var e5;
          e5 = p2(t4), this.ctx.fillStyle = e5.style, this.ctx.isFillTransparent = 0 === e5.a, this.ctx.fillOpacity = e5.a, this.pdf.setFillColor(e5.r, e5.g, e5.b, { a: e5.a }), this.pdf.setTextColor(e5.r, e5.g, e5.b, { a: e5.a });
        } }), Object.defineProperty(this, "strokeStyle", { get: function() {
          return this.ctx.strokeStyle;
        }, set: function(t4) {
          var e5 = p2(t4);
          this.ctx.strokeStyle = e5.style, this.ctx.isStrokeTransparent = 0 === e5.a, this.ctx.strokeOpacity = e5.a, 0 === e5.a ? this.pdf.setDrawColor(255, 255, 255) : (e5.a, this.pdf.setDrawColor(e5.r, e5.g, e5.b));
        } }), Object.defineProperty(this, "lineCap", { get: function() {
          return this.ctx.lineCap;
        }, set: function(t4) {
          -1 !== ["butt", "round", "square"].indexOf(t4) && (this.ctx.lineCap = t4, this.pdf.setLineCap(t4));
        } }), Object.defineProperty(this, "lineWidth", { get: function() {
          return this.ctx.lineWidth;
        }, set: function(t4) {
          isNaN(t4) || (this.ctx.lineWidth = t4, this.pdf.setLineWidth(t4));
        } }), Object.defineProperty(this, "lineJoin", { get: function() {
          return this.ctx.lineJoin;
        }, set: function(t4) {
          -1 !== ["bevel", "round", "miter"].indexOf(t4) && (this.ctx.lineJoin = t4, this.pdf.setLineJoin(t4));
        } }), Object.defineProperty(this, "miterLimit", { get: function() {
          return this.ctx.miterLimit;
        }, set: function(t4) {
          isNaN(t4) || (this.ctx.miterLimit = t4, this.pdf.setMiterLimit(t4));
        } }), Object.defineProperty(this, "textBaseline", { get: function() {
          return this.ctx.textBaseline;
        }, set: function(t4) {
          this.ctx.textBaseline = t4;
        } }), Object.defineProperty(this, "textAlign", { get: function() {
          return this.ctx.textAlign;
        }, set: function(t4) {
          -1 !== ["right", "end", "center", "left", "start"].indexOf(t4) && (this.ctx.textAlign = t4);
        } });
        var l3 = null, d3 = null;
        var g3 = null;
        Object.defineProperty(this, "fontFaces", { get: function() {
          return g3;
        }, set: function(t4) {
          l3 = null, d3 = null, g3 = t4;
        } }), Object.defineProperty(this, "font", { get: function() {
          return this.ctx.font;
        }, set: function(t4) {
          var e5;
          if (this.ctx.font = t4, null !== (e5 = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-_,\"\'\sa-z0-9]+?)\s*$/i.exec(t4))) {
            var r4 = e5[1];
            e5[2];
            var n3 = e5[3], i4 = e5[4];
            e5[5];
            var a5 = e5[6], o4 = /^([.\d]+)((?:%|in|[cem]m|ex|p[ctx]))$/i.exec(i4)[2];
            i4 = "px" === o4 ? Math.floor(parseFloat(i4) * this.pdf.internal.scaleFactor) : "em" === o4 ? Math.floor(parseFloat(i4) * this.pdf.getFontSize()) : Math.floor(parseFloat(i4) * this.pdf.internal.scaleFactor), this.pdf.setFontSize(i4);
            var s3 = (function(t5) {
              var e6, r5, n4 = [], i5 = t5.trim();
              if ("" === i5) return Dt;
              if (i5 in Ft) return [Ft[i5]];
              for (; "" !== i5; ) {
                switch (r5 = null, e6 = (i5 = jt(i5)).charAt(0)) {
                  case '"':
                  case "'":
                    r5 = Ct(i5.substring(1), e6);
                    break;
                  default:
                    r5 = Ot(i5);
                }
                if (null === r5) return Dt;
                if (n4.push(r5[0]), "" !== (i5 = jt(r5[1])) && "," !== i5.charAt(0)) return Dt;
                i5 = i5.replace(/^,/, "");
              }
              return n4;
            })(a5);
            if (this.fontFaces) {
              var c4 = (function(t5, e6) {
                var r5 = t5.getFontList(), n4 = JSON.stringify(r5);
                if (null === l3 || d3 !== n4) {
                  var i5 = (function(t6) {
                    var e7 = [];
                    return Object.keys(t6).forEach(function(r6) {
                      t6[r6].forEach(function(t7) {
                        var n5 = null;
                        switch (t7) {
                          case "bold":
                            n5 = { family: r6, weight: "bold" };
                            break;
                          case "italic":
                            n5 = { family: r6, style: "italic" };
                            break;
                          case "bolditalic":
                            n5 = { family: r6, weight: "bold", style: "italic" };
                            break;
                          case "":
                          case "normal":
                            n5 = { family: r6 };
                        }
                        null !== n5 && (n5.ref = { name: r6, style: t7 }, e7.push(n5));
                      });
                    }), e7;
                  })(r5);
                  l3 = (function(t6) {
                    for (var e7 = {}, r6 = 0; r6 < t6.length; ++r6) {
                      var n5 = _t(t6[r6]), i6 = n5.family, a6 = n5.stretch, o5 = n5.style, s4 = n5.weight;
                      e7[i6] = e7[i6] || {}, e7[i6][a6] = e7[i6][a6] || {}, e7[i6][a6][o5] = e7[i6][a6][o5] || {}, e7[i6][a6][o5][s4] = n5;
                    }
                    return e7;
                  })(i5.concat(e6)), d3 = n4;
                }
                return l3;
              })(this.pdf, this.fontFaces), u5 = s3.map(function(t5) {
                return { family: t5, stretch: "normal", weight: n3, style: r4 };
              }), h3 = (function(t5, e6, r5) {
                for (var n4 = (r5 = r5 || {}).defaultFontFamily || "times", i5 = Object.assign({}, kt, r5.genericFontFamilies || {}), a6 = null, o5 = null, s4 = 0; s4 < e6.length; ++s4) if (i5[(a6 = _t(e6[s4])).family] && (a6.family = i5[a6.family]), t5.hasOwnProperty(a6.family)) {
                  o5 = t5[a6.family];
                  break;
                }
                if (!(o5 = o5 || t5[n4])) throw new Error("Could not find a font-family for the rule '" + It(a6) + "' and default family '" + n4 + "'.");
                if (o5 = (function(t6, e7) {
                  if (e7[t6]) return e7[t6];
                  var r6 = xt[t6], n5 = r6 <= xt.normal ? -1 : 1, i6 = Pt(e7, Lt, r6, n5);
                  if (!i6) throw new Error("Could not find a matching font-stretch value for " + t6);
                  return i6;
                })(a6.stretch, o5), o5 = (function(t6, e7) {
                  if (e7[t6]) return e7[t6];
                  for (var r6 = Nt[t6], n5 = 0; n5 < r6.length; ++n5) if (e7[r6[n5]]) return e7[r6[n5]];
                  throw new Error("Could not find a matching font-style for " + t6);
                })(a6.style, o5), !(o5 = (function(t6, e7) {
                  if (e7[t6]) return e7[t6];
                  if (400 === t6 && e7[500]) return e7[500];
                  if (500 === t6 && e7[400]) return e7[400];
                  var r6 = St[t6], n5 = Pt(e7, At, r6, t6 < 400 ? -1 : 1);
                  if (!n5) throw new Error("Could not find a matching font-weight for value " + t6);
                  return n5;
                })(a6.weight, o5))) throw new Error("Failed to resolve a font for the rule '" + It(a6) + "'.");
                return o5;
              })(c4, u5);
              this.pdf.setFont(h3.ref.name, h3.ref.style);
            } else {
              var f4 = "";
              ("bold" === n3 || parseInt(n3, 10) >= 700 || "bold" === r4) && (f4 = "bold"), "italic" === r4 && (f4 += "italic"), 0 === f4.length && (f4 = "normal");
              for (var p3 = "", g4 = { arial: "Helvetica", Arial: "Helvetica", verdana: "Helvetica", Verdana: "Helvetica", helvetica: "Helvetica", Helvetica: "Helvetica", "sans-serif": "Helvetica", fixed: "Courier", monospace: "Courier", terminal: "Courier", cursive: "Times", fantasy: "Times", serif: "Times" }, m3 = 0; m3 < s3.length; m3++) {
                if (void 0 !== this.pdf.internal.getFont(s3[m3], f4, { noFallback: true, disableWarning: true })) {
                  p3 = s3[m3];
                  break;
                }
                if ("bolditalic" === f4 && void 0 !== this.pdf.internal.getFont(s3[m3], "bold", { noFallback: true, disableWarning: true })) p3 = s3[m3], f4 = "bold";
                else if (void 0 !== this.pdf.internal.getFont(s3[m3], "normal", { noFallback: true, disableWarning: true })) {
                  p3 = s3[m3], f4 = "normal";
                  break;
                }
              }
              if ("" === p3) {
                for (var v3 = 0; v3 < s3.length; v3++) if (g4[s3[v3]]) {
                  p3 = g4[s3[v3]];
                  break;
                }
              }
              p3 = "" === p3 ? "Times" : p3, this.pdf.setFont(p3, f4);
            }
          }
        } }), Object.defineProperty(this, "globalCompositeOperation", { get: function() {
          return this.ctx.globalCompositeOperation;
        }, set: function(t4) {
          this.ctx.globalCompositeOperation = t4;
        } }), Object.defineProperty(this, "globalAlpha", { get: function() {
          return this.ctx.globalAlpha;
        }, set: function(t4) {
          this.ctx.globalAlpha = t4;
        } }), Object.defineProperty(this, "lineDashOffset", { get: function() {
          return this.ctx.lineDashOffset;
        }, set: function(t4) {
          this.ctx.lineDashOffset = t4, D2.call(this);
        } }), Object.defineProperty(this, "lineDash", { get: function() {
          return this.ctx.lineDash;
        }, set: function(t4) {
          this.ctx.lineDash = t4, D2.call(this);
        } }), Object.defineProperty(this, "ignoreClearRect", { get: function() {
          return this.ctx.ignoreClearRect;
        }, set: function(t4) {
          this.ctx.ignoreClearRect = Boolean(t4);
        } });
      };
      d2.prototype.setLineDash = function(t3) {
        this.lineDash = t3;
      }, d2.prototype.getLineDash = function() {
        return this.lineDash.length % 2 ? this.lineDash.concat(this.lineDash) : this.lineDash.slice();
      }, d2.prototype.fill = function() {
        L3.call(this, "fill", false);
      }, d2.prototype.stroke = function() {
        L3.call(this, "stroke", false);
      }, d2.prototype.beginPath = function() {
        this.path = [{ type: "begin" }];
      }, d2.prototype.moveTo = function(t3, e4) {
        if (isNaN(t3) || isNaN(e4)) throw s.error("jsPDF.context2d.moveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.moveTo");
        var r3 = this.ctx.transform.applyToPoint(new c2(t3, e4));
        this.path.push({ type: "mt", x: r3.x, y: r3.y }), this.ctx.lastPoint = new c2(t3, e4);
      }, d2.prototype.closePath = function() {
        var t3 = new c2(0, 0), e4 = 0;
        for (e4 = this.path.length - 1; -1 !== e4; e4--) if ("begin" === this.path[e4].type && "object" == typeof this.path[e4 + 1] && "number" == typeof this.path[e4 + 1].x) {
          t3 = new c2(this.path[e4 + 1].x, this.path[e4 + 1].y);
          break;
        }
        this.path.push({ type: "close" }), this.ctx.lastPoint = new c2(t3.x, t3.y);
      }, d2.prototype.lineTo = function(t3, e4) {
        if (isNaN(t3) || isNaN(e4)) throw s.error("jsPDF.context2d.lineTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.lineTo");
        var r3 = this.ctx.transform.applyToPoint(new c2(t3, e4));
        this.path.push({ type: "lt", x: r3.x, y: r3.y }), this.ctx.lastPoint = new c2(r3.x, r3.y);
      }, d2.prototype.clip = function() {
        this.ctx.clip_path = JSON.parse(JSON.stringify(this.path)), L3.call(this, null, true);
      }, d2.prototype.quadraticCurveTo = function(t3, e4, r3, n2) {
        if (isNaN(r3) || isNaN(n2) || isNaN(t3) || isNaN(e4)) throw s.error("jsPDF.context2d.quadraticCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.quadraticCurveTo");
        var i3 = this.ctx.transform.applyToPoint(new c2(r3, n2)), a4 = this.ctx.transform.applyToPoint(new c2(t3, e4));
        this.path.push({ type: "qct", x1: a4.x, y1: a4.y, x: i3.x, y: i3.y }), this.ctx.lastPoint = new c2(i3.x, i3.y);
      }, d2.prototype.bezierCurveTo = function(t3, e4, r3, n2, i3, a4) {
        if (isNaN(i3) || isNaN(a4) || isNaN(t3) || isNaN(e4) || isNaN(r3) || isNaN(n2)) throw s.error("jsPDF.context2d.bezierCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.bezierCurveTo");
        var o3 = this.ctx.transform.applyToPoint(new c2(i3, a4)), u4 = this.ctx.transform.applyToPoint(new c2(t3, e4)), l3 = this.ctx.transform.applyToPoint(new c2(r3, n2));
        this.path.push({ type: "bct", x1: u4.x, y1: u4.y, x2: l3.x, y2: l3.y, x: o3.x, y: o3.y }), this.ctx.lastPoint = new c2(o3.x, o3.y);
      }, d2.prototype.arc = function(t3, e4, r3, n2, i3, a4) {
        if (isNaN(t3) || isNaN(e4) || isNaN(r3) || isNaN(n2) || isNaN(i3)) throw s.error("jsPDF.context2d.arc: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.arc");
        if (a4 = Boolean(a4), !this.ctx.transform.isIdentity) {
          var o3 = this.ctx.transform.applyToPoint(new c2(t3, e4));
          t3 = o3.x, e4 = o3.y;
          var u4 = this.ctx.transform.applyToPoint(new c2(0, r3)), l3 = this.ctx.transform.applyToPoint(new c2(0, 0));
          r3 = Math.sqrt(Math.pow(u4.x - l3.x, 2) + Math.pow(u4.y - l3.y, 2));
        }
        Math.abs(i3 - n2) >= 2 * Math.PI && (n2 = 0, i3 = 2 * Math.PI), this.path.push({ type: "arc", x: t3, y: e4, radius: r3, startAngle: n2, endAngle: i3, counterclockwise: a4 });
      }, d2.prototype.arcTo = function(t3, e4, r3, n2, i3) {
        throw new Error("arcTo not implemented.");
      }, d2.prototype.rect = function(t3, e4, r3, n2) {
        if (isNaN(t3) || isNaN(e4) || isNaN(r3) || isNaN(n2)) throw s.error("jsPDF.context2d.rect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rect");
        this.moveTo(t3, e4), this.lineTo(t3 + r3, e4), this.lineTo(t3 + r3, e4 + n2), this.lineTo(t3, e4 + n2), this.lineTo(t3, e4), this.lineTo(t3 + r3, e4), this.lineTo(t3, e4);
      }, d2.prototype.fillRect = function(t3, e4, r3, n2) {
        if (isNaN(t3) || isNaN(e4) || isNaN(r3) || isNaN(n2)) throw s.error("jsPDF.context2d.fillRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillRect");
        if (!g2.call(this)) {
          var i3 = {};
          "butt" !== this.lineCap && (i3.lineCap = this.lineCap, this.lineCap = "butt"), "miter" !== this.lineJoin && (i3.lineJoin = this.lineJoin, this.lineJoin = "miter"), this.beginPath(), this.rect(t3, e4, r3, n2), this.fill(), i3.hasOwnProperty("lineCap") && (this.lineCap = i3.lineCap), i3.hasOwnProperty("lineJoin") && (this.lineJoin = i3.lineJoin);
        }
      }, d2.prototype.strokeRect = function(t3, e4, r3, n2) {
        if (isNaN(t3) || isNaN(e4) || isNaN(r3) || isNaN(n2)) throw s.error("jsPDF.context2d.strokeRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeRect");
        m2.call(this) || (this.beginPath(), this.rect(t3, e4, r3, n2), this.stroke());
      }, d2.prototype.clearRect = function(t3, e4, r3, n2) {
        if (isNaN(t3) || isNaN(e4) || isNaN(r3) || isNaN(n2)) throw s.error("jsPDF.context2d.clearRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.clearRect");
        this.ignoreClearRect || (this.fillStyle = "#ffffff", this.fillRect(t3, e4, r3, n2));
      }, d2.prototype.save = function(t3) {
        t3 = "boolean" != typeof t3 || t3;
        for (var e4 = this.pdf.internal.getCurrentPageInfo().pageNumber, r3 = 0; r3 < this.pdf.internal.getNumberOfPages(); r3++) this.pdf.setPage(r3 + 1), this.pdf.internal.out("q");
        if (this.pdf.setPage(e4), t3) {
          this.ctx.fontSize = this.pdf.internal.getFontSize();
          var n2 = new f3(this.ctx);
          this.ctxStack.push(this.ctx), this.ctx = n2;
        }
      }, d2.prototype.restore = function(t3) {
        t3 = "boolean" != typeof t3 || t3;
        for (var e4 = this.pdf.internal.getCurrentPageInfo().pageNumber, r3 = 0; r3 < this.pdf.internal.getNumberOfPages(); r3++) this.pdf.setPage(r3 + 1), this.pdf.internal.out("Q");
        this.pdf.setPage(e4), t3 && 0 !== this.ctxStack.length && (this.ctx = this.ctxStack.pop(), this.fillStyle = this.ctx.fillStyle, this.strokeStyle = this.ctx.strokeStyle, this.font = this.ctx.font, this.lineCap = this.ctx.lineCap, this.lineWidth = this.ctx.lineWidth, this.lineJoin = this.ctx.lineJoin, this.lineDash = this.ctx.lineDash, this.lineDashOffset = this.ctx.lineDashOffset);
      }, d2.prototype.toDataURL = function() {
        throw new Error("toDataUrl not implemented.");
      };
      var p2 = function(t3) {
        var e4, r3, i3, a4;
        if (true === t3.isCanvasGradient && (t3 = t3.getColor()), !t3) return { r: 0, g: 0, b: 0, a: 0, style: t3 };
        if (/transparent|rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*0+\s*\)/.test(t3)) e4 = 0, r3 = 0, i3 = 0, a4 = 0;
        else {
          var o3 = /rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/.exec(t3);
          if (null !== o3) e4 = parseInt(o3[1]), r3 = parseInt(o3[2]), i3 = parseInt(o3[3]), a4 = 1;
          else if (null !== (o3 = /rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d.]+)\s*\)/.exec(t3))) e4 = parseInt(o3[1]), r3 = parseInt(o3[2]), i3 = parseInt(o3[3]), a4 = parseFloat(o3[4]);
          else {
            if (a4 = 1, "string" == typeof t3 && "#" !== t3.charAt(0)) {
              var s2 = new n(t3);
              t3 = s2.ok ? s2.toHex() : "#000000";
            }
            4 === t3.length ? (e4 = t3.substring(1, 2), e4 += e4, r3 = t3.substring(2, 3), r3 += r3, i3 = t3.substring(3, 4), i3 += i3) : (e4 = t3.substring(1, 3), r3 = t3.substring(3, 5), i3 = t3.substring(5, 7)), e4 = parseInt(e4, 16), r3 = parseInt(r3, 16), i3 = parseInt(i3, 16);
          }
        }
        return { r: e4, g: r3, b: i3, a: a4, style: t3 };
      }, g2 = function() {
        return this.ctx.isFillTransparent || 0 == this.globalAlpha;
      }, m2 = function() {
        return Boolean(this.ctx.isStrokeTransparent || 0 == this.globalAlpha);
      };
      d2.prototype.fillText = function(t3, e4, r3, n2) {
        if (isNaN(e4) || isNaN(r3) || "string" != typeof t3) throw s.error("jsPDF.context2d.fillText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillText");
        if (n2 = isNaN(n2) ? void 0 : n2, !g2.call(this)) {
          var i3 = M2(this.ctx.transform.rotation), a4 = this.ctx.transform.scaleX;
          I2.call(this, { text: t3, x: e4, y: r3, scale: a4, angle: i3, align: this.textAlign, maxWidth: n2 });
        }
      }, d2.prototype.strokeText = function(t3, e4, r3, n2) {
        if (isNaN(e4) || isNaN(r3) || "string" != typeof t3) throw s.error("jsPDF.context2d.strokeText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeText");
        if (!m2.call(this)) {
          n2 = isNaN(n2) ? void 0 : n2;
          var i3 = M2(this.ctx.transform.rotation), a4 = this.ctx.transform.scaleX;
          I2.call(this, { text: t3, x: e4, y: r3, scale: a4, renderingMode: "stroke", angle: i3, align: this.textAlign, maxWidth: n2 });
        }
      }, d2.prototype.measureText = function(t3) {
        if ("string" != typeof t3) throw s.error("jsPDF.context2d.measureText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.measureText");
        var e4 = this.pdf, r3 = this.pdf.internal.scaleFactor, n2 = e4.internal.getFontSize(), i3 = e4.getStringUnitWidth(t3) * n2 / e4.internal.scaleFactor;
        return new function(t4) {
          var e5 = (t4 = t4 || {}).width || 0;
          return Object.defineProperty(this, "width", { get: function() {
            return e5;
          } }), this;
        }({ width: i3 *= Math.round(96 * r3 / 72 * 1e4) / 1e4 });
      }, d2.prototype.scale = function(t3, e4) {
        if (isNaN(t3) || isNaN(e4)) throw s.error("jsPDF.context2d.scale: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.scale");
        var r3 = new l2(t3, 0, 0, e4, 0, 0);
        this.ctx.transform = this.ctx.transform.multiply(r3);
      }, d2.prototype.rotate = function(t3) {
        if (isNaN(t3)) throw s.error("jsPDF.context2d.rotate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rotate");
        var e4 = new l2(Math.cos(t3), Math.sin(t3), -Math.sin(t3), Math.cos(t3), 0, 0);
        this.ctx.transform = this.ctx.transform.multiply(e4);
      }, d2.prototype.translate = function(t3, e4) {
        if (isNaN(t3) || isNaN(e4)) throw s.error("jsPDF.context2d.translate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.translate");
        var r3 = new l2(1, 0, 0, 1, t3, e4);
        this.ctx.transform = this.ctx.transform.multiply(r3);
      }, d2.prototype.transform = function(t3, e4, r3, n2, i3, a4) {
        if (isNaN(t3) || isNaN(e4) || isNaN(r3) || isNaN(n2) || isNaN(i3) || isNaN(a4)) throw s.error("jsPDF.context2d.transform: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.transform");
        var o3 = new l2(t3, e4, r3, n2, i3, a4);
        this.ctx.transform = this.ctx.transform.multiply(o3);
      }, d2.prototype.setTransform = function(t3, e4, r3, n2, i3, a4) {
        t3 = isNaN(t3) ? 1 : t3, e4 = isNaN(e4) ? 0 : e4, r3 = isNaN(r3) ? 0 : r3, n2 = isNaN(n2) ? 1 : n2, i3 = isNaN(i3) ? 0 : i3, a4 = isNaN(a4) ? 0 : a4, this.ctx.transform = new l2(t3, e4, r3, n2, i3, a4);
      };
      var v2 = function() {
        return this.margin[0] > 0 || this.margin[1] > 0 || this.margin[2] > 0 || this.margin[3] > 0;
      };
      d2.prototype.drawImage = function(t3, e4, r3, n2, i3, a4, o3, s2, c3) {
        var h3 = this.pdf.getImageProperties(t3), f4 = 1, d3 = 1, p3 = 1, g3 = 1;
        void 0 !== n2 && void 0 !== s2 && (p3 = s2 / n2, g3 = c3 / i3, f4 = h3.width / n2 * s2 / n2, d3 = h3.height / i3 * c3 / i3), void 0 === a4 && (a4 = e4, o3 = r3, e4 = 0, r3 = 0), void 0 !== n2 && void 0 === s2 && (s2 = n2, c3 = i3), void 0 === n2 && void 0 === s2 && (s2 = h3.width, c3 = h3.height);
        var m3 = this.ctx.transform.decompose(), y3 = M2(m3.rotate.shx), L4 = new l2(), A4 = (L4 = (L4 = (L4 = L4.multiply(m3.translate)).multiply(m3.skew)).multiply(m3.scale)).applyToRectangle(new u3(a4 - e4 * p3, o3 - r3 * g3, n2 * f4, i3 * d3));
        if (this.autoPaging) {
          for (var S3, _3 = b2.call(this, A4), P3 = [], k3 = 0; k3 < _3.length; k3 += 1) -1 === P3.indexOf(_3[k3]) && P3.push(_3[k3]);
          N2(P3);
          for (var F4 = P3[0], I3 = P3[P3.length - 1], j3 = F4; j3 < I3 + 1; j3++) {
            this.pdf.setPage(j3);
            var C3 = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], O3 = 1 === j3 ? this.posY + this.margin[0] : this.margin[0], B4 = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], q3 = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], E4 = 1 === j3 ? 0 : B4 + (j3 - 2) * q3;
            if (0 !== this.ctx.clip_path.length) {
              var R3 = this.path;
              S3 = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = w2(S3, this.posX + this.margin[3], -E4 + O3 + this.ctx.prevPageLastElemOffset), x2.call(this, "fill", true), this.path = R3;
            }
            var D3 = JSON.parse(JSON.stringify(A4));
            D3 = w2([D3], this.posX + this.margin[3], -E4 + O3 + this.ctx.prevPageLastElemOffset)[0];
            const e5 = (j3 > F4 || j3 < I3) && v2.call(this);
            e5 && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], C3, q3, null).clip().discardPath()), this.pdf.addImage(t3, "JPEG", D3.x, D3.y, D3.w, D3.h, null, null, y3), e5 && this.pdf.restoreGraphicsState();
          }
        } else this.pdf.addImage(t3, "JPEG", A4.x, A4.y, A4.w, A4.h, null, null, y3);
      };
      var b2 = function(t3, e4, r3) {
        var n2 = [];
        e4 = e4 || this.pdf.internal.pageSize.width, r3 = r3 || this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2];
        var i3 = this.posY + this.ctx.prevPageLastElemOffset;
        switch (t3.type) {
          default:
          case "mt":
          case "lt":
            n2.push(Math.floor((t3.y + i3) / r3) + 1);
            break;
          case "arc":
            n2.push(Math.floor((t3.y + i3 - t3.radius) / r3) + 1), n2.push(Math.floor((t3.y + i3 + t3.radius) / r3) + 1);
            break;
          case "qct":
            var a4 = E3(this.ctx.lastPoint.x, this.ctx.lastPoint.y, t3.x1, t3.y1, t3.x, t3.y);
            n2.push(Math.floor((a4.y + i3) / r3) + 1), n2.push(Math.floor((a4.y + a4.h + i3) / r3) + 1);
            break;
          case "bct":
            var o3 = R2(this.ctx.lastPoint.x, this.ctx.lastPoint.y, t3.x1, t3.y1, t3.x2, t3.y2, t3.x, t3.y);
            n2.push(Math.floor((o3.y + i3) / r3) + 1), n2.push(Math.floor((o3.y + o3.h + i3) / r3) + 1);
            break;
          case "rect":
            n2.push(Math.floor((t3.y + i3) / r3) + 1), n2.push(Math.floor((t3.y + t3.h + i3) / r3) + 1);
        }
        for (var s2 = 0; s2 < n2.length; s2 += 1) for (; this.pdf.internal.getNumberOfPages() < n2[s2]; ) y2.call(this);
        return n2;
      }, y2 = function() {
        var t3 = this.fillStyle, e4 = this.strokeStyle, r3 = this.font, n2 = this.lineCap, i3 = this.lineWidth, a4 = this.lineJoin;
        this.pdf.addPage(), this.fillStyle = t3, this.strokeStyle = e4, this.font = r3, this.lineCap = n2, this.lineWidth = i3, this.lineJoin = a4;
      }, w2 = function(t3, e4, r3) {
        for (var n2 = 0; n2 < t3.length; n2++) switch (t3[n2].type) {
          case "bct":
            t3[n2].x2 += e4, t3[n2].y2 += r3;
          case "qct":
            t3[n2].x1 += e4, t3[n2].y1 += r3;
          default:
            t3[n2].x += e4, t3[n2].y += r3;
        }
        return t3;
      }, N2 = function(t3) {
        return t3.sort(function(t4, e4) {
          return t4 - e4;
        });
      }, L3 = function(t3, e4) {
        var r3 = this.fillStyle, n2 = this.strokeStyle, i3 = this.lineCap, a4 = this.lineWidth, o3 = Math.abs(a4 * this.ctx.transform.scaleX), s2 = this.lineJoin;
        if (this.autoPaging) {
          for (var c3, u4, l3 = JSON.parse(JSON.stringify(this.path)), h3 = JSON.parse(JSON.stringify(this.path)), f4 = [], d3 = 0; d3 < h3.length; d3++) if (void 0 !== h3[d3].x) for (var p3 = b2.call(this, h3[d3]), g3 = 0; g3 < p3.length; g3 += 1) -1 === f4.indexOf(p3[g3]) && f4.push(p3[g3]);
          for (var m3 = 0; m3 < f4.length; m3++) for (; this.pdf.internal.getNumberOfPages() < f4[m3]; ) y2.call(this);
          N2(f4);
          for (var L4 = f4[0], A4 = f4[f4.length - 1], S3 = L4; S3 < A4 + 1; S3++) {
            this.pdf.setPage(S3), this.fillStyle = r3, this.strokeStyle = n2, this.lineCap = i3, this.lineWidth = o3, this.lineJoin = s2;
            var _3 = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], P3 = 1 === S3 ? this.posY + this.margin[0] : this.margin[0], k3 = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], F4 = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], I3 = 1 === S3 ? 0 : k3 + (S3 - 2) * F4;
            if (0 !== this.ctx.clip_path.length) {
              var j3 = this.path;
              c3 = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = w2(c3, this.posX + this.margin[3], -I3 + P3 + this.ctx.prevPageLastElemOffset), x2.call(this, t3, true), this.path = j3;
            }
            if (u4 = JSON.parse(JSON.stringify(l3)), this.path = w2(u4, this.posX + this.margin[3], -I3 + P3 + this.ctx.prevPageLastElemOffset), false === e4 || 0 === S3) {
              const r4 = (S3 > L4 || S3 < A4) && v2.call(this);
              r4 && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], _3, F4, null).clip().discardPath()), x2.call(this, t3, e4), r4 && this.pdf.restoreGraphicsState();
            }
            this.lineWidth = a4;
          }
          this.path = l3;
        } else this.lineWidth = o3, x2.call(this, t3, e4), this.lineWidth = a4;
      }, x2 = function(t3, e4) {
        if (("stroke" !== t3 || e4 || !m2.call(this)) && ("stroke" === t3 || e4 || !g2.call(this))) {
          for (var r3, n2, i3 = [], a4 = this.path, o3 = 0; o3 < a4.length; o3++) {
            var s2 = a4[o3];
            switch (s2.type) {
              case "begin":
                i3.push({ begin: true });
                break;
              case "close":
                i3.push({ close: true });
                break;
              case "mt":
                i3.push({ start: s2, deltas: [], abs: [] });
                break;
              case "lt":
                var c3 = i3.length;
                if (a4[o3 - 1] && !isNaN(a4[o3 - 1].x) && (r3 = [s2.x - a4[o3 - 1].x, s2.y - a4[o3 - 1].y], c3 > 0)) {
                  for (; c3 >= 0; c3--) if (true !== i3[c3 - 1].close && true !== i3[c3 - 1].begin) {
                    i3[c3 - 1].deltas.push(r3), i3[c3 - 1].abs.push(s2);
                    break;
                  }
                }
                break;
              case "bct":
                r3 = [s2.x1 - a4[o3 - 1].x, s2.y1 - a4[o3 - 1].y, s2.x2 - a4[o3 - 1].x, s2.y2 - a4[o3 - 1].y, s2.x - a4[o3 - 1].x, s2.y - a4[o3 - 1].y], i3[i3.length - 1].deltas.push(r3);
                break;
              case "qct":
                var u4 = a4[o3 - 1].x + 2 / 3 * (s2.x1 - a4[o3 - 1].x), l3 = a4[o3 - 1].y + 2 / 3 * (s2.y1 - a4[o3 - 1].y), h3 = s2.x + 2 / 3 * (s2.x1 - s2.x), f4 = s2.y + 2 / 3 * (s2.y1 - s2.y), d3 = s2.x, p3 = s2.y;
                r3 = [u4 - a4[o3 - 1].x, l3 - a4[o3 - 1].y, h3 - a4[o3 - 1].x, f4 - a4[o3 - 1].y, d3 - a4[o3 - 1].x, p3 - a4[o3 - 1].y], i3[i3.length - 1].deltas.push(r3);
                break;
              case "arc":
                i3.push({ deltas: [], abs: [], arc: true }), Array.isArray(i3[i3.length - 1].abs) && i3[i3.length - 1].abs.push(s2);
            }
          }
          n2 = e4 ? null : "stroke" === t3 ? "stroke" : "fill";
          for (var v3 = false, b3 = 0; b3 < i3.length; b3++) if (i3[b3].arc) for (var y3 = i3[b3].abs, w3 = 0; w3 < y3.length; w3++) {
            var N3 = y3[w3];
            "arc" === N3.type ? _2.call(this, N3.x, N3.y, N3.radius, N3.startAngle, N3.endAngle, N3.counterclockwise, void 0, e4, !v3) : j2.call(this, N3.x, N3.y), v3 = true;
          }
          else if (true === i3[b3].close) this.pdf.internal.out("h"), v3 = false;
          else if (true !== i3[b3].begin) {
            var L4 = i3[b3].start.x, x3 = i3[b3].start.y;
            C2.call(this, i3[b3].deltas, L4, x3), v3 = true;
          }
          n2 && P2.call(this, n2), e4 && k2.call(this);
        }
      }, A3 = function(t3) {
        var e4 = this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor, r3 = e4 * (this.pdf.internal.getLineHeightFactor() - 1);
        switch (this.ctx.textBaseline) {
          case "bottom":
            return t3 - r3;
          case "top":
            return t3 + e4 - r3;
          case "hanging":
            return t3 + e4 - 2 * r3;
          case "middle":
            return t3 + e4 / 2 - r3;
          default:
            return t3;
        }
      }, S2 = function(t3) {
        return t3 + this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor * (this.pdf.internal.getLineHeightFactor() - 1);
      };
      d2.prototype.createLinearGradient = function() {
        var t3 = function() {
        };
        return t3.colorStops = [], t3.addColorStop = function(t4, e4) {
          this.colorStops.push([t4, e4]);
        }, t3.getColor = function() {
          return 0 === this.colorStops.length ? "#000000" : this.colorStops[0][1];
        }, t3.isCanvasGradient = true, t3;
      }, d2.prototype.createPattern = function() {
        return this.createLinearGradient();
      }, d2.prototype.createRadialGradient = function() {
        return this.createLinearGradient();
      };
      var _2 = function(t3, e4, r3, n2, i3, a4, o3, s2, c3) {
        for (var u4 = B3.call(this, r3, n2, i3, a4), l3 = 0; l3 < u4.length; l3++) {
          var h3 = u4[l3];
          0 === l3 && (c3 ? F3.call(this, h3.x1 + t3, h3.y1 + e4) : j2.call(this, h3.x1 + t3, h3.y1 + e4)), O2.call(this, t3, e4, h3.x2, h3.y2, h3.x3, h3.y3, h3.x4, h3.y4);
        }
        s2 ? k2.call(this) : P2.call(this, o3);
      }, P2 = function(t3) {
        switch (t3) {
          case "stroke":
            this.pdf.internal.out("S");
            break;
          case "fill":
            this.pdf.internal.out("f");
        }
      }, k2 = function() {
        this.pdf.clip(), this.pdf.discardPath();
      }, F3 = function(t3, e4) {
        this.pdf.internal.out(r2(t3) + " " + i2(e4) + " m");
      }, I2 = function(t3) {
        var e4;
        switch (t3.align) {
          case "right":
          case "end":
            e4 = "right";
            break;
          case "center":
            e4 = "center";
            break;
          default:
            e4 = "left";
        }
        var r3, n2, i3, a4 = this.pdf.getTextDimensions(t3.text), o3 = A3.call(this, t3.y), s2 = S2.call(this, o3) - a4.h, h3 = this.ctx.transform.applyToPoint(new c2(t3.x, o3));
        if (this.autoPaging) {
          var f4 = this.ctx.transform.decompose(), d3 = new l2();
          d3 = (d3 = (d3 = d3.multiply(f4.translate)).multiply(f4.skew)).multiply(f4.scale);
          for (var p3 = this.ctx.transform.applyToRectangle(new u3(t3.x, o3, a4.w, a4.h)), g3 = d3.applyToRectangle(new u3(t3.x, s2, a4.w, a4.h)), m3 = b2.call(this, g3), y3 = [], L4 = 0; L4 < m3.length; L4 += 1) -1 === y3.indexOf(m3[L4]) && y3.push(m3[L4]);
          N2(y3);
          for (var _3 = y3[0], P3 = y3[y3.length - 1], k3 = _3; k3 < P3 + 1; k3++) {
            this.pdf.setPage(k3);
            var F4 = 1 === k3 ? this.posY + this.margin[0] : this.margin[0], I3 = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], j3 = this.pdf.internal.pageSize.height - this.margin[2], C3 = j3 - this.margin[0], O3 = this.pdf.internal.pageSize.width - this.margin[1], B4 = O3 - this.margin[3], q3 = 1 === k3 ? 0 : I3 + (k3 - 2) * C3;
            if (0 !== this.ctx.clip_path.length) {
              var M3 = this.path;
              r3 = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = w2(r3, this.posX + this.margin[3], -1 * q3 + F4), x2.call(this, "fill", true), this.path = M3;
            }
            var E4 = w2([JSON.parse(JSON.stringify(g3))], this.posX + this.margin[3], -q3 + F4 + this.ctx.prevPageLastElemOffset)[0];
            t3.scale >= 0.01 && (n2 = this.pdf.internal.getFontSize(), this.pdf.setFontSize(n2 * t3.scale), i3 = this.lineWidth, this.lineWidth = i3 * t3.scale);
            var R3 = "text" !== this.autoPaging;
            if (R3 || E4.y + E4.h <= j3) {
              if (R3 || E4.y >= F4 && E4.x <= O3) {
                var D3 = R3 ? t3.text : this.pdf.splitTextToSize(t3.text, t3.maxWidth || O3 - E4.x)[0], T3 = w2([JSON.parse(JSON.stringify(p3))], this.posX + this.margin[3], -q3 + F4 + this.ctx.prevPageLastElemOffset)[0];
                const r4 = R3 && (k3 > _3 || k3 < P3) && v2.call(this);
                r4 && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], B4, C3, null).clip().discardPath()), this.pdf.text(D3, T3.x, T3.y, { angle: t3.angle, align: e4, renderingMode: t3.renderingMode }), r4 && this.pdf.restoreGraphicsState();
              }
            } else E4.y < j3 && (this.ctx.prevPageLastElemOffset += j3 - E4.y);
            t3.scale >= 0.01 && (this.pdf.setFontSize(n2), this.lineWidth = i3);
          }
        } else t3.scale >= 0.01 && (n2 = this.pdf.internal.getFontSize(), this.pdf.setFontSize(n2 * t3.scale), i3 = this.lineWidth, this.lineWidth = i3 * t3.scale), this.pdf.text(t3.text, h3.x + this.posX, h3.y + this.posY, { angle: t3.angle, align: e4, renderingMode: t3.renderingMode, maxWidth: t3.maxWidth }), t3.scale >= 0.01 && (this.pdf.setFontSize(n2), this.lineWidth = i3);
      }, j2 = function(t3, e4, n2, a4) {
        n2 = n2 || 0, a4 = a4 || 0, this.pdf.internal.out(r2(t3 + n2) + " " + i2(e4 + a4) + " l");
      }, C2 = function(t3, e4, r3) {
        return this.pdf.lines(t3, e4, r3, null, null);
      }, O2 = function(t3, r3, n2, i3, s2, c3, u4, l3) {
        this.pdf.internal.out([e3(a3(n2 + t3)), e3(o2(i3 + r3)), e3(a3(s2 + t3)), e3(o2(c3 + r3)), e3(a3(u4 + t3)), e3(o2(l3 + r3)), "c"].join(" "));
      }, B3 = function(t3, e4, r3, n2) {
        for (var i3 = 2 * Math.PI, a4 = Math.PI / 2; e4 > r3; ) e4 -= i3;
        var o3 = Math.abs(r3 - e4);
        o3 < i3 && n2 && (o3 = i3 - o3);
        for (var s2 = [], c3 = n2 ? -1 : 1, u4 = e4; o3 > 1e-5; ) {
          var l3 = u4 + c3 * Math.min(o3, a4);
          s2.push(q2.call(this, t3, u4, l3)), o3 -= Math.abs(l3 - u4), u4 = l3;
        }
        return s2;
      }, q2 = function(t3, e4, r3) {
        var n2 = (r3 - e4) / 2, i3 = t3 * Math.cos(n2), a4 = t3 * Math.sin(n2), o3 = i3, s2 = -a4, c3 = o3 * o3 + s2 * s2, u4 = c3 + o3 * i3 + s2 * a4, l3 = 4 / 3 * (Math.sqrt(2 * c3 * u4) - u4) / (o3 * a4 - s2 * i3), h3 = o3 - l3 * s2, f4 = s2 + l3 * o3, d3 = h3, p3 = -f4, g3 = n2 + e4, m3 = Math.cos(g3), v3 = Math.sin(g3);
        return { x1: t3 * Math.cos(e4), y1: t3 * Math.sin(e4), x2: h3 * m3 - f4 * v3, y2: h3 * v3 + f4 * m3, x3: d3 * m3 - p3 * v3, y3: d3 * v3 + p3 * m3, x4: t3 * Math.cos(r3), y4: t3 * Math.sin(r3) };
      }, M2 = function(t3) {
        return 180 * t3 / Math.PI;
      }, E3 = function(t3, e4, r3, n2, i3, a4) {
        var o3 = t3 + 0.5 * (r3 - t3), s2 = e4 + 0.5 * (n2 - e4), c3 = i3 + 0.5 * (r3 - i3), l3 = a4 + 0.5 * (n2 - a4), h3 = Math.min(t3, i3, o3, c3), f4 = Math.max(t3, i3, o3, c3), d3 = Math.min(e4, a4, s2, l3), p3 = Math.max(e4, a4, s2, l3);
        return new u3(h3, d3, f4 - h3, p3 - d3);
      }, R2 = function(t3, e4, r3, n2, i3, a4, o3, s2) {
        var c3, l3, h3, f4, d3, p3, g3, m3, v3, b3, y3, w3, N3, L4, x3 = r3 - t3, A4 = n2 - e4, S3 = i3 - r3, _3 = a4 - n2, P3 = o3 - i3, k3 = s2 - a4;
        for (l3 = 0; l3 < 41; l3++) v3 = (g3 = (h3 = t3 + (c3 = l3 / 40) * x3) + c3 * ((d3 = r3 + c3 * S3) - h3)) + c3 * (d3 + c3 * (i3 + c3 * P3 - d3) - g3), b3 = (m3 = (f4 = e4 + c3 * A4) + c3 * ((p3 = n2 + c3 * _3) - f4)) + c3 * (p3 + c3 * (a4 + c3 * k3 - p3) - m3), 0 == l3 ? (y3 = v3, w3 = b3, N3 = v3, L4 = b3) : (y3 = Math.min(y3, v3), w3 = Math.min(w3, b3), N3 = Math.max(N3, v3), L4 = Math.max(L4, b3));
        return new u3(Math.round(y3), Math.round(w3), Math.round(N3 - y3), Math.round(L4 - w3));
      }, D2 = function() {
        if (!this.prevLineDash && !this.ctx.lineDash.length && !this.ctx.lineDashOffset) return;
        const t3 = (e4 = this.ctx.lineDash, r3 = this.ctx.lineDashOffset, JSON.stringify({ lineDash: e4, lineDashOffset: r3 }));
        var e4, r3;
        this.prevLineDash !== t3 && (this.pdf.setLineDash(this.ctx.lineDash, this.ctx.lineDashOffset), this.prevLineDash = t3);
      };
    })(j.API), /**
     * @license
     * jsPDF filters PlugIn
     * Copyright (c) 2014 Aras Abbasi
     *
     * Licensed under the MIT License.
     * http://opensource.org/licenses/mit-license
     */
    (function(e3) {
      var r2 = function(t2) {
        var e4, r3, n3, i3, a4, o3, s2, c2, u3, l2;
        for (/[^\x00-\xFF]/.test(t2), r3 = [], n3 = 0, i3 = (t2 += e4 = "\0\0\0\0".slice(t2.length % 4 || 4)).length; i3 > n3; n3 += 4) 0 !== (a4 = (t2.charCodeAt(n3) << 24) + (t2.charCodeAt(n3 + 1) << 16) + (t2.charCodeAt(n3 + 2) << 8) + t2.charCodeAt(n3 + 3)) ? (o3 = (a4 = ((a4 = ((a4 = ((a4 = (a4 - (l2 = a4 % 85)) / 85) - (u3 = a4 % 85)) / 85) - (c2 = a4 % 85)) / 85) - (s2 = a4 % 85)) / 85) % 85, r3.push(o3 + 33, s2 + 33, c2 + 33, u3 + 33, l2 + 33)) : r3.push(122);
        return (function(t3, e5) {
          for (var r4 = e5; r4 > 0; r4--) t3.pop();
        })(r3, e4.length), String.fromCharCode.apply(String, r3) + "~>";
      }, n2 = function(t2) {
        var e4, r3, n3, i3, a4, o3 = String, s2 = "length", c2 = 255, u3 = "charCodeAt", l2 = "slice", h2 = "replace";
        for (t2[l2](-2), t2 = t2[l2](0, -2)[h2](/\s/g, "")[h2]("z", "!!!!!"), n3 = [], i3 = 0, a4 = (t2 += e4 = "uuuuu"[l2](t2[s2] % 5 || 5))[s2]; a4 > i3; i3 += 5) r3 = 52200625 * (t2[u3](i3) - 33) + 614125 * (t2[u3](i3 + 1) - 33) + 7225 * (t2[u3](i3 + 2) - 33) + 85 * (t2[u3](i3 + 3) - 33) + (t2[u3](i3 + 4) - 33), n3.push(c2 & r3 >> 24, c2 & r3 >> 16, c2 & r3 >> 8, c2 & r3);
        return (function(t3, e5) {
          for (var r4 = e5; r4 > 0; r4--) t3.pop();
        })(n3, e4[s2]), o3.fromCharCode.apply(o3, n3);
      }, i2 = function(t2) {
        return t2.split("").map(function(t3) {
          return ("0" + t3.charCodeAt().toString(16)).slice(-2);
        }).join("") + ">";
      }, a3 = function(t2) {
        var e4 = new RegExp(/^([0-9A-Fa-f]{2})+$/);
        if (-1 !== (t2 = t2.replace(/\s/g, "")).indexOf(">") && (t2 = t2.substr(0, t2.indexOf(">"))), t2.length % 2 && (t2 += "0"), false === e4.test(t2)) return "";
        for (var r3 = "", n3 = 0; n3 < t2.length; n3 += 2) r3 += String.fromCharCode("0x" + (t2[n3] + t2[n3 + 1]));
        return r3;
      }, o2 = function(e4) {
        for (var r3 = new Uint8Array(e4.length), n3 = e4.length; n3--; ) r3[n3] = e4.charCodeAt(n3);
        return (r3 = t.zlibSync(r3)).reduce(function(t2, e5) {
          return t2 + String.fromCharCode(e5);
        }, "");
      };
      e3.processDataByFilters = function(t2, e4) {
        var s2 = 0, c2 = t2 || "", u3 = [];
        for ("string" == typeof (e4 = e4 || []) && (e4 = [e4]), s2 = 0; s2 < e4.length; s2 += 1) switch (e4[s2]) {
          case "ASCII85Decode":
          case "/ASCII85Decode":
            c2 = n2(c2), u3.push("/ASCII85Encode");
            break;
          case "ASCII85Encode":
          case "/ASCII85Encode":
            c2 = r2(c2), u3.push("/ASCII85Decode");
            break;
          case "ASCIIHexDecode":
          case "/ASCIIHexDecode":
            c2 = a3(c2), u3.push("/ASCIIHexEncode");
            break;
          case "ASCIIHexEncode":
          case "/ASCIIHexEncode":
            c2 = i2(c2), u3.push("/ASCIIHexDecode");
            break;
          case "FlateEncode":
          case "/FlateEncode":
            c2 = o2(c2), u3.push("/FlateDecode");
            break;
          default:
            throw new Error('The filter: "' + e4[s2] + '" is not implemented');
        }
        return { data: c2, reverseChain: u3.reverse().join(" ") };
      };
    })(j.API), /**
     * @license
     * jsPDF fileloading PlugIn
     * Copyright (c) 2018 Aras Abbasi (aras.abbasi@gmail.com)
     *
     * Licensed under the MIT License.
     * http://opensource.org/licenses/mit-license
     */
    (function(t2) {
      function e3(t3, e4, r2) {
        e4 = false !== e4;
        var n2 = void 0, i2 = __require("fs"), a3 = __require("path");
        if (!process.permission && !this.allowFsRead) throw new Error("Trying to read a file from local file system. To enable this feature either run node with the --permission and --allow-fs-read flags or set the jsPDF.allowFsRead property.");
        try {
          t3 = i2.realpathSync(a3.resolve(t3));
        } catch (o2) {
          return e4 ? void 0 : void r2(void 0);
        }
        if (process.permission && !process.permission.has("fs.read", t3)) throw new Error(`Cannot read file '${t3}'. Permission denied.`);
        if (this.allowFsRead && !this.allowFsRead.some((e5) => {
          const r3 = e5.indexOf("*");
          if (r3 >= 0) {
            const n3 = e5.substring(0, r3);
            let i3 = a3.resolve(n3);
            return n3.endsWith(a3.sep) && !i3.endsWith(a3.sep) && (i3 += a3.sep), t3.startsWith(i3);
          }
          return t3 === a3.resolve(e5);
        })) throw new Error(`Cannot read file '${t3}'. Permission denied.`);
        if (e4) try {
          n2 = i2.readFileSync(t3, { encoding: "latin1" });
        } catch (o2) {
          return;
        }
        else i2.readFile(t3, { encoding: "latin1" }, function(t4, e5) {
          r2 && (t4 && r2(void 0), r2(e5));
        });
        return n2;
      }
      t2.loadFile = function(t3, r2, n2) {
        return e3.call(this, t3, r2, n2);
      }, t2.allowFsRead = void 0, t2.loadImageFile = t2.loadFile;
    })(j.API), /**
     * @license
     * Copyright (c) 2018 Erik Koopmans
     * Released under the MIT License.
     *
     * Licensed under the MIT License.
     * http://opensource.org/licenses/mit-license
     */
    (function(t2) {
      function e3() {
        return (r.html2canvas ? Promise.resolve(r.html2canvas) : "object" == typeof exports && "undefined" != typeof module ? new Promise(function(t3, e4) {
          try {
            t3((init_html2canvas_esm(), __toCommonJS(html2canvas_esm_exports)));
          } catch (r2) {
            e4(r2);
          }
        }) : "function" == typeof define && define.amd ? new Promise(function(t3, e4) {
          try {
            __require(["html2canvas"], t3);
          } catch (r2) {
            e4(r2);
          }
        }) : Promise.reject(new Error("Could not load html2canvas"))).catch(function(t3) {
          return Promise.reject(new Error("Could not load html2canvas: " + t3));
        }).then(function(t3) {
          return t3.default ? t3.default : t3;
        });
      }
      function n2() {
        return (r.DOMPurify ? Promise.resolve(r.DOMPurify) : "object" == typeof exports && "undefined" != typeof module ? new Promise(function(t3, e4) {
          try {
            t3(require_purify_cjs());
          } catch (r2) {
            e4(r2);
          }
        }) : "function" == typeof define && define.amd ? new Promise(function(t3, e4) {
          try {
            __require(["dompurify"], t3);
          } catch (r2) {
            e4(r2);
          }
        }) : Promise.reject(new Error("Could not load dompurify"))).catch(function(t3) {
          return Promise.reject(new Error("Could not load dompurify: " + t3));
        }).then(function(t3) {
          return t3.default ? t3.default : t3;
        });
      }
      var i2 = function(t3) {
        var e4 = typeof t3;
        return "undefined" === e4 ? "undefined" : "string" === e4 || t3 instanceof String ? "string" : "number" === e4 || t3 instanceof Number ? "number" : "function" === e4 || t3 instanceof Function ? "function" : t3 && t3.constructor === Array ? "array" : t3 && 1 === t3.nodeType ? "element" : "object" === e4 ? "object" : "unknown";
      }, a3 = function(t3, e4) {
        var r2 = document.createElement(t3);
        for (var n3 in e4.className && (r2.className = e4.className), e4.innerHTML && e4.dompurify && (r2.innerHTML = e4.dompurify.sanitize(e4.innerHTML)), e4.style) r2.style[n3] = e4.style[n3];
        return r2;
      }, o2 = function(t3, e4) {
        for (var r2 = 3 === t3.nodeType ? document.createTextNode(t3.nodeValue) : t3.cloneNode(false), n3 = t3.firstChild; n3; n3 = n3.nextSibling) true !== e4 && 1 === n3.nodeType && "SCRIPT" === n3.nodeName || r2.appendChild(o2(n3, e4));
        return 1 === t3.nodeType && ("CANVAS" === t3.nodeName ? (r2.width = t3.width, r2.height = t3.height, r2.getContext("2d").drawImage(t3, 0, 0)) : "TEXTAREA" !== t3.nodeName && "SELECT" !== t3.nodeName || (r2.value = t3.value), r2.addEventListener("load", function() {
          r2.scrollTop = t3.scrollTop, r2.scrollLeft = t3.scrollLeft;
        }, true)), r2;
      }, s2 = function t3(e4) {
        var r2 = Object.assign(t3.convert(Promise.resolve()), JSON.parse(JSON.stringify(t3.template))), n3 = t3.convert(Promise.resolve(), r2);
        return (n3 = n3.setProgress(1, t3, 1, [t3])).set(e4);
      };
      (s2.prototype = Object.create(Promise.prototype)).constructor = s2, s2.convert = function(t3, e4) {
        return t3.__proto__ = e4 || s2.prototype, t3;
      }, s2.template = { prop: { src: null, container: null, overlay: null, canvas: null, img: null, pdf: null, pageSize: null, callback: function() {
      } }, progress: { val: 0, state: null, n: 0, stack: [] }, opt: { filename: "file.pdf", margin: [0, 0, 0, 0], enableLinks: true, x: 0, y: 0, html2canvas: {}, jsPDF: {}, backgroundColor: "transparent" } }, s2.prototype.from = function(t3, e4) {
        return this.then(function() {
          switch (e4 = e4 || (function(t4) {
            switch (i2(t4)) {
              case "string":
                return "string";
              case "element":
                return "canvas" === t4.nodeName.toLowerCase() ? "canvas" : "element";
              default:
                return "unknown";
            }
          })(t3), e4) {
            case "string":
              return this.then(n2).then(function(e5) {
                return this.set({ src: a3("div", { innerHTML: t3, dompurify: e5 }) });
              });
            case "element":
              return this.set({ src: t3 });
            case "canvas":
              return this.set({ canvas: t3 });
            case "img":
              return this.set({ img: t3 });
            default:
              return this.error("Unknown source type.");
          }
        });
      }, s2.prototype.to = function(t3) {
        switch (t3) {
          case "container":
            return this.toContainer();
          case "canvas":
            return this.toCanvas();
          case "img":
            return this.toImg();
          case "pdf":
            return this.toPdf();
          default:
            return this.error("Invalid target.");
        }
      }, s2.prototype.toContainer = function() {
        return this.thenList([function() {
          return this.prop.src || this.error("Cannot duplicate - no source HTML.");
        }, function() {
          return this.prop.pageSize || this.setPageSize();
        }]).then(function() {
          var t3 = { position: "relative", display: "inline-block", width: ("number" != typeof this.opt.width || isNaN(this.opt.width) || "number" != typeof this.opt.windowWidth || isNaN(this.opt.windowWidth) ? Math.max(this.prop.src.clientWidth, this.prop.src.scrollWidth, this.prop.src.offsetWidth) : this.opt.windowWidth) + "px", left: 0, right: 0, top: 0, margin: "auto", backgroundColor: this.opt.backgroundColor }, e4 = o2(this.prop.src, this.opt.html2canvas.javascriptEnabled);
          "BODY" === e4.tagName && (t3.height = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight) + "px"), this.prop.overlay = a3("div", { className: "html2pdf__overlay", style: { position: "fixed", overflow: "hidden", zIndex: 1e3, left: "-100000px", right: 0, bottom: 0, top: 0 } }), this.prop.container = a3("div", { className: "html2pdf__container", style: t3 }), this.prop.container.appendChild(e4), this.prop.container.firstChild.appendChild(a3("div", { style: { clear: "both", border: "0 none transparent", margin: 0, padding: 0, height: 0 } })), this.prop.container.style.float = "none", this.prop.overlay.appendChild(this.prop.container), document.body.appendChild(this.prop.overlay), this.prop.container.firstChild.style.position = "relative", this.prop.container.height = Math.max(this.prop.container.firstChild.clientHeight, this.prop.container.firstChild.scrollHeight, this.prop.container.firstChild.offsetHeight) + "px";
        });
      }, s2.prototype.toCanvas = function() {
        var t3 = [function() {
          return document.body.contains(this.prop.container) || this.toContainer();
        }];
        return this.thenList(t3).then(e3).then(function(t4) {
          var e4 = Object.assign({}, this.opt.html2canvas);
          return delete e4.onrendered, t4(this.prop.container, e4);
        }).then(function(t4) {
          (this.opt.html2canvas.onrendered || function() {
          })(t4), this.prop.canvas = t4, document.body.removeChild(this.prop.overlay);
        });
      }, s2.prototype.toContext2d = function() {
        var t3 = [function() {
          return document.body.contains(this.prop.container) || this.toContainer();
        }];
        return this.thenList(t3).then(e3).then(function(t4) {
          var e4 = this.opt.jsPDF, r2 = this.opt.fontFaces, n3 = "number" != typeof this.opt.width || isNaN(this.opt.width) || "number" != typeof this.opt.windowWidth || isNaN(this.opt.windowWidth) ? 1 : this.opt.width / this.opt.windowWidth, i3 = Object.assign({ async: true, allowTaint: true, scale: n3, scrollX: this.opt.scrollX || 0, scrollY: this.opt.scrollY || 0, backgroundColor: "#ffffff", imageTimeout: 15e3, logging: true, proxy: null, removeContainer: true, foreignObjectRendering: false, useCORS: false }, this.opt.html2canvas);
          if (delete i3.onrendered, e4.context2d.autoPaging = void 0 === this.opt.autoPaging || this.opt.autoPaging, e4.context2d.posX = this.opt.x, e4.context2d.posY = this.opt.y, e4.context2d.margin = this.opt.margin, e4.context2d.fontFaces = r2, r2) for (var a4 = 0; a4 < r2.length; ++a4) {
            var o3 = r2[a4], s3 = o3.src.find(function(t5) {
              return "truetype" === t5.format;
            });
            s3 && e4.addFont(s3.url, o3.ref.name, o3.ref.style);
          }
          return i3.windowHeight = i3.windowHeight || 0, i3.windowHeight = 0 == i3.windowHeight ? Math.max(this.prop.container.clientHeight, this.prop.container.scrollHeight, this.prop.container.offsetHeight) : i3.windowHeight, e4.context2d.save(true), t4(this.prop.container, i3);
        }).then(function(t4) {
          this.opt.jsPDF.context2d.restore(true), (this.opt.html2canvas.onrendered || function() {
          })(t4), this.prop.canvas = t4, document.body.removeChild(this.prop.overlay);
        });
      }, s2.prototype.toImg = function() {
        return this.thenList([function() {
          return this.prop.canvas || this.toCanvas();
        }]).then(function() {
          var t3 = this.prop.canvas.toDataURL("image/" + this.opt.image.type, this.opt.image.quality);
          this.prop.img = document.createElement("img"), this.prop.img.src = t3;
        });
      }, s2.prototype.toPdf = function() {
        return this.thenList([function() {
          return this.toContext2d();
        }]).then(function() {
          this.prop.pdf = this.prop.pdf || this.opt.jsPDF;
        });
      }, s2.prototype.output = function(t3, e4, r2) {
        return "img" === (r2 = r2 || "pdf").toLowerCase() || "image" === r2.toLowerCase() ? this.outputImg(t3, e4) : this.outputPdf(t3, e4);
      }, s2.prototype.outputPdf = function(t3, e4) {
        return this.thenList([function() {
          return this.prop.pdf || this.toPdf();
        }]).then(function() {
          return this.prop.pdf.output(t3, e4);
        });
      }, s2.prototype.outputImg = function(t3) {
        return this.thenList([function() {
          return this.prop.img || this.toImg();
        }]).then(function() {
          switch (t3) {
            case void 0:
            case "img":
              return this.prop.img;
            case "datauristring":
            case "dataurlstring":
              return this.prop.img.src;
            case "datauri":
            case "dataurl":
              return document.location.href = this.prop.img.src;
            default:
              throw 'Image output type "' + t3 + '" is not supported.';
          }
        });
      }, s2.prototype.save = function(t3) {
        return this.thenList([function() {
          return this.prop.pdf || this.toPdf();
        }]).set(t3 ? { filename: t3 } : null).then(function() {
          this.prop.pdf.save(this.opt.filename);
        });
      }, s2.prototype.doCallback = function() {
        return this.thenList([function() {
          return this.prop.pdf || this.toPdf();
        }]).then(function() {
          this.prop.callback(this.prop.pdf);
        });
      }, s2.prototype.set = function(t3) {
        if ("object" !== i2(t3)) return this;
        var e4 = Object.keys(t3 || {}).map(function(e5) {
          if (e5 in s2.template.prop) return function() {
            this.prop[e5] = t3[e5];
          };
          switch (e5) {
            case "margin":
              return this.setMargin.bind(this, t3.margin);
            case "jsPDF":
              return function() {
                return this.opt.jsPDF = t3.jsPDF, this.setPageSize();
              };
            case "pageSize":
              return this.setPageSize.bind(this, t3.pageSize);
            default:
              return function() {
                this.opt[e5] = t3[e5];
              };
          }
        }, this);
        return this.then(function() {
          return this.thenList(e4);
        });
      }, s2.prototype.get = function(t3, e4) {
        return this.then(function() {
          var r2 = t3 in s2.template.prop ? this.prop[t3] : this.opt[t3];
          return e4 ? e4(r2) : r2;
        });
      }, s2.prototype.setMargin = function(t3) {
        return this.then(function() {
          switch (i2(t3)) {
            case "number":
              t3 = [t3, t3, t3, t3];
            case "array":
              if (2 === t3.length && (t3 = [t3[0], t3[1], t3[0], t3[1]]), 4 === t3.length) break;
            default:
              return this.error("Invalid margin array.");
          }
          this.opt.margin = t3;
        }).then(this.setPageSize);
      }, s2.prototype.setPageSize = function(t3) {
        function e4(t4, e5) {
          return Math.floor(t4 * e5 / 72 * 96);
        }
        return this.then(function() {
          (t3 = t3 || j.getPageSize(this.opt.jsPDF)).hasOwnProperty("inner") || (t3.inner = { width: t3.width - this.opt.margin[1] - this.opt.margin[3], height: t3.height - this.opt.margin[0] - this.opt.margin[2] }, t3.inner.px = { width: e4(t3.inner.width, t3.k), height: e4(t3.inner.height, t3.k) }, t3.inner.ratio = t3.inner.height / t3.inner.width), this.prop.pageSize = t3;
        });
      }, s2.prototype.setProgress = function(t3, e4, r2, n3) {
        return null != t3 && (this.progress.val = t3), null != e4 && (this.progress.state = e4), null != r2 && (this.progress.n = r2), null != n3 && (this.progress.stack = n3), this.progress.ratio = this.progress.val / this.progress.state, this;
      }, s2.prototype.updateProgress = function(t3, e4, r2, n3) {
        return this.setProgress(t3 ? this.progress.val + t3 : null, e4 || null, r2 ? this.progress.n + r2 : null, n3 ? this.progress.stack.concat(n3) : null);
      }, s2.prototype.then = function(t3, e4) {
        var r2 = this;
        return this.thenCore(t3, e4, function(t4, e5) {
          return r2.updateProgress(null, null, 1, [t4]), Promise.prototype.then.call(this, function(e6) {
            return r2.updateProgress(null, t4), e6;
          }).then(t4, e5).then(function(t5) {
            return r2.updateProgress(1), t5;
          });
        });
      }, s2.prototype.thenCore = function(t3, e4, r2) {
        r2 = r2 || Promise.prototype.then;
        var n3 = this;
        t3 && (t3 = t3.bind(n3)), e4 && (e4 = e4.bind(n3));
        var i3 = -1 !== Promise.toString().indexOf("[native code]") && "Promise" === Promise.name ? n3 : s2.convert(Object.assign({}, n3), Promise.prototype), a4 = r2.call(i3, t3, e4);
        return s2.convert(a4, n3.__proto__);
      }, s2.prototype.thenExternal = function(t3, e4) {
        return Promise.prototype.then.call(this, t3, e4);
      }, s2.prototype.thenList = function(t3) {
        var e4 = this;
        return t3.forEach(function(t4) {
          e4 = e4.thenCore(t4);
        }), e4;
      }, s2.prototype.catch = function(t3) {
        t3 && (t3 = t3.bind(this));
        var e4 = Promise.prototype.catch.call(this, t3);
        return s2.convert(e4, this);
      }, s2.prototype.catchExternal = function(t3) {
        return Promise.prototype.catch.call(this, t3);
      }, s2.prototype.error = function(t3) {
        return this.then(function() {
          throw new Error(t3);
        });
      }, s2.prototype.using = s2.prototype.set, s2.prototype.saveAs = s2.prototype.save, s2.prototype.export = s2.prototype.output, s2.prototype.run = s2.prototype.then, j.getPageSize = function(t3, e4, r2) {
        if ("object" == typeof t3) {
          var n3 = t3;
          t3 = n3.orientation, e4 = n3.unit || e4, r2 = n3.format || r2;
        }
        e4 = e4 || "mm", r2 = r2 || "a4", t3 = ("" + (t3 || "P")).toLowerCase();
        var i3, a4 = ("" + r2).toLowerCase(), o3 = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
        switch (e4) {
          case "pt":
            i3 = 1;
            break;
          case "mm":
            i3 = 72 / 25.4;
            break;
          case "cm":
            i3 = 72 / 2.54;
            break;
          case "in":
            i3 = 72;
            break;
          case "px":
            i3 = 0.75;
            break;
          case "pc":
          case "em":
            i3 = 12;
            break;
          case "ex":
            i3 = 6;
            break;
          default:
            throw "Invalid unit: " + e4;
        }
        var s3, c2 = 0, u3 = 0;
        if (o3.hasOwnProperty(a4)) c2 = o3[a4][1] / i3, u3 = o3[a4][0] / i3;
        else try {
          c2 = r2[1], u3 = r2[0];
        } catch (l2) {
          throw new Error("Invalid format: " + r2);
        }
        if ("p" === t3 || "portrait" === t3) t3 = "p", u3 > c2 && (s3 = u3, u3 = c2, c2 = s3);
        else {
          if ("l" !== t3 && "landscape" !== t3) throw "Invalid orientation: " + t3;
          t3 = "l", c2 > u3 && (s3 = u3, u3 = c2, c2 = s3);
        }
        return { width: u3, height: c2, unit: e4, k: i3, orientation: t3 };
      }, t2.html = function(t3, e4) {
        (e4 = e4 || {}).callback = e4.callback || function() {
        }, e4.html2canvas = e4.html2canvas || {}, e4.html2canvas.canvas = e4.html2canvas.canvas || this.canvas, e4.jsPDF = e4.jsPDF || this, e4.fontFaces = e4.fontFaces ? e4.fontFaces.map(_t) : null;
        var r2 = new s2(e4);
        return e4.worker ? r2 : r2.from(t3).doCallback();
      };
    })(j.API), j.API.addJS = function(t2) {
      var e3, r2;
      const n2 = (function(t3) {
        let e4 = "";
        for (let r3 = 0; r3 < t3.length; r3++) {
          const n3 = t3[r3];
          if ("(" === n3 || ")" === n3) {
            let i2 = 0;
            for (let e5 = r3 - 1; e5 >= 0 && "\\" === t3[e5]; e5--) i2++;
            e4 += i2 % 2 == 0 ? "\\" + n3 : n3;
          } else e4 += n3;
        }
        return e4;
      })(t2);
      return this.internal.events.subscribe("postPutResources", function() {
        e3 = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/Names [(EmbeddedJS) " + (e3 + 1) + " 0 R]"), this.internal.out(">>"), this.internal.out("endobj"), r2 = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /JavaScript"), this.internal.out("/JS (" + n2 + ")"), this.internal.out(">>"), this.internal.out("endobj");
      }), this.internal.events.subscribe("putCatalog", function() {
        void 0 !== e3 && void 0 !== r2 && this.internal.out("/Names <</JavaScript " + e3 + " 0 R>>");
      }), this;
    }, /**
     * @license
     * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
     *
     * Licensed under the MIT License.
     * http://opensource.org/licenses/mit-license
     */
    (function(t2) {
      var e3;
      t2.events.push(["postPutResources", function() {
        var t3 = this, r2 = /^(\d+) 0 obj$/;
        if (this.outline.root.children.length > 0) for (var n2 = t3.outline.render().split(/\r\n/), i2 = 0; i2 < n2.length; i2++) {
          var a3 = n2[i2], o2 = r2.exec(a3);
          if (null != o2) {
            var s2 = o2[1];
            t3.internal.newObjectDeferredBegin(s2, false);
          }
          t3.internal.write(a3);
        }
        if (this.outline.createNamedDestinations) {
          var c2 = this.internal.pages.length, u3 = [];
          for (i2 = 0; i2 < c2; i2++) {
            var l2 = t3.internal.newObject();
            u3.push(l2);
            var h2 = t3.internal.getPageInfo(i2 + 1);
            t3.internal.write("<< /D[" + h2.objId + " 0 R /XYZ null null null]>> endobj");
          }
          var f3 = t3.internal.newObject();
          for (t3.internal.write("<< /Names [ "), i2 = 0; i2 < u3.length; i2++) t3.internal.write("(page_" + (i2 + 1) + ")" + u3[i2] + " 0 R");
          t3.internal.write(" ] >>", "endobj"), e3 = t3.internal.newObject(), t3.internal.write("<< /Dests " + f3 + " 0 R"), t3.internal.write(">>", "endobj");
        }
      }]), t2.events.push(["putCatalog", function() {
        var t3 = this;
        t3.outline.root.children.length > 0 && (t3.internal.write("/Outlines", this.outline.makeRef(this.outline.root)), this.outline.createNamedDestinations && t3.internal.write("/Names " + e3 + " 0 R"));
      }]), t2.events.push(["initialized", function() {
        var t3 = this;
        t3.outline = { createNamedDestinations: false, root: { children: [] } }, t3.outline.add = function(t4, e4, r2) {
          var n2 = { title: e4, options: r2, children: [] };
          return null == t4 && (t4 = this.root), t4.children.push(n2), n2;
        }, t3.outline.render = function() {
          return this.ctx = {}, this.ctx.val = "", this.ctx.pdf = t3, this.genIds_r(this.root), this.renderRoot(this.root), this.renderItems(this.root), this.ctx.val;
        }, t3.outline.genIds_r = function(e4) {
          e4.id = t3.internal.newObjectDeferred();
          for (var r2 = 0; r2 < e4.children.length; r2++) this.genIds_r(e4.children[r2]);
        }, t3.outline.renderRoot = function(t4) {
          this.objStart(t4), this.line("/Type /Outlines"), t4.children.length > 0 && (this.line("/First " + this.makeRef(t4.children[0])), this.line("/Last " + this.makeRef(t4.children[t4.children.length - 1]))), this.line("/Count " + this.count_r({ count: 0 }, t4)), this.objEnd();
        }, t3.outline.renderItems = function(e4) {
          for (var r2 = this.ctx.pdf.internal.getVerticalCoordinateString, n2 = 0; n2 < e4.children.length; n2++) {
            var i2 = e4.children[n2];
            this.objStart(i2), this.line("/Title " + this.makeString(i2.title)), this.line("/Parent " + this.makeRef(e4)), n2 > 0 && this.line("/Prev " + this.makeRef(e4.children[n2 - 1])), n2 < e4.children.length - 1 && this.line("/Next " + this.makeRef(e4.children[n2 + 1])), i2.children.length > 0 && (this.line("/First " + this.makeRef(i2.children[0])), this.line("/Last " + this.makeRef(i2.children[i2.children.length - 1])));
            var a3 = this.count = this.count_r({ count: 0 }, i2);
            if (a3 > 0 && this.line("/Count " + a3), i2.options && i2.options.pageNumber) {
              var o2 = t3.internal.getPageInfo(i2.options.pageNumber);
              this.line("/Dest [" + o2.objId + " 0 R /XYZ 0 " + r2(0) + " 0]");
            }
            this.objEnd();
          }
          for (var s2 = 0; s2 < e4.children.length; s2++) this.renderItems(e4.children[s2]);
        }, t3.outline.line = function(t4) {
          this.ctx.val += t4 + "\r\n";
        }, t3.outline.makeRef = function(t4) {
          return t4.id + " 0 R";
        }, t3.outline.makeString = function(e4) {
          return "(" + t3.internal.pdfEscape(e4) + ")";
        }, t3.outline.objStart = function(t4) {
          this.ctx.val += "\r\n" + t4.id + " 0 obj\r\n<<\r\n";
        }, t3.outline.objEnd = function() {
          this.ctx.val += ">> \r\nendobj\r\n";
        }, t3.outline.count_r = function(t4, e4) {
          for (var r2 = 0; r2 < e4.children.length; r2++) t4.count++, this.count_r(t4, e4.children[r2]);
          return t4.count;
        };
      }]);
    })(j.API), /**
     * @license
     *
     * Licensed under the MIT License.
     * http://opensource.org/licenses/mit-license
     */
    (function(t2) {
      var e3 = [192, 193, 194, 195, 196, 197, 198, 199];
      t2.processJPEG = function(t3, r2, n2, i2, a3, o2) {
        var s2, c2 = this.decode.DCT_DECODE, u3 = null;
        if ("string" == typeof t3 || this.__addimage__.isArrayBuffer(t3) || this.__addimage__.isArrayBufferView(t3)) {
          switch (t3 = a3 || t3, t3 = this.__addimage__.isArrayBuffer(t3) ? new Uint8Array(t3) : t3, s2 = (function(t4) {
            for (var r3, n3 = 256 * t4.charCodeAt(4) + t4.charCodeAt(5), i3 = t4.length, a4 = { width: 0, height: 0, numcomponents: 1 }, o3 = 4; o3 < i3; o3 += 2) {
              if (o3 += n3, -1 !== e3.indexOf(t4.charCodeAt(o3 + 1))) {
                r3 = 256 * t4.charCodeAt(o3 + 5) + t4.charCodeAt(o3 + 6), a4 = { width: 256 * t4.charCodeAt(o3 + 7) + t4.charCodeAt(o3 + 8), height: r3, numcomponents: t4.charCodeAt(o3 + 9) };
                break;
              }
              n3 = 256 * t4.charCodeAt(o3 + 2) + t4.charCodeAt(o3 + 3);
            }
            return a4;
          })(t3 = this.__addimage__.isArrayBufferView(t3) ? this.__addimage__.arrayBufferToBinaryString(t3) : t3), s2.numcomponents) {
            case 1:
              o2 = this.color_spaces.DEVICE_GRAY;
              break;
            case 4:
              o2 = this.color_spaces.DEVICE_CMYK;
              break;
            case 3:
              o2 = this.color_spaces.DEVICE_RGB;
          }
          u3 = { data: t3, width: s2.width, height: s2.height, colorSpace: o2, bitsPerComponent: 8, filter: c2, index: r2, alias: n2 };
        }
        return u3;
      };
    })(j.API), /**
     * @license
     *
     * Copyright (c) 2014 James Robb, https://github.com/jamesbrobb
     *
     * Permission is hereby granted, free of charge, to any person obtaining
     * a copy of this software and associated documentation files (the
     * "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish,
     * distribute, sublicense, and/or sell copies of the Software, and to
     * permit persons to whom the Software is furnished to do so, subject to
     * the following conditions:
     *
     * The above copyright notice and this permission notice shall be
     * included in all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
     * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
     * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
     * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
     * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     * ====================================================================
     */
    j.API.processPNG = function(r2, n2, i2, a3) {
      if (this.__addimage__.isArrayBuffer(r2) && (r2 = new Uint8Array(r2)), !this.__addimage__.isArrayBufferView(r2)) return;
      const o2 = e2.decode(r2, { checkCrc: true }), { width: s2, height: c2, channels: u3, palette: l2, depth: h2 } = o2;
      let f3;
      f3 = l2 && 1 === u3 ? (function(t2) {
        const { width: e3, height: r3, data: n3, palette: i3, depth: a4 } = t2;
        let o3, s3 = false, c3 = [], u4 = [], l3 = false;
        let h3 = 0;
        for (let f4 = 0; f4 < i3.length; f4++) {
          const [t3, e4, r4, n4] = i3[f4];
          c3.push(t3, e4, r4), null != n4 && (0 === n4 ? (h3++, u4.length < 1 && u4.push(f4)) : n4 < 255 && (l3 = true));
        }
        if (l3 || h3 > 1) {
          s3 = true, u4 = void 0;
          const t3 = e3 * r3;
          o3 = new Uint8Array(t3);
          const c4 = new DataView(n3.buffer);
          for (let e4 = 0; e4 < t3; e4++) {
            const t4 = Jt(c4, e4, a4), [, , , r4] = i3[t4];
            o3[e4] = r4;
          }
        } else 0 === h3 && (u4 = void 0);
        return { colorSpace: "Indexed", colorsPerPixel: 1, sMaskBitsPerComponent: s3 ? 8 : void 0, colorBytes: n3, alphaBytes: o3, needSMask: s3, palette: c3, mask: u4 };
      })(o2) : 2 === u3 || 4 === u3 ? (function(t2) {
        const { data: e3, width: r3, height: n3, channels: i3, depth: a4 } = t2, o3 = 2 === i3 ? "DeviceGray" : "DeviceRGB", s3 = i3 - 1, c3 = r3 * n3, u4 = s3, l3 = c3 * u4, h3 = 1 * c3, f4 = Math.ceil(l3 * a4 / 8), d3 = Math.ceil(h3 * a4 / 8), p3 = new Uint8Array(f4), g3 = new Uint8Array(d3), m3 = new DataView(e3.buffer), v3 = new DataView(p3.buffer), b3 = new DataView(g3.buffer);
        let y3 = false;
        for (let w3 = 0; w3 < c3; w3++) {
          const t3 = w3 * i3;
          for (let r4 = 0; r4 < u4; r4++) Xt(v3, Jt(m3, t3 + r4, a4), w3 * u4 + r4, a4);
          const e4 = Jt(m3, t3 + u4, a4);
          e4 < (1 << a4) - 1 && (y3 = true), Xt(b3, e4, 1 * w3, a4);
        }
        return { colorSpace: o3, colorsPerPixel: s3, sMaskBitsPerComponent: y3 ? a4 : void 0, colorBytes: p3, alphaBytes: g3, needSMask: y3 };
      })(o2) : (function(t2) {
        const { data: e3, channels: r3 } = t2, n3 = 1 === r3 ? "DeviceGray" : "DeviceRGB", i3 = "DeviceGray" === n3 ? 1 : 3;
        let a4;
        return a4 = e3 instanceof Uint16Array ? (function(t3) {
          const e4 = t3.length, r4 = new Uint8Array(2 * e4), n4 = new DataView(r4.buffer, r4.byteOffset, r4.byteLength);
          for (let i4 = 0; i4 < e4; i4++) n4.setUint16(2 * i4, t3[i4], false);
          return r4;
        })(e3) : e3, { colorSpace: n3, colorsPerPixel: i3, colorBytes: a4, needSMask: false };
      })(o2);
      const { colorSpace: d2, colorsPerPixel: p2, sMaskBitsPerComponent: g2, colorBytes: m2, alphaBytes: v2, needSMask: b2, palette: y2, mask: w2 } = f3;
      let N2, L3, x2, A3 = null;
      return a3 !== j.API.image_compression.NONE && "function" == typeof t.zlibSync ? (A3 = (function(t2) {
        let e3;
        switch (t2) {
          case j.API.image_compression.FAST:
            e3 = 11;
            break;
          case j.API.image_compression.MEDIUM:
            e3 = 13;
            break;
          case j.API.image_compression.SLOW:
            e3 = 14;
            break;
          default:
            e3 = 12;
        }
        return e3;
      })(a3), N2 = this.decode.FLATE_DECODE, L3 = `/Predictor ${A3} /Colors ${p2} /BitsPerComponent ${h2} /Columns ${s2}`, r2 = Tt(m2, Math.ceil(s2 * p2 * h2 / 8), p2, h2, a3), b2 && (x2 = Tt(v2, Math.ceil(s2 * g2 / 8), 1, g2, a3))) : (N2 = void 0, L3 = void 0, r2 = m2, b2 && (x2 = v2)), (this.__addimage__.isArrayBuffer(r2) || this.__addimage__.isArrayBufferView(r2)) && (r2 = this.__addimage__.arrayBufferToBinaryString(r2)), (x2 && this.__addimage__.isArrayBuffer(x2) || this.__addimage__.isArrayBufferView(x2)) && (x2 = this.__addimage__.arrayBufferToBinaryString(x2)), { alias: i2, data: r2, index: n2, filter: N2, decodeParameters: L3, transparency: w2, palette: y2, sMask: x2, predictor: A3, width: s2, height: c2, bitsPerComponent: h2, sMaskBitsPerComponent: g2, colorSpace: d2 };
    }, (function(t2) {
      t2.processGIF89A = function(e3, r2, n2, i2) {
        var a3 = new $t(e3), o2 = a3.width, s2 = a3.height, c2 = [];
        a3.decodeAndBlitFrameRGBA(0, c2);
        var u3 = { data: c2, width: o2, height: s2 }, l2 = new Qt(100).encode(u3, 100);
        return t2.processJPEG.call(this, l2, r2, n2, i2);
      }, t2.processGIF87A = t2.processGIF89A;
    })(j.API), te.prototype.parseHeader = function() {
      if (this.fileSize = this.datav.getUint32(this.pos, true), this.pos += 4, this.reserved = this.datav.getUint32(this.pos, true), this.pos += 4, this.offset = this.datav.getUint32(this.pos, true), this.pos += 4, this.headerSize = this.datav.getUint32(this.pos, true), this.pos += 4, this.width = this.datav.getUint32(this.pos, true), this.pos += 4, this.height = this.datav.getInt32(this.pos, true), this.pos += 4, this.planes = this.datav.getUint16(this.pos, true), this.pos += 2, this.bitPP = this.datav.getUint16(this.pos, true), this.pos += 2, this.compress = this.datav.getUint32(this.pos, true), this.pos += 4, this.rawSize = this.datav.getUint32(this.pos, true), this.pos += 4, this.hr = this.datav.getUint32(this.pos, true), this.pos += 4, this.vr = this.datav.getUint32(this.pos, true), this.pos += 4, this.colors = this.datav.getUint32(this.pos, true), this.pos += 4, this.importantColors = this.datav.getUint32(this.pos, true), this.pos += 4, 16 === this.bitPP && this.is_with_alpha && (this.bitPP = 15), this.bitPP < 15) {
        var t2 = 0 === this.colors ? 1 << this.bitPP : this.colors;
        this.palette = new Array(t2);
        for (var e3 = 0; e3 < t2; e3++) {
          var r2 = this.datav.getUint8(this.pos++, true), n2 = this.datav.getUint8(this.pos++, true), i2 = this.datav.getUint8(this.pos++, true), a3 = this.datav.getUint8(this.pos++, true);
          this.palette[e3] = { red: i2, green: n2, blue: r2, quad: a3 };
        }
      }
      this.height < 0 && (this.height *= -1, this.bottom_up = false);
    }, te.prototype.parseBGR = function() {
      this.pos = this.offset;
      var t2 = "bit" + this.bitPP, e3 = this.width * this.height * 4;
      if (e3 > 536870912) throw new Error("Image dimensions exceed 512MB, which is too large.");
      this.data = new Uint8Array(e3);
      try {
        this[t2]();
      } catch (r2) {
        s.log("bit decode error:" + r2);
      }
    }, te.prototype.bit1 = function() {
      var t2, e3 = Math.ceil(this.width / 8), r2 = e3 % 4;
      for (t2 = this.height - 1; t2 >= 0; t2--) {
        for (var n2 = this.bottom_up ? t2 : this.height - 1 - t2, i2 = 0; i2 < e3; i2++) for (var a3 = this.datav.getUint8(this.pos++, true), o2 = n2 * this.width * 4 + 8 * i2 * 4, s2 = 0; s2 < 8 && 8 * i2 + s2 < this.width; s2++) {
          var c2 = this.palette[a3 >> 7 - s2 & 1];
          this.data[o2 + 4 * s2] = c2.blue, this.data[o2 + 4 * s2 + 1] = c2.green, this.data[o2 + 4 * s2 + 2] = c2.red, this.data[o2 + 4 * s2 + 3] = 255;
        }
        0 !== r2 && (this.pos += 4 - r2);
      }
    }, te.prototype.bit4 = function() {
      for (var t2 = Math.ceil(this.width / 2), e3 = t2 % 4, r2 = this.height - 1; r2 >= 0; r2--) {
        for (var n2 = this.bottom_up ? r2 : this.height - 1 - r2, i2 = 0; i2 < t2; i2++) {
          var a3 = this.datav.getUint8(this.pos++, true), o2 = n2 * this.width * 4 + 2 * i2 * 4, s2 = a3 >> 4, c2 = 15 & a3, u3 = this.palette[s2];
          if (this.data[o2] = u3.blue, this.data[o2 + 1] = u3.green, this.data[o2 + 2] = u3.red, this.data[o2 + 3] = 255, 2 * i2 + 1 >= this.width) break;
          u3 = this.palette[c2], this.data[o2 + 4] = u3.blue, this.data[o2 + 4 + 1] = u3.green, this.data[o2 + 4 + 2] = u3.red, this.data[o2 + 4 + 3] = 255;
        }
        0 !== e3 && (this.pos += 4 - e3);
      }
    }, te.prototype.bit8 = function() {
      for (var t2 = this.width % 4, e3 = this.height - 1; e3 >= 0; e3--) {
        for (var r2 = this.bottom_up ? e3 : this.height - 1 - e3, n2 = 0; n2 < this.width; n2++) {
          var i2 = this.datav.getUint8(this.pos++, true), a3 = r2 * this.width * 4 + 4 * n2;
          if (i2 < this.palette.length) {
            var o2 = this.palette[i2];
            this.data[a3] = o2.red, this.data[a3 + 1] = o2.green, this.data[a3 + 2] = o2.blue, this.data[a3 + 3] = 255;
          } else this.data[a3] = 255, this.data[a3 + 1] = 255, this.data[a3 + 2] = 255, this.data[a3 + 3] = 255;
        }
        0 !== t2 && (this.pos += 4 - t2);
      }
    }, te.prototype.bit15 = function() {
      for (var t2 = this.width % 3, e3 = parseInt("11111", 2), r2 = this.height - 1; r2 >= 0; r2--) {
        for (var n2 = this.bottom_up ? r2 : this.height - 1 - r2, i2 = 0; i2 < this.width; i2++) {
          var a3 = this.datav.getUint16(this.pos, true);
          this.pos += 2;
          var o2 = (a3 & e3) / e3 * 255 | 0, s2 = (a3 >> 5 & e3) / e3 * 255 | 0, c2 = (a3 >> 10 & e3) / e3 * 255 | 0, u3 = a3 >> 15 ? 255 : 0, l2 = n2 * this.width * 4 + 4 * i2;
          this.data[l2] = c2, this.data[l2 + 1] = s2, this.data[l2 + 2] = o2, this.data[l2 + 3] = u3;
        }
        this.pos += t2;
      }
    }, te.prototype.bit16 = function() {
      for (var t2 = this.width % 3, e3 = parseInt("11111", 2), r2 = parseInt("111111", 2), n2 = this.height - 1; n2 >= 0; n2--) {
        for (var i2 = this.bottom_up ? n2 : this.height - 1 - n2, a3 = 0; a3 < this.width; a3++) {
          var o2 = this.datav.getUint16(this.pos, true);
          this.pos += 2;
          var s2 = (o2 & e3) / e3 * 255 | 0, c2 = (o2 >> 5 & r2) / r2 * 255 | 0, u3 = (o2 >> 11) / e3 * 255 | 0, l2 = i2 * this.width * 4 + 4 * a3;
          this.data[l2] = u3, this.data[l2 + 1] = c2, this.data[l2 + 2] = s2, this.data[l2 + 3] = 255;
        }
        this.pos += t2;
      }
    }, te.prototype.bit24 = function() {
      for (var t2 = this.height - 1; t2 >= 0; t2--) {
        for (var e3 = this.bottom_up ? t2 : this.height - 1 - t2, r2 = 0; r2 < this.width; r2++) {
          var n2 = this.datav.getUint8(this.pos++, true), i2 = this.datav.getUint8(this.pos++, true), a3 = this.datav.getUint8(this.pos++, true), o2 = e3 * this.width * 4 + 4 * r2;
          this.data[o2] = a3, this.data[o2 + 1] = i2, this.data[o2 + 2] = n2, this.data[o2 + 3] = 255;
        }
        this.pos += this.width % 4;
      }
    }, te.prototype.bit32 = function() {
      for (var t2 = this.height - 1; t2 >= 0; t2--) for (var e3 = this.bottom_up ? t2 : this.height - 1 - t2, r2 = 0; r2 < this.width; r2++) {
        var n2 = this.datav.getUint8(this.pos++, true), i2 = this.datav.getUint8(this.pos++, true), a3 = this.datav.getUint8(this.pos++, true), o2 = this.datav.getUint8(this.pos++, true), s2 = e3 * this.width * 4 + 4 * r2;
        this.data[s2] = a3, this.data[s2 + 1] = i2, this.data[s2 + 2] = n2, this.data[s2 + 3] = o2;
      }
    }, te.prototype.getData = function() {
      return this.data;
    }, /**
     * @license
     * Copyright (c) 2018 Aras Abbasi
     *
     * Licensed under the MIT License.
     * http://opensource.org/licenses/mit-license
     */
    (function(t2) {
      t2.processBMP = function(e3, r2, n2, i2) {
        var a3 = new te(e3, false), o2 = a3.width, s2 = a3.height, c2 = { data: a3.getData(), width: o2, height: s2 }, u3 = new Qt(100).encode(c2, 100);
        return t2.processJPEG.call(this, u3, r2, n2, i2);
      };
    })(j.API), ee.prototype.getData = function() {
      return this.data;
    }, /**
     * @license
     * Copyright (c) 2019 Aras Abbasi
     *
     * Licensed under the MIT License.
     * http://opensource.org/licenses/mit-license
     */
    (function(t2) {
      t2.processWEBP = function(e3, r2, n2, i2) {
        var a3 = new ee(e3), o2 = a3.width, s2 = a3.height, c2 = { data: a3.getData(), width: o2, height: s2 }, u3 = new Qt(100).encode(c2, 100);
        return t2.processJPEG.call(this, u3, r2, n2, i2);
      };
    })(j.API), j.API.processRGBA = function(t2, e3, r2) {
      for (var n2 = t2.data, i2 = n2.length, a3 = new Uint8Array(i2 / 4 * 3), o2 = new Uint8Array(i2 / 4), s2 = 0, c2 = 0, u3 = 0; u3 < i2; u3 += 4) {
        var l2 = n2[u3], h2 = n2[u3 + 1], f3 = n2[u3 + 2], d2 = n2[u3 + 3];
        a3[s2++] = l2, a3[s2++] = h2, a3[s2++] = f3, o2[c2++] = d2;
      }
      var p2 = this.__addimage__.arrayBufferToBinaryString(a3);
      return { alpha: this.__addimage__.arrayBufferToBinaryString(o2), data: p2, index: e3, alias: r2, colorSpace: "DeviceRGB", bitsPerComponent: 8, width: t2.width, height: t2.height };
    }, j.API.setLanguage = function(t2) {
      return void 0 === this.internal.languageSettings && (this.internal.languageSettings = {}, this.internal.languageSettings.isSubscribed = false), void 0 !== { af: "Afrikaans", sq: "Albanian", ar: "Arabic (Standard)", "ar-DZ": "Arabic (Algeria)", "ar-BH": "Arabic (Bahrain)", "ar-EG": "Arabic (Egypt)", "ar-IQ": "Arabic (Iraq)", "ar-JO": "Arabic (Jordan)", "ar-KW": "Arabic (Kuwait)", "ar-LB": "Arabic (Lebanon)", "ar-LY": "Arabic (Libya)", "ar-MA": "Arabic (Morocco)", "ar-OM": "Arabic (Oman)", "ar-QA": "Arabic (Qatar)", "ar-SA": "Arabic (Saudi Arabia)", "ar-SY": "Arabic (Syria)", "ar-TN": "Arabic (Tunisia)", "ar-AE": "Arabic (U.A.E.)", "ar-YE": "Arabic (Yemen)", an: "Aragonese", hy: "Armenian", as: "Assamese", ast: "Asturian", az: "Azerbaijani", eu: "Basque", be: "Belarusian", bn: "Bengali", bs: "Bosnian", br: "Breton", bg: "Bulgarian", my: "Burmese", ca: "Catalan", ch: "Chamorro", ce: "Chechen", zh: "Chinese", "zh-HK": "Chinese (Hong Kong)", "zh-CN": "Chinese (PRC)", "zh-SG": "Chinese (Singapore)", "zh-TW": "Chinese (Taiwan)", cv: "Chuvash", co: "Corsican", cr: "Cree", hr: "Croatian", cs: "Czech", da: "Danish", nl: "Dutch (Standard)", "nl-BE": "Dutch (Belgian)", en: "English", "en-AU": "English (Australia)", "en-BZ": "English (Belize)", "en-CA": "English (Canada)", "en-IE": "English (Ireland)", "en-JM": "English (Jamaica)", "en-NZ": "English (New Zealand)", "en-PH": "English (Philippines)", "en-ZA": "English (South Africa)", "en-TT": "English (Trinidad & Tobago)", "en-GB": "English (United Kingdom)", "en-US": "English (United States)", "en-ZW": "English (Zimbabwe)", eo: "Esperanto", et: "Estonian", fo: "Faeroese", fj: "Fijian", fi: "Finnish", fr: "French (Standard)", "fr-BE": "French (Belgium)", "fr-CA": "French (Canada)", "fr-FR": "French (France)", "fr-LU": "French (Luxembourg)", "fr-MC": "French (Monaco)", "fr-CH": "French (Switzerland)", fy: "Frisian", fur: "Friulian", gd: "Gaelic (Scots)", "gd-IE": "Gaelic (Irish)", gl: "Galacian", ka: "Georgian", de: "German (Standard)", "de-AT": "German (Austria)", "de-DE": "German (Germany)", "de-LI": "German (Liechtenstein)", "de-LU": "German (Luxembourg)", "de-CH": "German (Switzerland)", el: "Greek", gu: "Gujurati", ht: "Haitian", he: "Hebrew", hi: "Hindi", hu: "Hungarian", is: "Icelandic", id: "Indonesian", iu: "Inuktitut", ga: "Irish", it: "Italian (Standard)", "it-CH": "Italian (Switzerland)", ja: "Japanese", kn: "Kannada", ks: "Kashmiri", kk: "Kazakh", km: "Khmer", ky: "Kirghiz", tlh: "Klingon", ko: "Korean", "ko-KP": "Korean (North Korea)", "ko-KR": "Korean (South Korea)", la: "Latin", lv: "Latvian", lt: "Lithuanian", lb: "Luxembourgish", mk: "North Macedonia", ms: "Malay", ml: "Malayalam", mt: "Maltese", mi: "Maori", mr: "Marathi", mo: "Moldavian", nv: "Navajo", ng: "Ndonga", ne: "Nepali", no: "Norwegian", nb: "Norwegian (Bokmal)", nn: "Norwegian (Nynorsk)", oc: "Occitan", or: "Oriya", om: "Oromo", fa: "Persian", "fa-IR": "Persian/Iran", pl: "Polish", pt: "Portuguese", "pt-BR": "Portuguese (Brazil)", pa: "Punjabi", "pa-IN": "Punjabi (India)", "pa-PK": "Punjabi (Pakistan)", qu: "Quechua", rm: "Rhaeto-Romanic", ro: "Romanian", "ro-MO": "Romanian (Moldavia)", ru: "Russian", "ru-MO": "Russian (Moldavia)", sz: "Sami (Lappish)", sg: "Sango", sa: "Sanskrit", sc: "Sardinian", sd: "Sindhi", si: "Singhalese", sr: "Serbian", sk: "Slovak", sl: "Slovenian", so: "Somani", sb: "Sorbian", es: "Spanish", "es-AR": "Spanish (Argentina)", "es-BO": "Spanish (Bolivia)", "es-CL": "Spanish (Chile)", "es-CO": "Spanish (Colombia)", "es-CR": "Spanish (Costa Rica)", "es-DO": "Spanish (Dominican Republic)", "es-EC": "Spanish (Ecuador)", "es-SV": "Spanish (El Salvador)", "es-GT": "Spanish (Guatemala)", "es-HN": "Spanish (Honduras)", "es-MX": "Spanish (Mexico)", "es-NI": "Spanish (Nicaragua)", "es-PA": "Spanish (Panama)", "es-PY": "Spanish (Paraguay)", "es-PE": "Spanish (Peru)", "es-PR": "Spanish (Puerto Rico)", "es-ES": "Spanish (Spain)", "es-UY": "Spanish (Uruguay)", "es-VE": "Spanish (Venezuela)", sx: "Sutu", sw: "Swahili", sv: "Swedish", "sv-FI": "Swedish (Finland)", "sv-SV": "Swedish (Sweden)", ta: "Tamil", tt: "Tatar", te: "Teluga", th: "Thai", tig: "Tigre", ts: "Tsonga", tn: "Tswana", tr: "Turkish", tk: "Turkmen", uk: "Ukrainian", hsb: "Upper Sorbian", ur: "Urdu", ve: "Venda", vi: "Vietnamese", vo: "Volapuk", wa: "Walloon", cy: "Welsh", xh: "Xhosa", ji: "Yiddish", zu: "Zulu" }[t2] && (this.internal.languageSettings.languageCode = t2, false === this.internal.languageSettings.isSubscribed && (this.internal.events.subscribe("putCatalog", function() {
        this.internal.write("/Lang (" + this.internal.languageSettings.languageCode + ")");
      }), this.internal.languageSettings.isSubscribed = true)), this;
    }, /** @license
     * MIT license.
     * Copyright (c) 2012 Willow Systems Corporation, https://github.com/willowsystems
     *               2014 Diego Casorran, https://github.com/diegocr
     *
     * Permission is hereby granted, free of charge, to any person obtaining
     * a copy of this software and associated documentation files (the
     * "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish,
     * distribute, sublicense, and/or sell copies of the Software, and to
     * permit persons to whom the Software is furnished to do so, subject to
     * the following conditions:
     *
     * The above copyright notice and this permission notice shall be
     * included in all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
     * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
     * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
     * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
     * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     * ====================================================================
     */
    Bt = j.API, qt = Bt.getCharWidthsArray = function(t2, e3) {
      var r2, n2, i2 = (e3 = e3 || {}).font || this.internal.getFont(), a3 = e3.fontSize || this.internal.getFontSize(), o2 = e3.charSpace || this.internal.getCharSpace(), s2 = e3.widths ? e3.widths : i2.metadata.Unicode.widths, c2 = s2.fof ? s2.fof : 1, u3 = e3.kerning ? e3.kerning : i2.metadata.Unicode.kerning, l2 = u3.fof ? u3.fof : 1, h2 = false !== e3.doKerning, f3 = 0, d2 = t2.length, p2 = 0, g2 = s2[0] || c2, m2 = [];
      for (r2 = 0; r2 < d2; r2++) n2 = t2.charCodeAt(r2), "function" == typeof i2.metadata.widthOfString ? m2.push((i2.metadata.widthOfGlyph(i2.metadata.characterToGlyph(n2)) + o2 * (1e3 / a3) || 0) / 1e3) : (f3 = h2 && "object" == typeof u3[n2] && !isNaN(parseInt(u3[n2][p2], 10)) ? u3[n2][p2] / l2 : 0, m2.push((s2[n2] || g2) / c2 + f3)), p2 = n2;
      return m2;
    }, Mt = Bt.getStringUnitWidth = function(t2, e3) {
      var r2 = (e3 = e3 || {}).fontSize || this.internal.getFontSize(), n2 = e3.font || this.internal.getFont(), i2 = e3.charSpace || this.internal.getCharSpace();
      return Bt.processArabic && (t2 = Bt.processArabic(t2)), "function" == typeof n2.metadata.widthOfString ? n2.metadata.widthOfString(t2, r2, i2) / r2 : qt.apply(this, arguments).reduce(function(t3, e4) {
        return t3 + e4;
      }, 0);
    }, Et = function(t2, e3, r2, n2) {
      for (var i2 = [], a3 = 0, o2 = t2.length, s2 = 0; a3 !== o2 && s2 + e3[a3] < r2; ) s2 += e3[a3], a3++;
      i2.push(t2.slice(0, a3));
      var c2 = a3;
      for (s2 = 0; a3 !== o2; ) s2 + e3[a3] > n2 && (i2.push(t2.slice(c2, a3)), s2 = 0, c2 = a3), s2 += e3[a3], a3++;
      return c2 !== a3 && i2.push(t2.slice(c2, a3)), i2;
    }, Rt = function(t2, e3, r2) {
      r2 || (r2 = {});
      var n2, i2, a3, o2, s2, c2, u3, l2 = [], h2 = [l2], f3 = r2.textIndent || 0, d2 = 0, p2 = 0, g2 = t2.split(" "), m2 = qt.apply(this, [" ", r2])[0];
      if (c2 = -1 === r2.lineIndent ? g2[0].length + 2 : r2.lineIndent || 0) {
        var v2 = Array(c2).join(" "), b2 = [];
        g2.map(function(t3) {
          (t3 = t3.split(/\s*\n/)).length > 1 ? b2 = b2.concat(t3.map(function(t4, e4) {
            return (e4 && t4.length ? "\n" : "") + t4;
          })) : b2.push(t3[0]);
        }), g2 = b2, c2 = Mt.apply(this, [v2, r2]);
      }
      for (a3 = 0, o2 = g2.length; a3 < o2; a3++) {
        var y2 = 0;
        if (n2 = g2[a3], c2 && "\n" == n2[0] && (n2 = n2.substr(1), y2 = 1), f3 + d2 + (p2 = (i2 = qt.apply(this, [n2, r2])).reduce(function(t3, e4) {
          return t3 + e4;
        }, 0)) > e3 || y2) {
          if (p2 > e3) {
            for (s2 = Et.apply(this, [n2, i2, e3 - (f3 + d2), e3]), l2.push(s2.shift()), l2 = [s2.pop()]; s2.length; ) h2.push([s2.shift()]);
            p2 = i2.slice(n2.length - (l2[0] ? l2[0].length : 0)).reduce(function(t3, e4) {
              return t3 + e4;
            }, 0);
          } else l2 = [n2];
          h2.push(l2), f3 = p2 + c2, d2 = m2;
        } else l2.push(n2), f3 += d2 + p2, d2 = m2;
      }
      return u3 = c2 ? function(t3, e4) {
        return (e4 ? v2 : "") + t3.join(" ");
      } : function(t3) {
        return t3.join(" ");
      }, h2.map(u3);
    }, Bt.splitTextToSize = function(t2, e3, r2) {
      var n2, i2 = (r2 = r2 || {}).fontSize || this.internal.getFontSize(), a3 = function(t3) {
        if (t3.widths && t3.kerning) return { widths: t3.widths, kerning: t3.kerning };
        var e4 = this.internal.getFont(t3.fontName, t3.fontStyle), r3 = "Unicode";
        return e4.metadata[r3] ? { widths: e4.metadata[r3].widths || { 0: 1 }, kerning: e4.metadata[r3].kerning || {} } : { font: e4.metadata, fontSize: this.internal.getFontSize(), charSpace: this.internal.getCharSpace() };
      }.call(this, r2);
      n2 = Array.isArray(t2) ? t2 : String(t2).split(/\r?\n/);
      var o2 = 1 * this.internal.scaleFactor * e3 / i2;
      a3.textIndent = r2.textIndent ? 1 * r2.textIndent * this.internal.scaleFactor / i2 : 0, a3.lineIndent = r2.lineIndent;
      var s2, c2, u3 = [];
      for (s2 = 0, c2 = n2.length; s2 < c2; s2++) u3 = u3.concat(Rt.apply(this, [n2[s2], o2, a3]));
      return u3;
    }, /** @license
     jsPDF standard_fonts_metrics plugin
     * Copyright (c) 2012 Willow Systems Corporation, https://github.com/willowsystems
     * MIT license.
     * Permission is hereby granted, free of charge, to any person obtaining
     * a copy of this software and associated documentation files (the
     * "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish,
     * distribute, sublicense, and/or sell copies of the Software, and to
     * permit persons to whom the Software is furnished to do so, subject to
     * the following conditions:
     * 
     * The above copyright notice and this permission notice shall be
     * included in all copies or substantial portions of the Software.
     * 
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
     * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
     * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
     * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
     * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     * ====================================================================
     */
    (function(t2) {
      t2.__fontmetrics__ = t2.__fontmetrics__ || {};
      for (var e3 = "0123456789abcdef", r2 = "klmnopqrstuvwxyz", n2 = {}, i2 = {}, a3 = 0; a3 < 16; a3++) n2[r2[a3]] = e3[a3], i2[e3[a3]] = r2[a3];
      var o2 = function(t3) {
        return "0x" + parseInt(t3, 10).toString(16);
      }, s2 = t2.__fontmetrics__.compress = function(t3) {
        var e4, r3, n3, a4, c3 = ["{"];
        for (var u4 in t3) {
          if (e4 = t3[u4], isNaN(parseInt(u4, 10)) ? r3 = "'" + u4 + "'" : (u4 = parseInt(u4, 10), r3 = (r3 = o2(u4).slice(2)).slice(0, -1) + i2[r3.slice(-1)]), "number" == typeof e4) e4 < 0 ? (n3 = o2(e4).slice(3), a4 = "-") : (n3 = o2(e4).slice(2), a4 = ""), n3 = a4 + n3.slice(0, -1) + i2[n3.slice(-1)];
          else {
            if ("object" != typeof e4) throw new Error("Don't know what to do with value type " + typeof e4 + ".");
            n3 = s2(e4);
          }
          c3.push(r3 + n3);
        }
        return c3.push("}"), c3.join("");
      }, c2 = t2.__fontmetrics__.uncompress = function(t3) {
        if ("string" != typeof t3) throw new Error("Invalid argument passed to uncompress.");
        for (var e4, r3, i3, a4, o3 = {}, s3 = 1, c3 = o3, u4 = [], l3 = "", h3 = "", f3 = t3.length - 1, d2 = 1; d2 < f3; d2 += 1) "'" == (a4 = t3[d2]) ? e4 ? (i3 = e4.join(""), e4 = void 0) : e4 = [] : e4 ? e4.push(a4) : "{" == a4 ? (u4.push([c3, i3]), c3 = {}, i3 = void 0) : "}" == a4 ? ((r3 = u4.pop())[0][r3[1]] = c3, i3 = void 0, c3 = r3[0]) : "-" == a4 ? s3 = -1 : void 0 === i3 ? n2.hasOwnProperty(a4) ? (l3 += n2[a4], i3 = parseInt(l3, 16) * s3, s3 = 1, l3 = "") : l3 += a4 : n2.hasOwnProperty(a4) ? (h3 += n2[a4], c3[i3] = parseInt(h3, 16) * s3, s3 = 1, i3 = void 0, h3 = "") : h3 += a4;
        return o3;
      }, u3 = { codePages: ["WinAnsiEncoding"], WinAnsiEncoding: c2("{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}") }, l2 = { Unicode: { Courier: u3, "Courier-Bold": u3, "Courier-BoldOblique": u3, "Courier-Oblique": u3, Helvetica: u3, "Helvetica-Bold": u3, "Helvetica-BoldOblique": u3, "Helvetica-Oblique": u3, "Times-Roman": u3, "Times-Bold": u3, "Times-BoldItalic": u3, "Times-Italic": u3 } }, h2 = { Unicode: { "Courier-Oblique": c2("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-BoldItalic": c2("{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}"), "Helvetica-Bold": c2("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), Courier: c2("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-BoldOblique": c2("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Bold": c2("{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}"), Symbol: c2("{'widths'{k3uaw4r19m3m2k1t2l2l202m2y2n3m2p5n202q6o3k3m2s2l2t2l2v3r2w1t3m3m2y1t2z1wbk2sbl3r'fof'6o3n3m3o3m3p3m3q3m3r3m3s3m3t3m3u1w3v1w3w3r3x3r3y3r3z2wbp3t3l3m5v2l5x2l5z3m2q4yfr3r7v3k7w1o7x3k}'kerning'{'fof'-6o}}"), Helvetica: c2("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}"), "Helvetica-BoldOblique": c2("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), ZapfDingbats: c2("{'widths'{k4u2k1w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-Bold": c2("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Italic": c2("{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}"), "Times-Roman": c2("{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}"), "Helvetica-Oblique": c2("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}") } };
      t2.events.push(["addFont", function(t3) {
        var e4 = t3.font, r3 = h2.Unicode[e4.postScriptName];
        r3 && (e4.metadata.Unicode = {}, e4.metadata.Unicode.widths = r3.widths, e4.metadata.Unicode.kerning = r3.kerning);
        var n3 = l2.Unicode[e4.postScriptName];
        n3 && (e4.metadata.Unicode.encoding = n3, e4.encoding = n3.codePages[0]);
      }]);
    })(j.API), /**
     * @license
     * Licensed under the MIT License.
     * http://opensource.org/licenses/mit-license
     */
    (function(t2) {
      var e3 = function(t3) {
        for (var e4 = t3.length, r2 = new Uint8Array(e4), n2 = 0; n2 < e4; n2++) r2[n2] = t3.charCodeAt(n2);
        return r2;
      };
      t2.API.events.push(["addFont", function(r2) {
        var n2 = void 0, a3 = r2.font, o2 = r2.instance;
        if (!a3.isStandardFont) {
          if (void 0 === o2) throw new Error("Font does not exist in vFS, import fonts or remove declaration doc.addFont('" + a3.postScriptName + "').");
          if ("string" != typeof (n2 = false === o2.existsFileInVFS(a3.postScriptName) ? o2.loadFile(a3.postScriptName) : o2.getFileFromVFS(a3.postScriptName))) throw new Error("Font is not stored as string-data in vFS, import fonts or remove declaration doc.addFont('" + a3.postScriptName + "').");
          !(function(r3, n3) {
            n3 = /^\x00\x01\x00\x00/.test(n3) ? e3(n3) : e3(i(n3)), r3.metadata = t2.API.TTFFont.open(n3), r3.metadata.Unicode = r3.metadata.Unicode || { encoding: {}, kerning: {}, widths: [] }, r3.metadata.glyIdsUsed = [0];
          })(a3, n2);
        }
      }]);
    })(j), j.API.addSvgAsImage = function(t2, e3, n2, i2, a3, o2, c2, u3) {
      if (isNaN(e3) || isNaN(n2)) throw s.error("jsPDF.addSvgAsImage: Invalid coordinates", arguments), new Error("Invalid coordinates passed to jsPDF.addSvgAsImage");
      if (isNaN(i2) || isNaN(a3)) throw s.error("jsPDF.addSvgAsImage: Invalid measurements", arguments), new Error("Invalid measurements (width and/or height) passed to jsPDF.addSvgAsImage");
      var l2 = document.createElement("canvas");
      l2.width = i2, l2.height = a3;
      var h2 = l2.getContext("2d");
      h2.fillStyle = "#fff", h2.fillRect(0, 0, l2.width, l2.height);
      var f3 = { ignoreMouse: true, ignoreAnimation: true, ignoreDimensions: true }, d2 = this;
      return (r.canvg ? Promise.resolve(r.canvg) : "object" == typeof exports && "undefined" != typeof module ? new Promise(function(t3, e4) {
        try {
          t3(require_lib2());
        } catch (r2) {
          e4(r2);
        }
      }) : "function" == typeof define && define.amd ? new Promise(function(t3, e4) {
        try {
          __require(["canvg"], t3);
        } catch (r2) {
          e4(r2);
        }
      }) : Promise.reject(new Error("Could not load canvg"))).catch(function(t3) {
        return Promise.reject(new Error("Could not load canvg: " + t3));
      }).then(function(t3) {
        return t3.default ? t3.default : t3;
      }).then(function(e4) {
        return e4.fromString(h2, t2, f3);
      }, function() {
        return Promise.reject(new Error("Could not load canvg."));
      }).then(function(t3) {
        return t3.render(f3);
      }).then(function() {
        d2.addImage(l2.toDataURL("image/jpeg", 1), e3, n2, i2, a3, c2, u3);
      });
    }, j.API.putTotalPages = function(t2) {
      var e3, r2 = 0;
      parseInt(this.internal.getFont().id.substr(1), 10) < 15 ? (e3 = new RegExp(t2, "g"), r2 = this.internal.getNumberOfPages()) : (e3 = new RegExp(this.pdfEscape16(t2, this.internal.getFont()), "g"), r2 = this.pdfEscape16(this.internal.getNumberOfPages() + "", this.internal.getFont()));
      for (var n2 = 1; n2 <= this.internal.getNumberOfPages(); n2++) for (var i2 = 0; i2 < this.internal.pages[n2].length; i2++) this.internal.pages[n2][i2] = this.internal.pages[n2][i2].replace(e3, r2);
      return this;
    }, j.API.viewerPreferences = function(t2, e3) {
      var r2;
      t2 = t2 || {}, e3 = e3 || false;
      var n2, i2, a3, o2 = { HideToolbar: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, HideMenubar: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, HideWindowUI: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, FitWindow: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, CenterWindow: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, DisplayDocTitle: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.4 }, NonFullScreenPageMode: { defaultValue: "UseNone", value: "UseNone", type: "name", explicitSet: false, valueSet: ["UseNone", "UseOutlines", "UseThumbs", "UseOC"], pdfVersion: 1.3 }, Direction: { defaultValue: "L2R", value: "L2R", type: "name", explicitSet: false, valueSet: ["L2R", "R2L"], pdfVersion: 1.3 }, ViewArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, ViewClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintScaling: { defaultValue: "AppDefault", value: "AppDefault", type: "name", explicitSet: false, valueSet: ["AppDefault", "None"], pdfVersion: 1.6 }, Duplex: { defaultValue: "", value: "none", type: "name", explicitSet: false, valueSet: ["Simplex", "DuplexFlipShortEdge", "DuplexFlipLongEdge", "none"], pdfVersion: 1.7 }, PickTrayByPDFSize: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.7 }, PrintPageRange: { defaultValue: "", value: "", type: "array", explicitSet: false, valueSet: null, pdfVersion: 1.7 }, NumCopies: { defaultValue: 1, value: 1, type: "integer", explicitSet: false, valueSet: null, pdfVersion: 1.7 } }, s2 = Object.keys(o2), c2 = [], u3 = 0, l2 = 0, h2 = 0;
      function f3(t3, e4) {
        var r3, n3 = false;
        for (r3 = 0; r3 < t3.length; r3 += 1) t3[r3] === e4 && (n3 = true);
        return n3;
      }
      if (void 0 === this.internal.viewerpreferences && (this.internal.viewerpreferences = {}, this.internal.viewerpreferences.configuration = JSON.parse(JSON.stringify(o2)), this.internal.viewerpreferences.isSubscribed = false), r2 = this.internal.viewerpreferences.configuration, "reset" === t2 || true === e3) {
        var d2 = s2.length;
        for (h2 = 0; h2 < d2; h2 += 1) r2[s2[h2]].value = r2[s2[h2]].defaultValue, r2[s2[h2]].explicitSet = false;
      }
      if ("object" == typeof t2) {
        for (i2 in t2) if (a3 = t2[i2], f3(s2, i2) && void 0 !== a3) {
          if ("boolean" === r2[i2].type && "boolean" == typeof a3) r2[i2].value = a3;
          else if ("name" === r2[i2].type && f3(r2[i2].valueSet, a3)) r2[i2].value = a3;
          else if ("integer" === r2[i2].type && Number.isInteger(a3)) r2[i2].value = a3;
          else if ("array" === r2[i2].type) {
            for (u3 = 0; u3 < a3.length; u3 += 1) if (n2 = true, 1 === a3[u3].length && "number" == typeof a3[u3][0]) c2.push(String(a3[u3] - 1));
            else if (a3[u3].length > 1) {
              for (l2 = 0; l2 < a3[u3].length; l2 += 1) "number" != typeof a3[u3][l2] && (n2 = false);
              true === n2 && c2.push([a3[u3][0] - 1, a3[u3][1] - 1].join(" "));
            }
            r2[i2].value = "[" + c2.join(" ") + "]";
          } else r2[i2].value = r2[i2].defaultValue;
          r2[i2].explicitSet = true;
        }
      }
      return false === this.internal.viewerpreferences.isSubscribed && (this.internal.events.subscribe("putCatalog", function() {
        var t3, e4 = [];
        for (t3 in r2) true === r2[t3].explicitSet && ("name" === r2[t3].type ? e4.push("/" + t3 + " /" + r2[t3].value) : e4.push("/" + t3 + " " + r2[t3].value));
        0 !== e4.length && this.internal.write("/ViewerPreferences\n<<\n" + e4.join("\n") + "\n>>");
      }), this.internal.viewerpreferences.isSubscribed = true), this.internal.viewerpreferences.configuration = r2, this;
    }, j.API.addMetadata = function(t2, e3) {
      return void 0 === this.internal.__metadata__ && (this.internal.__metadata__ = { metadata: t2, namespaceUri: e3 ?? "http://jspdf.default.namespaceuri/", rawXml: "boolean" == typeof e3 && e3 }, this.internal.events.subscribe("putCatalog", ne), this.internal.events.subscribe("postPutResources", re)), this;
    }, (function(t2) {
      var e3 = t2.API, r2 = e3.pdfEscape16 = function(t3, e4) {
        for (var r3, n3 = e4.metadata.Unicode.widths, i3 = ["", "0", "00", "000", "0000"], a3 = [""], o2 = 0, s2 = t3.length; o2 < s2; ++o2) {
          if (r3 = e4.metadata.characterToGlyph(t3.charCodeAt(o2)), e4.metadata.glyIdsUsed.push(r3), e4.metadata.toUnicode[r3] = t3.charCodeAt(o2), -1 == n3.indexOf(r3) && (n3.push(r3), n3.push([parseInt(e4.metadata.widthOfGlyph(r3), 10)])), "0" == r3) return a3.join("");
          r3 = r3.toString(16), a3.push(i3[4 - r3.length], r3);
        }
        return a3.join("");
      }, n2 = function(t3) {
        var e4, r3, n3, i3, a3, o2, s2;
        for (a3 = "/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap\n/CIDSystemInfo <<\n  /Registry (Adobe)\n  /Ordering (UCS)\n  /Supplement 0\n>> def\n/CMapName /Adobe-Identity-UCS def\n/CMapType 2 def\n1 begincodespacerange\n<0000><ffff>\nendcodespacerange", n3 = [], o2 = 0, s2 = (r3 = Object.keys(t3).sort(function(t4, e5) {
          return t4 - e5;
        })).length; o2 < s2; o2++) e4 = r3[o2], n3.length >= 100 && (a3 += "\n" + n3.length + " beginbfchar\n" + n3.join("\n") + "\nendbfchar", n3 = []), void 0 !== t3[e4] && null !== t3[e4] && "function" == typeof t3[e4].toString && (i3 = ("0000" + t3[e4].toString(16)).slice(-4), e4 = ("0000" + (+e4).toString(16)).slice(-4), n3.push("<" + e4 + "><" + i3 + ">"));
        return n3.length && (a3 += "\n" + n3.length + " beginbfchar\n" + n3.join("\n") + "\nendbfchar\n"), a3 + "endcmap\nCMapName currentdict /CMap defineresource pop\nend\nend";
      };
      e3.events.push(["putFont", function(e4) {
        !(function(e5) {
          var r3 = e5.font, i3 = e5.out, a3 = e5.newObject, o2 = e5.putStream;
          if (r3.metadata instanceof t2.API.TTFFont && "Identity-H" === r3.encoding) {
            for (var s2 = r3.metadata.Unicode.widths, c2 = r3.metadata.subset.encode(r3.metadata.glyIdsUsed, 1), u3 = "", l2 = 0; l2 < c2.length; l2++) u3 += String.fromCharCode(c2[l2]);
            var h2 = a3();
            o2({ data: u3, addLength1: true, objectId: h2 }), i3("endobj");
            var f3 = a3();
            o2({ data: n2(r3.metadata.toUnicode), addLength1: true, objectId: f3 }), i3("endobj");
            var d2 = a3();
            i3("<<"), i3("/Type /FontDescriptor"), i3("/FontName /" + S(r3.fontName)), i3("/FontFile2 " + h2 + " 0 R"), i3("/FontBBox " + t2.API.PDFObject.convert(r3.metadata.bbox)), i3("/Flags " + r3.metadata.flags), i3("/StemV " + r3.metadata.stemV), i3("/ItalicAngle " + r3.metadata.italicAngle), i3("/Ascent " + r3.metadata.ascender), i3("/Descent " + r3.metadata.decender), i3("/CapHeight " + r3.metadata.capHeight), i3(">>"), i3("endobj");
            var p2 = a3();
            i3("<<"), i3("/Type /Font"), i3("/BaseFont /" + S(r3.fontName)), i3("/FontDescriptor " + d2 + " 0 R"), i3("/W " + t2.API.PDFObject.convert(s2)), i3("/CIDToGIDMap /Identity"), i3("/DW 1000"), i3("/Subtype /CIDFontType2"), i3("/CIDSystemInfo"), i3("<<"), i3("/Supplement 0"), i3("/Registry (Adobe)"), i3("/Ordering (" + r3.encoding + ")"), i3(">>"), i3(">>"), i3("endobj"), r3.objectNumber = a3(), i3("<<"), i3("/Type /Font"), i3("/Subtype /Type0"), i3("/ToUnicode " + f3 + " 0 R"), i3("/BaseFont /" + S(r3.fontName)), i3("/Encoding /" + r3.encoding), i3("/DescendantFonts [" + p2 + " 0 R]"), i3(">>"), i3("endobj"), r3.isAlreadyPutted = true;
          }
        })(e4);
      }]), e3.events.push(["putFont", function(e4) {
        !(function(e5) {
          var r3 = e5.font, i3 = e5.out, a3 = e5.newObject, o2 = e5.putStream;
          if (r3.metadata instanceof t2.API.TTFFont && "WinAnsiEncoding" === r3.encoding) {
            for (var s2 = r3.metadata.rawData, c2 = "", u3 = 0; u3 < s2.length; u3++) c2 += String.fromCharCode(s2[u3]);
            var l2 = a3();
            o2({ data: c2, addLength1: true, objectId: l2 }), i3("endobj");
            var h2 = a3();
            o2({ data: n2(r3.metadata.toUnicode), addLength1: true, objectId: h2 }), i3("endobj");
            var f3 = a3();
            i3("<<"), i3("/Descent " + r3.metadata.decender), i3("/CapHeight " + r3.metadata.capHeight), i3("/StemV " + r3.metadata.stemV), i3("/Type /FontDescriptor"), i3("/FontFile2 " + l2 + " 0 R"), i3("/Flags 96"), i3("/FontBBox " + t2.API.PDFObject.convert(r3.metadata.bbox)), i3("/FontName /" + S(r3.fontName)), i3("/ItalicAngle " + r3.metadata.italicAngle), i3("/Ascent " + r3.metadata.ascender), i3(">>"), i3("endobj"), r3.objectNumber = a3();
            for (var d2 = 0; d2 < r3.metadata.hmtx.widths.length; d2++) r3.metadata.hmtx.widths[d2] = parseInt(r3.metadata.hmtx.widths[d2] * (1e3 / r3.metadata.head.unitsPerEm));
            i3("<</Subtype/TrueType/Type/Font/ToUnicode " + h2 + " 0 R/BaseFont/" + S(r3.fontName) + "/FontDescriptor " + f3 + " 0 R/Encoding/" + r3.encoding + " /FirstChar 29 /LastChar 255 /Widths " + t2.API.PDFObject.convert(r3.metadata.hmtx.widths) + ">>"), i3("endobj"), r3.isAlreadyPutted = true;
          }
        })(e4);
      }]);
      var i2 = function(t3) {
        var e4, n3 = t3.text || "", i3 = t3.x, a3 = t3.y, o2 = t3.options || {}, s2 = t3.mutex || {}, c2 = s2.pdfEscape, u3 = s2.activeFontKey, l2 = s2.fonts, h2 = u3, f3 = "", d2 = 0, p2 = "", g2 = l2[h2].encoding;
        if ("Identity-H" !== l2[h2].encoding) return { text: n3, x: i3, y: a3, options: o2, mutex: s2 };
        for (p2 = n3, h2 = u3, Array.isArray(n3) && (p2 = n3[0]), d2 = 0; d2 < p2.length; d2 += 1) l2[h2].metadata.hasOwnProperty("cmap") && (e4 = l2[h2].metadata.cmap.unicode.codeMap[p2[d2].charCodeAt(0)]), e4 || p2[d2].charCodeAt(0) < 256 && l2[h2].metadata.hasOwnProperty("Unicode") ? f3 += p2[d2] : f3 += "";
        var m2 = "";
        return parseInt(h2.slice(1)) < 14 || "WinAnsiEncoding" === g2 ? m2 = c2(f3, h2).split("").map(function(t4) {
          return t4.charCodeAt(0).toString(16);
        }).join("") : "Identity-H" === g2 && (m2 = r2(f3, l2[h2])), s2.isHex = true, { text: m2, x: i3, y: a3, options: o2, mutex: s2 };
      };
      e3.events.push(["postProcessText", function(t3) {
        var e4 = t3.text || "", r3 = [], n3 = { text: e4, x: t3.x, y: t3.y, options: t3.options, mutex: t3.mutex };
        if (Array.isArray(e4)) {
          var a3 = 0;
          for (a3 = 0; a3 < e4.length; a3 += 1) Array.isArray(e4[a3]) && 3 === e4[a3].length ? r3.push([i2(Object.assign({}, n3, { text: e4[a3][0] })).text, e4[a3][1], e4[a3][2]]) : r3.push(i2(Object.assign({}, n3, { text: e4[a3] })).text);
          t3.text = r3;
        } else t3.text = i2(Object.assign({}, n3, { text: e4 })).text;
      }]);
    })(j), /**
     * @license
     * jsPDF virtual FileSystem functionality
     *
     * Licensed under the MIT License.
     * http://opensource.org/licenses/mit-license
     */
    (function(t2) {
      var e3 = function() {
        return void 0 === this.internal.vFS && (this.internal.vFS = {}), true;
      };
      t2.existsFileInVFS = function(t3) {
        return e3.call(this), void 0 !== this.internal.vFS[t3];
      }, t2.addFileToVFS = function(t3, r2) {
        return e3.call(this), this.internal.vFS[t3] = r2, this;
      }, t2.getFileFromVFS = function(t3) {
        return e3.call(this), void 0 !== this.internal.vFS[t3] ? this.internal.vFS[t3] : null;
      };
    })(j.API), /**
     * @license
     * Unicode Bidi Engine based on the work of Alex Shensis (@asthensis)
     * MIT License
     */
    (function(t2) {
      t2.__bidiEngine__ = t2.prototype.__bidiEngine__ = function(t3) {
        var r3, n2, i2, a3, o2, s2, c2, u3 = e3, l2 = [[0, 3, 0, 1, 0, 0, 0], [0, 3, 0, 1, 2, 2, 0], [0, 3, 0, 17, 2, 0, 1], [0, 3, 5, 5, 4, 1, 0], [0, 3, 21, 21, 4, 0, 1], [0, 3, 5, 5, 4, 2, 0]], h2 = [[2, 0, 1, 1, 0, 1, 0], [2, 0, 1, 1, 0, 2, 0], [2, 0, 2, 1, 3, 2, 0], [2, 0, 2, 33, 3, 1, 1]], f3 = { L: 0, R: 1, EN: 2, AN: 3, N: 4, B: 5, S: 6 }, d2 = { 0: 0, 5: 1, 6: 2, 7: 3, 32: 4, 251: 5, 254: 6, 255: 7 }, p2 = ["(", ")", "(", "<", ">", "<", "[", "]", "[", "{", "}", "{", "\xAB", "\xBB", "\xAB", "\u2039", "\u203A", "\u2039", "\u2045", "\u2046", "\u2045", "\u207D", "\u207E", "\u207D", "\u208D", "\u208E", "\u208D", "\u2264", "\u2265", "\u2264", "\u2329", "\u232A", "\u2329", "\uFE59", "\uFE5A", "\uFE59", "\uFE5B", "\uFE5C", "\uFE5B", "\uFE5D", "\uFE5E", "\uFE5D", "\uFE64", "\uFE65", "\uFE64"], g2 = new RegExp(/^([1-4|9]|1[0-9]|2[0-9]|3[0168]|4[04589]|5[012]|7[78]|159|16[0-9]|17[0-2]|21[569]|22[03489]|250)$/), m2 = false, v2 = 0;
        this.__bidiEngine__ = {};
        var b2 = function(t4) {
          var e4 = t4.charCodeAt(), r4 = e4 >> 8, n3 = d2[r4];
          return void 0 !== n3 ? u3[256 * n3 + (255 & e4)] : 252 === r4 || 253 === r4 ? "AL" : g2.test(r4) ? "L" : 8 === r4 ? "R" : "N";
        }, y2 = function(t4) {
          for (var e4, r4 = 0; r4 < t4.length; r4++) {
            if ("L" === (e4 = b2(t4.charAt(r4)))) return false;
            if ("R" === e4) return true;
          }
          return false;
        }, w2 = function(t4, e4, o3, s3) {
          var c3, u4, l3, h3, f4 = e4[s3];
          switch (f4) {
            case "L":
            case "R":
            case "LRE":
            case "RLE":
            case "LRO":
            case "RLO":
            case "PDF":
              m2 = false;
              break;
            case "N":
            case "AN":
              break;
            case "EN":
              m2 && (f4 = "AN");
              break;
            case "AL":
              m2 = true, f4 = "R";
              break;
            case "WS":
            case "BN":
              f4 = "N";
              break;
            case "CS":
              s3 < 1 || s3 + 1 >= e4.length || "EN" !== (c3 = o3[s3 - 1]) && "AN" !== c3 || "EN" !== (u4 = e4[s3 + 1]) && "AN" !== u4 ? f4 = "N" : m2 && (u4 = "AN"), f4 = u4 === c3 ? u4 : "N";
              break;
            case "ES":
              f4 = "EN" === (c3 = s3 > 0 ? o3[s3 - 1] : "B") && s3 + 1 < e4.length && "EN" === e4[s3 + 1] ? "EN" : "N";
              break;
            case "ET":
              if (s3 > 0 && "EN" === o3[s3 - 1]) {
                f4 = "EN";
                break;
              }
              if (m2) {
                f4 = "N";
                break;
              }
              for (l3 = s3 + 1, h3 = e4.length; l3 < h3 && "ET" === e4[l3]; ) l3++;
              f4 = l3 < h3 && "EN" === e4[l3] ? "EN" : "N";
              break;
            case "NSM":
              if (i2 && !a3) {
                for (h3 = e4.length, l3 = s3 + 1; l3 < h3 && "NSM" === e4[l3]; ) l3++;
                if (l3 < h3) {
                  var d3 = t4[s3], p3 = d3 >= 1425 && d3 <= 2303 || 64286 === d3;
                  if (c3 = e4[l3], p3 && ("R" === c3 || "AL" === c3)) {
                    f4 = "R";
                    break;
                  }
                }
              }
              f4 = s3 < 1 || "B" === (c3 = e4[s3 - 1]) ? "N" : o3[s3 - 1];
              break;
            case "B":
              m2 = false, r3 = true, f4 = v2;
              break;
            case "S":
              n2 = true, f4 = "N";
          }
          return f4;
        }, N2 = function(t4, e4, r4) {
          var n3 = t4.split("");
          return r4 && L3(n3, r4, { hiLevel: v2 }), n3.reverse(), e4 && e4.reverse(), n3.join("");
        }, L3 = function(t4, e4, i3) {
          var a4, o3, s3, c3, u4, d3 = -1, p3 = t4.length, g3 = 0, y3 = [], N3 = v2 ? h2 : l2, L4 = [];
          for (m2 = false, r3 = false, n2 = false, o3 = 0; o3 < p3; o3++) L4[o3] = b2(t4[o3]);
          for (s3 = 0; s3 < p3; s3++) {
            if (u4 = g3, y3[s3] = w2(t4, L4, y3, s3), a4 = 240 & (g3 = N3[u4][f3[y3[s3]]]), g3 &= 15, e4[s3] = c3 = N3[g3][5], a4 > 0) if (16 === a4) {
              for (o3 = d3; o3 < s3; o3++) e4[o3] = 1;
              d3 = -1;
            } else d3 = -1;
            if (N3[g3][6]) -1 === d3 && (d3 = s3);
            else if (d3 > -1) {
              for (o3 = d3; o3 < s3; o3++) e4[o3] = c3;
              d3 = -1;
            }
            "B" === L4[s3] && (e4[s3] = 0), i3.hiLevel |= c3;
          }
          n2 && (function(t5, e5, r4) {
            for (var n3 = 0; n3 < r4; n3++) if ("S" === t5[n3]) {
              e5[n3] = v2;
              for (var i4 = n3 - 1; i4 >= 0 && "WS" === t5[i4]; i4--) e5[i4] = v2;
            }
          })(L4, e4, p3);
        }, x2 = function(t4, e4, n3, i3, a4) {
          if (!(a4.hiLevel < t4)) {
            if (1 === t4 && 1 === v2 && !r3) return e4.reverse(), void (n3 && n3.reverse());
            for (var o3, s3, c3, u4, l3 = e4.length, h3 = 0; h3 < l3; ) {
              if (i3[h3] >= t4) {
                for (c3 = h3 + 1; c3 < l3 && i3[c3] >= t4; ) c3++;
                for (u4 = h3, s3 = c3 - 1; u4 < s3; u4++, s3--) o3 = e4[u4], e4[u4] = e4[s3], e4[s3] = o3, n3 && (o3 = n3[u4], n3[u4] = n3[s3], n3[s3] = o3);
                h3 = c3;
              }
              h3++;
            }
          }
        }, A3 = function(t4, e4, r4) {
          var n3 = t4.split(""), i3 = { hiLevel: v2 };
          return r4 || (r4 = []), L3(n3, r4, i3), (function(t5, e5, r5) {
            if (0 !== r5.hiLevel && c2) for (var n4, i4 = 0; i4 < t5.length; i4++) 1 === e5[i4] && (n4 = p2.indexOf(t5[i4])) >= 0 && (t5[i4] = p2[n4 + 1]);
          })(n3, r4, i3), x2(2, n3, e4, r4, i3), x2(1, n3, e4, r4, i3), n3.join("");
        };
        return this.__bidiEngine__.doBidiReorder = function(t4, e4, r4) {
          if ((function(t5, e5) {
            if (e5) for (var r5 = 0; r5 < t5.length; r5++) e5[r5] = r5;
            void 0 === a3 && (a3 = y2(t5)), void 0 === s2 && (s2 = y2(t5));
          })(t4, e4), i2 || !o2 || s2) if (i2 && o2 && a3 ^ s2) v2 = a3 ? 1 : 0, t4 = N2(t4, e4, r4);
          else if (!i2 && o2 && s2) v2 = a3 ? 1 : 0, t4 = A3(t4, e4, r4), t4 = N2(t4, e4);
          else if (!i2 || a3 || o2 || s2) {
            if (i2 && !o2 && a3 ^ s2) t4 = N2(t4, e4), a3 ? (v2 = 0, t4 = A3(t4, e4, r4)) : (v2 = 1, t4 = A3(t4, e4, r4), t4 = N2(t4, e4));
            else if (i2 && a3 && !o2 && s2) v2 = 1, t4 = A3(t4, e4, r4), t4 = N2(t4, e4);
            else if (!i2 && !o2 && a3 ^ s2) {
              var n3 = c2;
              a3 ? (v2 = 1, t4 = A3(t4, e4, r4), v2 = 0, c2 = false, t4 = A3(t4, e4, r4), c2 = n3) : (v2 = 0, t4 = A3(t4, e4, r4), t4 = N2(t4, e4), v2 = 1, c2 = false, t4 = A3(t4, e4, r4), c2 = n3, t4 = N2(t4, e4));
            }
          } else v2 = 0, t4 = A3(t4, e4, r4);
          else v2 = a3 ? 1 : 0, t4 = A3(t4, e4, r4);
          return t4;
        }, this.__bidiEngine__.setOptions = function(t4) {
          t4 && (i2 = t4.isInputVisual, o2 = t4.isOutputVisual, a3 = t4.isInputRtl, s2 = t4.isOutputRtl, c2 = t4.isSymmetricSwapping);
        }, this.__bidiEngine__.setOptions(t3), this.__bidiEngine__;
      };
      var e3 = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "N", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "L", "N", "N", "BN", "N", "N", "ET", "ET", "EN", "EN", "N", "L", "N", "N", "N", "EN", "L", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "N", "N", "N", "N", "N", "ET", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "NSM", "R", "NSM", "NSM", "R", "NSM", "NSM", "R", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AN", "AN", "AN", "AN", "AN", "AN", "N", "N", "AL", "ET", "ET", "AL", "CS", "AL", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "N", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "R", "N", "N", "N", "N", "R", "N", "N", "N", "N", "N", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "BN", "BN", "BN", "L", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "B", "LRE", "RLE", "PDF", "LRO", "RLO", "CS", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "BN", "BN", "BN", "BN", "BN", "N", "LRI", "RLI", "FSI", "PDI", "BN", "BN", "BN", "BN", "BN", "BN", "EN", "L", "N", "N", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "L", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "R", "NSM", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "ES", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "R", "R", "R", "R", "R", "N", "R", "N", "R", "R", "N", "R", "R", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "CS", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "ET", "N", "N", "ES", "ES", "N", "N", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "BN", "N", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "N", "N", "N", "ET", "ET", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N"], r2 = new t2.__bidiEngine__({ isInputVisual: true });
      t2.API.events.push(["postProcessText", function(t3) {
        var e4 = t3.text;
        t3.x, t3.y;
        var n2 = t3.options || {};
        t3.mutex, n2.lang;
        var i2 = [];
        if (n2.isInputVisual = "boolean" != typeof n2.isInputVisual || n2.isInputVisual, r2.setOptions(n2), "[object Array]" === Object.prototype.toString.call(e4)) {
          var a3 = 0;
          for (i2 = [], a3 = 0; a3 < e4.length; a3 += 1) "[object Array]" === Object.prototype.toString.call(e4[a3]) ? i2.push([r2.doBidiReorder(e4[a3][0]), e4[a3][1], e4[a3][2]]) : i2.push([r2.doBidiReorder(e4[a3])]);
          t3.text = i2;
        } else t3.text = r2.doBidiReorder(e4);
        r2.setOptions({ isInputVisual: true });
      }]);
    })(j), j.API.TTFFont = (function() {
      function t2(t3) {
        var e3;
        if (this.rawData = t3, e3 = this.contents = new ae(t3), this.contents.pos = 4, "ttcf" === e3.readString(4)) throw new Error("TTCF not supported.");
        e3.pos = 0, this.parse(), this.subset = new Ae(this), this.registerTTF();
      }
      return t2.open = function(e3) {
        return new t2(e3);
      }, t2.prototype.parse = function() {
        return this.directory = new oe(this.contents), this.head = new ue(this), this.name = new me(this), this.cmap = new he(this), this.toUnicode = {}, this.hhea = new fe(this), this.maxp = new ve(this), this.hmtx = new be(this), this.post = new pe(this), this.os2 = new de(this), this.loca = new xe(this), this.glyf = new we(this), this.ascender = this.os2.exists && this.os2.ascender || this.hhea.ascender, this.decender = this.os2.exists && this.os2.decender || this.hhea.decender, this.lineGap = this.os2.exists && this.os2.lineGap || this.hhea.lineGap, this.bbox = [this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax];
      }, t2.prototype.registerTTF = function() {
        var t3, e3, r2, n2, i2;
        if (this.scaleFactor = 1e3 / this.head.unitsPerEm, this.bbox = function() {
          var e4, r3, n3, i3;
          for (i3 = [], e4 = 0, r3 = (n3 = this.bbox).length; e4 < r3; e4++) t3 = n3[e4], i3.push(Math.round(t3 * this.scaleFactor));
          return i3;
        }.call(this), this.stemV = 0, this.post.exists ? (r2 = 255 & (n2 = this.post.italic_angle), 32768 & (e3 = n2 >> 16) && (e3 = -(1 + (65535 ^ e3))), this.italicAngle = +(e3 + "." + r2)) : this.italicAngle = 0, this.ascender = Math.round(this.ascender * this.scaleFactor), this.decender = Math.round(this.decender * this.scaleFactor), this.lineGap = Math.round(this.lineGap * this.scaleFactor), this.capHeight = this.os2.exists && this.os2.capHeight || this.ascender, this.xHeight = this.os2.exists && this.os2.xHeight || 0, this.familyClass = (this.os2.exists && this.os2.familyClass || 0) >> 8, this.isSerif = 1 === (i2 = this.familyClass) || 2 === i2 || 3 === i2 || 4 === i2 || 5 === i2 || 7 === i2, this.isScript = 10 === this.familyClass, this.flags = 0, this.post.isFixedPitch && (this.flags |= 1), this.isSerif && (this.flags |= 2), this.isScript && (this.flags |= 8), 0 !== this.italicAngle && (this.flags |= 64), this.flags |= 32, !this.cmap.unicode) throw new Error("No unicode cmap for font");
      }, t2.prototype.characterToGlyph = function(t3) {
        var e3;
        return (null != (e3 = this.cmap.unicode) ? e3.codeMap[t3] : void 0) || 0;
      }, t2.prototype.widthOfGlyph = function(t3) {
        var e3;
        return e3 = 1e3 / this.head.unitsPerEm, this.hmtx.forGlyph(t3).advance * e3;
      }, t2.prototype.widthOfString = function(t3, e3, r2) {
        var n2, i2, a3, o2;
        for (a3 = 0, i2 = 0, o2 = (t3 = "" + t3).length; 0 <= o2 ? i2 < o2 : i2 > o2; i2 = 0 <= o2 ? ++i2 : --i2) n2 = t3.charCodeAt(i2), a3 += this.widthOfGlyph(this.characterToGlyph(n2)) + r2 * (1e3 / e3) || 0;
        return a3 * (e3 / 1e3);
      }, t2.prototype.lineHeight = function(t3, e3) {
        var r2;
        return null == e3 && (e3 = false), r2 = e3 ? this.lineGap : 0, (this.ascender + r2 - this.decender) / 1e3 * t3;
      }, t2;
    })();
    var ie;
    var ae = (function() {
      function t2(t3) {
        this.data = null != t3 ? t3 : [], this.pos = 0, this.length = this.data.length;
      }
      return t2.prototype.readByte = function() {
        return this.data[this.pos++];
      }, t2.prototype.writeByte = function(t3) {
        return this.data[this.pos++] = t3;
      }, t2.prototype.readUInt32 = function() {
        return 16777216 * this.readByte() + (this.readByte() << 16) + (this.readByte() << 8) + this.readByte();
      }, t2.prototype.writeUInt32 = function(t3) {
        return this.writeByte(t3 >>> 24 & 255), this.writeByte(t3 >> 16 & 255), this.writeByte(t3 >> 8 & 255), this.writeByte(255 & t3);
      }, t2.prototype.readInt32 = function() {
        var t3;
        return (t3 = this.readUInt32()) >= 2147483648 ? t3 - 4294967296 : t3;
      }, t2.prototype.writeInt32 = function(t3) {
        return t3 < 0 && (t3 += 4294967296), this.writeUInt32(t3);
      }, t2.prototype.readUInt16 = function() {
        return this.readByte() << 8 | this.readByte();
      }, t2.prototype.writeUInt16 = function(t3) {
        return this.writeByte(t3 >> 8 & 255), this.writeByte(255 & t3);
      }, t2.prototype.readInt16 = function() {
        var t3;
        return (t3 = this.readUInt16()) >= 32768 ? t3 - 65536 : t3;
      }, t2.prototype.writeInt16 = function(t3) {
        return t3 < 0 && (t3 += 65536), this.writeUInt16(t3);
      }, t2.prototype.readString = function(t3) {
        var e3, r2;
        for (r2 = [], e3 = 0; 0 <= t3 ? e3 < t3 : e3 > t3; e3 = 0 <= t3 ? ++e3 : --e3) r2[e3] = String.fromCharCode(this.readByte());
        return r2.join("");
      }, t2.prototype.writeString = function(t3) {
        var e3, r2, n2;
        for (n2 = [], e3 = 0, r2 = t3.length; 0 <= r2 ? e3 < r2 : e3 > r2; e3 = 0 <= r2 ? ++e3 : --e3) n2.push(this.writeByte(t3.charCodeAt(e3)));
        return n2;
      }, t2.prototype.readShort = function() {
        return this.readInt16();
      }, t2.prototype.writeShort = function(t3) {
        return this.writeInt16(t3);
      }, t2.prototype.readLongLong = function() {
        var t3, e3, r2, n2, i2, a3, o2, s2;
        return t3 = this.readByte(), e3 = this.readByte(), r2 = this.readByte(), n2 = this.readByte(), i2 = this.readByte(), a3 = this.readByte(), o2 = this.readByte(), s2 = this.readByte(), 128 & t3 ? -1 * (72057594037927940 * (255 ^ t3) + 281474976710656 * (255 ^ e3) + 1099511627776 * (255 ^ r2) + 4294967296 * (255 ^ n2) + 16777216 * (255 ^ i2) + 65536 * (255 ^ a3) + 256 * (255 ^ o2) + (255 ^ s2) + 1) : 72057594037927940 * t3 + 281474976710656 * e3 + 1099511627776 * r2 + 4294967296 * n2 + 16777216 * i2 + 65536 * a3 + 256 * o2 + s2;
      }, t2.prototype.writeLongLong = function(t3) {
        var e3, r2;
        return e3 = Math.floor(t3 / 4294967296), r2 = 4294967295 & t3, this.writeByte(e3 >> 24 & 255), this.writeByte(e3 >> 16 & 255), this.writeByte(e3 >> 8 & 255), this.writeByte(255 & e3), this.writeByte(r2 >> 24 & 255), this.writeByte(r2 >> 16 & 255), this.writeByte(r2 >> 8 & 255), this.writeByte(255 & r2);
      }, t2.prototype.readInt = function() {
        return this.readInt32();
      }, t2.prototype.writeInt = function(t3) {
        return this.writeInt32(t3);
      }, t2.prototype.read = function(t3) {
        var e3, r2;
        for (e3 = [], r2 = 0; 0 <= t3 ? r2 < t3 : r2 > t3; r2 = 0 <= t3 ? ++r2 : --r2) e3.push(this.readByte());
        return e3;
      }, t2.prototype.write = function(t3) {
        var e3, r2, n2, i2;
        for (i2 = [], r2 = 0, n2 = t3.length; r2 < n2; r2++) e3 = t3[r2], i2.push(this.writeByte(e3));
        return i2;
      }, t2;
    })();
    var oe = (function() {
      var t2;
      function e3(t3) {
        var e4, r2, n2;
        for (this.scalarType = t3.readInt(), this.tableCount = t3.readShort(), this.searchRange = t3.readShort(), this.entrySelector = t3.readShort(), this.rangeShift = t3.readShort(), this.tables = {}, r2 = 0, n2 = this.tableCount; 0 <= n2 ? r2 < n2 : r2 > n2; r2 = 0 <= n2 ? ++r2 : --r2) e4 = { tag: t3.readString(4), checksum: t3.readInt(), offset: t3.readInt(), length: t3.readInt() }, this.tables[e4.tag] = e4;
      }
      return e3.prototype.encode = function(e4) {
        var r2, n2, i2, a3, o2, s2, c2, u3, l2, h2, f3, d2, p2;
        for (p2 in f3 = Object.keys(e4).length, s2 = Math.log(2), l2 = 16 * Math.floor(Math.log(f3) / s2), a3 = Math.floor(l2 / s2), u3 = 16 * f3 - l2, (n2 = new ae()).writeInt(this.scalarType), n2.writeShort(f3), n2.writeShort(l2), n2.writeShort(a3), n2.writeShort(u3), i2 = 16 * f3, c2 = n2.pos + i2, o2 = null, d2 = [], e4) for (h2 = e4[p2], n2.writeString(p2), n2.writeInt(t2(h2)), n2.writeInt(c2), n2.writeInt(h2.length), d2 = d2.concat(h2), "head" === p2 && (o2 = c2), c2 += h2.length; c2 % 4; ) d2.push(0), c2++;
        return n2.write(d2), r2 = 2981146554 - t2(n2.data), n2.pos = o2 + 8, n2.writeUInt32(r2), n2.data;
      }, t2 = function(t3) {
        var e4, r2, n2, i2;
        for (t3 = ye.call(t3); t3.length % 4; ) t3.push(0);
        for (n2 = new ae(t3), r2 = 0, e4 = 0, i2 = t3.length; e4 < i2; e4 = e4 += 4) r2 += n2.readUInt32();
        return 4294967295 & r2;
      }, e3;
    })();
    var se = {}.hasOwnProperty;
    var ce = function(t2, e3) {
      for (var r2 in e3) se.call(e3, r2) && (t2[r2] = e3[r2]);
      function n2() {
        this.constructor = t2;
      }
      return n2.prototype = e3.prototype, t2.prototype = new n2(), t2.__super__ = e3.prototype, t2;
    };
    ie = (function() {
      function t2(t3) {
        var e3;
        this.file = t3, e3 = this.file.directory.tables[this.tag], this.exists = !!e3, e3 && (this.offset = e3.offset, this.length = e3.length, this.parse(this.file.contents));
      }
      return t2.prototype.parse = function() {
      }, t2.prototype.encode = function() {
      }, t2.prototype.raw = function() {
        return this.exists ? (this.file.contents.pos = this.offset, this.file.contents.read(this.length)) : null;
      }, t2;
    })();
    var ue = (function() {
      function t2() {
        return t2.__super__.constructor.apply(this, arguments);
      }
      return ce(t2, ie), t2.prototype.tag = "head", t2.prototype.parse = function(t3) {
        return t3.pos = this.offset, this.version = t3.readInt(), this.revision = t3.readInt(), this.checkSumAdjustment = t3.readInt(), this.magicNumber = t3.readInt(), this.flags = t3.readShort(), this.unitsPerEm = t3.readShort(), this.created = t3.readLongLong(), this.modified = t3.readLongLong(), this.xMin = t3.readShort(), this.yMin = t3.readShort(), this.xMax = t3.readShort(), this.yMax = t3.readShort(), this.macStyle = t3.readShort(), this.lowestRecPPEM = t3.readShort(), this.fontDirectionHint = t3.readShort(), this.indexToLocFormat = t3.readShort(), this.glyphDataFormat = t3.readShort();
      }, t2.prototype.encode = function(t3) {
        var e3;
        return (e3 = new ae()).writeInt(this.version), e3.writeInt(this.revision), e3.writeInt(this.checkSumAdjustment), e3.writeInt(this.magicNumber), e3.writeShort(this.flags), e3.writeShort(this.unitsPerEm), e3.writeLongLong(this.created), e3.writeLongLong(this.modified), e3.writeShort(this.xMin), e3.writeShort(this.yMin), e3.writeShort(this.xMax), e3.writeShort(this.yMax), e3.writeShort(this.macStyle), e3.writeShort(this.lowestRecPPEM), e3.writeShort(this.fontDirectionHint), e3.writeShort(t3), e3.writeShort(this.glyphDataFormat), e3.data;
      }, t2;
    })();
    var le = (function() {
      function t2(t3, e3) {
        var r2, n2, i2, a3, o2, s2, c2, u3, l2, h2, f3, d2, p2, g2, m2, v2, b2;
        switch (this.platformID = t3.readUInt16(), this.encodingID = t3.readShort(), this.offset = e3 + t3.readInt(), l2 = t3.pos, t3.pos = this.offset, this.format = t3.readUInt16(), this.length = t3.readUInt16(), this.language = t3.readUInt16(), this.isUnicode = 3 === this.platformID && 1 === this.encodingID && 4 === this.format || 0 === this.platformID && 4 === this.format, this.codeMap = {}, this.format) {
          case 0:
            for (s2 = 0; s2 < 256; ++s2) this.codeMap[s2] = t3.readByte();
            break;
          case 4:
            for (f3 = t3.readUInt16(), h2 = f3 / 2, t3.pos += 6, i2 = (function() {
              var e4, r3;
              for (r3 = [], s2 = e4 = 0; 0 <= h2 ? e4 < h2 : e4 > h2; s2 = 0 <= h2 ? ++e4 : --e4) r3.push(t3.readUInt16());
              return r3;
            })(), t3.pos += 2, p2 = (function() {
              var e4, r3;
              for (r3 = [], s2 = e4 = 0; 0 <= h2 ? e4 < h2 : e4 > h2; s2 = 0 <= h2 ? ++e4 : --e4) r3.push(t3.readUInt16());
              return r3;
            })(), c2 = (function() {
              var e4, r3;
              for (r3 = [], s2 = e4 = 0; 0 <= h2 ? e4 < h2 : e4 > h2; s2 = 0 <= h2 ? ++e4 : --e4) r3.push(t3.readUInt16());
              return r3;
            })(), u3 = (function() {
              var e4, r3;
              for (r3 = [], s2 = e4 = 0; 0 <= h2 ? e4 < h2 : e4 > h2; s2 = 0 <= h2 ? ++e4 : --e4) r3.push(t3.readUInt16());
              return r3;
            })(), n2 = (this.length - t3.pos + this.offset) / 2, o2 = (function() {
              var e4, r3;
              for (r3 = [], s2 = e4 = 0; 0 <= n2 ? e4 < n2 : e4 > n2; s2 = 0 <= n2 ? ++e4 : --e4) r3.push(t3.readUInt16());
              return r3;
            })(), s2 = m2 = 0, b2 = i2.length; m2 < b2; s2 = ++m2) for (g2 = i2[s2], r2 = v2 = d2 = p2[s2]; d2 <= g2 ? v2 <= g2 : v2 >= g2; r2 = d2 <= g2 ? ++v2 : --v2) 0 === u3[s2] ? a3 = r2 + c2[s2] : 0 !== (a3 = o2[u3[s2] / 2 + (r2 - d2) - (h2 - s2)] || 0) && (a3 += c2[s2]), this.codeMap[r2] = 65535 & a3;
        }
        t3.pos = l2;
      }
      return t2.encode = function(t3, e3) {
        var r2, n2, i2, a3, o2, s2, c2, u3, l2, h2, f3, d2, p2, g2, m2, v2, b2, y2, w2, N2, L3, x2, A3, S2, _2, P2, k2, F3, I2, j2, C2, O2, B3, q2, M2, E3, R2, D2, T3, z3, U3, H4, W2, V3, G2, Y2;
        switch (F3 = new ae(), a3 = Object.keys(t3).sort(function(t4, e4) {
          return t4 - e4;
        }), e3) {
          case "macroman":
            for (p2 = 0, g2 = (function() {
              var t4 = [];
              for (d2 = 0; d2 < 256; ++d2) t4.push(0);
              return t4;
            })(), v2 = { 0: 0 }, i2 = {}, I2 = 0, B3 = a3.length; I2 < B3; I2++) null == v2[W2 = t3[n2 = a3[I2]]] && (v2[W2] = ++p2), i2[n2] = { old: t3[n2], new: v2[t3[n2]] }, g2[n2] = v2[t3[n2]];
            return F3.writeUInt16(1), F3.writeUInt16(0), F3.writeUInt32(12), F3.writeUInt16(0), F3.writeUInt16(262), F3.writeUInt16(0), F3.write(g2), { charMap: i2, subtable: F3.data, maxGlyphID: p2 + 1 };
          case "unicode":
            for (P2 = [], l2 = [], b2 = 0, v2 = {}, r2 = {}, m2 = c2 = null, j2 = 0, q2 = a3.length; j2 < q2; j2++) null == v2[w2 = t3[n2 = a3[j2]]] && (v2[w2] = ++b2), r2[n2] = { old: w2, new: v2[w2] }, o2 = v2[w2] - n2, null != m2 && o2 === c2 || (m2 && l2.push(m2), P2.push(n2), c2 = o2), m2 = n2;
            for (m2 && l2.push(m2), l2.push(65535), P2.push(65535), S2 = 2 * (A3 = P2.length), x2 = 2 * Math.pow(Math.log(A3) / Math.LN2, 2), h2 = Math.log(x2 / 2) / Math.LN2, L3 = 2 * A3 - x2, s2 = [], N2 = [], f3 = [], d2 = C2 = 0, M2 = P2.length; C2 < M2; d2 = ++C2) {
              if (_2 = P2[d2], u3 = l2[d2], 65535 === _2) {
                s2.push(0), N2.push(0);
                break;
              }
              if (_2 - (k2 = r2[_2].new) >= 32768) for (s2.push(0), N2.push(2 * (f3.length + A3 - d2)), n2 = O2 = _2; _2 <= u3 ? O2 <= u3 : O2 >= u3; n2 = _2 <= u3 ? ++O2 : --O2) f3.push(r2[n2].new);
              else s2.push(k2 - _2), N2.push(0);
            }
            for (F3.writeUInt16(3), F3.writeUInt16(1), F3.writeUInt32(12), F3.writeUInt16(4), F3.writeUInt16(16 + 8 * A3 + 2 * f3.length), F3.writeUInt16(0), F3.writeUInt16(S2), F3.writeUInt16(x2), F3.writeUInt16(h2), F3.writeUInt16(L3), U3 = 0, E3 = l2.length; U3 < E3; U3++) n2 = l2[U3], F3.writeUInt16(n2);
            for (F3.writeUInt16(0), H4 = 0, R2 = P2.length; H4 < R2; H4++) n2 = P2[H4], F3.writeUInt16(n2);
            for (V3 = 0, D2 = s2.length; V3 < D2; V3++) o2 = s2[V3], F3.writeUInt16(o2);
            for (G2 = 0, T3 = N2.length; G2 < T3; G2++) y2 = N2[G2], F3.writeUInt16(y2);
            for (Y2 = 0, z3 = f3.length; Y2 < z3; Y2++) p2 = f3[Y2], F3.writeUInt16(p2);
            return { charMap: r2, subtable: F3.data, maxGlyphID: b2 + 1 };
        }
      }, t2;
    })();
    var he = (function() {
      function t2() {
        return t2.__super__.constructor.apply(this, arguments);
      }
      return ce(t2, ie), t2.prototype.tag = "cmap", t2.prototype.parse = function(t3) {
        var e3, r2, n2;
        for (t3.pos = this.offset, this.version = t3.readUInt16(), n2 = t3.readUInt16(), this.tables = [], this.unicode = null, r2 = 0; 0 <= n2 ? r2 < n2 : r2 > n2; r2 = 0 <= n2 ? ++r2 : --r2) e3 = new le(t3, this.offset), this.tables.push(e3), e3.isUnicode && null == this.unicode && (this.unicode = e3);
        return true;
      }, t2.encode = function(t3, e3) {
        var r2, n2;
        return null == e3 && (e3 = "macroman"), r2 = le.encode(t3, e3), (n2 = new ae()).writeUInt16(0), n2.writeUInt16(1), r2.table = n2.data.concat(r2.subtable), r2;
      }, t2;
    })();
    var fe = (function() {
      function t2() {
        return t2.__super__.constructor.apply(this, arguments);
      }
      return ce(t2, ie), t2.prototype.tag = "hhea", t2.prototype.parse = function(t3) {
        return t3.pos = this.offset, this.version = t3.readInt(), this.ascender = t3.readShort(), this.decender = t3.readShort(), this.lineGap = t3.readShort(), this.advanceWidthMax = t3.readShort(), this.minLeftSideBearing = t3.readShort(), this.minRightSideBearing = t3.readShort(), this.xMaxExtent = t3.readShort(), this.caretSlopeRise = t3.readShort(), this.caretSlopeRun = t3.readShort(), this.caretOffset = t3.readShort(), t3.pos += 8, this.metricDataFormat = t3.readShort(), this.numberOfMetrics = t3.readUInt16();
      }, t2;
    })();
    var de = (function() {
      function t2() {
        return t2.__super__.constructor.apply(this, arguments);
      }
      return ce(t2, ie), t2.prototype.tag = "OS/2", t2.prototype.parse = function(t3) {
        if (t3.pos = this.offset, this.version = t3.readUInt16(), this.averageCharWidth = t3.readShort(), this.weightClass = t3.readUInt16(), this.widthClass = t3.readUInt16(), this.type = t3.readShort(), this.ySubscriptXSize = t3.readShort(), this.ySubscriptYSize = t3.readShort(), this.ySubscriptXOffset = t3.readShort(), this.ySubscriptYOffset = t3.readShort(), this.ySuperscriptXSize = t3.readShort(), this.ySuperscriptYSize = t3.readShort(), this.ySuperscriptXOffset = t3.readShort(), this.ySuperscriptYOffset = t3.readShort(), this.yStrikeoutSize = t3.readShort(), this.yStrikeoutPosition = t3.readShort(), this.familyClass = t3.readShort(), this.panose = (function() {
          var e3, r2;
          for (r2 = [], e3 = 0; e3 < 10; ++e3) r2.push(t3.readByte());
          return r2;
        })(), this.charRange = (function() {
          var e3, r2;
          for (r2 = [], e3 = 0; e3 < 4; ++e3) r2.push(t3.readInt());
          return r2;
        })(), this.vendorID = t3.readString(4), this.selection = t3.readShort(), this.firstCharIndex = t3.readShort(), this.lastCharIndex = t3.readShort(), this.version > 0 && (this.ascent = t3.readShort(), this.descent = t3.readShort(), this.lineGap = t3.readShort(), this.winAscent = t3.readShort(), this.winDescent = t3.readShort(), this.codePageRange = (function() {
          var e3, r2;
          for (r2 = [], e3 = 0; e3 < 2; e3 = ++e3) r2.push(t3.readInt());
          return r2;
        })(), this.version > 1)) return this.xHeight = t3.readShort(), this.capHeight = t3.readShort(), this.defaultChar = t3.readShort(), this.breakChar = t3.readShort(), this.maxContext = t3.readShort();
      }, t2;
    })();
    var pe = (function() {
      function t2() {
        return t2.__super__.constructor.apply(this, arguments);
      }
      return ce(t2, ie), t2.prototype.tag = "post", t2.prototype.parse = function(t3) {
        var e3, r2, n2;
        switch (t3.pos = this.offset, this.format = t3.readInt(), this.italicAngle = t3.readInt(), this.underlinePosition = t3.readShort(), this.underlineThickness = t3.readShort(), this.isFixedPitch = t3.readInt(), this.minMemType42 = t3.readInt(), this.maxMemType42 = t3.readInt(), this.minMemType1 = t3.readInt(), this.maxMemType1 = t3.readInt(), this.format) {
          case 65536:
          case 196608:
            break;
          case 131072:
            var i2;
            for (r2 = t3.readUInt16(), this.glyphNameIndex = [], i2 = 0; 0 <= r2 ? i2 < r2 : i2 > r2; i2 = 0 <= r2 ? ++i2 : --i2) this.glyphNameIndex.push(t3.readUInt16());
            for (this.names = [], n2 = []; t3.pos < this.offset + this.length; ) e3 = t3.readByte(), n2.push(this.names.push(t3.readString(e3)));
            return n2;
          case 151552:
            return r2 = t3.readUInt16(), this.offsets = t3.read(r2);
          case 262144:
            return this.map = function() {
              var e4, r3, n3;
              for (n3 = [], i2 = e4 = 0, r3 = this.file.maxp.numGlyphs; 0 <= r3 ? e4 < r3 : e4 > r3; i2 = 0 <= r3 ? ++e4 : --e4) n3.push(t3.readUInt32());
              return n3;
            }.call(this);
        }
      }, t2;
    })();
    var ge = function(t2, e3) {
      this.raw = t2, this.length = t2.length, this.platformID = e3.platformID, this.encodingID = e3.encodingID, this.languageID = e3.languageID;
    };
    var me = (function() {
      function t2() {
        return t2.__super__.constructor.apply(this, arguments);
      }
      return ce(t2, ie), t2.prototype.tag = "name", t2.prototype.parse = function(t3) {
        var e3, r2, n2, i2, a3, o2, s2, c2, u3, l2, h2;
        for (t3.pos = this.offset, t3.readShort(), e3 = t3.readShort(), o2 = t3.readShort(), r2 = [], i2 = 0; 0 <= e3 ? i2 < e3 : i2 > e3; i2 = 0 <= e3 ? ++i2 : --i2) r2.push({ platformID: t3.readShort(), encodingID: t3.readShort(), languageID: t3.readShort(), nameID: t3.readShort(), length: t3.readShort(), offset: this.offset + o2 + t3.readShort() });
        for (s2 = {}, i2 = u3 = 0, l2 = r2.length; u3 < l2; i2 = ++u3) n2 = r2[i2], t3.pos = n2.offset, c2 = t3.readString(n2.length), a3 = new ge(c2, n2), null == s2[h2 = n2.nameID] && (s2[h2] = []), s2[n2.nameID].push(a3);
        this.strings = s2, this.copyright = s2[0], this.fontFamily = s2[1], this.fontSubfamily = s2[2], this.uniqueSubfamily = s2[3], this.fontName = s2[4], this.version = s2[5];
        try {
          this.postscriptName = s2[6][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
        } catch (f3) {
          this.postscriptName = s2[4][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
        }
        return this.trademark = s2[7], this.manufacturer = s2[8], this.designer = s2[9], this.description = s2[10], this.vendorUrl = s2[11], this.designerUrl = s2[12], this.license = s2[13], this.licenseUrl = s2[14], this.preferredFamily = s2[15], this.preferredSubfamily = s2[17], this.compatibleFull = s2[18], this.sampleText = s2[19];
      }, t2;
    })();
    var ve = (function() {
      function t2() {
        return t2.__super__.constructor.apply(this, arguments);
      }
      return ce(t2, ie), t2.prototype.tag = "maxp", t2.prototype.parse = function(t3) {
        return t3.pos = this.offset, this.version = t3.readInt(), this.numGlyphs = t3.readUInt16(), this.maxPoints = t3.readUInt16(), this.maxContours = t3.readUInt16(), this.maxCompositePoints = t3.readUInt16(), this.maxComponentContours = t3.readUInt16(), this.maxZones = t3.readUInt16(), this.maxTwilightPoints = t3.readUInt16(), this.maxStorage = t3.readUInt16(), this.maxFunctionDefs = t3.readUInt16(), this.maxInstructionDefs = t3.readUInt16(), this.maxStackElements = t3.readUInt16(), this.maxSizeOfInstructions = t3.readUInt16(), this.maxComponentElements = t3.readUInt16(), this.maxComponentDepth = t3.readUInt16();
      }, t2;
    })();
    var be = (function() {
      function t2() {
        return t2.__super__.constructor.apply(this, arguments);
      }
      return ce(t2, ie), t2.prototype.tag = "hmtx", t2.prototype.parse = function(t3) {
        var e3, r2, n2, i2, a3, o2, s2;
        for (t3.pos = this.offset, this.metrics = [], e3 = 0, o2 = this.file.hhea.numberOfMetrics; 0 <= o2 ? e3 < o2 : e3 > o2; e3 = 0 <= o2 ? ++e3 : --e3) this.metrics.push({ advance: t3.readUInt16(), lsb: t3.readInt16() });
        for (n2 = this.file.maxp.numGlyphs - this.file.hhea.numberOfMetrics, this.leftSideBearings = (function() {
          var r3, i3;
          for (i3 = [], e3 = r3 = 0; 0 <= n2 ? r3 < n2 : r3 > n2; e3 = 0 <= n2 ? ++r3 : --r3) i3.push(t3.readInt16());
          return i3;
        })(), this.widths = function() {
          var t4, e4, r3, n3;
          for (n3 = [], t4 = 0, e4 = (r3 = this.metrics).length; t4 < e4; t4++) i2 = r3[t4], n3.push(i2.advance);
          return n3;
        }.call(this), r2 = this.widths[this.widths.length - 1], s2 = [], e3 = a3 = 0; 0 <= n2 ? a3 < n2 : a3 > n2; e3 = 0 <= n2 ? ++a3 : --a3) s2.push(this.widths.push(r2));
        return s2;
      }, t2.prototype.forGlyph = function(t3) {
        return t3 in this.metrics ? this.metrics[t3] : { advance: this.metrics[this.metrics.length - 1].advance, lsb: this.leftSideBearings[t3 - this.metrics.length] };
      }, t2;
    })();
    var ye = [].slice;
    var we = (function() {
      function t2() {
        return t2.__super__.constructor.apply(this, arguments);
      }
      return ce(t2, ie), t2.prototype.tag = "glyf", t2.prototype.parse = function() {
        return this.cache = {};
      }, t2.prototype.glyphFor = function(t3) {
        var e3, r2, n2, i2, a3, o2, s2, c2, u3, l2;
        return t3 in this.cache ? this.cache[t3] : (i2 = this.file.loca, e3 = this.file.contents, r2 = i2.indexOf(t3), 0 === (n2 = i2.lengthOf(t3)) ? this.cache[t3] = null : (e3.pos = this.offset + r2, a3 = (o2 = new ae(e3.read(n2))).readShort(), c2 = o2.readShort(), l2 = o2.readShort(), s2 = o2.readShort(), u3 = o2.readShort(), this.cache[t3] = -1 === a3 ? new Le(o2, c2, l2, s2, u3) : new Ne(o2, a3, c2, l2, s2, u3), this.cache[t3]));
      }, t2.prototype.encode = function(t3, e3, r2) {
        var n2, i2, a3, o2, s2;
        for (a3 = [], i2 = [], o2 = 0, s2 = e3.length; o2 < s2; o2++) n2 = t3[e3[o2]], i2.push(a3.length), n2 && (a3 = a3.concat(n2.encode(r2)));
        return i2.push(a3.length), { table: a3, offsets: i2 };
      }, t2;
    })();
    var Ne = (function() {
      function t2(t3, e3, r2, n2, i2, a3) {
        this.raw = t3, this.numberOfContours = e3, this.xMin = r2, this.yMin = n2, this.xMax = i2, this.yMax = a3, this.compound = false;
      }
      return t2.prototype.encode = function() {
        return this.raw.data;
      }, t2;
    })();
    var Le = (function() {
      function t2(t3, e3, r2, n2, i2) {
        var a3, o2;
        for (this.raw = t3, this.xMin = e3, this.yMin = r2, this.xMax = n2, this.yMax = i2, this.compound = true, this.glyphIDs = [], this.glyphOffsets = [], a3 = this.raw; o2 = a3.readShort(), this.glyphOffsets.push(a3.pos), this.glyphIDs.push(a3.readUInt16()), 32 & o2; ) a3.pos += 1 & o2 ? 4 : 2, 128 & o2 ? a3.pos += 8 : 64 & o2 ? a3.pos += 4 : 8 & o2 && (a3.pos += 2);
      }
      return t2.prototype.encode = function() {
        var t3, e3, r2;
        for (e3 = new ae(ye.call(this.raw.data)), t3 = 0, r2 = this.glyphIDs.length; t3 < r2; ++t3) e3.pos = this.glyphOffsets[t3];
        return e3.data;
      }, t2;
    })();
    var xe = (function() {
      function t2() {
        return t2.__super__.constructor.apply(this, arguments);
      }
      return ce(t2, ie), t2.prototype.tag = "loca", t2.prototype.parse = function(t3) {
        var e3, r2;
        return t3.pos = this.offset, e3 = this.file.head.indexToLocFormat, this.offsets = 0 === e3 ? function() {
          var e4, n2;
          for (n2 = [], r2 = 0, e4 = this.length; r2 < e4; r2 += 2) n2.push(2 * t3.readUInt16());
          return n2;
        }.call(this) : function() {
          var e4, n2;
          for (n2 = [], r2 = 0, e4 = this.length; r2 < e4; r2 += 4) n2.push(t3.readUInt32());
          return n2;
        }.call(this);
      }, t2.prototype.indexOf = function(t3) {
        return this.offsets[t3];
      }, t2.prototype.lengthOf = function(t3) {
        return this.offsets[t3 + 1] - this.offsets[t3];
      }, t2.prototype.encode = function(t3, e3) {
        for (var r2 = new Uint32Array(this.offsets.length), n2 = 0, i2 = 0, a3 = 0; a3 < r2.length; ++a3) if (r2[a3] = n2, i2 < e3.length && e3[i2] == a3) {
          ++i2, r2[a3] = n2;
          var o2 = this.offsets[a3], s2 = this.offsets[a3 + 1] - o2;
          s2 > 0 && (n2 += s2);
        }
        for (var c2 = new Array(4 * r2.length), u3 = 0; u3 < r2.length; ++u3) c2[4 * u3 + 3] = 255 & r2[u3], c2[4 * u3 + 2] = (65280 & r2[u3]) >> 8, c2[4 * u3 + 1] = (16711680 & r2[u3]) >> 16, c2[4 * u3] = (4278190080 & r2[u3]) >> 24;
        return c2;
      }, t2;
    })();
    var Ae = (function() {
      function t2(t3) {
        this.font = t3, this.subset = {}, this.unicodes = {}, this.next = 33;
      }
      return t2.prototype.generateCmap = function() {
        var t3, e3, r2, n2, i2;
        for (e3 in n2 = this.font.cmap.tables[0].codeMap, t3 = {}, i2 = this.subset) r2 = i2[e3], t3[e3] = n2[r2];
        return t3;
      }, t2.prototype.glyphsFor = function(t3) {
        var e3, r2, n2, i2, a3, o2, s2;
        for (n2 = {}, a3 = 0, o2 = t3.length; a3 < o2; a3++) n2[i2 = t3[a3]] = this.font.glyf.glyphFor(i2);
        for (i2 in e3 = [], n2) (null != (r2 = n2[i2]) ? r2.compound : void 0) && e3.push.apply(e3, r2.glyphIDs);
        if (e3.length > 0) for (i2 in s2 = this.glyphsFor(e3)) r2 = s2[i2], n2[i2] = r2;
        return n2;
      }, t2.prototype.encode = function(t3, e3) {
        var r2, n2, i2, a3, o2, s2, c2, u3, l2, h2, f3, d2, p2, g2, m2;
        for (n2 in r2 = he.encode(this.generateCmap(), "unicode"), a3 = this.glyphsFor(t3), f3 = { 0: 0 }, m2 = r2.charMap) f3[(s2 = m2[n2]).old] = s2.new;
        for (d2 in h2 = r2.maxGlyphID, a3) d2 in f3 || (f3[d2] = h2++);
        return u3 = (function(t4) {
          var e4, r3;
          for (e4 in r3 = {}, t4) r3[t4[e4]] = e4;
          return r3;
        })(f3), l2 = Object.keys(u3).sort(function(t4, e4) {
          return t4 - e4;
        }), p2 = (function() {
          var t4, e4, r3;
          for (r3 = [], t4 = 0, e4 = l2.length; t4 < e4; t4++) o2 = l2[t4], r3.push(u3[o2]);
          return r3;
        })(), i2 = this.font.glyf.encode(a3, p2, f3), c2 = this.font.loca.encode(i2.offsets, p2), g2 = { cmap: this.font.cmap.raw(), glyf: i2.table, loca: c2, hmtx: this.font.hmtx.raw(), hhea: this.font.hhea.raw(), maxp: this.font.maxp.raw(), post: this.font.post.raw(), name: this.font.name.raw(), head: this.font.head.encode(e3) }, this.font.os2.exists && (g2["OS/2"] = this.font.os2.raw()), this.font.directory.encode(g2);
      }, t2;
    })();
    j.API.PDFObject = (function() {
      var t2;
      function e3() {
      }
      return t2 = function(t3, e4) {
        return (Array(e4 + 1).join("0") + t3).slice(-e4);
      }, e3.convert = function(r2) {
        var n2, i2, a3, o2;
        if (Array.isArray(r2)) return "[" + (function() {
          var t3, i3, a4;
          for (a4 = [], t3 = 0, i3 = r2.length; t3 < i3; t3++) n2 = r2[t3], a4.push(e3.convert(n2));
          return a4;
        })().join(" ") + "]";
        if ("string" == typeof r2) return "/" + r2;
        if (null != r2 ? r2.isString : void 0) return "(" + r2 + ")";
        if (r2 instanceof Date) return "(D:" + t2(r2.getUTCFullYear(), 4) + t2(r2.getUTCMonth(), 2) + t2(r2.getUTCDate(), 2) + t2(r2.getUTCHours(), 2) + t2(r2.getUTCMinutes(), 2) + t2(r2.getUTCSeconds(), 2) + "Z)";
        if ("[object Object]" === {}.toString.call(r2)) {
          for (i2 in a3 = ["<<"], r2) o2 = r2[i2], a3.push("/" + i2 + " " + e3.convert(o2));
          return a3.push(">>"), a3.join("\n");
        }
        return "" + r2;
      }, e3;
    })(), exports.AcroForm = yt, exports.AcroFormAppearance = vt, exports.AcroFormButton = lt, exports.AcroFormCheckBox = pt, exports.AcroFormChoiceField = ot, exports.AcroFormComboBox = ct, exports.AcroFormEditBox = ut, exports.AcroFormListBox = st, exports.AcroFormPasswordField = mt, exports.AcroFormPushButton = ht, exports.AcroFormRadioButton = ft, exports.AcroFormTextField = gt, exports.GState = P, exports.ShadingPattern = F2, exports.TilingPattern = I, exports.default = j, exports.jsPDF = j;
  }
});

// node_modules/angularx-qrcode/fesm2022/angularx-qrcode.mjs
var import_qrcode = __toESM(require_lib(), 1);
var _c0 = ["qrcElement"];
var QRCodeComponent = class _QRCodeComponent {
  allowEmptyString = false;
  colorDark = "#000000ff";
  colorLight = "#ffffffff";
  cssClass = "qrcode";
  elementType = "canvas";
  errorCorrectionLevel = "M";
  imageSrc;
  imageHeight;
  imageWidth;
  margin = 4;
  qrdata = "";
  scale = 4;
  version;
  width = 10;
  // Accessibility features introduced in 13.0.4+
  alt;
  ariaLabel;
  title;
  qrCodeURL = new EventEmitter();
  qrcElement;
  context = null;
  centerImage;
  renderer = inject(Renderer2);
  sanitizer = inject(DomSanitizer);
  async ngOnChanges() {
    await this.createQRCode();
  }
  isValidQrCodeText(data) {
    if (this.allowEmptyString === false) {
      return !(typeof data === "undefined" || data === "" || data === "null" || data === null);
    }
    return !(typeof data === "undefined");
  }
  toDataURL(qrCodeConfig) {
    return new Promise((resolve, reject) => {
      (0, import_qrcode.toDataURL)(this.qrdata, qrCodeConfig, (err2, url) => {
        if (err2) {
          reject(err2);
        } else {
          resolve(url);
        }
      });
    });
  }
  toCanvas(canvas, qrCodeConfig) {
    return new Promise((resolve, reject) => {
      (0, import_qrcode.toCanvas)(canvas, this.qrdata, qrCodeConfig, (error) => {
        if (error) {
          reject(error);
        } else {
          resolve("success");
        }
      });
    });
  }
  toSVG(qrCodeConfig) {
    return new Promise((resolve, reject) => {
      (0, import_qrcode.toString)(this.qrdata, qrCodeConfig, (err2, url) => {
        if (err2) {
          reject(err2);
        } else {
          resolve(url);
        }
      });
    });
  }
  renderElement(element) {
    for (const node of this.qrcElement.nativeElement.childNodes) {
      this.renderer.removeChild(this.qrcElement.nativeElement, node);
    }
    this.renderer.appendChild(this.qrcElement.nativeElement, element);
  }
  async createQRCode() {
    if (this.version && this.version > 40) {
      console.warn("[angularx-qrcode] max value for `version` is 40");
      this.version = 40;
    } else if (this.version && this.version < 1) {
      console.warn("[angularx-qrcode]`min value for `version` is 1");
      this.version = 1;
    } else if (this.version !== void 0 && isNaN(this.version)) {
      console.warn("[angularx-qrcode] version should be a number, defaulting to auto.");
      this.version = void 0;
    }
    try {
      if (!this.isValidQrCodeText(this.qrdata)) {
        throw new Error("[angularx-qrcode] Field `qrdata` is empty, set 'allowEmptyString=\"true\"' to overwrite this behaviour.");
      }
      if (this.isValidQrCodeText(this.qrdata) && this.qrdata === "") {
        this.qrdata = " ";
      }
      const config = {
        color: {
          dark: this.colorDark,
          light: this.colorLight
        },
        errorCorrectionLevel: this.errorCorrectionLevel,
        margin: this.margin,
        scale: this.scale,
        version: this.version,
        width: this.width
      };
      const centerImageSrc = this.imageSrc;
      const centerImageHeight = this.imageHeight ? +this.imageHeight : 40;
      const centerImageWidth = this.imageWidth ? +this.imageWidth : 40;
      switch (this.elementType) {
        case "canvas": {
          const canvasElement = this.renderer.createElement("canvas");
          this.context = canvasElement.getContext("2d");
          this.toCanvas(canvasElement, config).then(() => {
            if (this.ariaLabel) {
              this.renderer.setAttribute(canvasElement, "aria-label", `${this.ariaLabel}`);
            }
            if (this.title) {
              this.renderer.setAttribute(canvasElement, "title", `${this.title}`);
            }
            if (centerImageSrc && this.context) {
              this.centerImage = new Image(centerImageWidth, centerImageHeight);
              if (centerImageSrc !== this.centerImage.src) {
                this.centerImage.crossOrigin = "anonymous";
                this.centerImage.src = centerImageSrc;
              }
              if (centerImageHeight !== this.centerImage.height) {
                this.centerImage.height = centerImageHeight;
              }
              if (centerImageWidth !== this.centerImage.width) {
                this.centerImage.width = centerImageWidth;
              }
              const centerImage = this.centerImage;
              if (centerImage) {
                centerImage.onload = () => {
                  this.context?.drawImage(centerImage, canvasElement.width / 2 - centerImageWidth / 2, canvasElement.height / 2 - centerImageHeight / 2, centerImageWidth, centerImageHeight);
                };
              }
            }
            this.renderElement(canvasElement);
            this.emitQRCodeURL(canvasElement);
          }).catch((e2) => {
            console.error("[angularx-qrcode] canvas error:", e2);
          });
          break;
        }
        case "svg": {
          const svgParentElement = this.renderer.createElement("div");
          this.toSVG(config).then((svgString) => {
            this.renderer.setProperty(svgParentElement, "innerHTML", svgString);
            const svgElement = svgParentElement.firstChild;
            this.renderer.setAttribute(svgElement, "height", `${this.width}`);
            this.renderer.setAttribute(svgElement, "width", `${this.width}`);
            this.renderElement(svgElement);
            this.emitQRCodeURL(svgElement);
          }).catch((e2) => {
            console.error("[angularx-qrcode] svg error:", e2);
          });
          break;
        }
        case "url":
        case "img":
        default: {
          const imgElement = this.renderer.createElement("img");
          this.toDataURL(config).then((dataUrl) => {
            if (this.alt) {
              imgElement.setAttribute("alt", this.alt);
            }
            if (this.ariaLabel) {
              imgElement.setAttribute("aria-label", this.ariaLabel);
            }
            imgElement.setAttribute("src", dataUrl);
            if (this.title) {
              imgElement.setAttribute("title", this.title);
            }
            this.renderElement(imgElement);
            this.emitQRCodeURL(imgElement);
          }).catch((e2) => {
            console.error("[angularx-qrcode] img/url error:", e2);
          });
        }
      }
    } catch (e2) {
      console.error("[angularx-qrcode] Error generating QR Code:", e2.message);
    }
  }
  convertBase64ImageUrlToBlob(base64ImageUrl) {
    const parts = base64ImageUrl.split(";base64,");
    const imageType = parts[0].split(":")[1];
    const decodedData = atob(parts[1]);
    const uInt8Array = new Uint8Array(decodedData.length);
    for (let i = 0; i < decodedData.length; ++i) {
      uInt8Array[i] = decodedData.charCodeAt(i);
    }
    return new Blob([uInt8Array], {
      type: imageType
    });
  }
  emitQRCodeURL(element) {
    const className = element.constructor.name;
    if (className === SVGSVGElement.name) {
      const svgHTML = element.outerHTML;
      const blob = new Blob([svgHTML], {
        type: "image/svg+xml"
      });
      const urlSvg = URL.createObjectURL(blob);
      const urlSanitized2 = this.sanitizer.bypassSecurityTrustUrl(urlSvg);
      this.qrCodeURL.emit(urlSanitized2);
      return;
    }
    let urlImage = "";
    if (className === HTMLCanvasElement.name) {
      urlImage = element.toDataURL("image/png");
    }
    if (className === HTMLImageElement.name) {
      urlImage = element.src;
    }
    const blobData = this.convertBase64ImageUrlToBlob(urlImage);
    const urlBlob = URL.createObjectURL(blobData);
    const urlSanitized = this.sanitizer.bypassSecurityTrustUrl(urlBlob);
    this.qrCodeURL.emit(urlSanitized);
  }
  static \u0275fac = function QRCodeComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _QRCodeComponent)();
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
    type: _QRCodeComponent,
    selectors: [["qrcode"]],
    viewQuery: function QRCodeComponent_Query(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275viewQuery(_c0, 7);
      }
      if (rf & 2) {
        let _t;
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.qrcElement = _t.first);
      }
    },
    inputs: {
      allowEmptyString: "allowEmptyString",
      colorDark: "colorDark",
      colorLight: "colorLight",
      cssClass: "cssClass",
      elementType: "elementType",
      errorCorrectionLevel: "errorCorrectionLevel",
      imageSrc: "imageSrc",
      imageHeight: "imageHeight",
      imageWidth: "imageWidth",
      margin: "margin",
      qrdata: "qrdata",
      scale: "scale",
      version: "version",
      width: "width",
      alt: "alt",
      ariaLabel: "ariaLabel",
      title: "title"
    },
    outputs: {
      qrCodeURL: "qrCodeURL"
    },
    features: [\u0275\u0275NgOnChangesFeature],
    decls: 2,
    vars: 2,
    consts: [["qrcElement", ""]],
    template: function QRCodeComponent_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275domElement(0, "div", null, 0);
      }
      if (rf & 2) {
        \u0275\u0275classMap(ctx.cssClass);
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(QRCodeComponent, [{
    type: Component,
    args: [{
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "qrcode",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `<div #qrcElement [class]="cssClass"></div>`
    }]
  }], null, {
    allowEmptyString: [{
      type: Input
    }],
    colorDark: [{
      type: Input
    }],
    colorLight: [{
      type: Input
    }],
    cssClass: [{
      type: Input
    }],
    elementType: [{
      type: Input
    }],
    errorCorrectionLevel: [{
      type: Input
    }],
    imageSrc: [{
      type: Input
    }],
    imageHeight: [{
      type: Input
    }],
    imageWidth: [{
      type: Input
    }],
    margin: [{
      type: Input
    }],
    qrdata: [{
      type: Input
    }],
    scale: [{
      type: Input
    }],
    version: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    alt: [{
      type: Input
    }],
    ariaLabel: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    qrCodeURL: [{
      type: Output
    }],
    qrcElement: [{
      type: ViewChild,
      args: ["qrcElement", {
        static: true
      }]
    }]
  });
})();

// src/app/admin/repairs/admin-repair-form-page.ts
var import_jspdf = __toESM(require_jspdf_node_min());

// node_modules/jspdf-autotable/dist/jspdf.plugin.autotable.mjs
function autoTableText(text, x, y, styles, doc) {
  styles = styles || {};
  var PHYSICAL_LINE_HEIGHT = 1.15;
  var k = doc.internal.scaleFactor;
  var fontSize2 = doc.internal.getFontSize() / k;
  var lineHeightFactor = doc.getLineHeightFactor ? doc.getLineHeightFactor() : PHYSICAL_LINE_HEIGHT;
  var lineHeight2 = fontSize2 * lineHeightFactor;
  var splitRegex = /\r\n|\r|\n/g;
  var splitText = "";
  var lineCount = 1;
  if (styles.valign === "middle" || styles.valign === "bottom" || styles.halign === "center" || styles.halign === "right") {
    splitText = typeof text === "string" ? text.split(splitRegex) : text;
    lineCount = splitText.length || 1;
  }
  y += fontSize2 * (2 - PHYSICAL_LINE_HEIGHT);
  if (styles.valign === "middle")
    y -= lineCount / 2 * lineHeight2;
  else if (styles.valign === "bottom")
    y -= lineCount * lineHeight2;
  if (styles.halign === "center" || styles.halign === "right") {
    var alignSize = fontSize2;
    if (styles.halign === "center")
      alignSize *= 0.5;
    if (splitText && lineCount >= 1) {
      for (var iLine = 0; iLine < splitText.length; iLine++) {
        doc.text(splitText[iLine], x - doc.getStringUnitWidth(splitText[iLine]) * alignSize, y);
        y += lineHeight2;
      }
      return doc;
    }
    x -= doc.getStringUnitWidth(text) * alignSize;
  }
  if (styles.halign === "justify") {
    doc.text(text, x, y, { maxWidth: styles.maxWidth || 100, align: "justify" });
  } else {
    doc.text(text, x, y);
  }
  return doc;
}
var globalDefaults = {};
var DocHandler = (
  /** @class */
  (function() {
    function DocHandler2(jsPDFDocument) {
      this.jsPDFDocument = jsPDFDocument;
      this.userStyles = {
        // Black for versions of jspdf without getTextColor
        textColor: jsPDFDocument.getTextColor ? this.jsPDFDocument.getTextColor() : 0,
        fontSize: jsPDFDocument.internal.getFontSize(),
        fontStyle: jsPDFDocument.internal.getFont().fontStyle,
        font: jsPDFDocument.internal.getFont().fontName,
        // 0 for versions of jspdf without getLineWidth
        lineWidth: jsPDFDocument.getLineWidth ? this.jsPDFDocument.getLineWidth() : 0,
        // Black for versions of jspdf without getDrawColor
        lineColor: jsPDFDocument.getDrawColor ? this.jsPDFDocument.getDrawColor() : 0
      };
    }
    DocHandler2.setDefaults = function(defaults, doc) {
      if (doc === void 0) {
        doc = null;
      }
      if (doc) {
        doc.__autoTableDocumentDefaults = defaults;
      } else {
        globalDefaults = defaults;
      }
    };
    DocHandler2.unifyColor = function(c) {
      if (Array.isArray(c)) {
        return c;
      } else if (typeof c === "number") {
        return [c, c, c];
      } else if (typeof c === "string") {
        return [c];
      } else {
        return null;
      }
    };
    DocHandler2.prototype.applyStyles = function(styles, fontOnly) {
      var _a2, _b, _c;
      if (fontOnly === void 0) {
        fontOnly = false;
      }
      if (styles.fontStyle && this.jsPDFDocument.setFontStyle) {
        this.jsPDFDocument.setFontStyle(styles.fontStyle);
      }
      var _d = this.jsPDFDocument.internal.getFont(), fontStyle2 = _d.fontStyle, fontName = _d.fontName;
      if (styles.font)
        fontName = styles.font;
      if (styles.fontStyle) {
        fontStyle2 = styles.fontStyle;
        var availableFontStyles = this.getFontList()[fontName];
        if (availableFontStyles && availableFontStyles.indexOf(fontStyle2) === -1 && this.jsPDFDocument.setFontStyle) {
          this.jsPDFDocument.setFontStyle(availableFontStyles[0]);
          fontStyle2 = availableFontStyles[0];
        }
      }
      this.jsPDFDocument.setFont(fontName, fontStyle2);
      if (styles.fontSize)
        this.jsPDFDocument.setFontSize(styles.fontSize);
      if (fontOnly) {
        return;
      }
      var color2 = DocHandler2.unifyColor(styles.fillColor);
      if (color2)
        (_a2 = this.jsPDFDocument).setFillColor.apply(_a2, color2);
      color2 = DocHandler2.unifyColor(styles.textColor);
      if (color2)
        (_b = this.jsPDFDocument).setTextColor.apply(_b, color2);
      color2 = DocHandler2.unifyColor(styles.lineColor);
      if (color2)
        (_c = this.jsPDFDocument).setDrawColor.apply(_c, color2);
      if (typeof styles.lineWidth === "number") {
        this.jsPDFDocument.setLineWidth(styles.lineWidth);
      }
    };
    DocHandler2.prototype.splitTextToSize = function(text, size, opts) {
      return this.jsPDFDocument.splitTextToSize(text, size, opts);
    };
    DocHandler2.prototype.rect = function(x, y, width, height, fillStyle) {
      return this.jsPDFDocument.rect(x, y, width, height, fillStyle);
    };
    DocHandler2.prototype.getLastAutoTable = function() {
      return this.jsPDFDocument.lastAutoTable || null;
    };
    DocHandler2.prototype.getTextWidth = function(text) {
      return this.jsPDFDocument.getTextWidth(text);
    };
    DocHandler2.prototype.getDocument = function() {
      return this.jsPDFDocument;
    };
    DocHandler2.prototype.setPage = function(page) {
      this.jsPDFDocument.setPage(page);
    };
    DocHandler2.prototype.addPage = function() {
      return this.jsPDFDocument.addPage();
    };
    DocHandler2.prototype.getFontList = function() {
      return this.jsPDFDocument.getFontList();
    };
    DocHandler2.prototype.getGlobalOptions = function() {
      return globalDefaults || {};
    };
    DocHandler2.prototype.getDocumentOptions = function() {
      return this.jsPDFDocument.__autoTableDocumentDefaults || {};
    };
    DocHandler2.prototype.pageSize = function() {
      var pageSize = this.jsPDFDocument.internal.pageSize;
      if (pageSize.width == null) {
        pageSize = { width: pageSize.getWidth(), height: pageSize.getHeight() };
      }
      return pageSize;
    };
    DocHandler2.prototype.scaleFactor = function() {
      return this.jsPDFDocument.internal.scaleFactor;
    };
    DocHandler2.prototype.getLineHeightFactor = function() {
      var doc = this.jsPDFDocument;
      return doc.getLineHeightFactor ? doc.getLineHeightFactor() : 1.15;
    };
    DocHandler2.prototype.getLineHeight = function(fontSize2) {
      return fontSize2 / this.scaleFactor() * this.getLineHeightFactor();
    };
    DocHandler2.prototype.pageNumber = function() {
      var pageInfo = this.jsPDFDocument.internal.getCurrentPageInfo();
      if (!pageInfo) {
        return this.jsPDFDocument.internal.getNumberOfPages();
      }
      return pageInfo.pageNumber;
    };
    return DocHandler2;
  })()
);
var extendStatics2 = function(d, b) {
  extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
  };
  return extendStatics2(d, b);
};
function __extends2(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics2(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var HtmlRowInput = (
  /** @class */
  (function(_super) {
    __extends2(HtmlRowInput2, _super);
    function HtmlRowInput2(element) {
      var _this = _super.call(this) || this;
      _this._element = element;
      return _this;
    }
    return HtmlRowInput2;
  })(Array)
);
function defaultStyles(scaleFactor) {
  return {
    font: "helvetica",
    // helvetica, times, courier
    fontStyle: "normal",
    // normal, bold, italic, bolditalic
    overflow: "linebreak",
    // linebreak, ellipsize, visible or hidden
    fillColor: false,
    // Either false for transparent, rbg array e.g. [255, 255, 255] or gray level e.g 200
    textColor: 20,
    halign: "left",
    // left, center, right, justify
    valign: "top",
    // top, middle, bottom
    fontSize: 10,
    cellPadding: 5 / scaleFactor,
    // number or {top,left,right,left,vertical,horizontal}
    lineColor: 200,
    lineWidth: 0,
    cellWidth: "auto",
    // 'auto'|'wrap'|number
    minCellHeight: 0,
    minCellWidth: 0
  };
}
function getTheme(name) {
  var themes = {
    striped: {
      table: { fillColor: 255, textColor: 80, fontStyle: "normal" },
      head: { textColor: 255, fillColor: [41, 128, 185], fontStyle: "bold" },
      body: {},
      foot: { textColor: 255, fillColor: [41, 128, 185], fontStyle: "bold" },
      alternateRow: { fillColor: 245 }
    },
    grid: {
      table: {
        fillColor: 255,
        textColor: 80,
        fontStyle: "normal",
        lineWidth: 0.1
      },
      head: {
        textColor: 255,
        fillColor: [26, 188, 156],
        fontStyle: "bold",
        lineWidth: 0
      },
      body: {},
      foot: {
        textColor: 255,
        fillColor: [26, 188, 156],
        fontStyle: "bold",
        lineWidth: 0
      },
      alternateRow: {}
    },
    plain: { head: { fontStyle: "bold" }, foot: { fontStyle: "bold" } }
  };
  return themes[name];
}
function getStringWidth(text, styles, doc) {
  doc.applyStyles(styles, true);
  var textArr = Array.isArray(text) ? text : [text];
  var widestLineWidth = textArr.map(function(text2) {
    return doc.getTextWidth(text2);
  }).reduce(function(a2, b) {
    return Math.max(a2, b);
  }, 0);
  return widestLineWidth;
}
function addTableBorder(doc, table, startPos, cursor) {
  var lineWidth = table.settings.tableLineWidth;
  var lineColor = table.settings.tableLineColor;
  doc.applyStyles({ lineWidth, lineColor });
  var fillStyle = getFillStyle(lineWidth, false);
  if (fillStyle) {
    doc.rect(startPos.x, startPos.y, table.getWidth(doc.pageSize().width), cursor.y - startPos.y, fillStyle);
  }
}
function getFillStyle(lineWidth, fillColor) {
  var drawLine = lineWidth > 0;
  var drawBackground = fillColor || fillColor === 0;
  if (drawLine && drawBackground) {
    return "DF";
  } else if (drawLine) {
    return "S";
  } else if (drawBackground) {
    return "F";
  } else {
    return null;
  }
}
function parseSpacing(value, defaultValue) {
  var _a2, _b, _c, _d;
  value = value || defaultValue;
  if (Array.isArray(value)) {
    if (value.length >= 4) {
      return {
        top: value[0],
        right: value[1],
        bottom: value[2],
        left: value[3]
      };
    } else if (value.length === 3) {
      return {
        top: value[0],
        right: value[1],
        bottom: value[2],
        left: value[1]
      };
    } else if (value.length === 2) {
      return {
        top: value[0],
        right: value[1],
        bottom: value[0],
        left: value[1]
      };
    } else if (value.length === 1) {
      value = value[0];
    } else {
      value = defaultValue;
    }
  }
  if (typeof value === "object") {
    if (typeof value.vertical === "number") {
      value.top = value.vertical;
      value.bottom = value.vertical;
    }
    if (typeof value.horizontal === "number") {
      value.right = value.horizontal;
      value.left = value.horizontal;
    }
    return {
      left: (_a2 = value.left) !== null && _a2 !== void 0 ? _a2 : defaultValue,
      top: (_b = value.top) !== null && _b !== void 0 ? _b : defaultValue,
      right: (_c = value.right) !== null && _c !== void 0 ? _c : defaultValue,
      bottom: (_d = value.bottom) !== null && _d !== void 0 ? _d : defaultValue
    };
  }
  if (typeof value !== "number") {
    value = defaultValue;
  }
  return { top: value, right: value, bottom: value, left: value };
}
function getPageAvailableWidth(doc, table) {
  var margins = parseSpacing(table.settings.margin, 0);
  return doc.pageSize().width - (margins.left + margins.right);
}
function parseCss(supportedFonts, element, scaleFactor, style, window2) {
  var result = {};
  var pxScaleFactor = 96 / 72;
  var backgroundColor2 = parseColor2(element, function(elem) {
    return window2.getComputedStyle(elem)["backgroundColor"];
  });
  if (backgroundColor2 != null)
    result.fillColor = backgroundColor2;
  var textColor = parseColor2(element, function(elem) {
    return window2.getComputedStyle(elem)["color"];
  });
  if (textColor != null)
    result.textColor = textColor;
  var padding = parsePadding(style, scaleFactor);
  if (padding)
    result.cellPadding = padding;
  var borderColorSide = "borderTopColor";
  var finalScaleFactor = pxScaleFactor * scaleFactor;
  var btw = style.borderTopWidth;
  if (style.borderBottomWidth === btw && style.borderRightWidth === btw && style.borderLeftWidth === btw) {
    var borderWidth = (parseFloat(btw) || 0) / finalScaleFactor;
    if (borderWidth)
      result.lineWidth = borderWidth;
  } else {
    result.lineWidth = {
      top: (parseFloat(style.borderTopWidth) || 0) / finalScaleFactor,
      right: (parseFloat(style.borderRightWidth) || 0) / finalScaleFactor,
      bottom: (parseFloat(style.borderBottomWidth) || 0) / finalScaleFactor,
      left: (parseFloat(style.borderLeftWidth) || 0) / finalScaleFactor
    };
    if (!result.lineWidth.top) {
      if (result.lineWidth.right) {
        borderColorSide = "borderRightColor";
      } else if (result.lineWidth.bottom) {
        borderColorSide = "borderBottomColor";
      } else if (result.lineWidth.left) {
        borderColorSide = "borderLeftColor";
      }
    }
  }
  var borderColor = parseColor2(element, function(elem) {
    return window2.getComputedStyle(elem)[borderColorSide];
  });
  if (borderColor != null)
    result.lineColor = borderColor;
  var accepted = ["left", "right", "center", "justify"];
  if (accepted.indexOf(style.textAlign) !== -1) {
    result.halign = style.textAlign;
  }
  accepted = ["middle", "bottom", "top"];
  if (accepted.indexOf(style.verticalAlign) !== -1) {
    result.valign = style.verticalAlign;
  }
  var res = parseInt(style.fontSize || "");
  if (!isNaN(res))
    result.fontSize = res / pxScaleFactor;
  var fontStyle2 = parseFontStyle(style);
  if (fontStyle2)
    result.fontStyle = fontStyle2;
  var font = (style.fontFamily || "").toLowerCase();
  if (supportedFonts.indexOf(font) !== -1) {
    result.font = font;
  }
  return result;
}
function parseFontStyle(style) {
  var res = "";
  if (style.fontWeight === "bold" || style.fontWeight === "bolder" || parseInt(style.fontWeight) >= 700) {
    res = "bold";
  }
  if (style.fontStyle === "italic" || style.fontStyle === "oblique") {
    res += "italic";
  }
  return res;
}
function parseColor2(element, styleGetter) {
  var cssColor = realColor(element, styleGetter);
  if (!cssColor)
    return null;
  var rgba = cssColor.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d*\.?\d*))?\)$/);
  if (!rgba || !Array.isArray(rgba)) {
    return null;
  }
  var color2 = [
    parseInt(rgba[1]),
    parseInt(rgba[2]),
    parseInt(rgba[3])
  ];
  var alpha = parseInt(rgba[4]);
  if (alpha === 0 || isNaN(color2[0]) || isNaN(color2[1]) || isNaN(color2[2])) {
    return null;
  }
  return color2;
}
function realColor(elem, styleGetter) {
  var bg = styleGetter(elem);
  if (bg === "rgba(0, 0, 0, 0)" || bg === "transparent" || bg === "initial" || bg === "inherit") {
    if (elem.parentElement == null) {
      return null;
    }
    return realColor(elem.parentElement, styleGetter);
  } else {
    return bg;
  }
}
function parsePadding(style, scaleFactor) {
  var val = [
    style.paddingTop,
    style.paddingRight,
    style.paddingBottom,
    style.paddingLeft
  ];
  var pxScaleFactor = 96 / (72 / scaleFactor);
  var linePadding = (parseInt(style.lineHeight) - parseInt(style.fontSize)) / scaleFactor / 2;
  var inputPadding = val.map(function(n) {
    return parseInt(n || "0") / pxScaleFactor;
  });
  var padding = parseSpacing(inputPadding, 0);
  if (linePadding > padding.top) {
    padding.top = linePadding;
  }
  if (linePadding > padding.bottom) {
    padding.bottom = linePadding;
  }
  return padding;
}
function parseHtml(doc, input, window2, includeHiddenHtml, useCss) {
  var _a2, _b;
  if (includeHiddenHtml === void 0) {
    includeHiddenHtml = false;
  }
  if (useCss === void 0) {
    useCss = false;
  }
  var tableElement;
  if (typeof input === "string") {
    tableElement = window2.document.querySelector(input);
  } else {
    tableElement = input;
  }
  var supportedFonts = Object.keys(doc.getFontList());
  var scaleFactor = doc.scaleFactor();
  var head = [], body = [], foot = [];
  if (!tableElement) {
    console.error("Html table could not be found with input: ", input);
    return { head, body, foot };
  }
  for (var i = 0; i < tableElement.rows.length; i++) {
    var element = tableElement.rows[i];
    var tagName = (_b = (_a2 = element === null || element === void 0 ? void 0 : element.parentElement) === null || _a2 === void 0 ? void 0 : _a2.tagName) === null || _b === void 0 ? void 0 : _b.toLowerCase();
    var row = parseRowContent(supportedFonts, scaleFactor, window2, element, includeHiddenHtml, useCss);
    if (!row)
      continue;
    if (tagName === "thead") {
      head.push(row);
    } else if (tagName === "tfoot") {
      foot.push(row);
    } else {
      body.push(row);
    }
  }
  return { head, body, foot };
}
function parseRowContent(supportedFonts, scaleFactor, window2, row, includeHidden, useCss) {
  var resultRow = new HtmlRowInput(row);
  for (var i = 0; i < row.cells.length; i++) {
    var cell = row.cells[i];
    var style_1 = window2.getComputedStyle(cell);
    if (includeHidden || style_1.display !== "none") {
      var cellStyles2 = void 0;
      if (useCss) {
        cellStyles2 = parseCss(supportedFonts, cell, scaleFactor, style_1, window2);
      }
      resultRow.push({
        rowSpan: cell.rowSpan,
        colSpan: cell.colSpan,
        styles: cellStyles2,
        _element: cell,
        content: parseCellContent(cell)
      });
    }
  }
  var style = window2.getComputedStyle(row);
  if (resultRow.length > 0 && (includeHidden || style.display !== "none")) {
    return resultRow;
  }
}
function parseCellContent(orgCell) {
  var cell = orgCell.cloneNode(true);
  cell.innerHTML = cell.innerHTML.replace(/\n/g, "").replace(/ +/g, " ");
  cell.innerHTML = cell.innerHTML.split(/<br.*?>/).map(function(part) {
    return part.trim();
  }).join("\n");
  return cell.innerText || cell.textContent || "";
}
function validateInput(global2, document2, current) {
  for (var _i = 0, _a2 = [global2, document2, current]; _i < _a2.length; _i++) {
    var options = _a2[_i];
    if (options && typeof options !== "object") {
      console.error("The options parameter should be of type object, is: " + typeof options);
    }
    if (options.startY && typeof options.startY !== "number") {
      console.error("Invalid value for startY option", options.startY);
      delete options.startY;
    }
  }
}
function assign2(target, s, s1, s2, s3) {
  if (target == null) {
    throw new TypeError("Cannot convert undefined or null to object");
  }
  var to = Object(target);
  for (var index = 1; index < arguments.length; index++) {
    var nextSource = arguments[index];
    if (nextSource != null) {
      for (var nextKey in nextSource) {
        if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
          to[nextKey] = nextSource[nextKey];
        }
      }
    }
  }
  return to;
}
function parseInput(d, current) {
  var doc = new DocHandler(d);
  var document2 = doc.getDocumentOptions();
  var global2 = doc.getGlobalOptions();
  validateInput(global2, document2, current);
  var options = assign2({}, global2, document2, current);
  var win;
  if (typeof window !== "undefined") {
    win = window;
  }
  var styles = parseStyles(global2, document2, current);
  var hooks = parseHooks(global2, document2, current);
  var settings = parseSettings(doc, options);
  var content2 = parseContent$1(doc, options, win);
  return { id: current.tableId, content: content2, hooks, styles, settings };
}
function parseStyles(gInput, dInput, cInput) {
  var styleOptions = {
    styles: {},
    headStyles: {},
    bodyStyles: {},
    footStyles: {},
    alternateRowStyles: {},
    columnStyles: {}
  };
  var _loop_1 = function(prop2) {
    if (prop2 === "columnStyles") {
      var global_1 = gInput[prop2];
      var document_1 = dInput[prop2];
      var current = cInput[prop2];
      styleOptions.columnStyles = assign2({}, global_1, document_1, current);
    } else {
      var allOptions = [gInput, dInput, cInput];
      var styles = allOptions.map(function(opts) {
        return opts[prop2] || {};
      });
      styleOptions[prop2] = assign2({}, styles[0], styles[1], styles[2]);
    }
  };
  for (var _i = 0, _a2 = Object.keys(styleOptions); _i < _a2.length; _i++) {
    var prop = _a2[_i];
    _loop_1(prop);
  }
  return styleOptions;
}
function parseHooks(global2, document2, current) {
  var allOptions = [global2, document2, current];
  var result = {
    didParseCell: [],
    willDrawCell: [],
    didDrawCell: [],
    willDrawPage: [],
    didDrawPage: []
  };
  for (var _i = 0, allOptions_1 = allOptions; _i < allOptions_1.length; _i++) {
    var options = allOptions_1[_i];
    if (options.didParseCell)
      result.didParseCell.push(options.didParseCell);
    if (options.willDrawCell)
      result.willDrawCell.push(options.willDrawCell);
    if (options.didDrawCell)
      result.didDrawCell.push(options.didDrawCell);
    if (options.willDrawPage)
      result.willDrawPage.push(options.willDrawPage);
    if (options.didDrawPage)
      result.didDrawPage.push(options.didDrawPage);
  }
  return result;
}
function parseSettings(doc, options) {
  var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
  var margin = parseSpacing(options.margin, 40 / doc.scaleFactor());
  var startY = (_a2 = getStartY(doc, options.startY)) !== null && _a2 !== void 0 ? _a2 : margin.top;
  var showFoot;
  if (options.showFoot === true) {
    showFoot = "everyPage";
  } else if (options.showFoot === false) {
    showFoot = "never";
  } else {
    showFoot = (_b = options.showFoot) !== null && _b !== void 0 ? _b : "everyPage";
  }
  var showHead;
  if (options.showHead === true) {
    showHead = "everyPage";
  } else if (options.showHead === false) {
    showHead = "never";
  } else {
    showHead = (_c = options.showHead) !== null && _c !== void 0 ? _c : "everyPage";
  }
  var useCss = (_d = options.useCss) !== null && _d !== void 0 ? _d : false;
  var theme = options.theme || (useCss ? "plain" : "striped");
  var horizontalPageBreak = !!options.horizontalPageBreak;
  var horizontalPageBreakRepeat = (_e = options.horizontalPageBreakRepeat) !== null && _e !== void 0 ? _e : null;
  return {
    includeHiddenHtml: (_f = options.includeHiddenHtml) !== null && _f !== void 0 ? _f : false,
    useCss,
    theme,
    startY,
    margin,
    pageBreak: (_g = options.pageBreak) !== null && _g !== void 0 ? _g : "auto",
    rowPageBreak: (_h = options.rowPageBreak) !== null && _h !== void 0 ? _h : "auto",
    tableWidth: (_j = options.tableWidth) !== null && _j !== void 0 ? _j : "auto",
    showHead,
    showFoot,
    tableLineWidth: (_k = options.tableLineWidth) !== null && _k !== void 0 ? _k : 0,
    tableLineColor: (_l = options.tableLineColor) !== null && _l !== void 0 ? _l : 200,
    horizontalPageBreak,
    horizontalPageBreakRepeat,
    horizontalPageBreakBehaviour: (_m = options.horizontalPageBreakBehaviour) !== null && _m !== void 0 ? _m : "afterAllRows"
  };
}
function getStartY(doc, userStartY) {
  var previous = doc.getLastAutoTable();
  var sf = doc.scaleFactor();
  var currentPage = doc.pageNumber();
  var isSamePageAsPreviousTable = false;
  if (previous && previous.startPageNumber) {
    var endingPage = previous.startPageNumber + previous.pageNumber - 1;
    isSamePageAsPreviousTable = endingPage === currentPage;
  }
  if (typeof userStartY === "number") {
    return userStartY;
  } else if (userStartY == null || userStartY === false) {
    if (isSamePageAsPreviousTable && (previous === null || previous === void 0 ? void 0 : previous.finalY) != null) {
      return previous.finalY + 20 / sf;
    }
  }
  return null;
}
function parseContent$1(doc, options, window2) {
  var head = options.head || [];
  var body = options.body || [];
  var foot = options.foot || [];
  if (options.html) {
    var hidden = options.includeHiddenHtml;
    if (window2) {
      var htmlContent = parseHtml(doc, options.html, window2, hidden, options.useCss) || {};
      head = htmlContent.head || head;
      body = htmlContent.body || head;
      foot = htmlContent.foot || head;
    } else {
      console.error("Cannot parse html in non browser environment");
    }
  }
  var columns = options.columns || parseColumns(head, body, foot);
  return { columns, head, body, foot };
}
function parseColumns(head, body, foot) {
  var firstRow = head[0] || body[0] || foot[0] || [];
  var result = [];
  Object.keys(firstRow).filter(function(key) {
    return key !== "_element";
  }).forEach(function(key) {
    var colSpan = 1;
    var input;
    if (Array.isArray(firstRow)) {
      input = firstRow[parseInt(key)];
    } else {
      input = firstRow[key];
    }
    if (typeof input === "object" && !Array.isArray(input)) {
      colSpan = (input === null || input === void 0 ? void 0 : input.colSpan) || 1;
    }
    for (var i = 0; i < colSpan; i++) {
      var id = void 0;
      if (Array.isArray(firstRow)) {
        id = result.length;
      } else {
        id = key + (i > 0 ? "_".concat(i) : "");
      }
      var rowResult = { dataKey: id };
      result.push(rowResult);
    }
  });
  return result;
}
var HookData = (
  /** @class */
  /* @__PURE__ */ (function() {
    function HookData2(doc, table, cursor) {
      this.table = table;
      this.pageNumber = table.pageNumber;
      this.settings = table.settings;
      this.cursor = cursor;
      this.doc = doc.getDocument();
    }
    return HookData2;
  })()
);
var CellHookData = (
  /** @class */
  (function(_super) {
    __extends2(CellHookData2, _super);
    function CellHookData2(doc, table, cell, row, column, cursor) {
      var _this = _super.call(this, doc, table, cursor) || this;
      _this.cell = cell;
      _this.row = row;
      _this.column = column;
      _this.section = row.section;
      return _this;
    }
    return CellHookData2;
  })(HookData)
);
var Table = (
  /** @class */
  (function() {
    function Table2(input, content2) {
      this.pageNumber = 1;
      this.id = input.id;
      this.settings = input.settings;
      this.styles = input.styles;
      this.hooks = input.hooks;
      this.columns = content2.columns;
      this.head = content2.head;
      this.body = content2.body;
      this.foot = content2.foot;
    }
    Table2.prototype.getHeadHeight = function(columns) {
      return this.head.reduce(function(acc, row) {
        return acc + row.getMaxCellHeight(columns);
      }, 0);
    };
    Table2.prototype.getFootHeight = function(columns) {
      return this.foot.reduce(function(acc, row) {
        return acc + row.getMaxCellHeight(columns);
      }, 0);
    };
    Table2.prototype.allRows = function() {
      return this.head.concat(this.body).concat(this.foot);
    };
    Table2.prototype.callCellHooks = function(doc, handlers, cell, row, column, cursor) {
      for (var _i = 0, handlers_1 = handlers; _i < handlers_1.length; _i++) {
        var handler = handlers_1[_i];
        var data = new CellHookData(doc, this, cell, row, column, cursor);
        var result = handler(data) === false;
        cell.text = Array.isArray(cell.text) ? cell.text : [cell.text];
        if (result) {
          return false;
        }
      }
      return true;
    };
    Table2.prototype.callEndPageHooks = function(doc, cursor) {
      doc.applyStyles(doc.userStyles);
      for (var _i = 0, _a2 = this.hooks.didDrawPage; _i < _a2.length; _i++) {
        var handler = _a2[_i];
        handler(new HookData(doc, this, cursor));
      }
    };
    Table2.prototype.callWillDrawPageHooks = function(doc, cursor) {
      for (var _i = 0, _a2 = this.hooks.willDrawPage; _i < _a2.length; _i++) {
        var handler = _a2[_i];
        handler(new HookData(doc, this, cursor));
      }
    };
    Table2.prototype.getWidth = function(pageWidth) {
      if (typeof this.settings.tableWidth === "number") {
        return this.settings.tableWidth;
      } else if (this.settings.tableWidth === "wrap") {
        var wrappedWidth = this.columns.reduce(function(total, col) {
          return total + col.wrappedWidth;
        }, 0);
        return wrappedWidth;
      } else {
        var margin = this.settings.margin;
        return pageWidth - margin.left - margin.right;
      }
    };
    return Table2;
  })()
);
var Row = (
  /** @class */
  (function() {
    function Row2(raw, index, section, cells, spansMultiplePages) {
      if (spansMultiplePages === void 0) {
        spansMultiplePages = false;
      }
      this.height = 0;
      this.raw = raw;
      if (raw instanceof HtmlRowInput) {
        this.raw = raw._element;
        this.element = raw._element;
      }
      this.index = index;
      this.section = section;
      this.cells = cells;
      this.spansMultiplePages = spansMultiplePages;
    }
    Row2.prototype.getMaxCellHeight = function(columns) {
      var _this = this;
      return columns.reduce(function(acc, column) {
        var _a2;
        return Math.max(acc, ((_a2 = _this.cells[column.index]) === null || _a2 === void 0 ? void 0 : _a2.height) || 0);
      }, 0);
    };
    Row2.prototype.hasRowSpan = function(columns) {
      var _this = this;
      return columns.filter(function(column) {
        var cell = _this.cells[column.index];
        if (!cell)
          return false;
        return cell.rowSpan > 1;
      }).length > 0;
    };
    Row2.prototype.canEntireRowFit = function(height, columns) {
      return this.getMaxCellHeight(columns) <= height;
    };
    Row2.prototype.getMinimumRowHeight = function(columns, doc) {
      var _this = this;
      return columns.reduce(function(acc, column) {
        var cell = _this.cells[column.index];
        if (!cell)
          return 0;
        var lineHeight2 = doc.getLineHeight(cell.styles.fontSize);
        var vPadding = cell.padding("vertical");
        var oneRowHeight = vPadding + lineHeight2;
        return oneRowHeight > acc ? oneRowHeight : acc;
      }, 0);
    };
    return Row2;
  })()
);
var Cell = (
  /** @class */
  (function() {
    function Cell2(raw, styles, section) {
      var _a2;
      this.contentHeight = 0;
      this.contentWidth = 0;
      this.wrappedWidth = 0;
      this.minReadableWidth = 0;
      this.minWidth = 0;
      this.width = 0;
      this.height = 0;
      this.x = 0;
      this.y = 0;
      this.styles = styles;
      this.section = section;
      this.raw = raw;
      var content2 = raw;
      if (raw != null && typeof raw === "object" && !Array.isArray(raw)) {
        this.rowSpan = raw.rowSpan || 1;
        this.colSpan = raw.colSpan || 1;
        content2 = (_a2 = raw.content) !== null && _a2 !== void 0 ? _a2 : raw;
        if (raw._element) {
          this.raw = raw._element;
        }
      } else {
        this.rowSpan = 1;
        this.colSpan = 1;
      }
      var text = content2 != null ? "" + content2 : "";
      var splitRegex = /\r\n|\r|\n/g;
      this.text = text.split(splitRegex);
    }
    Cell2.prototype.getTextPos = function() {
      var y;
      if (this.styles.valign === "top") {
        y = this.y + this.padding("top");
      } else if (this.styles.valign === "bottom") {
        y = this.y + this.height - this.padding("bottom");
      } else {
        var netHeight = this.height - this.padding("vertical");
        y = this.y + netHeight / 2 + this.padding("top");
      }
      var x;
      if (this.styles.halign === "right") {
        x = this.x + this.width - this.padding("right");
      } else if (this.styles.halign === "center") {
        var netWidth = this.width - this.padding("horizontal");
        x = this.x + netWidth / 2 + this.padding("left");
      } else {
        x = this.x + this.padding("left");
      }
      return { x, y };
    };
    Cell2.prototype.getContentHeight = function(scaleFactor, lineHeightFactor) {
      if (lineHeightFactor === void 0) {
        lineHeightFactor = 1.15;
      }
      var lineCount = Array.isArray(this.text) ? this.text.length : 1;
      var lineHeight2 = this.styles.fontSize / scaleFactor * lineHeightFactor;
      var height = lineCount * lineHeight2 + this.padding("vertical");
      return Math.max(height, this.styles.minCellHeight);
    };
    Cell2.prototype.padding = function(name) {
      var padding = parseSpacing(this.styles.cellPadding, 0);
      if (name === "vertical") {
        return padding.top + padding.bottom;
      } else if (name === "horizontal") {
        return padding.left + padding.right;
      } else {
        return padding[name];
      }
    };
    return Cell2;
  })()
);
var Column = (
  /** @class */
  (function() {
    function Column2(dataKey, raw, index) {
      this.wrappedWidth = 0;
      this.minReadableWidth = 0;
      this.minWidth = 0;
      this.width = 0;
      this.dataKey = dataKey;
      this.raw = raw;
      this.index = index;
    }
    Column2.prototype.getMaxCustomCellWidth = function(table) {
      var max = 0;
      for (var _i = 0, _a2 = table.allRows(); _i < _a2.length; _i++) {
        var row = _a2[_i];
        var cell = row.cells[this.index];
        if (cell && typeof cell.styles.cellWidth === "number") {
          max = Math.max(max, cell.styles.cellWidth);
        }
      }
      return max;
    };
    return Column2;
  })()
);
function calculateWidths(doc, table) {
  calculate(doc, table);
  var resizableColumns = [];
  var initialTableWidth = 0;
  table.columns.forEach(function(column) {
    var customWidth = column.getMaxCustomCellWidth(table);
    if (customWidth) {
      column.width = customWidth;
    } else {
      column.width = column.wrappedWidth;
      resizableColumns.push(column);
    }
    initialTableWidth += column.width;
  });
  var resizeWidth = table.getWidth(doc.pageSize().width) - initialTableWidth;
  if (resizeWidth) {
    resizeWidth = resizeColumns(resizableColumns, resizeWidth, function(column) {
      return Math.max(column.minReadableWidth, column.minWidth);
    });
  }
  if (resizeWidth) {
    resizeWidth = resizeColumns(resizableColumns, resizeWidth, function(column) {
      return column.minWidth;
    });
  }
  resizeWidth = Math.abs(resizeWidth);
  if (!table.settings.horizontalPageBreak && resizeWidth > 0.1 / doc.scaleFactor()) {
    resizeWidth = resizeWidth < 1 ? resizeWidth : Math.round(resizeWidth);
    console.log("Of the table content, ".concat(resizeWidth, " units width could not fit page"));
  }
  applyColSpans(table);
  fitContent(table, doc);
  applyRowSpans(table);
}
function calculate(doc, table) {
  var sf = doc.scaleFactor();
  var horizontalPageBreak = table.settings.horizontalPageBreak;
  var availablePageWidth = getPageAvailableWidth(doc, table);
  table.allRows().forEach(function(row) {
    for (var _i = 0, _a2 = table.columns; _i < _a2.length; _i++) {
      var column = _a2[_i];
      var cell = row.cells[column.index];
      if (!cell)
        continue;
      var hooks = table.hooks.didParseCell;
      table.callCellHooks(doc, hooks, cell, row, column, null);
      var padding = cell.padding("horizontal");
      cell.contentWidth = getStringWidth(cell.text, cell.styles, doc) + padding;
      var longestWordWidth = getStringWidth(cell.text.join(" ").split(/[^\S\u00A0]+/), cell.styles, doc);
      cell.minReadableWidth = longestWordWidth + cell.padding("horizontal");
      if (typeof cell.styles.cellWidth === "number") {
        cell.minWidth = cell.styles.cellWidth;
        cell.wrappedWidth = cell.styles.cellWidth;
      } else if (cell.styles.cellWidth === "wrap" || horizontalPageBreak === true) {
        if (cell.contentWidth > availablePageWidth) {
          cell.minWidth = availablePageWidth;
          cell.wrappedWidth = availablePageWidth;
        } else {
          cell.minWidth = cell.contentWidth;
          cell.wrappedWidth = cell.contentWidth;
        }
      } else {
        var defaultMinWidth = 10 / sf;
        cell.minWidth = cell.styles.minCellWidth || defaultMinWidth;
        cell.wrappedWidth = cell.contentWidth;
        if (cell.minWidth > cell.wrappedWidth) {
          cell.wrappedWidth = cell.minWidth;
        }
      }
    }
  });
  table.allRows().forEach(function(row) {
    for (var _i = 0, _a2 = table.columns; _i < _a2.length; _i++) {
      var column = _a2[_i];
      var cell = row.cells[column.index];
      if (cell && cell.colSpan === 1) {
        column.wrappedWidth = Math.max(column.wrappedWidth, cell.wrappedWidth);
        column.minWidth = Math.max(column.minWidth, cell.minWidth);
        column.minReadableWidth = Math.max(column.minReadableWidth, cell.minReadableWidth);
      } else {
        var columnStyles = table.styles.columnStyles[column.dataKey] || table.styles.columnStyles[column.index] || {};
        var cellWidth = columnStyles.cellWidth || columnStyles.minCellWidth;
        if (cellWidth && typeof cellWidth === "number") {
          column.minWidth = cellWidth;
          column.wrappedWidth = cellWidth;
        }
      }
      if (cell) {
        if (cell.colSpan > 1 && !column.minWidth) {
          column.minWidth = cell.minWidth;
        }
        if (cell.colSpan > 1 && !column.wrappedWidth) {
          column.wrappedWidth = cell.minWidth;
        }
      }
    }
  });
}
function resizeColumns(columns, resizeWidth, getMinWidth) {
  var initialResizeWidth = resizeWidth;
  var sumWrappedWidth = columns.reduce(function(acc, column2) {
    return acc + column2.wrappedWidth;
  }, 0);
  for (var i = 0; i < columns.length; i++) {
    var column = columns[i];
    var ratio = column.wrappedWidth / sumWrappedWidth;
    var suggestedChange = initialResizeWidth * ratio;
    var suggestedWidth = column.width + suggestedChange;
    var minWidth = getMinWidth(column);
    var newWidth = suggestedWidth < minWidth ? minWidth : suggestedWidth;
    resizeWidth -= newWidth - column.width;
    column.width = newWidth;
  }
  resizeWidth = Math.round(resizeWidth * 1e10) / 1e10;
  if (resizeWidth) {
    var resizableColumns = columns.filter(function(column2) {
      return resizeWidth < 0 ? column2.width > getMinWidth(column2) : true;
    });
    if (resizableColumns.length) {
      resizeWidth = resizeColumns(resizableColumns, resizeWidth, getMinWidth);
    }
  }
  return resizeWidth;
}
function applyRowSpans(table) {
  var rowSpanCells = {};
  var colRowSpansLeft = 1;
  var all = table.allRows();
  for (var rowIndex = 0; rowIndex < all.length; rowIndex++) {
    var row = all[rowIndex];
    for (var _i = 0, _a2 = table.columns; _i < _a2.length; _i++) {
      var column = _a2[_i];
      var data = rowSpanCells[column.index];
      if (colRowSpansLeft > 1) {
        colRowSpansLeft--;
        delete row.cells[column.index];
      } else if (data) {
        data.cell.height += row.height;
        colRowSpansLeft = data.cell.colSpan;
        delete row.cells[column.index];
        data.left--;
        if (data.left <= 1) {
          delete rowSpanCells[column.index];
        }
      } else {
        var cell = row.cells[column.index];
        if (!cell) {
          continue;
        }
        cell.height = row.height;
        if (cell.rowSpan > 1) {
          var remaining = all.length - rowIndex;
          var left = cell.rowSpan > remaining ? remaining : cell.rowSpan;
          rowSpanCells[column.index] = { cell, left, row };
        }
      }
    }
  }
}
function applyColSpans(table) {
  var all = table.allRows();
  for (var rowIndex = 0; rowIndex < all.length; rowIndex++) {
    var row = all[rowIndex];
    var colSpanCell = null;
    var combinedColSpanWidth = 0;
    var colSpansLeft = 0;
    for (var columnIndex = 0; columnIndex < table.columns.length; columnIndex++) {
      var column = table.columns[columnIndex];
      colSpansLeft -= 1;
      if (colSpansLeft > 1 && table.columns[columnIndex + 1]) {
        combinedColSpanWidth += column.width;
        delete row.cells[column.index];
      } else if (colSpanCell) {
        var cell = colSpanCell;
        delete row.cells[column.index];
        colSpanCell = null;
        cell.width = column.width + combinedColSpanWidth;
      } else {
        var cell = row.cells[column.index];
        if (!cell)
          continue;
        colSpansLeft = cell.colSpan;
        combinedColSpanWidth = 0;
        if (cell.colSpan > 1) {
          colSpanCell = cell;
          combinedColSpanWidth += column.width;
          continue;
        }
        cell.width = column.width + combinedColSpanWidth;
      }
    }
  }
}
function fitContent(table, doc) {
  var rowSpanHeight = { count: 0, height: 0 };
  for (var _i = 0, _a2 = table.allRows(); _i < _a2.length; _i++) {
    var row = _a2[_i];
    for (var _b = 0, _c = table.columns; _b < _c.length; _b++) {
      var column = _c[_b];
      var cell = row.cells[column.index];
      if (!cell)
        continue;
      doc.applyStyles(cell.styles, true);
      var textSpace = cell.width - cell.padding("horizontal");
      if (cell.styles.overflow === "linebreak") {
        cell.text = doc.splitTextToSize(cell.text, textSpace + 1 / doc.scaleFactor(), { fontSize: cell.styles.fontSize });
      } else if (cell.styles.overflow === "ellipsize") {
        cell.text = ellipsize(cell.text, textSpace, cell.styles, doc, "...");
      } else if (cell.styles.overflow === "hidden") {
        cell.text = ellipsize(cell.text, textSpace, cell.styles, doc, "");
      } else if (typeof cell.styles.overflow === "function") {
        var result = cell.styles.overflow(cell.text, textSpace);
        if (typeof result === "string") {
          cell.text = [result];
        } else {
          cell.text = result;
        }
      }
      cell.contentHeight = cell.getContentHeight(doc.scaleFactor(), doc.getLineHeightFactor());
      var realContentHeight = cell.contentHeight / cell.rowSpan;
      if (cell.rowSpan > 1 && rowSpanHeight.count * rowSpanHeight.height < realContentHeight * cell.rowSpan) {
        rowSpanHeight = { height: realContentHeight, count: cell.rowSpan };
      } else if (rowSpanHeight && rowSpanHeight.count > 0) {
        if (rowSpanHeight.height > realContentHeight) {
          realContentHeight = rowSpanHeight.height;
        }
      }
      if (realContentHeight > row.height) {
        row.height = realContentHeight;
      }
    }
    rowSpanHeight.count--;
  }
}
function ellipsize(text, width, styles, doc, overflow2) {
  return text.map(function(str) {
    return ellipsizeStr(str, width, styles, doc, overflow2);
  });
}
function ellipsizeStr(text, width, styles, doc, overflow2) {
  var precision = 1e4 * doc.scaleFactor();
  width = Math.ceil(width * precision) / precision;
  if (width >= getStringWidth(text, styles, doc)) {
    return text;
  }
  while (width < getStringWidth(text + overflow2, styles, doc)) {
    if (text.length <= 1) {
      break;
    }
    text = text.substring(0, text.length - 1);
  }
  return text.trim() + overflow2;
}
function createTable(jsPDFDoc, input) {
  var doc = new DocHandler(jsPDFDoc);
  var content2 = parseContent(input, doc.scaleFactor());
  var table = new Table(input, content2);
  calculateWidths(doc, table);
  doc.applyStyles(doc.userStyles);
  return table;
}
function parseContent(input, sf) {
  var content2 = input.content;
  var columns = createColumns(content2.columns);
  if (content2.head.length === 0) {
    var sectionRow = generateSectionRow(columns, "head");
    if (sectionRow)
      content2.head.push(sectionRow);
  }
  if (content2.foot.length === 0) {
    var sectionRow = generateSectionRow(columns, "foot");
    if (sectionRow)
      content2.foot.push(sectionRow);
  }
  var theme = input.settings.theme;
  var styles = input.styles;
  return {
    columns,
    head: parseSection("head", content2.head, columns, styles, theme, sf),
    body: parseSection("body", content2.body, columns, styles, theme, sf),
    foot: parseSection("foot", content2.foot, columns, styles, theme, sf)
  };
}
function parseSection(sectionName, sectionRows, columns, styleProps, theme, scaleFactor) {
  var rowSpansLeftForColumn = {};
  var result = sectionRows.map(function(rawRow, rowIndex) {
    var skippedRowForRowSpans = 0;
    var cells = {};
    var colSpansAdded = 0;
    var columnSpansLeft = 0;
    for (var _i = 0, columns_1 = columns; _i < columns_1.length; _i++) {
      var column = columns_1[_i];
      if (rowSpansLeftForColumn[column.index] == null || rowSpansLeftForColumn[column.index].left === 0) {
        if (columnSpansLeft === 0) {
          var rawCell = void 0;
          if (Array.isArray(rawRow)) {
            rawCell = rawRow[column.index - colSpansAdded - skippedRowForRowSpans];
          } else {
            rawCell = rawRow[column.dataKey];
          }
          var cellInputStyles = {};
          if (typeof rawCell === "object" && !Array.isArray(rawCell)) {
            cellInputStyles = (rawCell === null || rawCell === void 0 ? void 0 : rawCell.styles) || {};
          }
          var styles = cellStyles(sectionName, column, rowIndex, theme, styleProps, scaleFactor, cellInputStyles);
          var cell = new Cell(rawCell, styles, sectionName);
          cells[column.dataKey] = cell;
          cells[column.index] = cell;
          columnSpansLeft = cell.colSpan - 1;
          rowSpansLeftForColumn[column.index] = {
            left: cell.rowSpan - 1,
            times: columnSpansLeft
          };
        } else {
          columnSpansLeft--;
          colSpansAdded++;
        }
      } else {
        rowSpansLeftForColumn[column.index].left--;
        columnSpansLeft = rowSpansLeftForColumn[column.index].times;
        skippedRowForRowSpans++;
      }
    }
    return new Row(rawRow, rowIndex, sectionName, cells);
  });
  return result;
}
function generateSectionRow(columns, section) {
  var sectionRow = {};
  columns.forEach(function(col) {
    if (col.raw != null) {
      var title = getSectionTitle(section, col.raw);
      if (title != null)
        sectionRow[col.dataKey] = title;
    }
  });
  return Object.keys(sectionRow).length > 0 ? sectionRow : null;
}
function getSectionTitle(section, column) {
  if (section === "head") {
    if (typeof column === "object") {
      return column.header || null;
    } else if (typeof column === "string" || typeof column === "number") {
      return column;
    }
  } else if (section === "foot" && typeof column === "object") {
    return column.footer;
  }
  return null;
}
function createColumns(columns) {
  return columns.map(function(input, index) {
    var _a2;
    var key;
    if (typeof input === "object") {
      key = (_a2 = input.dataKey) !== null && _a2 !== void 0 ? _a2 : index;
    } else {
      key = index;
    }
    return new Column(key, input, index);
  });
}
function cellStyles(sectionName, column, rowIndex, themeName, styles, scaleFactor, cellInputStyles) {
  var theme = getTheme(themeName);
  var sectionStyles;
  if (sectionName === "head") {
    sectionStyles = styles.headStyles;
  } else if (sectionName === "body") {
    sectionStyles = styles.bodyStyles;
  } else if (sectionName === "foot") {
    sectionStyles = styles.footStyles;
  }
  var otherStyles = assign2({}, theme.table, theme[sectionName], styles.styles, sectionStyles);
  var columnStyles = styles.columnStyles[column.dataKey] || styles.columnStyles[column.index] || {};
  var colStyles = sectionName === "body" ? columnStyles : {};
  var rowStyles = sectionName === "body" && rowIndex % 2 === 0 ? assign2({}, theme.alternateRow, styles.alternateRowStyles) : {};
  var defaultStyle = defaultStyles(scaleFactor);
  var themeStyles = assign2({}, defaultStyle, otherStyles, rowStyles, colStyles);
  return assign2(themeStyles, cellInputStyles);
}
function getColumnsCanFitInPage(doc, table, config) {
  var _a2;
  if (config === void 0) {
    config = {};
  }
  var remainingWidth = getPageAvailableWidth(doc, table);
  var repeatColumnsMap = /* @__PURE__ */ new Map();
  var colIndexes = [];
  var columns = [];
  var horizontalPageBreakRepeat = [];
  if (Array.isArray(table.settings.horizontalPageBreakRepeat)) {
    horizontalPageBreakRepeat = table.settings.horizontalPageBreakRepeat;
  } else if (typeof table.settings.horizontalPageBreakRepeat === "string" || typeof table.settings.horizontalPageBreakRepeat === "number") {
    horizontalPageBreakRepeat = [table.settings.horizontalPageBreakRepeat];
  }
  horizontalPageBreakRepeat.forEach(function(field) {
    var col = table.columns.find(function(item) {
      return item.dataKey === field || item.index === field;
    });
    if (col && !repeatColumnsMap.has(col.index)) {
      repeatColumnsMap.set(col.index, true);
      colIndexes.push(col.index);
      columns.push(table.columns[col.index]);
      remainingWidth -= col.wrappedWidth;
    }
  });
  var first = true;
  var i = (_a2 = config === null || config === void 0 ? void 0 : config.start) !== null && _a2 !== void 0 ? _a2 : 0;
  while (i < table.columns.length) {
    if (repeatColumnsMap.has(i)) {
      i++;
      continue;
    }
    var colWidth = table.columns[i].wrappedWidth;
    if (first || remainingWidth >= colWidth) {
      first = false;
      colIndexes.push(i);
      columns.push(table.columns[i]);
      remainingWidth -= colWidth;
    } else {
      break;
    }
    i++;
  }
  return { colIndexes, columns, lastIndex: i - 1 };
}
function calculateAllColumnsCanFitInPage(doc, table) {
  var allResults = [];
  for (var i = 0; i < table.columns.length; i++) {
    var result = getColumnsCanFitInPage(doc, table, { start: i });
    if (result.columns.length) {
      allResults.push(result);
      i = result.lastIndex;
    }
  }
  return allResults;
}
function drawTable(jsPDFDoc, table) {
  var settings = table.settings;
  var startY = settings.startY;
  var margin = settings.margin;
  var cursor = { x: margin.left, y: startY };
  var sectionsHeight = table.getHeadHeight(table.columns) + table.getFootHeight(table.columns);
  var minTableBottomPos = startY + margin.bottom + sectionsHeight;
  if (settings.pageBreak === "avoid") {
    var rows = table.body;
    var tableHeight = rows.reduce(function(acc, row) {
      return acc + row.height;
    }, 0);
    minTableBottomPos += tableHeight;
  }
  var doc = new DocHandler(jsPDFDoc);
  if (settings.pageBreak === "always" || settings.startY != null && minTableBottomPos > doc.pageSize().height) {
    nextPage(doc);
    cursor.y = margin.top;
  }
  table.callWillDrawPageHooks(doc, cursor);
  var startPos = assign2({}, cursor);
  table.startPageNumber = doc.pageNumber();
  if (settings.horizontalPageBreak) {
    printTableWithHorizontalPageBreak(doc, table, startPos, cursor);
  } else {
    doc.applyStyles(doc.userStyles);
    if (settings.showHead === "firstPage" || settings.showHead === "everyPage") {
      table.head.forEach(function(row) {
        return printRow(doc, table, row, cursor, table.columns);
      });
    }
    doc.applyStyles(doc.userStyles);
    table.body.forEach(function(row, index) {
      var isLastRow = index === table.body.length - 1;
      printFullRow(doc, table, row, isLastRow, startPos, cursor, table.columns);
    });
    doc.applyStyles(doc.userStyles);
    if (settings.showFoot === "lastPage" || settings.showFoot === "everyPage") {
      table.foot.forEach(function(row) {
        return printRow(doc, table, row, cursor, table.columns);
      });
    }
  }
  addTableBorder(doc, table, startPos, cursor);
  table.callEndPageHooks(doc, cursor);
  table.finalY = cursor.y;
  jsPDFDoc.lastAutoTable = table;
  doc.applyStyles(doc.userStyles);
}
function printTableWithHorizontalPageBreak(doc, table, startPos, cursor) {
  var allColumnsCanFitResult = calculateAllColumnsCanFitInPage(doc, table);
  var settings = table.settings;
  if (settings.horizontalPageBreakBehaviour === "afterAllRows") {
    allColumnsCanFitResult.forEach(function(colsAndIndexes, index) {
      doc.applyStyles(doc.userStyles);
      if (index > 0) {
        addPage(doc, table, startPos, cursor, colsAndIndexes.columns, true);
      } else {
        printHead(doc, table, cursor, colsAndIndexes.columns);
      }
      printBody(doc, table, startPos, cursor, colsAndIndexes.columns);
      printFoot(doc, table, cursor, colsAndIndexes.columns);
    });
  } else {
    var lastRowIndexOfLastPage_1 = -1;
    var firstColumnsToFitResult = allColumnsCanFitResult[0];
    var _loop_1 = function() {
      var lastPrintedRowIndex = lastRowIndexOfLastPage_1;
      if (firstColumnsToFitResult) {
        doc.applyStyles(doc.userStyles);
        var firstColumnsToFit = firstColumnsToFitResult.columns;
        if (lastRowIndexOfLastPage_1 >= 0) {
          addPage(doc, table, startPos, cursor, firstColumnsToFit, true);
        } else {
          printHead(doc, table, cursor, firstColumnsToFit);
        }
        lastPrintedRowIndex = printBodyWithoutPageBreaks(doc, table, lastRowIndexOfLastPage_1 + 1, cursor, firstColumnsToFit);
        printFoot(doc, table, cursor, firstColumnsToFit);
      }
      var maxNumberOfRows = lastPrintedRowIndex - lastRowIndexOfLastPage_1;
      allColumnsCanFitResult.slice(1).forEach(function(colsAndIndexes) {
        doc.applyStyles(doc.userStyles);
        addPage(doc, table, startPos, cursor, colsAndIndexes.columns, true);
        printBodyWithoutPageBreaks(doc, table, lastRowIndexOfLastPage_1 + 1, cursor, colsAndIndexes.columns, maxNumberOfRows);
        printFoot(doc, table, cursor, colsAndIndexes.columns);
      });
      lastRowIndexOfLastPage_1 = lastPrintedRowIndex;
    };
    while (lastRowIndexOfLastPage_1 < table.body.length - 1) {
      _loop_1();
    }
  }
}
function printHead(doc, table, cursor, columns) {
  var settings = table.settings;
  doc.applyStyles(doc.userStyles);
  if (settings.showHead === "firstPage" || settings.showHead === "everyPage") {
    table.head.forEach(function(row) {
      return printRow(doc, table, row, cursor, columns);
    });
  }
}
function printBody(doc, table, startPos, cursor, columns) {
  doc.applyStyles(doc.userStyles);
  table.body.forEach(function(row, index) {
    var isLastRow = index === table.body.length - 1;
    printFullRow(doc, table, row, isLastRow, startPos, cursor, columns);
  });
}
function printBodyWithoutPageBreaks(doc, table, startRowIndex, cursor, columns, maxNumberOfRows) {
  doc.applyStyles(doc.userStyles);
  maxNumberOfRows = maxNumberOfRows !== null && maxNumberOfRows !== void 0 ? maxNumberOfRows : table.body.length;
  var endRowIndex = Math.min(startRowIndex + maxNumberOfRows, table.body.length);
  var lastPrintedRowIndex = -1;
  table.body.slice(startRowIndex, endRowIndex).forEach(function(row, index) {
    var isLastRow = startRowIndex + index === table.body.length - 1;
    var remainingSpace = getRemainingPageSpace(doc, table, isLastRow, cursor);
    if (row.canEntireRowFit(remainingSpace, columns)) {
      printRow(doc, table, row, cursor, columns);
      lastPrintedRowIndex = startRowIndex + index;
    }
  });
  return lastPrintedRowIndex;
}
function printFoot(doc, table, cursor, columns) {
  var settings = table.settings;
  doc.applyStyles(doc.userStyles);
  if (settings.showFoot === "lastPage" || settings.showFoot === "everyPage") {
    table.foot.forEach(function(row) {
      return printRow(doc, table, row, cursor, columns);
    });
  }
}
function getRemainingLineCount(cell, remainingPageSpace, doc) {
  var lineHeight2 = doc.getLineHeight(cell.styles.fontSize);
  var vPadding = cell.padding("vertical");
  var remainingLines = Math.floor((remainingPageSpace - vPadding) / lineHeight2);
  return Math.max(0, remainingLines);
}
function modifyRowToFit(row, remainingPageSpace, table, doc) {
  var cells = {};
  row.spansMultiplePages = true;
  row.height = 0;
  var rowHeight = 0;
  for (var _i = 0, _a2 = table.columns; _i < _a2.length; _i++) {
    var column = _a2[_i];
    var cell = row.cells[column.index];
    if (!cell)
      continue;
    if (!Array.isArray(cell.text)) {
      cell.text = [cell.text];
    }
    var remainderCell = new Cell(cell.raw, cell.styles, cell.section);
    remainderCell = assign2(remainderCell, cell);
    remainderCell.text = [];
    var remainingLineCount = getRemainingLineCount(cell, remainingPageSpace, doc);
    if (cell.text.length > remainingLineCount) {
      remainderCell.text = cell.text.splice(remainingLineCount, cell.text.length);
    }
    var scaleFactor = doc.scaleFactor();
    var lineHeightFactor = doc.getLineHeightFactor();
    cell.contentHeight = cell.getContentHeight(scaleFactor, lineHeightFactor);
    if (cell.contentHeight >= remainingPageSpace) {
      cell.contentHeight = remainingPageSpace;
      remainderCell.styles.minCellHeight -= remainingPageSpace;
    }
    if (cell.contentHeight > row.height) {
      row.height = cell.contentHeight;
    }
    remainderCell.contentHeight = remainderCell.getContentHeight(scaleFactor, lineHeightFactor);
    if (remainderCell.contentHeight > rowHeight) {
      rowHeight = remainderCell.contentHeight;
    }
    cells[column.index] = remainderCell;
  }
  var remainderRow = new Row(row.raw, -1, row.section, cells, true);
  remainderRow.height = rowHeight;
  for (var _b = 0, _c = table.columns; _b < _c.length; _b++) {
    var column = _c[_b];
    var remainderCell = remainderRow.cells[column.index];
    if (remainderCell) {
      remainderCell.height = remainderRow.height;
    }
    var cell = row.cells[column.index];
    if (cell) {
      cell.height = row.height;
    }
  }
  return remainderRow;
}
function shouldPrintOnCurrentPage(doc, row, remainingPageSpace, table) {
  var pageHeight = doc.pageSize().height;
  var margin = table.settings.margin;
  var marginHeight = margin.top + margin.bottom;
  var maxRowHeight = pageHeight - marginHeight;
  if (row.section === "body") {
    maxRowHeight -= table.getHeadHeight(table.columns) + table.getFootHeight(table.columns);
  }
  var minRowHeight = row.getMinimumRowHeight(table.columns, doc);
  var minRowFits = minRowHeight < remainingPageSpace;
  if (minRowHeight > maxRowHeight) {
    console.log("Will not be able to print row ".concat(row.index, " correctly since it's minimum height is larger than page height"));
    return true;
  }
  if (!minRowFits) {
    return false;
  }
  var rowHasRowSpanCell = row.hasRowSpan(table.columns);
  var rowHigherThanPage = row.getMaxCellHeight(table.columns) > maxRowHeight;
  if (rowHigherThanPage) {
    if (rowHasRowSpanCell) {
      console.log("The content of row ".concat(row.index, " will not be drawn correctly since drawing rows with a height larger than the page height and has cells with rowspans is not supported."));
    }
    return true;
  }
  if (rowHasRowSpanCell) {
    return false;
  }
  if (table.settings.rowPageBreak === "avoid") {
    return false;
  }
  return true;
}
function printFullRow(doc, table, row, isLastRow, startPos, cursor, columns) {
  var remainingSpace = getRemainingPageSpace(doc, table, isLastRow, cursor);
  if (row.canEntireRowFit(remainingSpace, columns)) {
    printRow(doc, table, row, cursor, columns);
  } else if (shouldPrintOnCurrentPage(doc, row, remainingSpace, table)) {
    var remainderRow = modifyRowToFit(row, remainingSpace, table, doc);
    printRow(doc, table, row, cursor, columns);
    addPage(doc, table, startPos, cursor, columns);
    printFullRow(doc, table, remainderRow, isLastRow, startPos, cursor, columns);
  } else {
    addPage(doc, table, startPos, cursor, columns);
    printFullRow(doc, table, row, isLastRow, startPos, cursor, columns);
  }
}
function printRow(doc, table, row, cursor, columns) {
  cursor.x = table.settings.margin.left;
  for (var _i = 0, columns_1 = columns; _i < columns_1.length; _i++) {
    var column = columns_1[_i];
    var cell = row.cells[column.index];
    if (!cell) {
      cursor.x += column.width;
      continue;
    }
    doc.applyStyles(cell.styles);
    cell.x = cursor.x;
    cell.y = cursor.y;
    var result = table.callCellHooks(doc, table.hooks.willDrawCell, cell, row, column, cursor);
    if (result === false) {
      cursor.x += column.width;
      continue;
    }
    drawCellRect(doc, cell, cursor);
    var textPos = cell.getTextPos();
    autoTableText(cell.text, textPos.x, textPos.y, {
      halign: cell.styles.halign,
      valign: cell.styles.valign,
      maxWidth: Math.ceil(cell.width - cell.padding("left") - cell.padding("right"))
    }, doc.getDocument());
    table.callCellHooks(doc, table.hooks.didDrawCell, cell, row, column, cursor);
    cursor.x += column.width;
  }
  cursor.y += row.height;
}
function drawCellRect(doc, cell, cursor) {
  var cellStyles2 = cell.styles;
  doc.getDocument().setFillColor(doc.getDocument().getFillColor());
  if (typeof cellStyles2.lineWidth === "number") {
    var fillStyle = getFillStyle(cellStyles2.lineWidth, cellStyles2.fillColor);
    if (fillStyle) {
      doc.rect(cell.x, cursor.y, cell.width, cell.height, fillStyle);
    }
  } else if (typeof cellStyles2.lineWidth === "object") {
    if (cellStyles2.fillColor) {
      doc.rect(cell.x, cursor.y, cell.width, cell.height, "F");
    }
    drawCellBorders(doc, cell, cursor, cellStyles2.lineWidth);
  }
}
function drawCellBorders(doc, cell, cursor, lineWidth) {
  var x1, y1, x2, y2;
  if (lineWidth.top) {
    x1 = cursor.x;
    y1 = cursor.y;
    x2 = cursor.x + cell.width;
    y2 = cursor.y;
    if (lineWidth.right) {
      x2 += 0.5 * lineWidth.right;
    }
    if (lineWidth.left) {
      x1 -= 0.5 * lineWidth.left;
    }
    drawLine(lineWidth.top, x1, y1, x2, y2);
  }
  if (lineWidth.bottom) {
    x1 = cursor.x;
    y1 = cursor.y + cell.height;
    x2 = cursor.x + cell.width;
    y2 = cursor.y + cell.height;
    if (lineWidth.right) {
      x2 += 0.5 * lineWidth.right;
    }
    if (lineWidth.left) {
      x1 -= 0.5 * lineWidth.left;
    }
    drawLine(lineWidth.bottom, x1, y1, x2, y2);
  }
  if (lineWidth.left) {
    x1 = cursor.x;
    y1 = cursor.y;
    x2 = cursor.x;
    y2 = cursor.y + cell.height;
    if (lineWidth.top) {
      y1 -= 0.5 * lineWidth.top;
    }
    if (lineWidth.bottom) {
      y2 += 0.5 * lineWidth.bottom;
    }
    drawLine(lineWidth.left, x1, y1, x2, y2);
  }
  if (lineWidth.right) {
    x1 = cursor.x + cell.width;
    y1 = cursor.y;
    x2 = cursor.x + cell.width;
    y2 = cursor.y + cell.height;
    if (lineWidth.top) {
      y1 -= 0.5 * lineWidth.top;
    }
    if (lineWidth.bottom) {
      y2 += 0.5 * lineWidth.bottom;
    }
    drawLine(lineWidth.right, x1, y1, x2, y2);
  }
  function drawLine(width, x12, y12, x22, y22) {
    doc.getDocument().setLineWidth(width);
    doc.getDocument().line(x12, y12, x22, y22, "S");
  }
}
function getRemainingPageSpace(doc, table, isLastRow, cursor) {
  var bottomContentHeight = table.settings.margin.bottom;
  var showFoot = table.settings.showFoot;
  if (showFoot === "everyPage" || showFoot === "lastPage" && isLastRow) {
    bottomContentHeight += table.getFootHeight(table.columns);
  }
  return doc.pageSize().height - cursor.y - bottomContentHeight;
}
function addPage(doc, table, startPos, cursor, columns, suppressFooter) {
  if (columns === void 0) {
    columns = [];
  }
  if (suppressFooter === void 0) {
    suppressFooter = false;
  }
  doc.applyStyles(doc.userStyles);
  if (table.settings.showFoot === "everyPage" && !suppressFooter) {
    table.foot.forEach(function(row) {
      return printRow(doc, table, row, cursor, columns);
    });
  }
  table.callEndPageHooks(doc, cursor);
  var margin = table.settings.margin;
  addTableBorder(doc, table, startPos, cursor);
  nextPage(doc);
  table.pageNumber++;
  cursor.x = margin.left;
  cursor.y = margin.top;
  startPos.y = margin.top;
  table.callWillDrawPageHooks(doc, cursor);
  if (table.settings.showHead === "everyPage") {
    table.head.forEach(function(row) {
      return printRow(doc, table, row, cursor, columns);
    });
    doc.applyStyles(doc.userStyles);
  }
}
function nextPage(doc) {
  var current = doc.pageNumber();
  doc.setPage(current + 1);
  var newCurrent = doc.pageNumber();
  if (newCurrent === current) {
    doc.addPage();
    return true;
  }
  return false;
}
function applyPlugin(jsPDF2) {
  jsPDF2.API.autoTable = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var options = args[0];
    var input = parseInput(this, options);
    var table = createTable(this, input);
    drawTable(this, table);
    return this;
  };
  jsPDF2.API.lastAutoTable = false;
  jsPDF2.API.autoTableText = function(text, x, y, styles) {
    autoTableText(text, x, y, styles, this);
  };
  jsPDF2.API.autoTableSetDefaults = function(defaults) {
    DocHandler.setDefaults(defaults, this);
    return this;
  };
  jsPDF2.autoTableSetDefaults = function(defaults, doc) {
    DocHandler.setDefaults(defaults, doc);
  };
  jsPDF2.API.autoTableHtmlToJson = function(tableElem, includeHiddenElements) {
    var _a2;
    if (includeHiddenElements === void 0) {
      includeHiddenElements = false;
    }
    if (typeof window === "undefined") {
      console.error("Cannot run autoTableHtmlToJson in non browser environment");
      return null;
    }
    var doc = new DocHandler(this);
    var _b = parseHtml(doc, tableElem, window, includeHiddenElements, false), head = _b.head, body = _b.body;
    var columns = ((_a2 = head[0]) === null || _a2 === void 0 ? void 0 : _a2.map(function(c) {
      return c.content;
    })) || [];
    return { columns, rows: body, data: body };
  };
}
var _a;
function autoTable(d, options) {
  var input = parseInput(d, options);
  var table = createTable(d, input);
  drawTable(d, table);
}
try {
  if (typeof window !== "undefined" && window) {
    anyWindow = window;
    jsPDF2 = anyWindow.jsPDF || ((_a = anyWindow.jspdf) === null || _a === void 0 ? void 0 : _a.jsPDF);
    if (jsPDF2) {
      applyPlugin(jsPDF2);
    }
  }
} catch (error) {
  console.error("Could not apply autoTable plugin", error);
}
var anyWindow;
var jsPDF2;

// src/app/admin/repairs/admin-repair-form-page.ts
var _forTrack0 = ($index, $item) => $item.id;
function AdminRepairFormPage_Conditional_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 7);
    \u0275\u0275element(1, "span", 54);
    \u0275\u0275elementEnd();
  }
}
function AdminRepairFormPage_Conditional_9_Conditional_37_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 71);
    \u0275\u0275element(1, "span", 123);
    \u0275\u0275text(2, " Subiendo im\xE1genes... ");
    \u0275\u0275elementEnd();
  }
}
function AdminRepairFormPage_Conditional_9_Conditional_38_For_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 124);
    \u0275\u0275element(1, "img", 125);
    \u0275\u0275elementStart(2, "button", 126);
    \u0275\u0275listener("click", function AdminRepairFormPage_Conditional_9_Conditional_38_For_2_Template_button_click_2_listener() {
      const \u0275$index_100_r4 = \u0275\u0275restoreView(_r3).$index;
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.removeImage(\u0275$index_100_r4));
    });
    \u0275\u0275element(3, "i", 127);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const img_r5 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275property("src", img_r5, \u0275\u0275sanitizeUrl);
  }
}
function AdminRepairFormPage_Conditional_9_Conditional_38_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 72);
    \u0275\u0275repeaterCreate(1, AdminRepairFormPage_Conditional_9_Conditional_38_For_2_Template, 4, 1, "div", 124, \u0275\u0275repeaterTrackByIdentity);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275repeater(ctx_r1.form().images);
  }
}
function AdminRepairFormPage_Conditional_9_For_119_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "tr")(1, "td", 128);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "td", 100)(4, "input", 129);
    \u0275\u0275twoWayListener("ngModelChange", function AdminRepairFormPage_Conditional_9_For_119_Template_input_ngModelChange_4_listener($event) {
      const part_r7 = \u0275\u0275restoreView(_r6).$implicit;
      \u0275\u0275twoWayBindingSet(part_r7.quantity, $event) || (part_r7.quantity = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275listener("change", function AdminRepairFormPage_Conditional_9_For_119_Template_input_change_4_listener() {
      \u0275\u0275restoreView(_r6);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.calculateFinalCost());
    });
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(5, "td", 130);
    \u0275\u0275text(6);
    \u0275\u0275pipe(7, "currency");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(8, "td", 131);
    \u0275\u0275text(9);
    \u0275\u0275pipe(10, "currency");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(11, "td", 21)(12, "button", 132);
    \u0275\u0275listener("click", function AdminRepairFormPage_Conditional_9_For_119_Template_button_click_12_listener() {
      const $index_r8 = \u0275\u0275restoreView(_r6).$index;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.removePart($index_r8));
    });
    \u0275\u0275element(13, "i", 133);
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    const part_r7 = ctx.$implicit;
    const $index_r8 = ctx.$index;
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(part_r7.name);
    \u0275\u0275advance(2);
    \u0275\u0275twoWayProperty("ngModel", part_r7.quantity);
    \u0275\u0275property("name", "part_qty_" + $index_r8);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind4(7, 5, part_r7.unit_price_at_time, "ARS", "symbol", "1.0-0"), " ");
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind4(10, 10, part_r7.cost_at_time, "ARS", "symbol", "1.0-0"), " ");
  }
}
function AdminRepairFormPage_Conditional_9_Conditional_120_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "tr")(1, "td", 134);
    \u0275\u0275text(2, "No hay repuestos cargados");
    \u0275\u0275elementEnd()();
  }
}
function AdminRepairFormPage_Conditional_9_Conditional_189_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 116);
    \u0275\u0275element(1, "i", 135);
    \u0275\u0275elementStart(2, "span");
    \u0275\u0275text(3);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(ctx_r1.error());
  }
}
function AdminRepairFormPage_Conditional_9_Conditional_191_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 136);
    \u0275\u0275listener("click", function AdminRepairFormPage_Conditional_9_Conditional_191_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r9);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.shareWhatsApp());
    });
    \u0275\u0275element(1, "i", 137);
    \u0275\u0275text(2, " Compartir ");
    \u0275\u0275elementEnd();
  }
}
function AdminRepairFormPage_Conditional_9_Conditional_198_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 123);
  }
}
function AdminRepairFormPage_Conditional_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "form", 55);
    \u0275\u0275listener("ngSubmit", function AdminRepairFormPage_Conditional_9_Template_form_ngSubmit_0_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.save());
    });
    \u0275\u0275elementStart(1, "div", 56)(2, "div", 57)(3, "label", 58)(4, "span", 59);
    \u0275\u0275text(5, "Nombre del Cliente");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(6, "label", 60);
    \u0275\u0275element(7, "i", 61);
    \u0275\u0275elementStart(8, "input", 62);
    \u0275\u0275twoWayListener("ngModelChange", function AdminRepairFormPage_Conditional_9_Template_input_ngModelChange_8_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      \u0275\u0275twoWayBindingSet(ctx_r1.form().customer_name, $event) || (ctx_r1.form().customer_name = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(9, "div", 57)(10, "label", 58)(11, "span", 59);
    \u0275\u0275text(12, "Tel\xE9fono");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(13, "label", 60);
    \u0275\u0275element(14, "i", 63);
    \u0275\u0275elementStart(15, "input", 64);
    \u0275\u0275twoWayListener("ngModelChange", function AdminRepairFormPage_Conditional_9_Template_input_ngModelChange_15_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      \u0275\u0275twoWayBindingSet(ctx_r1.form().customer_phone, $event) || (ctx_r1.form().customer_phone = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd()()()();
    \u0275\u0275elementStart(16, "div", 56)(17, "div", 57)(18, "label", 58)(19, "span", 59);
    \u0275\u0275text(20, "Modelo del Dispositivo");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(21, "label", 60);
    \u0275\u0275element(22, "i", 65);
    \u0275\u0275elementStart(23, "input", 66);
    \u0275\u0275twoWayListener("ngModelChange", function AdminRepairFormPage_Conditional_9_Template_input_ngModelChange_23_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      \u0275\u0275twoWayBindingSet(ctx_r1.form().device_model, $event) || (ctx_r1.form().device_model = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(24, "div", 57)(25, "label", 58)(26, "span", 59);
    \u0275\u0275text(27, "IMEI / Serie");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(28, "label", 60);
    \u0275\u0275element(29, "i", 67);
    \u0275\u0275elementStart(30, "input", 68);
    \u0275\u0275twoWayListener("ngModelChange", function AdminRepairFormPage_Conditional_9_Template_input_ngModelChange_30_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      \u0275\u0275twoWayBindingSet(ctx_r1.form().imei, $event) || (ctx_r1.form().imei = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd()()()();
    \u0275\u0275elementStart(31, "div", 57)(32, "label", 58)(33, "span", 59);
    \u0275\u0275text(34, "Im\xE1genes del Equipo");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(35, "div", 69)(36, "input", 70);
    \u0275\u0275listener("change", function AdminRepairFormPage_Conditional_9_Template_input_change_36_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onFileSelected($event));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275conditionalCreate(37, AdminRepairFormPage_Conditional_9_Conditional_37_Template, 3, 0, "div", 71);
    \u0275\u0275conditionalCreate(38, AdminRepairFormPage_Conditional_9_Conditional_38_Template, 3, 0, "div", 72);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(39, "div", 57)(40, "label", 58)(41, "span", 59);
    \u0275\u0275text(42, "Descripci\xF3n del Problema");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(43, "textarea", 73);
    \u0275\u0275twoWayListener("ngModelChange", function AdminRepairFormPage_Conditional_9_Template_textarea_ngModelChange_43_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      \u0275\u0275twoWayBindingSet(ctx_r1.form().issue_description, $event) || (ctx_r1.form().issue_description = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(44, "div", 74);
    \u0275\u0275text(45, "Detalles del Equipo");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(46, "div", 57)(47, "label", 58)(48, "span", 59);
    \u0275\u0275text(49, "Accesorios Recibidos");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(50, "div", 75)(51, "label", 76)(52, "input", 77);
    \u0275\u0275twoWayListener("ngModelChange", function AdminRepairFormPage_Conditional_9_Template_input_ngModelChange_52_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      \u0275\u0275twoWayBindingSet(ctx_r1.form().checklist.charger, $event) || (ctx_r1.form().checklist.charger = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(53, "span", 78);
    \u0275\u0275text(54, "Cargador");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(55, "label", 76)(56, "input", 79);
    \u0275\u0275twoWayListener("ngModelChange", function AdminRepairFormPage_Conditional_9_Template_input_ngModelChange_56_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      \u0275\u0275twoWayBindingSet(ctx_r1.form().checklist.battery, $event) || (ctx_r1.form().checklist.battery = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(57, "span", 78);
    \u0275\u0275text(58, "Bater\xEDa");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(59, "label", 76)(60, "input", 80);
    \u0275\u0275twoWayListener("ngModelChange", function AdminRepairFormPage_Conditional_9_Template_input_ngModelChange_60_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      \u0275\u0275twoWayBindingSet(ctx_r1.form().checklist.chip, $event) || (ctx_r1.form().checklist.chip = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(61, "span", 78);
    \u0275\u0275text(62, "Chip");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(63, "label", 76)(64, "input", 81);
    \u0275\u0275twoWayListener("ngModelChange", function AdminRepairFormPage_Conditional_9_Template_input_ngModelChange_64_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      \u0275\u0275twoWayBindingSet(ctx_r1.form().checklist.sd, $event) || (ctx_r1.form().checklist.sd = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(65, "span", 78);
    \u0275\u0275text(66, "Tarjeta SD");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(67, "label", 76)(68, "input", 82);
    \u0275\u0275twoWayListener("ngModelChange", function AdminRepairFormPage_Conditional_9_Template_input_ngModelChange_68_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      \u0275\u0275twoWayBindingSet(ctx_r1.form().checklist.case, $event) || (ctx_r1.form().checklist.case = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(69, "span", 78);
    \u0275\u0275text(70, "Funda");
    \u0275\u0275elementEnd()()()();
    \u0275\u0275elementStart(71, "div", 83)(72, "div", 57)(73, "label", 58)(74, "span", 59);
    \u0275\u0275text(75, "PIN / Contrase\xF1a");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(76, "label", 60);
    \u0275\u0275element(77, "i", 84);
    \u0275\u0275elementStart(78, "input", 85);
    \u0275\u0275twoWayListener("ngModelChange", function AdminRepairFormPage_Conditional_9_Template_input_ngModelChange_78_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      \u0275\u0275twoWayBindingSet(ctx_r1.form().security_pin, $event) || (ctx_r1.form().security_pin = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(79, "div", 57)(80, "label", 58)(81, "span", 59);
    \u0275\u0275text(82, "Patr\xF3n");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(83, "label", 60);
    \u0275\u0275element(84, "i", 86);
    \u0275\u0275elementStart(85, "input", 87);
    \u0275\u0275twoWayListener("ngModelChange", function AdminRepairFormPage_Conditional_9_Template_input_ngModelChange_85_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      \u0275\u0275twoWayBindingSet(ctx_r1.form().security_pattern, $event) || (ctx_r1.form().security_pattern = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(86, "div", 57)(87, "label", 58)(88, "span", 59);
    \u0275\u0275text(89, "Passcode (Num\xE9rico/Texto)");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(90, "label", 60);
    \u0275\u0275element(91, "i", 88);
    \u0275\u0275elementStart(92, "input", 89);
    \u0275\u0275twoWayListener("ngModelChange", function AdminRepairFormPage_Conditional_9_Template_input_ngModelChange_92_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      \u0275\u0275twoWayBindingSet(ctx_r1.form().device_passcode, $event) || (ctx_r1.form().device_passcode = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd()()()();
    \u0275\u0275elementStart(93, "div", 74);
    \u0275\u0275text(94, "Gesti\xF3n T\xE9cnica & Repuestos");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(95, "div", 90)(96, "div", 91)(97, "h3", 92);
    \u0275\u0275element(98, "i", 93);
    \u0275\u0275text(99, " Repuestos Utilizados ");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(100, "div", 94)(101, "button", 95);
    \u0275\u0275listener("click", function AdminRepairFormPage_Conditional_9_Template_button_click_101_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.loadProducts());
    });
    \u0275\u0275element(102, "i", 96);
    \u0275\u0275text(103, " A\xF1adir Repuesto ");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(104, "div", 97)(105, "table", 98)(106, "thead", 99)(107, "tr")(108, "th");
    \u0275\u0275text(109, "Repuesto");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(110, "th", 100);
    \u0275\u0275text(111, "Cant.");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(112, "th", 21);
    \u0275\u0275text(113, "Precio Venta");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(114, "th", 21);
    \u0275\u0275text(115, "Costo");
    \u0275\u0275elementEnd();
    \u0275\u0275element(116, "th");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(117, "tbody");
    \u0275\u0275repeaterCreate(118, AdminRepairFormPage_Conditional_9_For_119_Template, 14, 15, "tr", null, \u0275\u0275repeaterTrackByIndex);
    \u0275\u0275conditionalCreate(120, AdminRepairFormPage_Conditional_9_Conditional_120_Template, 3, 0, "tr");
    \u0275\u0275elementEnd()()()();
    \u0275\u0275elementStart(121, "div", 56)(122, "div", 57)(123, "label", 58)(124, "span", 59);
    \u0275\u0275text(125, "Mano de Obra (Labor T\xE9cnica)");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(126, "label", 60);
    \u0275\u0275element(127, "i", 101);
    \u0275\u0275elementStart(128, "input", 102);
    \u0275\u0275twoWayListener("ngModelChange", function AdminRepairFormPage_Conditional_9_Template_input_ngModelChange_128_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      \u0275\u0275twoWayBindingSet(ctx_r1.form().technical_labor_cost, $event) || (ctx_r1.form().technical_labor_cost = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275listener("change", function AdminRepairFormPage_Conditional_9_Template_input_change_128_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.calculateFinalCost());
    });
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(129, "div", 57)(130, "label", 58)(131, "span", 59);
    \u0275\u0275text(132, "Estado Final");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(133, "select", 103);
    \u0275\u0275twoWayListener("ngModelChange", function AdminRepairFormPage_Conditional_9_Template_select_ngModelChange_133_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      \u0275\u0275twoWayBindingSet(ctx_r1.form().current_status_id, $event) || (ctx_r1.form().current_status_id = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementStart(134, "option", 104);
    \u0275\u0275text(135, "PENDIENTE DE DIAGN\xD3STICO");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(136, "option", 104);
    \u0275\u0275text(137, "GESTI\xD3N DE REPUESTOS");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(138, "option", 104);
    \u0275\u0275text(139, "EN REPARACI\xD3N");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(140, "option", 104);
    \u0275\u0275text(141, "CONTROL DE CALIDAD");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(142, "option", 104);
    \u0275\u0275text(143, "LISTO PARA RETIRAR");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(144, "option", 104);
    \u0275\u0275text(145, "ENTREGADO");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(146, "option", 104);
    \u0275\u0275text(147, "CANCELADO");
    \u0275\u0275elementEnd()()()();
    \u0275\u0275elementStart(148, "div", 57)(149, "label", 58)(150, "span", 105);
    \u0275\u0275text(151, "Reporte T\xE9cnico (P\xFAblico)");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(152, "textarea", 106);
    \u0275\u0275twoWayListener("ngModelChange", function AdminRepairFormPage_Conditional_9_Template_textarea_ngModelChange_152_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      \u0275\u0275twoWayBindingSet(ctx_r1.form().technical_report, $event) || (ctx_r1.form().technical_report = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(153, "div", 74);
    \u0275\u0275text(154, "Resumen Financiero");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(155, "div", 107)(156, "div", 57)(157, "label", 58)(158, "span", 59);
    \u0275\u0275text(159, "Presupuesto Inicial Estimado");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(160, "label", 60);
    \u0275\u0275element(161, "i", 108);
    \u0275\u0275elementStart(162, "input", 109);
    \u0275\u0275twoWayListener("ngModelChange", function AdminRepairFormPage_Conditional_9_Template_input_ngModelChange_162_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      \u0275\u0275twoWayBindingSet(ctx_r1.form().estimated_cost, $event) || (ctx_r1.form().estimated_cost = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(163, "div", 57)(164, "label", 58)(165, "span", 59);
    \u0275\u0275text(166, "Costo Total (Final)");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(167, "div", 110);
    \u0275\u0275text(168);
    \u0275\u0275pipe(169, "currency");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(170, "div", 57)(171, "label", 58)(172, "span", 59);
    \u0275\u0275text(173, "Se\xF1a / Adelanto");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(174, "label", 60);
    \u0275\u0275element(175, "i", 111);
    \u0275\u0275elementStart(176, "input", 112);
    \u0275\u0275twoWayListener("ngModelChange", function AdminRepairFormPage_Conditional_9_Template_input_ngModelChange_176_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      \u0275\u0275twoWayBindingSet(ctx_r1.form().deposit_amount, $event) || (ctx_r1.form().deposit_amount = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(177, "div", 57)(178, "label", 58)(179, "span", 113);
    \u0275\u0275text(180, "Saldo Pendiente");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(181, "div", 114);
    \u0275\u0275text(182);
    \u0275\u0275pipe(183, "currency");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(184, "div", 57)(185, "label", 58)(186, "span", 59);
    \u0275\u0275text(187, "Notas del T\xE9cnico (Interno)");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(188, "textarea", 115);
    \u0275\u0275twoWayListener("ngModelChange", function AdminRepairFormPage_Conditional_9_Template_textarea_ngModelChange_188_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      \u0275\u0275twoWayBindingSet(ctx_r1.form().technician_notes, $event) || (ctx_r1.form().technician_notes = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd()();
    \u0275\u0275conditionalCreate(189, AdminRepairFormPage_Conditional_9_Conditional_189_Template, 4, 1, "div", 116);
    \u0275\u0275elementStart(190, "div", 117);
    \u0275\u0275conditionalCreate(191, AdminRepairFormPage_Conditional_9_Conditional_191_Template, 3, 0, "button", 118);
    \u0275\u0275elementStart(192, "button", 119);
    \u0275\u0275listener("click", function AdminRepairFormPage_Conditional_9_Template_button_click_192_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.printOrder());
    });
    \u0275\u0275element(193, "i", 120);
    \u0275\u0275text(194, " Imprimir Orden ");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(195, "a", 121);
    \u0275\u0275text(196, "Cancelar");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(197, "button", 122);
    \u0275\u0275conditionalCreate(198, AdminRepairFormPage_Conditional_9_Conditional_198_Template, 1, 0, "span", 123);
    \u0275\u0275text(199, " Guardar Reparaci\xF3n ");
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(8);
    \u0275\u0275twoWayProperty("ngModel", ctx_r1.form().customer_name);
    \u0275\u0275advance(7);
    \u0275\u0275twoWayProperty("ngModel", ctx_r1.form().customer_phone);
    \u0275\u0275advance(8);
    \u0275\u0275twoWayProperty("ngModel", ctx_r1.form().device_model);
    \u0275\u0275advance(7);
    \u0275\u0275twoWayProperty("ngModel", ctx_r1.form().imei);
    \u0275\u0275advance(6);
    \u0275\u0275property("disabled", ctx_r1.uploadingImages());
    \u0275\u0275advance();
    \u0275\u0275conditional(ctx_r1.uploadingImages() ? 37 : -1);
    \u0275\u0275advance();
    \u0275\u0275conditional(ctx_r1.form().images.length > 0 ? 38 : -1);
    \u0275\u0275advance(5);
    \u0275\u0275twoWayProperty("ngModel", ctx_r1.form().issue_description);
    \u0275\u0275advance(8);
    \u0275\u0275classProp("bg-primary-content", ctx_r1.form().checklist.charger)("border-primary", ctx_r1.form().checklist.charger)("text-primary", ctx_r1.form().checklist.charger)("bg-gray-100", !ctx_r1.form().checklist.charger)("border-gray-300", !ctx_r1.form().checklist.charger)("text-gray-700", !ctx_r1.form().checklist.charger);
    \u0275\u0275advance();
    \u0275\u0275twoWayProperty("ngModel", ctx_r1.form().checklist.charger);
    \u0275\u0275advance(3);
    \u0275\u0275classProp("bg-primary-content", ctx_r1.form().checklist.battery)("border-primary", ctx_r1.form().checklist.battery)("text-primary", ctx_r1.form().checklist.battery)("bg-gray-100", !ctx_r1.form().checklist.battery)("border-gray-300", !ctx_r1.form().checklist.battery)("text-gray-700", !ctx_r1.form().checklist.battery);
    \u0275\u0275advance();
    \u0275\u0275twoWayProperty("ngModel", ctx_r1.form().checklist.battery);
    \u0275\u0275advance(3);
    \u0275\u0275classProp("bg-primary-content", ctx_r1.form().checklist.chip)("border-primary", ctx_r1.form().checklist.chip)("text-primary", ctx_r1.form().checklist.chip)("bg-gray-100", !ctx_r1.form().checklist.chip)("border-gray-300", !ctx_r1.form().checklist.chip)("text-gray-700", !ctx_r1.form().checklist.chip);
    \u0275\u0275advance();
    \u0275\u0275twoWayProperty("ngModel", ctx_r1.form().checklist.chip);
    \u0275\u0275advance(3);
    \u0275\u0275classProp("bg-primary-content", ctx_r1.form().checklist.sd)("border-primary", ctx_r1.form().checklist.sd)("text-primary", ctx_r1.form().checklist.sd)("bg-gray-100", !ctx_r1.form().checklist.sd)("border-gray-300", !ctx_r1.form().checklist.sd)("text-gray-700", !ctx_r1.form().checklist.sd);
    \u0275\u0275advance();
    \u0275\u0275twoWayProperty("ngModel", ctx_r1.form().checklist.sd);
    \u0275\u0275advance(3);
    \u0275\u0275classProp("bg-primary-content", ctx_r1.form().checklist.case)("border-primary", ctx_r1.form().checklist.case)("text-primary", ctx_r1.form().checklist.case)("bg-gray-100", !ctx_r1.form().checklist.case)("border-gray-300", !ctx_r1.form().checklist.case)("text-gray-700", !ctx_r1.form().checklist.case);
    \u0275\u0275advance();
    \u0275\u0275twoWayProperty("ngModel", ctx_r1.form().checklist.case);
    \u0275\u0275advance(10);
    \u0275\u0275twoWayProperty("ngModel", ctx_r1.form().security_pin);
    \u0275\u0275advance(7);
    \u0275\u0275twoWayProperty("ngModel", ctx_r1.form().security_pattern);
    \u0275\u0275advance(7);
    \u0275\u0275twoWayProperty("ngModel", ctx_r1.form().device_passcode);
    \u0275\u0275advance(26);
    \u0275\u0275repeater(ctx_r1.form().parts);
    \u0275\u0275advance(2);
    \u0275\u0275conditional(ctx_r1.form().parts.length === 0 ? 120 : -1);
    \u0275\u0275advance(8);
    \u0275\u0275twoWayProperty("ngModel", ctx_r1.form().technical_labor_cost);
    \u0275\u0275advance(5);
    \u0275\u0275twoWayProperty("ngModel", ctx_r1.form().current_status_id);
    \u0275\u0275advance();
    \u0275\u0275property("value", 1);
    \u0275\u0275advance(2);
    \u0275\u0275property("value", 2);
    \u0275\u0275advance(2);
    \u0275\u0275property("value", 3);
    \u0275\u0275advance(2);
    \u0275\u0275property("value", 4);
    \u0275\u0275advance(2);
    \u0275\u0275property("value", 5);
    \u0275\u0275advance(2);
    \u0275\u0275property("value", 6);
    \u0275\u0275advance(2);
    \u0275\u0275property("value", 7);
    \u0275\u0275advance(6);
    \u0275\u0275twoWayProperty("ngModel", ctx_r1.form().technical_report);
    \u0275\u0275advance(10);
    \u0275\u0275twoWayProperty("ngModel", ctx_r1.form().estimated_cost);
    \u0275\u0275advance(6);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind4(169, 97, ctx_r1.form().final_cost, "ARS", "symbol", "1.0-0"), " ");
    \u0275\u0275advance(8);
    \u0275\u0275twoWayProperty("ngModel", ctx_r1.form().deposit_amount);
    \u0275\u0275advance(6);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind4(183, 102, ctx_r1.form().final_cost - (ctx_r1.form().deposit_amount || 0), "ARS", "symbol", "1.0-0"), " ");
    \u0275\u0275advance(6);
    \u0275\u0275twoWayProperty("ngModel", ctx_r1.form().technician_notes);
    \u0275\u0275advance();
    \u0275\u0275conditional(ctx_r1.error() ? 189 : -1);
    \u0275\u0275advance(2);
    \u0275\u0275conditional(ctx_r1.id && ctx_r1.form().tracking_code ? 191 : -1);
    \u0275\u0275advance();
    \u0275\u0275property("disabled", ctx_r1.saving());
    \u0275\u0275advance(5);
    \u0275\u0275property("disabled", ctx_r1.saving() || !ctx_r1.form().customer_name || !ctx_r1.form().device_model);
    \u0275\u0275advance();
    \u0275\u0275conditional(ctx_r1.saving() ? 198 : -1);
  }
}
function AdminRepairFormPage_Conditional_10_Conditional_10_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "p", 145);
    \u0275\u0275text(1, "No se encontraron repuestos.");
    \u0275\u0275elementEnd();
  }
}
function AdminRepairFormPage_Conditional_10_For_12_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "img", 150);
  }
  if (rf & 2) {
    const product_r12 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275property("src", product_r12.image_url, \u0275\u0275sanitizeUrl);
  }
}
function AdminRepairFormPage_Conditional_10_For_12_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 151);
    \u0275\u0275element(1, "i", 158);
    \u0275\u0275elementEnd();
  }
}
function AdminRepairFormPage_Conditional_10_For_12_Template(rf, ctx) {
  if (rf & 1) {
    const _r11 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 146)(1, "div", 149);
    \u0275\u0275conditionalCreate(2, AdminRepairFormPage_Conditional_10_For_12_Conditional_2_Template, 1, 1, "img", 150)(3, AdminRepairFormPage_Conditional_10_For_12_Conditional_3_Template, 2, 0, "div", 151);
    \u0275\u0275elementStart(4, "div")(5, "div", 152);
    \u0275\u0275text(6);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(7, "div", 153)(8, "span");
    \u0275\u0275text(9);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(10, "span", 154);
    \u0275\u0275text(11, "|");
    \u0275\u0275elementEnd();
    \u0275\u0275text(12, " Precio: ");
    \u0275\u0275elementStart(13, "span", 155);
    \u0275\u0275text(14);
    \u0275\u0275pipe(15, "currency");
    \u0275\u0275elementEnd()()()();
    \u0275\u0275elementStart(16, "button", 156);
    \u0275\u0275listener("click", function AdminRepairFormPage_Conditional_10_For_12_Template_button_click_16_listener() {
      const product_r12 = \u0275\u0275restoreView(_r11).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      ctx_r1.addPart(product_r12);
      return \u0275\u0275resetView(ctx_r1.showProductModal.set(false));
    });
    \u0275\u0275element(17, "i", 157);
    \u0275\u0275text(18, " A\xF1adir ");
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const product_r12 = ctx.$implicit;
    \u0275\u0275advance(2);
    \u0275\u0275conditional(product_r12.image_url ? 2 : 3);
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate(product_r12.name);
    \u0275\u0275advance(2);
    \u0275\u0275classProp("text-red-500", product_r12.stock === 0)("text-amber-500", product_r12.stock > 0 && product_r12.stock <= 5)("text-green-500", product_r12.stock > 5);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" Stock: ", product_r12.stock, " ");
    \u0275\u0275advance(5);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind4(15, 10, product_r12.price, "ARS", "symbol", "1.0-0"));
  }
}
function AdminRepairFormPage_Conditional_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r10 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 9)(1, "div", 138)(2, "h3", 139);
    \u0275\u0275element(3, "i", 140);
    \u0275\u0275text(4, " Seleccionar Repuesto ");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "div", 141)(6, "label", 60);
    \u0275\u0275element(7, "i", 142);
    \u0275\u0275elementStart(8, "input", 143);
    \u0275\u0275listener("ngModelChange", function AdminRepairFormPage_Conditional_10_Template_input_ngModelChange_8_listener($event) {
      \u0275\u0275restoreView(_r10);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.searchQuery.set($event));
    });
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(9, "div", 144);
    \u0275\u0275conditionalCreate(10, AdminRepairFormPage_Conditional_10_Conditional_10_Template, 2, 0, "p", 145);
    \u0275\u0275repeaterCreate(11, AdminRepairFormPage_Conditional_10_For_12_Template, 19, 15, "div", 146, _forTrack0);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(13, "div", 147)(14, "button", 148);
    \u0275\u0275listener("click", function AdminRepairFormPage_Conditional_10_Template_button_click_14_listener() {
      \u0275\u0275restoreView(_r10);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.showProductModal.set(false));
    });
    \u0275\u0275text(15, "Cerrar");
    \u0275\u0275elementEnd()()()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(8);
    \u0275\u0275property("ngModel", ctx_r1.searchQuery());
    \u0275\u0275advance(2);
    \u0275\u0275conditional(ctx_r1.filteredProducts().length === 0 ? 10 : -1);
    \u0275\u0275advance();
    \u0275\u0275repeater(ctx_r1.filteredProducts());
  }
}
function AdminRepairFormPage_Conditional_16_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "img", 15);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("src", ctx_r1.company().logo_url, \u0275\u0275sanitizeUrl);
  }
}
function AdminRepairFormPage_Conditional_30_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "qrcode", 20);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("qrdata", ctx_r1.getTrackingUrl())("width", 60)("margin", 0)("errorCorrectionLevel", "M");
  }
}
var AdminRepairFormPage = class _AdminRepairFormPage {
  route = inject(ActivatedRoute);
  router = inject(Router);
  companyService = inject(CompanyService);
  repairService = inject(AdminRepairService);
  productService = inject(AdminProductService);
  id = null;
  date = /* @__PURE__ */ new Date();
  // Initial form state matching entity structure
  initialFormState = {
    customer_name: "",
    customer_phone: "",
    device_model: "",
    device_type: "smartphone",
    device_brand: "generic",
    imei: "",
    issue_description: "",
    current_status_id: RepairStatus.PENDING_DIAGNOSIS,
    estimated_cost: 0,
    final_cost: 0,
    technician_notes: "",
    checklist: {
      charger: false,
      battery: false,
      chip: false,
      sd: false,
      case: false
    },
    security_pin: "",
    security_pattern: "",
    device_passcode: "",
    // New field
    deposit_amount: 0,
    tracking_code: "",
    repair_number: 0,
    images: [],
    technical_labor_cost: 0,
    // New field
    technical_report: "",
    // New field
    parts: []
    // New field for RepairPart
  };
  form = signal(__spreadValues({}, this.initialFormState), ...ngDevMode ? [{ debugName: "form" }] : []);
  availableProducts = signal([], ...ngDevMode ? [{ debugName: "availableProducts" }] : []);
  // To select parts from
  searchQuery = signal("", ...ngDevMode ? [{ debugName: "searchQuery" }] : []);
  filteredProducts = computed(() => {
    const query = this.searchQuery().toLowerCase().trim();
    const products = this.availableProducts();
    if (!query)
      return products;
    return products.filter((p) => p.name.toLowerCase().includes(query));
  }, ...ngDevMode ? [{ debugName: "filteredProducts" }] : []);
  showProductModal = signal(false, ...ngDevMode ? [{ debugName: "showProductModal" }] : []);
  async ngOnInit() {
    this.id = this.route.snapshot.paramMap.get("id");
    await this.loadCompanySettings();
    await this.loadProducts();
    if (this.id) {
      await this.loadRepair();
    }
    this.loading.set(false);
  }
  loading = signal(true, ...ngDevMode ? [{ debugName: "loading" }] : []);
  saving = signal(false, ...ngDevMode ? [{ debugName: "saving" }] : []);
  error = signal(null, ...ngDevMode ? [{ debugName: "error" }] : []);
  company = signal(null, ...ngDevMode ? [{ debugName: "company" }] : []);
  uploadingImages = signal(false, ...ngDevMode ? [{ debugName: "uploadingImages" }] : []);
  async loadProducts() {
    try {
      const products = await this.productService.getProducts();
      this.availableProducts.set(products);
      this.showProductModal.set(true);
    } catch (e2) {
      console.error("Error loading products:", e2);
      this.error.set("Error al cargar repuestos sugeridos");
    }
  }
  async onFileSelected(event) {
    const input = event.target;
    const files = input.files;
    if (!files || files.length === 0)
      return;
    this.uploadingImages.set(true);
    const uploadedUrls = [];
    try {
      for (let i = 0; i < files.length; i++) {
        const file = files.item(i);
        if (file) {
          const url = await this.repairService.uploadImage(file);
          uploadedUrls.push(url);
        }
      }
      this.form.update((f2) => __spreadProps(__spreadValues({}, f2), {
        images: [...f2.images, ...uploadedUrls]
      }));
    } catch (e2) {
      console.error("Error uploading images:", e2);
      const message = e2 instanceof Error ? e2.message : "Unknown error";
      this.error.set("Error al subir im\xE1genes: " + message);
    } finally {
      this.uploadingImages.set(false);
      input.value = "";
    }
  }
  removeImage(index) {
    this.form.update((f2) => {
      const newImages = [...f2.images];
      newImages.splice(index, 1);
      return __spreadProps(__spreadValues({}, f2), { images: newImages });
    });
  }
  async loadCompanySettings() {
    try {
      const data = await this.companyService.getSettings();
      if (data) {
        this.company.set(data);
      }
    } catch (error) {
      console.error("Error loading company settings", error);
    }
  }
  addPart(product) {
    this.form.update((f2) => {
      const parts = [...f2.parts];
      parts.push({
        product_id: product.id,
        name: product.name,
        // For UI display
        quantity: 1,
        unit_price_at_time: product.price,
        cost_at_time: product.cost || 0
        // Assuming product has cost
      });
      return __spreadProps(__spreadValues({}, f2), { parts });
    });
    this.calculateFinalCost();
  }
  removePart(index) {
    this.form.update((f2) => {
      const parts = [...f2.parts];
      parts.splice(index, 1);
      return __spreadProps(__spreadValues({}, f2), { parts });
    });
    this.calculateFinalCost();
  }
  calculateFinalCost() {
    this.form.update((f2) => {
      const partsTotal = f2.parts.reduce((acc, p) => acc + p.unit_price_at_time * p.quantity, 0);
      return __spreadProps(__spreadValues({}, f2), {
        final_cost: (f2.technical_labor_cost || 0) + partsTotal
      });
    });
  }
  async loadRepair() {
    if (!this.id)
      return;
    try {
      const data = await this.repairService.getById(this.id);
      if (data) {
        this.form.set({
          customer_name: data.customer_name || "",
          customer_phone: data.customer_phone || "",
          device_model: data.device_model || "",
          device_type: data.device_type || "smartphone",
          device_brand: data.device_brand || "generic",
          imei: data.imei || "",
          issue_description: data.issue_description || "",
          current_status_id: data.current_status_id,
          estimated_cost: data.estimated_cost || 0,
          final_cost: data.final_cost || 0,
          technician_notes: data.technician_notes || "",
          checklist: data.checklist || this.initialFormState.checklist,
          security_pin: data.security_pin || "",
          security_pattern: data.security_pattern || "",
          device_passcode: data.device_passcode || "",
          deposit_amount: data.deposit_amount || 0,
          tracking_code: data.tracking_code,
          repair_number: data.repair_number || 0,
          images: data.images || [],
          technical_labor_cost: data.technical_labor_cost || 0,
          technical_report: data.technical_report || "",
          parts: data.parts || []
        });
      }
    } catch (e2) {
      const message = e2 instanceof Error ? e2.message : "Unknown error";
      this.error.set("Error cargando reparaci\xF3n: " + message);
    }
  }
  async save() {
    this.saving.set(true);
    this.error.set(null);
    try {
      const formData = this.form();
      const payload = __spreadProps(__spreadValues({}, formData), {
        parts: formData.parts.map((p) => ({
          product_id: p.product_id,
          quantity: p.quantity,
          unit_price_at_time: p.unit_price_at_time,
          cost_at_time: p.cost_at_time
        }))
      });
      if (this.id) {
        await this.repairService.update(this.id, payload);
      } else {
        await this.repairService.create(payload);
      }
      this.router.navigate(["/admin/repairs"]);
    } catch (e2) {
      console.error("Error saving repair:", e2);
      const message = e2.message || e2.error_description || (e2 instanceof Error ? e2.message : "Unknown error");
      this.error.set(message);
    } finally {
      this.saving.set(false);
    }
  }
  printOrder() {
    const doc = new import_jspdf.jsPDF({
      orientation: "portrait",
      unit: "mm",
      format: "a4"
    });
    const formData = this.form();
    const companyData = this.company();
    const primaryColor = companyData?.branding_settings?.primary_color || "#16a34a";
    const hexToRgb = (hex) => {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? [
        parseInt(result[1], 16),
        parseInt(result[2], 16),
        parseInt(result[3], 16)
      ] : [22, 163, 74];
    };
    const colorArray = hexToRgb(primaryColor);
    doc.setFillColor(243, 244, 246);
    doc.rect(0, 0, 210, 45, "F");
    doc.setFontSize(24);
    doc.setTextColor(colorArray[0], colorArray[1], colorArray[2]);
    doc.text(companyData?.name || "Arecofix", 15, 20);
    doc.setTextColor(55, 65, 81);
    doc.setFontSize(10);
    doc.text(companyData?.address || "Direcci\xF3n de la Sucursal", 15, 28);
    doc.text(`Tel: ${companyData?.phone || "Sin Tel\xE9fono"}`, 15, 34);
    doc.setFontSize(16);
    doc.setTextColor(0, 0, 0);
    doc.text(`ORDEN T\xC9CNICA # ${formData.repair_number || "S/N"}`, 120, 20);
    doc.setFontSize(10);
    doc.text(`Fecha: ${(/* @__PURE__ */ new Date()).toLocaleDateString()}`, 120, 28);
    doc.text(`C\xF3digo de Seguimiento:`, 120, 34);
    doc.setFontSize(11);
    doc.setTextColor(colorArray[0], colorArray[1], colorArray[2]);
    doc.text(`${formData.tracking_code || "---"}`, 162, 34);
    doc.setTextColor(0, 0, 0);
    doc.setFontSize(12);
    doc.text("Datos del Cliente", 15, 55);
    doc.line(15, 57, 95, 57);
    doc.setFontSize(10);
    doc.text(`Nombre: ${formData.customer_name}`, 15, 65);
    doc.text(`Tel\xE9fono: ${formData.customer_phone || "No registrado"}`, 15, 72);
    doc.setFontSize(12);
    doc.text("Detalles del Equipo", 110, 55);
    doc.line(110, 57, 195, 57);
    doc.setFontSize(10);
    doc.text(`Modelo: ${formData.device_model}`, 110, 65);
    doc.text(`IMEI/Serie: ${formData.imei || "Sin declarar"}`, 110, 72);
    doc.text(`Tipo/Marca: ${formData.device_type} / ${formData.device_brand}`, 110, 79);
    doc.setDrawColor(200, 200, 200);
    doc.setFillColor(249, 250, 251);
    doc.roundedRect(15, 87, 180, 25, 3, 3, "FD");
    doc.text(`Seguridad - PIN: ${formData.security_pin || "Ninguno"} | Patr\xF3n: ${formData.security_pattern || "Ninguno"} | Passcode: ${formData.device_passcode || "No"}`, 20, 95);
    const chk = formData.checklist;
    doc.text(`Accesorios: [${chk.charger ? "X" : " "}] Cargador  [${chk.battery ? "X" : " "}] Bater\xEDa  [${chk.chip ? "X" : " "}] Chip  [${chk.sd ? "X" : " "}] SD  [${chk.case ? "X" : " "}] Funda`, 20, 105);
    doc.setFontSize(12);
    doc.text("Motivo de Ingreso / Falla Reportada", 15, 122);
    doc.setFontSize(10);
    const splitDescription = doc.splitTextToSize(formData.issue_description || "Sin detalles.", 180);
    doc.text(splitDescription, 15, 130);
    const defaultTableY = splitDescription.length * 5 + 135;
    const tableData = formData.parts.map((p) => [
      p.name,
      p.quantity.toString(),
      `$ ${p.unit_price_at_time.toLocaleString("es-AR")}`,
      `$ ${(p.unit_price_at_time * p.quantity).toLocaleString("es-AR")}`
    ]);
    if (formData.technical_labor_cost > 0) {
      tableData.push(["Mano de Obra T\xE9cnica", "1", `$ ${formData.technical_labor_cost.toLocaleString("es-AR")}`, `$ ${formData.technical_labor_cost.toLocaleString("es-AR")}`]);
    }
    if (tableData.length > 0) {
      autoTable(doc, {
        startY: defaultTableY,
        head: [["Detalle", "Cant", "Precio Unitario", "Subtotal"]],
        body: tableData,
        theme: "striped",
        headStyles: { fillColor: colorArray },
        margin: { left: 15, right: 15 }
      });
    }
    const finalY = doc.lastAutoTable ? doc.lastAutoTable.finalY : defaultTableY + 10;
    doc.setFontSize(11);
    doc.text(`Presupuesto Inicial Estimado: $ ${formData.estimated_cost?.toLocaleString("es-AR") || "0"}`, 110, finalY + 10);
    doc.text(`Se\xF1a / Adelanto Pagado: $ ${formData.deposit_amount?.toLocaleString("es-AR") || "0"}`, 110, finalY + 17);
    doc.setFontSize(14);
    doc.setFont("helvetica", "bold");
    doc.text(`RESTANTE A ABONAR: $ ${(formData.final_cost - (formData.deposit_amount || 0)).toLocaleString("es-AR")}`, 110, finalY + 27);
    doc.setFontSize(10);
    doc.setFont("helvetica", "normal");
    doc.line(25, finalY + 50, 85, finalY + 50);
    doc.text("Firma y Aclaraci\xF3n Cliente", 33, finalY + 56);
    doc.line(125, finalY + 50, 185, finalY + 50);
    doc.text("Firma T\xE9cnico / Local", 135, finalY + 56);
    doc.setFontSize(7);
    doc.setTextColor(100, 100, 100);
    const terminos = "T\xE9rminos y Condiciones: Pasados los 30 d\xEDas de notificada la reparaci\xF3n, la empresa cobrar\xE1 resguardo diario. Pasados los 90 d\xEDas el equipo se considerar\xE1 abandonado perdiendo el cliente todo derecho a reclamo y pasando a ser propiedad del local para cubrir costos. Todo presupuesto no aceptado tiene cargo de revisi\xF3n t\xE9cnica. NO SE ENTREGAN EQUIPOS SIN ESTA ORDEN.";
    doc.text(doc.splitTextToSize(terminos, 180), 15, 275);
    doc.setFontSize(9);
    doc.text(`Sigue el estado de tu equipo online en: ${window.location.origin}/#/tracking/${formData.tracking_code}`, 15, 290);
    doc.save(`Arecofix_Orden_${formData.repair_number || "S-N"}_${formData.customer_name.replace(" ", "_")}.pdf`);
  }
  shareWhatsApp() {
    if (!this.form().tracking_code)
      return;
    const customerName = this.form().customer_name;
    const device = this.form().device_model;
    const url = this.getTrackingUrl();
    let message = `Hola ${customerName}, tu ${device} est\xE1 en reparaci\xF3n. Pod\xE9s seguir el estado en tiempo real aqu\xED: ${url}`;
    if (this.form().current_status_id === RepairStatus.READY_FOR_PICKUP) {
      const reviewLink = environment.contact.socialMedia.googleMaps;
      message = `Hola ${customerName}, su reparaci\xF3n del ${device} ya est\xE1 lista. Agradecemos su rese\xF1a en el siguiente enlace: ${reviewLink}`;
    }
    const whatsappUrl = `https://wa.me/${this.form().customer_phone}?text=${encodeURIComponent(message)}`;
    window.open(whatsappUrl, "_blank");
  }
  getTrackingUrl() {
    if (!this.form().tracking_code)
      return "";
    return `${window.location.origin}/#/tracking/${this.form().tracking_code}`;
  }
  static \u0275fac = function AdminRepairFormPage_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AdminRepairFormPage)();
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _AdminRepairFormPage, selectors: [["app-admin-repair-form-page"]], decls: 167, vars: 44, consts: [[1, "container", "mx-auto", "p-4", "max-w-5xl", "no-print"], [1, "flex", "justify-between", "items-center", "mb-6"], [1, "text-2xl", "font-bold", "text-green-600"], ["routerLink", "/admin/repairs", 1, "btn", "btn-circle", "btn-ghost", "text-base-content"], [1, "fas", "fa-arrow-left"], [1, "card", "bg-base-100", "shadow-lg"], [1, "card-body", "p-6"], [1, "flex", "justify-center", "py-12"], [1, "space-y-6"], [1, "modal", "modal-open"], [1, "print-container", "font-sans", "text-xs", "leading-tight", "hidden"], [1, "flex", "flex-col", "h-full"], [1, "w-full", "pb-4", "border-b-2", "border-dashed", "border-gray-400", "mb-4", "flex", "flex-col"], [1, "flex", "justify-between", "items-start", "mb-2", "border-b", "border-gray-300", "pb-2"], [1, "flex", "items-center"], ["alt", "Logo", 1, "h-10", "w-auto", "mr-3", "object-contain", 3, "src"], [1, "text-lg", "font-bold", "uppercase", "mb-0"], [1, "text-[9px]", "text-gray-600"], [1, "text-right", "flex", "items-center", "gap-2"], [1, "flex", "flex-col", "items-center"], [3, "qrdata", "width", "margin", "errorCorrectionLevel"], [1, "text-right"], [1, "font-bold", "text-base", "text-green-700", "uppercase"], [1, "text-[9px]", "text-gray-600", "leading-tight"], [1, "grid", "grid-cols-2", "gap-3", "mb-2", "grow"], [1, "flex", "flex-col", "gap-2"], [1, "border", "border-gray-300", "rounded", "p-1"], [1, "font-bold", "bg-gray-100", "px-1", "text-[9px]", "mb-0.5"], [1, "px-1", "text-[9px]"], [1, "flex", "justify-between"], [1, "font-bold"], [1, "truncate", "ml-1"], [1, "border-t", "border-gray-200", "my-0.5"], [1, "mt-1", "pt-1", "border-t", "border-gray-200"], [1, "grid", "grid-cols-3", "gap-0.5", "text-[8px]"], [1, "flex", "justify-between", "border-t", "border-gray-300", "pt-0.5", "mt-0.5", "font-bold"], [1, "border", "border-gray-300", "rounded", "p-1", "grow"], [1, "px-1", "text-[9px]", "h-full", "overflow-hidden", "leading-tight"], [1, "mt-auto"], [1, "flex", "justify-between", "items-end", "text-[9px]"], [1, "w-5/12", "text-center", "border-t", "border-black", "pt-1"], [1, "w-full", "pt-2", "flex", "flex-col", "justify-between"], [1, "grid", "grid-cols-2", "gap-4"], [1, "text-center", "mb-3"], [1, "font-bold", "text-xs", "uppercase", "border-b", "border-black", "pb-1", "mb-1"], [1, "text-[10px]", "font-bold", "truncate"], [1, "mb-3"], [1, "text-sm", "font-bold", "mb-0.5", "text-center", "border", "border-gray-300", "rounded", "bg-gray-50"], [1, "text-[9px]", "text-center", "text-gray-600"], [1, "space-y-2"], [1, "text-[9px]"], [1, "mt-2", "pt-2", "border-t", "border-gray-300"], [1, "text-[8px]", "text-gray-500", "text-justify", "leading-tight", "mb-2"], [1, "text-center", "font-bold", "text-[10px]"], [1, "loading", "loading-spinner", "loading-lg", "text-primary"], [1, "space-y-6", 3, "ngSubmit"], [1, "grid", "grid-cols-1", "md:grid-cols-2", "gap-6"], [1, "form-control"], [1, "label"], [1, "label-text", "font-medium"], [1, "input", "input-bordered", "flex", "items-center", "gap-2"], [1, "fas", "fa-user", "text-gray-400"], ["type", "text", "name", "customer_name", "required", "", 1, "grow", 3, "ngModelChange", "ngModel"], [1, "fas", "fa-phone", "text-gray-400"], ["type", "tel", "name", "customer_phone", 1, "grow", 3, "ngModelChange", "ngModel"], [1, "fas", "fa-mobile-alt", "text-gray-400"], ["type", "text", "name", "device_model", "required", "", "placeholder", "Ej: iPhone 11, Samsung A52...", 1, "grow", 3, "ngModelChange", "ngModel"], [1, "fas", "fa-barcode", "text-gray-400"], ["type", "text", "name", "imei", "placeholder", "Opcional", 1, "grow", 3, "ngModelChange", "ngModel"], [1, "flex", "flex-col", "gap-4"], ["type", "file", "multiple", "", "accept", "image/*", 1, "file-input", "file-input-bordered", "w-full", 3, "change", "disabled"], [1, "flex", "items-center", "gap-2", "text-sm", "text-gray-500"], [1, "grid", "grid-cols-2", "md:grid-cols-4", "gap-4"], ["name", "issue_description", "placeholder", "Describe la falla reportada por el cliente...", 1, "textarea", "textarea-bordered", "h-24", "leading-relaxed", 3, "ngModelChange", "ngModel"], [1, "divider", "text-sm", "font-medium", "text-gray-500"], [1, "flex", "flex-wrap", "gap-3"], [1, "cursor-pointer", "select-none", "transition-all", "duration-200", "border", "rounded-lg", "px-4", "py-2", "flex", "items-center", "gap-3", "hover:bg-gray-200"], ["type", "checkbox", "name", "check_charger", 1, "checkbox", "checkbox-primary", "checkbox-sm", 3, "ngModelChange", "ngModel"], [1, "font-medium"], ["type", "checkbox", "name", "check_battery", 1, "checkbox", "checkbox-primary", "checkbox-sm", 3, "ngModelChange", "ngModel"], ["type", "checkbox", "name", "check_chip", 1, "checkbox", "checkbox-primary", "checkbox-sm", 3, "ngModelChange", "ngModel"], ["type", "checkbox", "name", "check_sd", 1, "checkbox", "checkbox-primary", "checkbox-sm", 3, "ngModelChange", "ngModel"], ["type", "checkbox", "name", "check_case", 1, "checkbox", "checkbox-primary", "checkbox-sm", 3, "ngModelChange", "ngModel"], [1, "grid", "grid-cols-1", "md:grid-cols-3", "gap-6"], [1, "fas", "fa-lock", "text-gray-400"], ["type", "text", "name", "security_pin", "placeholder", "1234", 1, "grow", 3, "ngModelChange", "ngModel"], [1, "fas", "fa-draw-polygon", "text-gray-400"], ["type", "text", "name", "security_pattern", "placeholder", "Ej: Z, L, etc", 1, "grow", 3, "ngModelChange", "ngModel"], [1, "fas", "fa-key", "text-gray-400"], ["type", "text", "name", "device_passcode", "placeholder", "Contrase\xF1a de pantalla", 1, "grow", 3, "ngModelChange", "ngModel"], [1, "form-control", "bg-neutral-50", "p-6", "rounded-2xl", "border", "border-neutral-100"], [1, "flex", "justify-between", "items-center", "mb-4"], [1, "font-bold", "text-neutral-800", "flex", "items-center", "gap-2"], [1, "fas", "fa-box-open", "text-primary"], [1, "flex", "gap-2"], ["type", "button", 1, "btn", "btn-sm", "btn-outline", "btn-primary", "rounded-xl", 3, "click"], [1, "fas", "fa-plus"], [1, "overflow-x-auto"], [1, "table", "table-sm"], [1, "bg-white/50", "text-neutral-400"], [1, "text-center"], [1, "fas", "fa-tools", "text-gray-400"], ["type", "number", "name", "technical_labor_cost", "min", "0", 1, "grow", 3, "ngModelChange", "change", "ngModel"], ["name", "current_status_id", 1, "select", "select-bordered", "w-full", 3, "ngModelChange", "ngModel"], [3, "value"], [1, "label-text", "font-bold", "text-primary", "italic"], ["name", "technical_report", "placeholder", "Escribe el informe que ver\xE1 el cliente en la web...", 1, "textarea", "textarea-bordered", "h-24", "leading-relaxed", "font-mono", "text-xs", 3, "ngModelChange", "ngModel"], [1, "grid", "grid-cols-1", "md:grid-cols-2", "lg:grid-cols-4", "gap-6"], [1, "fas", "fa-calculator", "text-gray-400"], ["type", "number", "name", "estimated_cost", "min", "0", 1, "grow", 3, "ngModelChange", "ngModel"], [1, "text-3xl", "font-black", "text-neutral-800", "tracking-tighter"], [1, "fas", "fa-hand-holding-usd", "text-gray-400"], ["type", "number", "name", "deposit_amount", "min", "0", 1, "grow", 3, "ngModelChange", "ngModel"], [1, "label-text", "font-bold", "text-green-600"], [1, "text-3xl", "font-black", "text-green-600", "tracking-tighter"], ["name", "technician_notes", "placeholder", "Detalles de la reparaci\xF3n realizada...", 1, "textarea", "textarea-bordered", "h-24", "leading-relaxed", 3, "ngModelChange", "ngModel"], [1, "alert", "alert-error", "mb-6", "shadow-sm"], [1, "flex", "flex-col", "sm:flex-row", "justify-end", "gap-4", "pt-6", "border-t", "border-base-200"], ["type", "button", 1, "btn", "bg-green-600", "hover:bg-green-700", "text-white", "border-none", "w-full", "sm:w-auto"], ["type", "button", 1, "btn", "btn-outline", "w-full", "sm:w-auto", 3, "click", "disabled"], [1, "fas", "fa-print", "mr-2"], ["routerLink", "/admin/repairs", 1, "btn", "btn-error", "text-white", "w-full", "sm:w-auto"], ["type", "submit", 1, "btn", "btn-primary", "w-full", "sm:w-auto", 3, "disabled"], [1, "loading", "loading-spinner", "loading-xs"], [1, "relative", "group", "aspect-square", "bg-base-200", "rounded-lg", "overflow-hidden", "border", "border-base-300"], ["alt", "Repair image", 1, "w-full", "h-full", "object-cover", 3, "src"], ["type", "button", 1, "absolute", "top-1", "right-1", "btn", "btn-circle", "btn-xs", "btn-error", "opacity-0", "group-hover:opacity-100", "transition-opacity", 3, "click"], [1, "fas", "fa-times"], [1, "font-bold", "text-neutral-700"], ["type", "number", 1, "input", "input-xs", "input-bordered", "w-16", "text-center", 3, "ngModelChange", "change", "ngModel", "name"], [1, "text-right", "font-mono", "text-primary", "font-bold"], [1, "text-right", "font-mono", "text-neutral-400", "text-[10px]"], ["type", "button", 1, "btn", "btn-ghost", "btn-xs", "text-rose-500", 3, "click"], [1, "fas", "fa-trash"], ["colspan", "5", 1, "text-center", "py-4", "text-xs", "italic", "text-neutral-400"], [1, "fas", "fa-exclamation-circle"], ["type", "button", 1, "btn", "bg-green-600", "hover:bg-green-700", "text-white", "border-none", "w-full", "sm:w-auto", 3, "click"], [1, "fab", "fa-whatsapp", "mr-2"], [1, "modal-box", "w-11/12", "max-w-2xl", "bg-white", "shadow-2xl", "rounded-2xl", "p-6"], [1, "font-bold", "text-lg", "mb-4", "text-green-700", "flex", "items-center", "gap-2"], [1, "fas", "fa-box"], [1, "form-control", "mb-4"], [1, "fas", "fa-search", "text-gray-400"], ["type", "text", "name", "searchQuery", "placeholder", "Buscar repuesto por nombre...", 1, "grow", 3, "ngModelChange", "ngModel"], [1, "max-h-96", "overflow-y-auto", "pr-2"], [1, "text-sm", "text-gray-500", "text-center", "py-6", "italic"], [1, "flex", "justify-between", "items-center", "py-3", "border-b", "border-gray-100", "hover:bg-gray-50", "transition-colors", "px-2", "rounded-lg"], [1, "modal-action", "mt-6", "pt-4", "border-t", "border-gray-100"], ["type", "button", 1, "btn", "rounded-xl", 3, "click"], [1, "flex", "items-center", "gap-3"], ["alt", "", 1, "w-10", "h-10", "object-cover", "rounded-md", "border", "border-gray-200", 3, "src"], [1, "w-10", "h-10", "bg-gray-100", "rounded-md", "border", "border-gray-200", "flex", "items-center", "justify-center", "text-gray-400"], [1, "font-bold", "text-gray-800"], [1, "text-xs", "text-gray-500"], [1, "mx-2"], [1, "font-medium", "text-primary"], ["type", "button", 1, "btn", "btn-sm", "btn-primary", "rounded-xl", 3, "click"], [1, "fas", "fa-plus", "mr-1"], [1, "fas", "fa-image"]], template: function AdminRepairFormPage_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div", 0)(1, "div", 1)(2, "h1", 2);
      \u0275\u0275text(3);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(4, "a", 3);
      \u0275\u0275element(5, "i", 4);
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(6, "div", 5)(7, "div", 6);
      \u0275\u0275conditionalCreate(8, AdminRepairFormPage_Conditional_8_Template, 2, 0, "div", 7)(9, AdminRepairFormPage_Conditional_9_Template, 200, 107, "form", 8);
      \u0275\u0275elementEnd()()();
      \u0275\u0275conditionalCreate(10, AdminRepairFormPage_Conditional_10_Template, 16, 2, "div", 9);
      \u0275\u0275elementStart(11, "div", 10)(12, "div", 11)(13, "div", 12)(14, "div", 13)(15, "div", 14);
      \u0275\u0275conditionalCreate(16, AdminRepairFormPage_Conditional_16_Template, 1, 1, "img", 15);
      \u0275\u0275elementStart(17, "div")(18, "h1", 16);
      \u0275\u0275text(19);
      \u0275\u0275pipe(20, "number");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(21, "div", 17)(22, "span");
      \u0275\u0275text(23);
      \u0275\u0275pipe(24, "date");
      \u0275\u0275elementEnd();
      \u0275\u0275text(25, " | ");
      \u0275\u0275elementStart(26, "span");
      \u0275\u0275text(27);
      \u0275\u0275elementEnd()()()();
      \u0275\u0275elementStart(28, "div", 18)(29, "div", 19);
      \u0275\u0275conditionalCreate(30, AdminRepairFormPage_Conditional_30_Template, 1, 4, "qrcode", 20);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(31, "div", 21)(32, "h2", 22);
      \u0275\u0275text(33);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(34, "div", 23)(35, "p");
      \u0275\u0275text(36);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(37, "p");
      \u0275\u0275text(38);
      \u0275\u0275elementEnd()()()()();
      \u0275\u0275elementStart(39, "div", 24)(40, "div", 25)(41, "div", 26)(42, "h3", 27);
      \u0275\u0275text(43, "CLIENTE & EQUIPO");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(44, "div", 28)(45, "div", 29)(46, "span", 30);
      \u0275\u0275text(47, "Nombre:");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(48, "span", 31);
      \u0275\u0275text(49);
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(50, "div", 29)(51, "span", 30);
      \u0275\u0275text(52, "Tel:");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(53, "span", 31);
      \u0275\u0275text(54);
      \u0275\u0275elementEnd()();
      \u0275\u0275element(55, "div", 32);
      \u0275\u0275elementStart(56, "div", 29)(57, "span", 30);
      \u0275\u0275text(58, "Modelo:");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(59, "span", 31);
      \u0275\u0275text(60);
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(61, "div", 29)(62, "span", 30);
      \u0275\u0275text(63, "IMEI:");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(64, "span", 31);
      \u0275\u0275text(65);
      \u0275\u0275elementEnd()()()();
      \u0275\u0275elementStart(66, "div", 26)(67, "h3", 27);
      \u0275\u0275text(68, "SEGURIDAD");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(69, "div", 28)(70, "div", 29)(71, "span", 30);
      \u0275\u0275text(72, "PIN:");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(73, "span");
      \u0275\u0275text(74);
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(75, "div", 29)(76, "span", 30);
      \u0275\u0275text(77, "Patr\xF3n:");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(78, "span");
      \u0275\u0275text(79);
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(80, "div", 33)(81, "div", 34)(82, "span");
      \u0275\u0275text(83);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(84, "span");
      \u0275\u0275text(85);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(86, "span");
      \u0275\u0275text(87);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(88, "span");
      \u0275\u0275text(89);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(90, "span");
      \u0275\u0275text(91);
      \u0275\u0275elementEnd()()()()()();
      \u0275\u0275elementStart(92, "div", 25)(93, "div", 26)(94, "h3", 27);
      \u0275\u0275text(95, "PRECIOS");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(96, "div", 28)(97, "div", 29)(98, "span", 30);
      \u0275\u0275text(99, "Presupuesto:");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(100, "span");
      \u0275\u0275text(101);
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(102, "div", 29)(103, "span", 30);
      \u0275\u0275text(104, "Se\xF1a:");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(105, "span");
      \u0275\u0275text(106);
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(107, "div", 35)(108, "span");
      \u0275\u0275text(109, "Total:");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(110, "span");
      \u0275\u0275text(111);
      \u0275\u0275elementEnd()()()();
      \u0275\u0275elementStart(112, "div", 36)(113, "h3", 27);
      \u0275\u0275text(114, "FALLA / NOTAS");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(115, "div", 37);
      \u0275\u0275text(116);
      \u0275\u0275elementEnd()()()();
      \u0275\u0275element(117, "hr")(118, "br");
      \u0275\u0275elementStart(119, "div", 38)(120, "div", 39)(121, "div", 40);
      \u0275\u0275text(122, "FIRMA CLIENTE");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(123, "div", 40);
      \u0275\u0275text(124, "FIRMA T\xC9CNICO");
      \u0275\u0275elementEnd()()()();
      \u0275\u0275elementStart(125, "div", 41)(126, "div", 42)(127, "div")(128, "div", 43)(129, "h2", 44);
      \u0275\u0275text(130, "TAL\xD3N DE RETIRO");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(131, "div", 45);
      \u0275\u0275text(132);
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(133, "div", 46)(134, "div", 47);
      \u0275\u0275text(135);
      \u0275\u0275pipe(136, "number");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(137, "div", 48);
      \u0275\u0275text(138);
      \u0275\u0275pipe(139, "date");
      \u0275\u0275elementEnd()()();
      \u0275\u0275elementStart(140, "div", 49)(141, "div", 26)(142, "div", 50)(143, "div", 29)(144, "span", 30);
      \u0275\u0275text(145, "Cliente:");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(146, "span", 31);
      \u0275\u0275text(147);
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(148, "div", 29)(149, "span", 30);
      \u0275\u0275text(150, "Equipo:");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(151, "span", 31);
      \u0275\u0275text(152);
      \u0275\u0275elementEnd()()()();
      \u0275\u0275elementStart(153, "div", 26)(154, "div", 50)(155, "div", 29)(156, "span", 30);
      \u0275\u0275text(157, "Presupuesto:");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(158, "span");
      \u0275\u0275text(159);
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(160, "div", 29);
      \u0275\u0275element(161, "span", 30);
      \u0275\u0275elementEnd()()()()();
      \u0275\u0275elementStart(162, "div", 51)(163, "div", 52);
      \u0275\u0275text(164, " CONDICIONES: La empresa no se responsabiliza por la p\xE9rdida de informaci\xF3n. Pasados los 90 d\xEDas el equipo se considerar\xE1 abandonado. La garant\xEDa cubre \xFAnicamente la reparaci\xF3n realizada y por un plazo de 30 d\xEDas. No cubre da\xF1os por mal uso, golpes o humedad. ");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(165, "div", 53);
      \u0275\u0275text(166, " Este tal\xF3n deber\xE1 ser presentado indefectiblemente para retirar el equipo. ");
      \u0275\u0275elementEnd()()()()();
    }
    if (rf & 2) {
      let tmp_3_0;
      let tmp_8_0;
      let tmp_9_0;
      let tmp_10_0;
      let tmp_26_0;
      \u0275\u0275advance(3);
      \u0275\u0275textInterpolate(ctx.id ? "Editar Reparaci\xF3n" : "Nueva Reparaci\xF3n");
      \u0275\u0275advance(5);
      \u0275\u0275conditional(ctx.loading() ? 8 : 9);
      \u0275\u0275advance(2);
      \u0275\u0275conditional(ctx.showProductModal() ? 10 : -1);
      \u0275\u0275advance(6);
      \u0275\u0275conditional(((tmp_3_0 = ctx.company()) == null ? null : tmp_3_0.logo_url) ? 16 : -1);
      \u0275\u0275advance(3);
      \u0275\u0275textInterpolate1("Orden #", \u0275\u0275pipeBind2(20, 32, ctx.form().repair_number, "3.0-0") || "---");
      \u0275\u0275advance(4);
      \u0275\u0275textInterpolate(\u0275\u0275pipeBind2(24, 35, ctx.date, "dd/MM/yyyy"));
      \u0275\u0275advance(4);
      \u0275\u0275textInterpolate1("ID: ", ctx.form().tracking_code);
      \u0275\u0275advance(3);
      \u0275\u0275conditional(ctx.form().tracking_code ? 30 : -1);
      \u0275\u0275advance(3);
      \u0275\u0275textInterpolate(((tmp_8_0 = ctx.company()) == null ? null : tmp_8_0.name) || "ARECOFIX");
      \u0275\u0275advance(3);
      \u0275\u0275textInterpolate((tmp_9_0 = ctx.company()) == null ? null : tmp_9_0.address);
      \u0275\u0275advance(2);
      \u0275\u0275textInterpolate((tmp_10_0 = ctx.company()) == null ? null : tmp_10_0.phone);
      \u0275\u0275advance(11);
      \u0275\u0275textInterpolate(ctx.form().customer_name);
      \u0275\u0275advance(5);
      \u0275\u0275textInterpolate(ctx.form().customer_phone);
      \u0275\u0275advance(6);
      \u0275\u0275textInterpolate(ctx.form().device_model);
      \u0275\u0275advance(5);
      \u0275\u0275textInterpolate(ctx.form().imei);
      \u0275\u0275advance(9);
      \u0275\u0275textInterpolate(ctx.form().security_pin);
      \u0275\u0275advance(5);
      \u0275\u0275textInterpolate(ctx.form().security_pattern);
      \u0275\u0275advance(4);
      \u0275\u0275textInterpolate1("[", ctx.form().checklist.charger ? "X" : " ", "] Carg");
      \u0275\u0275advance(2);
      \u0275\u0275textInterpolate1("[", ctx.form().checklist.battery ? "X" : " ", "] Bat");
      \u0275\u0275advance(2);
      \u0275\u0275textInterpolate1("[", ctx.form().checklist.chip ? "X" : " ", "] Chip");
      \u0275\u0275advance(2);
      \u0275\u0275textInterpolate1("[", ctx.form().checklist.sd ? "X" : " ", "] SD");
      \u0275\u0275advance(2);
      \u0275\u0275textInterpolate1("[", ctx.form().checklist.case ? "X" : " ", "] Funda");
      \u0275\u0275advance(10);
      \u0275\u0275textInterpolate1("$ ", ctx.form().estimated_cost);
      \u0275\u0275advance(5);
      \u0275\u0275textInterpolate1("$ ", ctx.form().deposit_amount);
      \u0275\u0275advance(5);
      \u0275\u0275textInterpolate1("$ ", ctx.form().final_cost || ctx.form().estimated_cost);
      \u0275\u0275advance(5);
      \u0275\u0275textInterpolate1(" ", ctx.form().issue_description, " ");
      \u0275\u0275advance(16);
      \u0275\u0275textInterpolate(((tmp_26_0 = ctx.company()) == null ? null : tmp_26_0.name) || "ARECOFIX");
      \u0275\u0275advance(3);
      \u0275\u0275textInterpolate1("#", \u0275\u0275pipeBind2(136, 38, ctx.form().repair_number, "3.0-0") || "---");
      \u0275\u0275advance(3);
      \u0275\u0275textInterpolate(\u0275\u0275pipeBind2(139, 41, ctx.date, "dd/MM/yyyy"));
      \u0275\u0275advance(9);
      \u0275\u0275textInterpolate(ctx.form().customer_name);
      \u0275\u0275advance(5);
      \u0275\u0275textInterpolate(ctx.form().device_model);
      \u0275\u0275advance(7);
      \u0275\u0275textInterpolate1("$ ", ctx.form().estimated_cost);
    }
  }, dependencies: [CommonModule, FormsModule, \u0275NgNoValidate, NgSelectOption, \u0275NgSelectMultipleOption, DefaultValueAccessor, NumberValueAccessor, CheckboxControlValueAccessor, SelectControlValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator, MinValidator, NgModel, NgForm, RouterLink, QRCodeComponent, DecimalPipe, CurrencyPipe, DatePipe], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AdminRepairFormPage, [{
    type: Component,
    args: [{ selector: "app-admin-repair-form-page", standalone: true, imports: [CommonModule, FormsModule, RouterLink, QRCodeComponent], template: `<div class="container mx-auto p-4 max-w-5xl no-print">\r
    <div class="flex justify-between items-center mb-6">\r
        <h1 class="text-2xl font-bold text-green-600">{{ id ? 'Editar Reparaci\xF3n' : 'Nueva Reparaci\xF3n' }}</h1>\r
        <a routerLink="/admin/repairs" class="btn btn-circle btn-ghost text-base-content">\r
            <i class="fas fa-arrow-left"></i>\r
        </a>\r
    </div>\r
\r
    <div class="card bg-base-100 shadow-lg">\r
        <div class="card-body p-6">\r
            @if (loading()) {\r
            <div class="flex justify-center py-12">\r
                <span class="loading loading-spinner loading-lg text-primary"></span>\r
            </div>\r
            } @else {\r
            <form (ngSubmit)="save()" class="space-y-6">\r
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">\r
                    <!-- Customer Info -->\r
                    <div class="form-control">\r
                        <label class="label">\r
                            <span class="label-text font-medium">Nombre del Cliente</span>\r
                        </label>\r
                        <label class="input input-bordered flex items-center gap-2">\r
                            <i class="fas fa-user text-gray-400"></i>\r
                            <input type="text" [(ngModel)]="form().customer_name" name="customer_name" class="grow" required />\r
                        </label>\r
                    </div>\r
                    <div class="form-control">\r
                        <label class="label">\r
                            <span class="label-text font-medium">Tel\xE9fono</span>\r
                        </label>\r
                        <label class="input input-bordered flex items-center gap-2">\r
                            <i class="fas fa-phone text-gray-400"></i>\r
                            <input type="tel" [(ngModel)]="form().customer_phone" name="customer_phone" class="grow" />\r
                        </label>\r
                    </div>\r
                </div>\r
\r
                <!-- Device Info -->\r
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">\r
                    <div class="form-control">\r
                        <label class="label">\r
                            <span class="label-text font-medium">Modelo del Dispositivo</span>\r
                        </label>\r
                        <label class="input input-bordered flex items-center gap-2">\r
                            <i class="fas fa-mobile-alt text-gray-400"></i>\r
                            <input type="text" [(ngModel)]="form().device_model" name="device_model" class="grow" required\r
                                placeholder="Ej: iPhone 11, Samsung A52..." />\r
                        </label>\r
                    </div>\r
                    <div class="form-control">\r
                        <label class="label">\r
                            <span class="label-text font-medium">IMEI / Serie</span>\r
                        </label>\r
                        <label class="input input-bordered flex items-center gap-2">\r
                            <i class="fas fa-barcode text-gray-400"></i>\r
                            <input type="text" [(ngModel)]="form().imei" name="imei" class="grow" placeholder="Opcional" />\r
                        </label>\r
                    </div>\r
                </div>\r
                \r
                <!-- Images -->\r
                <div class="form-control">\r
                    <label class="label">\r
                        <span class="label-text font-medium">Im\xE1genes del Equipo</span>\r
                    </label>\r
                    <div class="flex flex-col gap-4">\r
                        <input type="file" (change)="onFileSelected($event)" multiple accept="image/*" \r
                            class="file-input file-input-bordered w-full" \r
                            [disabled]="uploadingImages()" />\r
                        \r
                        @if (uploadingImages()) {\r
                            <div class="flex items-center gap-2 text-sm text-gray-500">\r
                                <span class="loading loading-spinner loading-xs"></span>\r
                                Subiendo im\xE1genes...\r
                            </div>\r
                        }\r
\r
                        @if (form().images.length > 0) {\r
                            <div class="grid grid-cols-2 md:grid-cols-4 gap-4">\r
                                @for (img of form().images; track img; let i = $index) {\r
                                    <div class="relative group aspect-square bg-base-200 rounded-lg overflow-hidden border border-base-300">\r
                                        <img [src]="img" class="w-full h-full object-cover" alt="Repair image" />\r
                                        <button type="button" (click)="removeImage(i)" \r
                                            class="absolute top-1 right-1 btn btn-circle btn-xs btn-error opacity-0 group-hover:opacity-100 transition-opacity">\r
                                            <i class="fas fa-times"></i>\r
                                        </button>\r
                                    </div>\r
                                }\r
                            </div>\r
                        }\r
                    </div>\r
                </div>\r
\r
                <div class="form-control">\r
                    <label class="label">\r
                        <span class="label-text font-medium">Descripci\xF3n del Problema</span>\r
                    </label>\r
                    <textarea [(ngModel)]="form().issue_description" name="issue_description"\r
                        class="textarea textarea-bordered h-24 leading-relaxed"\r
                        placeholder="Describe la falla reportada por el cliente..."></textarea>\r
                </div>\r
\r
                <div class="divider text-sm font-medium text-gray-500">Detalles del Equipo</div>\r
\r
                <!-- Checklist -->\r
                <div class="form-control">\r
                    <label class="label">\r
                        <span class="label-text font-medium">Accesorios Recibidos</span>\r
                    </label>\r
                    <div class="flex flex-wrap gap-3">\r
                        <label class="cursor-pointer select-none transition-all duration-200 border rounded-lg px-4 py-2 flex items-center gap-3 hover:bg-gray-200"\r
                            [class.bg-primary-content]="form().checklist.charger"\r
                            [class.border-primary]="form().checklist.charger"\r
                            [class.text-primary]="form().checklist.charger"\r
                            [class.bg-gray-100]="!form().checklist.charger"\r
                            [class.border-gray-300]="!form().checklist.charger"\r
                            [class.text-gray-700]="!form().checklist.charger">\r
                            <input type="checkbox" [(ngModel)]="form().checklist.charger" name="check_charger" \r
                                class="checkbox checkbox-primary checkbox-sm" />\r
                            <span class="font-medium">Cargador</span>\r
                        </label>\r
\r
                        <label class="cursor-pointer select-none transition-all duration-200 border rounded-lg px-4 py-2 flex items-center gap-3 hover:bg-gray-200"\r
                            [class.bg-primary-content]="form().checklist.battery"\r
                            [class.border-primary]="form().checklist.battery"\r
                            [class.text-primary]="form().checklist.battery"\r
                            [class.bg-gray-100]="!form().checklist.battery"\r
                            [class.border-gray-300]="!form().checklist.battery"\r
                            [class.text-gray-700]="!form().checklist.battery">\r
                            <input type="checkbox" [(ngModel)]="form().checklist.battery" name="check_battery" \r
                                class="checkbox checkbox-primary checkbox-sm" />\r
                            <span class="font-medium">Bater\xEDa</span>\r
                        </label>\r
\r
                        <label class="cursor-pointer select-none transition-all duration-200 border rounded-lg px-4 py-2 flex items-center gap-3 hover:bg-gray-200"\r
                            [class.bg-primary-content]="form().checklist.chip"\r
                            [class.border-primary]="form().checklist.chip"\r
                            [class.text-primary]="form().checklist.chip"\r
                            [class.bg-gray-100]="!form().checklist.chip"\r
                            [class.border-gray-300]="!form().checklist.chip"\r
                            [class.text-gray-700]="!form().checklist.chip">\r
                            <input type="checkbox" [(ngModel)]="form().checklist.chip" name="check_chip" \r
                                class="checkbox checkbox-primary checkbox-sm" />\r
                            <span class="font-medium">Chip</span>\r
                        </label>\r
\r
                        <label class="cursor-pointer select-none transition-all duration-200 border rounded-lg px-4 py-2 flex items-center gap-3 hover:bg-gray-200"\r
                            [class.bg-primary-content]="form().checklist.sd"\r
                            [class.border-primary]="form().checklist.sd"\r
                            [class.text-primary]="form().checklist.sd"\r
                            [class.bg-gray-100]="!form().checklist.sd"\r
                            [class.border-gray-300]="!form().checklist.sd"\r
                            [class.text-gray-700]="!form().checklist.sd">\r
                            <input type="checkbox" [(ngModel)]="form().checklist.sd" name="check_sd" \r
                                class="checkbox checkbox-primary checkbox-sm" />\r
                            <span class="font-medium">Tarjeta SD</span>\r
                        </label>\r
\r
                        <label class="cursor-pointer select-none transition-all duration-200 border rounded-lg px-4 py-2 flex items-center gap-3 hover:bg-gray-200"\r
                            [class.bg-primary-content]="form().checklist.case"\r
                            [class.border-primary]="form().checklist.case"\r
                            [class.text-primary]="form().checklist.case"\r
                            [class.bg-gray-100]="!form().checklist.case"\r
                            [class.border-gray-300]="!form().checklist.case"\r
                            [class.text-gray-700]="!form().checklist.case">\r
                            <input type="checkbox" [(ngModel)]="form().checklist.case" name="check_case" \r
                                class="checkbox checkbox-primary checkbox-sm" />\r
                            <span class="font-medium">Funda</span>\r
                        </label>\r
                    </div>\r
                </div>\r
\r
                <!-- Security -->\r
                <div class="grid grid-cols-1 md:grid-cols-3 gap-6">\r
                    <div class="form-control">\r
                        <label class="label">\r
                            <span class="label-text font-medium">PIN / Contrase\xF1a</span>\r
                        </label>\r
                        <label class="input input-bordered flex items-center gap-2">\r
                            <i class="fas fa-lock text-gray-400"></i>\r
                            <input type="text" [(ngModel)]="form().security_pin" name="security_pin" class="grow" placeholder="1234" />\r
                        </label>\r
                    </div>\r
                    <div class="form-control">\r
                        <label class="label">\r
                            <span class="label-text font-medium">Patr\xF3n</span>\r
                        </label>\r
                        <label class="input input-bordered flex items-center gap-2">\r
                            <i class="fas fa-draw-polygon text-gray-400"></i>\r
                            <input type="text" [(ngModel)]="form().security_pattern" name="security_pattern" class="grow"\r
                                placeholder="Ej: Z, L, etc" />\r
                        </label>\r
                    </div>\r
                    <div class="form-control">\r
                        <label class="label">\r
                            <span class="label-text font-medium">Passcode (Num\xE9rico/Texto)</span>\r
                        </label>\r
                        <label class="input input-bordered flex items-center gap-2">\r
                            <i class="fas fa-key text-gray-400"></i>\r
                            <input type="text" [(ngModel)]="form().device_passcode" name="device_passcode" class="grow" placeholder="Contrase\xF1a de pantalla" />\r
                        </label>\r
                    </div>\r
                </div>\r
\r
                <div class="divider text-sm font-medium text-gray-500">Gesti\xF3n T\xE9cnica & Repuestos</div>\r
\r
                <!-- Parts Management -->\r
                <div class="form-control bg-neutral-50 p-6 rounded-2xl border border-neutral-100">\r
                    <div class="flex justify-between items-center mb-4">\r
                        <h3 class="font-bold text-neutral-800 flex items-center gap-2">\r
                            <i class="fas fa-box-open text-primary"></i> Repuestos Utilizados\r
                        </h3>\r
                        <div class="flex gap-2">\r
                             <button type="button" (click)="loadProducts()" class="btn btn-sm btn-outline btn-primary rounded-xl">\r
                                <i class="fas fa-plus"></i> A\xF1adir Repuesto\r
                             </button>\r
                        </div>\r
                    </div>\r
\r
                    <div class="overflow-x-auto">\r
                        <table class="table table-sm">\r
                            <thead class="bg-white/50 text-neutral-400">\r
                                <tr>\r
                                    <th>Repuesto</th>\r
                                    <th class="text-center">Cant.</th>\r
                                    <th class="text-right">Precio Venta</th>\r
                                    <th class="text-right">Costo</th>\r
                                    <th></th>\r
                                </tr>\r
                            </thead>\r
                            <tbody>\r
                                @for (part of form().parts; track $index) {\r
                                <tr>\r
                                    <td class="font-bold text-neutral-700">{{ part.name }}</td>\r
                                    <td class="text-center">\r
                                        <input type="number" [(ngModel)]="part.quantity" [name]="'part_qty_' + $index" (change)="calculateFinalCost()"\r
                                            class="input input-xs input-bordered w-16 text-center" />\r
                                    </td>\r
                                    <td class="text-right font-mono text-primary font-bold">\r
                                        {{ part.unit_price_at_time | currency:'ARS':'symbol':'1.0-0' }}\r
                                    </td>\r
                                    <td class="text-right font-mono text-neutral-400 text-[10px]">\r
                                        {{ part.cost_at_time | currency:'ARS':'symbol':'1.0-0' }}\r
                                    </td>\r
                                    <td class="text-right">\r
                                        <button type="button" (click)="removePart($index)" class="btn btn-ghost btn-xs text-rose-500">\r
                                            <i class="fas fa-trash"></i>\r
                                        </button>\r
                                    </td>\r
                                </tr>\r
                                }\r
                                @if (form().parts.length === 0) {\r
                                <tr>\r
                                    <td colspan="5" class="text-center py-4 text-xs italic text-neutral-400">No hay repuestos cargados</td>\r
                                </tr>\r
                                }\r
                            </tbody>\r
                        </table>\r
                    </div>\r
                </div>\r
\r
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">\r
                    <div class="form-control">\r
                        <label class="label">\r
                            <span class="label-text font-medium">Mano de Obra (Labor T\xE9cnica)</span>\r
                        </label>\r
                        <label class="input input-bordered flex items-center gap-2">\r
                            <i class="fas fa-tools text-gray-400"></i>\r
                            <input type="number" [(ngModel)]="form().technical_labor_cost" name="technical_labor_cost" (change)="calculateFinalCost()" class="grow" min="0" />\r
                        </label>\r
                    </div>\r
                    \r
                    <div class="form-control">\r
                        <label class="label">\r
                            <span class="label-text font-medium">Estado Final</span>\r
                        </label>\r
                        <select [(ngModel)]="form().current_status_id" name="current_status_id" class="select select-bordered w-full">\r
                            <option [value]="1">PENDIENTE DE DIAGN\xD3STICO</option>\r
                            <option [value]="2">GESTI\xD3N DE REPUESTOS</option>\r
                            <option [value]="3">EN REPARACI\xD3N</option>\r
                            <option [value]="4">CONTROL DE CALIDAD</option>\r
                            <option [value]="5">LISTO PARA RETIRAR</option>\r
                            <option [value]="6">ENTREGADO</option>\r
                            <option [value]="7">CANCELADO</option>\r
                        </select>\r
                    </div>\r
                </div>\r
\r
                <div class="form-control">\r
                    <label class="label">\r
                        <span class="label-text font-bold text-primary italic">Reporte T\xE9cnico (P\xFAblico)</span>\r
                    </label>\r
                    <textarea [(ngModel)]="form().technical_report" name="technical_report"\r
                        class="textarea textarea-bordered h-24 leading-relaxed font-mono text-xs"\r
                        placeholder="Escribe el informe que ver\xE1 el cliente en la web..."></textarea>\r
                </div>\r
\r
                <div class="divider text-sm font-medium text-gray-500">Resumen Financiero</div>\r
\r
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">\r
                    <div class="form-control">\r
                        <label class="label">\r
                            <span class="label-text font-medium">Presupuesto Inicial Estimado</span>\r
                        </label>\r
                        <label class="input input-bordered flex items-center gap-2">\r
                            <i class="fas fa-calculator text-gray-400"></i>\r
                            <input type="number" [(ngModel)]="form().estimated_cost" name="estimated_cost" class="grow" min="0" />\r
                        </label>\r
                    </div>\r
                    <div class="form-control">\r
                        <label class="label">\r
                            <span class="label-text font-medium">Costo Total (Final)</span>\r
                        </label>\r
                        <div class="text-3xl font-black text-neutral-800 tracking-tighter">\r
                            {{ form().final_cost | currency:'ARS':'symbol':'1.0-0' }}\r
                        </div>\r
                    </div>\r
                    <div class="form-control">\r
                        <label class="label">\r
                            <span class="label-text font-medium">Se\xF1a / Adelanto</span>\r
                        </label>\r
                        <label class="input input-bordered flex items-center gap-2">\r
                            <i class="fas fa-hand-holding-usd text-gray-400"></i>\r
                            <input type="number" [(ngModel)]="form().deposit_amount" name="deposit_amount" class="grow" min="0" />\r
                        </label>\r
                    </div>\r
                    <div class="form-control">\r
                        <label class="label">\r
                            <span class="label-text font-bold text-green-600">Saldo Pendiente</span>\r
                        </label>\r
                        <div class="text-3xl font-black text-green-600 tracking-tighter">\r
                            {{ (form().final_cost - (form().deposit_amount || 0)) | currency:'ARS':'symbol':'1.0-0' }}\r
                        </div>\r
                    </div>\r
                </div>\r
\r
                <div class="form-control">\r
                    <label class="label">\r
                        <span class="label-text font-medium">Notas del T\xE9cnico (Interno)</span>\r
                    </label>\r
                    <textarea [(ngModel)]="form().technician_notes" name="technician_notes"\r
                        class="textarea textarea-bordered h-24 leading-relaxed"\r
                        placeholder="Detalles de la reparaci\xF3n realizada..."></textarea>\r
                </div>\r
\r
                <!-- Error Message -->\r
                @if (error()) {\r
                <div class="alert alert-error mb-6 shadow-sm">\r
                    <i class="fas fa-exclamation-circle"></i>\r
                    <span>{{ error() }}</span>\r
                </div>\r
                }\r
\r
                <!-- Actions -->\r
                <div class="flex flex-col sm:flex-row justify-end gap-4 pt-6 border-t border-base-200">\r
                    @if (id && form().tracking_code) {\r
                    <button type="button" (click)="shareWhatsApp()"\r
                        class="btn bg-green-600 hover:bg-green-700 text-white border-none w-full sm:w-auto">\r
                        <i class="fab fa-whatsapp mr-2"></i> Compartir\r
                    </button>\r
                    }\r
\r
                    <button type="button" (click)="printOrder()" class="btn btn-outline w-full sm:w-auto"\r
                        [disabled]="saving()">\r
                        <i class="fas fa-print mr-2"></i> Imprimir Orden\r
                    </button>\r
                    <a routerLink="/admin/repairs" class="btn btn-error text-white w-full sm:w-auto">Cancelar</a>\r
                    <button type="submit" class="btn btn-primary w-full sm:w-auto"\r
                        [disabled]="saving() || !form().customer_name || !form().device_model">\r
                        @if (saving()) {\r
                        <span class="loading loading-spinner loading-xs"></span>\r
                        }\r
                        Guardar Reparaci\xF3n\r
                    </button>\r
                </div>\r
            </form>\r
            }\r
        </div>\r
    </div>\r
</div>\r
\r
<!-- Modal Selecci\xF3n de Repuestos -->\r
@if (showProductModal()) {\r
<div class="modal modal-open">\r
    <div class="modal-box w-11/12 max-w-2xl bg-white shadow-2xl rounded-2xl p-6">\r
        <h3 class="font-bold text-lg mb-4 text-green-700 flex items-center gap-2">\r
            <i class="fas fa-box"></i> Seleccionar Repuesto\r
        </h3>\r
        \r
        <div class="form-control mb-4">\r
            <label class="input input-bordered flex items-center gap-2">\r
                <i class="fas fa-search text-gray-400"></i>\r
                <input type="text" [ngModel]="searchQuery()" (ngModelChange)="searchQuery.set($event)" name="searchQuery" class="grow" placeholder="Buscar repuesto por nombre..." />\r
            </label>\r
        </div>\r
\r
        <div class="max-h-96 overflow-y-auto pr-2">\r
            @if (filteredProducts().length === 0) {\r
            <p class="text-sm text-gray-500 text-center py-6 italic">No se encontraron repuestos.</p>\r
            }\r
            @for (product of filteredProducts(); track product.id) {\r
            <div class="flex justify-between items-center py-3 border-b border-gray-100 hover:bg-gray-50 transition-colors px-2 rounded-lg">\r
                <div class="flex items-center gap-3">\r
                    @if (product.image_url) {\r
                        <img [src]="product.image_url" alt="" class="w-10 h-10 object-cover rounded-md border border-gray-200" />\r
                    } @else {\r
                        <div class="w-10 h-10 bg-gray-100 rounded-md border border-gray-200 flex items-center justify-center text-gray-400">\r
                            <i class="fas fa-image"></i>\r
                        </div>\r
                    }\r
                    <div>\r
                        <div class="font-bold text-gray-800">{{ product.name }}</div>\r
                        <div class="text-xs text-gray-500">\r
                            <span [class.text-red-500]="product.stock === 0" [class.text-amber-500]="product.stock > 0 && product.stock <= 5" [class.text-green-500]="product.stock > 5">\r
                                Stock: {{ product.stock }}\r
                            </span>\r
                            <span class="mx-2">|</span>\r
                            Precio: <span class="font-medium text-primary">{{ product.price | currency:'ARS':'symbol':'1.0-0' }}</span>\r
                        </div>\r
                    </div>\r
                </div>\r
                <button type="button" class="btn btn-sm btn-primary rounded-xl" (click)="addPart(product); showProductModal.set(false)">\r
                    <i class="fas fa-plus mr-1"></i> A\xF1adir\r
                </button>\r
            </div>\r
            }\r
        </div>\r
        <div class="modal-action mt-6 pt-4 border-t border-gray-100">\r
            <button type="button" class="btn rounded-xl" (click)="showProductModal.set(false)">Cerrar</button>\r
        </div>\r
    </div>\r
</div>\r
}\r
\r
<!-- Print Layout (Hidden on screen via CSS, visible on print via CSS) -->\r
<div class="print-container font-sans text-xs leading-tight hidden">\r
    <div class="flex flex-col h-full">\r
        <!-- Main Ticket (Top) -->\r
        <div class="w-full pb-4 border-b-2 border-dashed border-gray-400 mb-4 flex flex-col">\r
            <!-- Header -->\r
            <div class="flex justify-between items-start mb-2 border-b border-gray-300 pb-2">\r
                <div class="flex items-center">\r
                    @if (company()?.logo_url) {\r
                        <img [src]="company().logo_url" alt="Logo" class="h-10 w-auto mr-3 object-contain">\r
                    }\r
                    <div>\r
                        <h1 class="text-lg font-bold uppercase mb-0">Orden #{{ (form().repair_number | number:'3.0-0') || '---' }}</h1>\r
                        <div class="text-[9px] text-gray-600">\r
                            <span>{{ date | date:'dd/MM/yyyy' }}</span> |\r
                            <span>ID: {{ form().tracking_code }}</span>\r
                        </div>\r
                    </div>\r
                </div>\r
                <!-- QR Code for tracking -->\r
                <div class="text-right flex items-center gap-2">\r
                    <div class="flex flex-col items-center">\r
                         @if (form().tracking_code) {\r
                            <qrcode [qrdata]="getTrackingUrl()" [width]="60" [margin]="0" [errorCorrectionLevel]="'M'"></qrcode>\r
                         }\r
                    </div>\r
                    <div class="text-right">\r
                        <h2 class="font-bold text-base text-green-700 uppercase">{{ company()?.name || 'ARECOFIX' }}</h2>\r
                        <div class="text-[9px] text-gray-600 leading-tight">\r
                            <p>{{ company()?.address }}</p>\r
                            <p>{{ company()?.phone }}</p>\r
                        </div>\r
                    </div>\r
                </div>\r
            </div>\r
\r
            <!-- Content Grid (2 Columns) -->\r
            <div class="grid grid-cols-2 gap-3 mb-2 grow">\r
                <!-- Col 1: Customer, Device, Security -->\r
                <div class="flex flex-col gap-2">\r
                    <div class="border border-gray-300 rounded p-1">\r
                        <h3 class="font-bold bg-gray-100 px-1 text-[9px] mb-0.5">CLIENTE & EQUIPO</h3>\r
                        <div class="px-1 text-[9px]">\r
                            <div class="flex justify-between"><span class="font-bold">Nombre:</span> <span class="truncate ml-1">{{ form().customer_name }}</span></div>\r
                            <div class="flex justify-between"><span class="font-bold">Tel:</span> <span class="truncate ml-1">{{ form().customer_phone }}</span></div>\r
                            <div class="border-t border-gray-200 my-0.5"></div>\r
                            <div class="flex justify-between"><span class="font-bold">Modelo:</span> <span class="truncate ml-1">{{ form().device_model }}</span></div>\r
                            <div class="flex justify-between"><span class="font-bold">IMEI:</span> <span class="truncate ml-1">{{ form().imei }}</span></div>\r
                        </div>\r
                    </div>\r
\r
                    <div class="border border-gray-300 rounded p-1">\r
                        <h3 class="font-bold bg-gray-100 px-1 text-[9px] mb-0.5">SEGURIDAD</h3>\r
                        <div class="px-1 text-[9px]">\r
                            <div class="flex justify-between"><span class="font-bold">PIN:</span> <span>{{ form().security_pin }}</span></div>\r
                            <div class="flex justify-between"><span class="font-bold">Patr\xF3n:</span> <span>{{ form().security_pattern }}</span></div>\r
                            <div class="mt-1 pt-1 border-t border-gray-200">\r
                                <div class="grid grid-cols-3 gap-0.5 text-[8px]">\r
                                    <span>[{{ form().checklist.charger ? 'X' : ' ' }}] Carg</span>\r
                                    <span>[{{ form().checklist.battery ? 'X' : ' ' }}] Bat</span>\r
                                    <span>[{{ form().checklist.chip ? 'X' : ' ' }}] Chip</span>\r
                                    <span>[{{ form().checklist.sd ? 'X' : ' ' }}] SD</span>\r
                                    <span>[{{ form().checklist.case ? 'X' : ' ' }}] Funda</span>\r
                                </div>\r
                            </div>\r
                        </div>\r
                    </div>\r
                </div>\r
\r
                <!-- Col 2: Costs, Fault -->\r
                <div class="flex flex-col gap-2">\r
                    <div class="border border-gray-300 rounded p-1">\r
                        <h3 class="font-bold bg-gray-100 px-1 text-[9px] mb-0.5">PRECIOS</h3>\r
                        <div class="px-1 text-[9px]">\r
                            <div class="flex justify-between">\r
                                <span class="font-bold">Presupuesto:</span>\r
                                <span>$ {{ form().estimated_cost }}</span>\r
                            </div>\r
                            <div class="flex justify-between">\r
                                <span class="font-bold">Se\xF1a:</span>\r
                                <span>$ {{ form().deposit_amount }}</span>\r
                            </div>\r
                            <div class="flex justify-between border-t border-gray-300 pt-0.5 mt-0.5 font-bold">\r
                                <span>Total:</span>\r
                                <span>$ {{ form().final_cost || form().estimated_cost }}</span>\r
                            </div>\r
                        </div>\r
                    </div>\r
                    <div class="border border-gray-300 rounded p-1 grow">\r
                        <h3 class="font-bold bg-gray-100 px-1 text-[9px] mb-0.5">FALLA / NOTAS</h3>\r
                        <div class="px-1 text-[9px] h-full overflow-hidden leading-tight">\r
                            {{ form().issue_description }}\r
                        </div>\r
                    </div>\r
                </div>\r
            </div>\r
            \r
            <hr>\r
            <br>\r
\r
            <div class="mt-auto">\r
                <div class="flex justify-between items-end text-[9px]">\r
                    <div class="w-5/12 text-center border-t border-black pt-1">FIRMA CLIENTE</div>\r
                    <div class="w-5/12 text-center border-t border-black pt-1">FIRMA T\xC9CNICO</div>\r
                </div>\r
            </div>\r
        </div>\r
\r
        <!-- Stub (Bottom) -->\r
        <div class="w-full pt-2 flex flex-col justify-between">\r
            <div class="grid grid-cols-2 gap-4">\r
                <div>\r
                    <div class="text-center mb-3">\r
                        <h2 class="font-bold text-xs uppercase border-b border-black pb-1 mb-1">TAL\xD3N DE RETIRO</h2>\r
                        <div class="text-[10px] font-bold truncate">{{ company()?.name || 'ARECOFIX' }}</div>\r
                    </div>\r
                    \r
                    <div class="mb-3">\r
                        <div class="text-sm font-bold mb-0.5 text-center border border-gray-300 rounded bg-gray-50">#{{ (form().repair_number | number:'3.0-0') || '---' }}</div>\r
                        <div class="text-[9px] text-center text-gray-600">{{ date | date:'dd/MM/yyyy' }}</div>\r
                    </div>\r
                </div>\r
\r
                <div class="space-y-2">\r
                    <div class="border border-gray-300 rounded p-1">\r
                        <div class="text-[9px]">\r
                            <div class="flex justify-between"><span class="font-bold">Cliente:</span> <span class="truncate ml-1">{{ form().customer_name }}</span></div>\r
                            <div class="flex justify-between"><span class="font-bold">Equipo:</span> <span class="truncate ml-1">{{ form().device_model }}</span></div>\r
                        </div>\r
                    </div>\r
\r
                    <div class="border border-gray-300 rounded p-1">\r
                        <div class="text-[9px]">\r
                            <div class="flex justify-between"><span class="font-bold">Presupuesto:</span> <span>$ {{ form().estimated_cost }}</span></div>\r
                            <div class="flex justify-between"><span class="font-bold"></span></div>\r
                        </div>\r
                    </div>\r
                </div>\r
            </div>\r
\r
            <!-- Conditions & Footer -->\r
            <div class="mt-2 pt-2 border-t border-gray-300">\r
                <div class="text-[8px] text-gray-500 text-justify leading-tight mb-2">\r
                    CONDICIONES: La empresa no se responsabiliza por la p\xE9rdida de informaci\xF3n. Pasados los 90 d\xEDas el equipo se considerar\xE1 abandonado. La garant\xEDa cubre \xFAnicamente la reparaci\xF3n realizada y por un plazo de 30 d\xEDas. No cubre da\xF1os por mal uso, golpes o humedad.\r
                </div>\r
                <div class="text-center font-bold text-[10px]">\r
                    Este tal\xF3n deber\xE1 ser presentado indefectiblemente para retirar el equipo.\r
                </div>\r
            </div>\r
        </div>\r
    </div>\r
</div>` }]
  }], null, null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(AdminRepairFormPage, { className: "AdminRepairFormPage", filePath: "src/app/admin/repairs/admin-repair-form-page.ts", lineNumber: 21 });
})();
export {
  AdminRepairFormPage
};
/*! Bundled license information:

pako/dist/pako.esm.mjs:
  (*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) *)

html2canvas/dist/html2canvas.esm.js:
  (*!
   * html2canvas 1.4.1 <https://html2canvas.hertzen.com>
   * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
   * Released under MIT License
   *)
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

dompurify/dist/purify.cjs.js:
  (*! @license DOMPurify 3.3.1 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.3.1/LICENSE *)

@babel/runtime/helpers/regenerator.js:
  (*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE *)

svg-pathdata/lib/SVGPathData.cjs:
  (*! *****************************************************************************
      Copyright (c) Microsoft Corporation.
  
      Permission to use, copy, modify, and/or distribute this software for any
      purpose with or without fee is hereby granted.
  
      THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
      REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
      AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
      INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
      LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
      OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
      PERFORMANCE OF THIS SOFTWARE.
      ***************************************************************************** *)

jspdf/dist/jspdf.node.min.js:
  (** @license
   *
   * jsPDF - PDF Document creation from JavaScript
   * Version 4.2.0 Built on 2026-02-19T09:43:09.013Z
   *                      CommitID 00000000
   *
   * Copyright (c) 2010-2025 James Hall <james@parall.ax>, https://github.com/MrRio/jsPDF
   *               2015-2025 yWorks GmbH, http://www.yworks.com
   *               2015-2025 Lukas Holländer <lukas.hollaender@yworks.com>, https://github.com/HackbrettXXX
   *               2016-2018 Aras Abbasi <aras.abbasi@gmail.com>
   *               2010 Aaron Spike, https://github.com/acspike
   *               2012 Willow Systems Corporation, https://github.com/willowsystems
   *               2012 Pablo Hess, https://github.com/pablohess
   *               2012 Florian Jenett, https://github.com/fjenett
   *               2013 Warren Weckesser, https://github.com/warrenweckesser
   *               2013 Youssef Beddad, https://github.com/lifof
   *               2013 Lee Driscoll, https://github.com/lsdriscoll
   *               2013 Stefan Slonevskiy, https://github.com/stefslon
   *               2013 Jeremy Morel, https://github.com/jmorel
   *               2013 Christoph Hartmann, https://github.com/chris-rock
   *               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria
   *               2014 James Makes, https://github.com/dollaruw
   *               2014 Diego Casorran, https://github.com/diegocr
   *               2014 Steven Spungin, https://github.com/Flamenco
   *               2014 Kenneth Glassey, https://github.com/Gavvers
   *
   * Permission is hereby granted, free of charge, to any person obtaining
   * a copy of this software and associated documentation files (the
   * "Software"), to deal in the Software without restriction, including
   * without limitation the rights to use, copy, modify, merge, publish,
   * distribute, sublicense, and/or sell copies of the Software, and to
   * permit persons to whom the Software is furnished to do so, subject to
   * the following conditions:
   *
   * The above copyright notice and this permission notice shall be
   * included in all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
   * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
   * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
   * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   *
   * Contributor(s):
   *    siefkenj, ahwolf, rickygu, Midnith, saintclair, eaparango,
   *    kim3er, mfo, alnorth, Flamenco
   *)
  (**
   * A class to parse color values
   * @author Stoyan Stefanov <sstoo@gmail.com>
   * {@link   http://www.phpied.com/rgb-color-parser-in-javascript/}
   * @license Use it if you like it
   *)
  (**
   * @license
   * Joseph Myers does not specify a particular license for his work.
   *
   * Author: Joseph Myers
   * Accessed from: http://www.myersdaily.org/joseph/javascript/md5.js
   *
   * Modified by: Owen Leong
   *)
  (**
   * @license
   * FPDF is released under a permissive license: there is no usage restriction.
   * You may embed it freely in your application (commercial or not), with or
   * without modifications.
   *
   * Reference: http://www.fpdf.org/en/script/script37.php
   *)
  (**
   * @license
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   * Author: Owen Leong (@owenl131)
   * Date: 15 Oct 2020
   * References:
   * https://www.cs.cmu.edu/~dst/Adobe/Gallery/anon21jul01-pdf-encryption.txt
   * https://github.com/foliojs/pdfkit/blob/master/lib/security.js
   * http://www.fpdf.org/en/script/script37.php
   *)
  (** @license
   * jsPDF addImage plugin
   * Copyright (c) 2012 Jason Siefken, https://github.com/siefkenj/
   *               2013 Chris Dowling, https://github.com/gingerchris
   *               2013 Trinh Ho, https://github.com/ineedfat
   *               2013 Edwin Alejandro Perez, https://github.com/eaparango
   *               2013 Norah Smith, https://github.com/burnburnrocket
   *               2014 Diego Casorran, https://github.com/diegocr
   *               2014 James Robb, https://github.com/jamesbrobb
   *
   * Permission is hereby granted, free of charge, to any person obtaining
   * a copy of this software and associated documentation files (the
   * "Software"), to deal in the Software without restriction, including
   * without limitation the rights to use, copy, modify, merge, publish,
   * distribute, sublicense, and/or sell copies of the Software, and to
   * permit persons to whom the Software is furnished to do so, subject to
   * the following conditions:
   *
   * The above copyright notice and this permission notice shall be
   * included in all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
   * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
   * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
   * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   *)
  (**
   * @license
    Copyright (c) 2008, Adobe Systems Incorporated
    All rights reserved.
  
    Redistribution and use in source and binary forms, with or without 
    modification, are permitted provided that the following conditions are
    met:
  
    * Redistributions of source code must retain the above copyright notice, 
      this list of conditions and the following disclaimer.
    
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the 
      documentation and/or other materials provided with the distribution.
    
    * Neither the name of Adobe Systems Incorporated nor the names of its 
      contributors may be used to endorse or promote products derived from 
      this software without specific prior written permission.
  
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
    IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
    THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
    CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
    LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *)
  (**
   * @license
   * Copyright (c) 2017 Aras Abbasi
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   *)
  (** ====================================================================
   * @license
   * jsPDF XMP metadata plugin
   * Copyright (c) 2016 Jussi Utunen, u-jussi@suomi24.fi
   *
   * Permission is hereby granted, free of charge, to any person obtaining
   * a copy of this software and associated documentation files (the
   * "Software"), to deal in the Software without restriction, including
   * without limitation the rights to use, copy, modify, merge, publish,
   * distribute, sublicense, and/or sell copies of the Software, and to
   * permit persons to whom the Software is furnished to do so, subject to
   * the following conditions:
   *
   * The above copyright notice and this permission notice shall be
   * included in all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
   * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
   * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
   * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   * ====================================================================
   *)
*/
//# sourceMappingURL=chunk-YKJHDQ7Z.mjs.map
