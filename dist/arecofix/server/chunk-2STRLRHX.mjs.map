{
  "version": 3,
  "sources": ["src/app/shared/services/csv.service.ts", "src/app/shared/utils/string.utils.ts", "src/app/admin/products/services/admin-product.service.ts"],
  "sourcesContent": ["import { Injectable } from '@angular/core';\r\n\r\nexport interface CsvImportResult<T> {\r\n  data: Partial<T>[];\r\n  errors: number;\r\n}\r\n\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class CsvService {\r\n  constructor() {}\r\n\r\n  async parse<T>(file: File, parser: (values: string[], headers: string[]) => T | null): Promise<CsvImportResult<T>> {\r\n    return new Promise((resolve, reject) => {\r\n      const reader = new FileReader();\r\n      \r\n      reader.onload = (e: ProgressEvent<FileReader>) => {\r\n        try {\r\n          const csv = e.target?.result as string;\r\n          if (!csv) {\r\n            reject(new Error('Empty file'));\r\n            return;\r\n          }\r\n          \r\n          const lines = csv.split(/\\r\\n|\\n/);\r\n          const headers = lines[0].split(',').map(h => h.trim());\r\n          \r\n          const data: Partial<T>[] = [];\r\n          let errorCount = 0;\r\n\r\n          for (let i = 1; i < lines.length; i++) {\r\n            const line = lines[i].trim();\r\n            if (!line) continue;\r\n\r\n            const values = this.parseLine(line);\r\n            \r\n            if (values.length !== headers.length) {\r\n              console.warn(`Skipping line ${i + 1}: Column count mismatch`);\r\n              errorCount++;\r\n              continue;\r\n            }\r\n\r\n            const item = parser(values, headers);\r\n            if (item) {\r\n              data.push(item);\r\n            } else {\r\n              errorCount++;\r\n            }\r\n          }\r\n\r\n          resolve({ data, errors: errorCount });\r\n        } catch (error) {\r\n          reject(error);\r\n        }\r\n      };\r\n\r\n      reader.onerror = (error) => reject(error);\r\n      reader.readAsText(file);\r\n    });\r\n  }\r\n\r\n  exportToCsv<T>(data: T[], filename: string, headers: (keyof T | string)[]): void {\r\n    if (!data.length) return;\r\n\r\n    const csvContent = [\r\n      headers.join(','),\r\n      ...data.map(item => {\r\n        return headers.map(header => {\r\n          const value = (item as any)[header];\r\n          const safeValue = value === undefined || value === null ? '' : value;\r\n          \r\n          if (typeof safeValue === 'string' && (safeValue.includes(',') || safeValue.includes('\"') || safeValue.includes('\\n'))) {\r\n            return `\"${safeValue.replace(/\"/g, '\"\"')}\"`;\r\n          }\r\n          return safeValue;\r\n        }).join(',');\r\n      })\r\n    ].join('\\n');\r\n\r\n    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });\r\n    const link = document.createElement('a');\r\n    const url = URL.createObjectURL(blob);\r\n    \r\n    link.setAttribute('href', url);\r\n    link.setAttribute('download', `${filename}_${new Date().toISOString().split('T')[0]}.csv`);\r\n    link.style.visibility = 'hidden';\r\n    document.body.appendChild(link);\r\n    link.click();\r\n    document.body.removeChild(link);\r\n  }\r\n\r\n  private parseLine(line: string): string[] {\r\n    const values: string[] = [];\r\n    let inQuotes = false;\r\n    let currentValue = '';\r\n    \r\n    for (let char of line) {\r\n      if (char === '\"') {\r\n        inQuotes = !inQuotes;\r\n      } else if (char === ',' && !inQuotes) {\r\n        values.push(currentValue);\r\n        currentValue = '';\r\n      } else {\r\n        currentValue += char;\r\n      }\r\n    }\r\n    values.push(currentValue);\r\n    return values;\r\n  }\r\n}\r\n", "export class StringUtils {\r\n  static slugify(text: string): string {\r\n    return text\r\n      .toString()\r\n      .toLowerCase()\r\n      .trim()\r\n      .replace(/\\s+/g, '-')\r\n      .replace(/&/g, '-and-')\r\n      .replace(/[^a-z0-9-]/g, '')\r\n      .replace(/-+/g, '-');\r\n  }\r\n\r\n  static capitalize(text: string): string {\r\n    if (!text) return '';\r\n    return text.charAt(0).toUpperCase() + text.slice(1);\r\n  }\r\n}\r\n", "import { Injectable, inject } from '@angular/core';\r\nimport { Product } from '@app/features/products/domain/entities/product.entity';\r\nimport { Brand } from '@app/features/products/domain/entities/brand.entity';\r\nimport { Category } from '@app/features/products/domain/entities/category.entity';\r\nimport { ProductRepository, BulkPriceUpdate, ImportProductSummary } from '@app/features/products/domain/repositories/product.repository';\r\nimport { BrandRepository } from '@app/features/products/domain/repositories/brand.repository';\r\nimport { CategoryRepository } from '@app/features/products/domain/repositories/category.repository';\r\nimport { AuthService } from '@app/core/services/auth.service';\r\nimport { CsvService } from '@app/shared/services/csv.service';\r\nimport { StringUtils } from '@app/shared/utils/string.utils';\r\nimport { firstValueFrom } from 'rxjs';\r\n\r\n// ‚îÄ‚îÄ‚îÄ Import Report ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\r\nexport interface ImportReport {\r\n    /** Products actually inserted as new */\r\n    inserted: number;\r\n    /** Products where only the price was updated */\r\n    priceUpdated: number;\r\n    /** Products renamed from 'repuesto' + price updated */\r\n    renamed: number;\r\n    /** Rows in the CSV that could not be processed */\r\n    skipped: number;\r\n    /** Human-readable summary lines */\r\n    details: string[];\r\n}\r\n\r\n// ‚îÄ‚îÄ‚îÄ Raw CSV row after parsing ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\r\ninterface CsvRow {\r\n    id?: string;\r\n    name: string;\r\n    price: number;\r\n    stock?: number;\r\n    sku?: string;\r\n    barcode?: string;\r\n    description?: string;\r\n    category_id?: string;\r\n    brand_id?: string;\r\n    image_url?: string;\r\n    slug?: string;\r\n    is_active?: boolean;\r\n    is_featured?: boolean;\r\n}\r\n\r\n@Injectable({\r\n    providedIn: 'root'\r\n})\r\nexport class AdminProductService {\r\n    private productRepo = inject(ProductRepository);\r\n    private brandRepo = inject(BrandRepository);\r\n    private categoryRepo = inject(CategoryRepository);\r\n    private csvService = inject(CsvService);\r\n    private auth = inject(AuthService);\r\n\r\n    async getProducts(): Promise<Product[]> {\r\n        const user = this.auth.getCurrentUser();\r\n        if (user) {\r\n            const profile = await this.auth.getUserProfile(user.id);\r\n            return firstValueFrom(this.productRepo.getAll(profile?.branch_id));\r\n        }\r\n        return firstValueFrom(this.productRepo.getAll());\r\n    }\r\n\r\n    async getProductsPaginated(params: any): Promise<any> {\r\n        const enrichedParams = {\r\n            ...params,\r\n            include_inactive: params.include_inactive ?? true\r\n        };\r\n        return firstValueFrom(this.productRepo.findWithFilters(enrichedParams));\r\n    }\r\n\r\n    async getProduct(id: string): Promise<Product> {\r\n        return firstValueFrom(this.productRepo.getById(id));\r\n    }\r\n\r\n    async getBrands(): Promise<Brand[]> {\r\n        return firstValueFrom(this.brandRepo.getAll());\r\n    }\r\n\r\n    async getCategories(): Promise<Category[]> {\r\n        return firstValueFrom(this.categoryRepo.getAll());\r\n    }\r\n\r\n    async createProduct(payload: Partial<Product>): Promise<void> {\r\n        await firstValueFrom(this.productRepo.create(payload as Product));\r\n    }\r\n\r\n    async updateProduct(id: string, payload: Partial<Product>): Promise<void> {\r\n        await firstValueFrom(this.productRepo.update(id, payload));\r\n    }\r\n\r\n    async uploadImage(file: File): Promise<string> {\r\n        return this.productRepo.uploadImage(file);\r\n    }\r\n\r\n    slugify(text: string): string {\r\n        return StringUtils.slugify(text);\r\n    }\r\n\r\n    async exportProductsToCSV(): Promise<void> {\r\n        const products = await this.getProducts();\r\n        if (!products.length) return;\r\n\r\n        const headers = [\r\n            'id', 'name', 'slug', 'description', 'price',\r\n            'stock', 'category_id', 'brand_id', 'image_url',\r\n            'is_active', 'is_featured', 'sku', 'barcode'\r\n        ];\r\n\r\n        this.csvService.exportToCsv(products, 'products_export', headers);\r\n    }\r\n\r\n    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\r\n    // SMART IMPORT\r\n    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\r\n\r\n    /**\r\n     * Intelligent CSV import that:\r\n     * 1. Parses and validates the CSV\r\n     * 2. Fetches all existing products (lean projection for speed)\r\n     * 3. Classifies each CSV row as: UPDATE (price only) | RENAME+UPDATE | INSERT (new)\r\n     * 4. Never overwrites images, descriptions, categories or other data on existing products\r\n     */\r\n    async importProductsFromCSV(file: File): Promise<ImportReport> {\r\n        // ‚îÄ‚îÄ STEP 1: Parse CSV ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\r\n        const parseResult = await this.csvService.parse<CsvRow>(file, (values, headers) => {\r\n            const raw: Record<string, any> = {};\r\n            headers.forEach((h: string, i: number) => {\r\n                let v = values[i]?.trim();\r\n                if (v === '' || v === undefined) {\r\n                    raw[h] = null;\r\n                } else if (['price', 'stock', 'min_stock_alert'].includes(h)) {\r\n                    raw[h] = Number(v);\r\n                } else if (['is_active', 'is_featured'].includes(h)) {\r\n                    raw[h] = v.toLowerCase() === 'true';\r\n                } else {\r\n                    raw[h] = v;\r\n                }\r\n            });\r\n\r\n            // must have at least a name and a non-negative price\r\n            const name = (raw['name'] as string)?.trim();\r\n            const price = raw['price'];\r\n            if (!name || price === null || price === undefined || isNaN(Number(price))) {\r\n                return null;\r\n            }\r\n\r\n            // clean up sentinel IDs\r\n            const id = raw['id'] && raw['id'] !== 'new' && raw['id'] !== '' ? raw['id'] : undefined;\r\n\r\n            return {\r\n                id,\r\n                name,\r\n                price: Number(price),\r\n                stock: raw['stock'] != null ? Number(raw['stock']) : undefined,\r\n                sku: raw['sku'] || undefined,\r\n                barcode: raw['barcode'] || undefined,\r\n                description: raw['description'] || undefined,\r\n                category_id: raw['category_id'] || undefined,\r\n                brand_id: raw['brand_id'] || undefined,\r\n                image_url: raw['image_url'] || undefined,\r\n                slug: raw['slug'] || undefined,\r\n                is_active: raw['is_active'] != null ? Boolean(raw['is_active']) : true,\r\n                is_featured: raw['is_featured'] != null ? Boolean(raw['is_featured']) : false,\r\n            } as CsvRow;\r\n        });\r\n\r\n\r\n        const csvRows: CsvRow[] = parseResult.data as CsvRow[];\r\n        const skipped = parseResult.errors;\r\n\r\n        if (csvRows.length === 0) {\r\n            return { inserted: 0, priceUpdated: 0, renamed: 0, skipped, details: ['No se encontraron filas v√°lidas en el CSV.'] };\r\n        }\r\n\r\n        // ‚îÄ‚îÄ STEP 2: Load existing metadata ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\r\n        const [existing, brands, categories] = await Promise.all([\r\n            firstValueFrom(this.productRepo.getAllForImport()),\r\n            this.getBrands(),\r\n            this.getCategories()\r\n        ]);\r\n\r\n        // Build fast lookup indexes\r\n        const byId   = new Map<string, ImportProductSummary>();\r\n        const bySku  = new Map<string, ImportProductSummary>();\r\n        const byName = new Map<string, ImportProductSummary>(); // normalised name ‚Üí product\r\n        const bySlug = new Set<string>();\r\n\r\n        for (const p of existing) {\r\n            byId.set(p.id, p);\r\n            if (p.sku) bySku.set(p.sku.trim().toLowerCase(), p);\r\n            byName.set(this._normaliseName(p.name), p);\r\n            bySlug.add(p.slug);\r\n        }\r\n\r\n        // Metadata lookups (mutable: we'll add auto-created entries)\r\n        const brandByName = new Map<string, string>();   // normalised name ‚Üí brand id\r\n        const brandById   = new Set<string>();             // known brand UUIDs\r\n        brands.forEach(b => { brandByName.set(this._normaliseName(b.name), b.id); brandById.add(b.id); });\r\n\r\n        const catByName = new Map<string, string>();      // normalised name ‚Üí category id\r\n        const catById   = new Set<string>();               // known category UUIDs\r\n        categories.forEach(c => { catByName.set(this._normaliseName(c.name), c.id); catById.add(c.id); });\r\n\r\n        // ‚îÄ‚îÄ STEP 2b: Collect all brand/category names from CSV and auto-create missing ones ‚îÄ‚îÄ\r\n        const details: string[] = [];\r\n        const brandNamesToCreate = new Set<string>();\r\n        const catNamesToCreate = new Set<string>();\r\n\r\n        for (const row of csvRows) {\r\n            // Brand: if provided and either NOT a UUID or a UUID that doesn't exist in DB\r\n            if (row.brand_id) {\r\n                if (this._isUuid(row.brand_id)) {\r\n                    // UUID that doesn't exist in DB ‚Üí treat the CSV value as a problem; strip it\r\n                    // (We cannot reliably create a brand from a UUID string)\r\n                    if (!brandById.has(row.brand_id)) {\r\n                        // Mark as needing strip ‚Äî handled in STEP 3\r\n                    }\r\n                } else {\r\n                    const normName = this._normaliseName(row.brand_id);\r\n                    if (!brandByName.has(normName)) {\r\n                        brandNamesToCreate.add(normName);\r\n                    }\r\n                }\r\n            }\r\n            // Category: same logic\r\n            if (row.category_id) {\r\n                if (this._isUuid(row.category_id)) {\r\n                    if (!catById.has(row.category_id)) {\r\n                        // invalid UUID ‚Üí strip in STEP 3\r\n                    }\r\n                } else {\r\n                    const normName = this._normaliseName(row.category_id);\r\n                    if (!catByName.has(normName)) {\r\n                        catNamesToCreate.add(normName);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Auto-create missing brands\r\n        for (const normName of brandNamesToCreate) {\r\n            try {\r\n                const displayName = normName.charAt(0).toUpperCase() + normName.slice(1);\r\n                const newBrand = await firstValueFrom(\r\n                    this.brandRepo.create({ name: displayName, slug: StringUtils.slugify(normName), is_active: true } as any)\r\n                );\r\n                brandByName.set(normName, newBrand.id);\r\n                brandById.add(newBrand.id);\r\n                details.push(`‚ÑπÔ∏è Marca creada autom√°ticamente: ${displayName}`);\r\n            } catch (e: any) {\r\n                details.push(`‚ö†Ô∏è No se pudo crear la marca \"${normName}\": ${e.message ?? e}`);\r\n            }\r\n        }\r\n\r\n        // Auto-create missing categories\r\n        for (const normName of catNamesToCreate) {\r\n            try {\r\n                const displayName = normName.charAt(0).toUpperCase() + normName.slice(1);\r\n                const newCat = await firstValueFrom(\r\n                    this.categoryRepo.create({ name: displayName, slug: StringUtils.slugify(normName), type: 'product', is_active: true } as any)\r\n                );\r\n                catByName.set(normName, newCat.id);\r\n                catById.add(newCat.id);\r\n                details.push(`‚ÑπÔ∏è Categor√≠a creada autom√°ticamente: ${displayName}`);\r\n            } catch (e: any) {\r\n                details.push(`‚ö†Ô∏è No se pudo crear la categor√≠a \"${normName}\": ${e.message ?? e}`);\r\n            }\r\n        }\r\n\r\n\r\n        // ‚îÄ‚îÄ STEP 3: Classify ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\r\n        const priceUpdates: BulkPriceUpdate[] = [];   // existing ‚Äì price only (¬±name fix)\r\n        const toInsert: Partial<Product>[] = [];       // truly new products\r\n        const usedSlugsInBatch = new Set<string>();\r\n\r\n        for (const row of csvRows) {\r\n            const found = this._findExisting(row, byId, bySku, byName);\r\n\r\n            if (found) {\r\n                // Product EXISTS ‚Üí only update fields allowed\r\n                // Cap price to avoid numeric overflow (e.g. numeric(10,2))\r\n                const safePrice = Math.min(row.price, 99999999.99);\r\n                const update: BulkPriceUpdate = { id: found.id, price: safePrice };\r\n\r\n                if (this._isGenericRepuesto(found.name) && row.name && !this._isGenericRepuesto(row.name)) {\r\n                    update.newName = row.name;\r\n                }\r\n\r\n                priceUpdates.push(update);\r\n            } else {\r\n                // Product does NOT EXIST ‚Üí prepare for insertion\r\n                \r\n                // Resolve Brand ID ‚Äî 3-way check:\r\n                // 1. If it's a valid UUID that exists in DB ‚Üí use it directly\r\n                // 2. If it's a name (or unknown UUID) ‚Üí look up by normalised name\r\n                // 3. Still not found ‚Üí strip it (null) to avoid FK violation\r\n                let brandId: string | undefined = undefined;\r\n                if (row.brand_id) {\r\n                    if (this._isUuid(row.brand_id) && brandById.has(row.brand_id)) {\r\n                        brandId = row.brand_id;\r\n                    } else {\r\n                        // Try by name (covers both plain names and unrecognised UUIDs treated as strings)\r\n                        const norm = this._isUuid(row.brand_id)\r\n                            ? undefined  // unknown UUID ‚Äî can't resolve as name, strip\r\n                            : brandByName.get(this._normaliseName(row.brand_id));\r\n                        brandId = norm;\r\n                    }\r\n                }\r\n\r\n                // Resolve Category ID ‚Äî same 3-way logic\r\n                let catId: string | undefined = undefined;\r\n                if (row.category_id) {\r\n                    if (this._isUuid(row.category_id) && catById.has(row.category_id)) {\r\n                        catId = row.category_id;\r\n                    } else {\r\n                        const norm = this._isUuid(row.category_id)\r\n                            ? undefined\r\n                            : catByName.get(this._normaliseName(row.category_id));\r\n                        catId = norm;\r\n                    }\r\n                }\r\n\r\n                // Ensure unique slug\r\n                let baseSlug = row.slug || StringUtils.slugify(row.name);\r\n                let slug = baseSlug;\r\n                let counter = 1;\r\n                while (bySlug.has(slug) || usedSlugsInBatch.has(slug)) {\r\n                    slug = `${baseSlug}-${counter++}`;\r\n                }\r\n                usedSlugsInBatch.add(slug);\r\n\r\n                toInsert.push({\r\n                    name: row.name,\r\n                    slug: slug,\r\n                    price: Math.min(row.price, 99999999.99),\r\n                    stock: Math.min(row.stock ?? 1, 99999), \r\n                    sku: row.sku || undefined,\r\n                    barcode: row.barcode || undefined,\r\n                    description: row.description || '',\r\n                    category_id: catId || undefined,\r\n                    brand_id: brandId || undefined,\r\n                    image_url: row.image_url || undefined,\r\n                    is_active: row.is_active ?? true,\r\n                    is_featured: row.is_featured ?? false,\r\n                });\r\n            }\r\n        }\r\n\r\n        // ‚îÄ‚îÄ STEP 4: Execute ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\r\n        let priceUpdated = 0;\r\n        let renamed = 0;\r\n        let inserted = 0;\r\n\r\n        // 4a. Bulk price updates\r\n        if (priceUpdates.length > 0) {\r\n            try {\r\n                const { updated, errors: updateErrors } = await firstValueFrom(\r\n                    this.productRepo.bulkUpdatePrices(priceUpdates)\r\n                );\r\n                priceUpdated = priceUpdates.filter(u => !u.newName).length;\r\n                renamed = priceUpdates.filter(u => !!u.newName).length;\r\n                details.push(`‚úÖ ${updated} productos actualizados (precio${renamed > 0 ? ` + ${renamed} renombrados` : ''}).`);\r\n                if (updateErrors > 0) {\r\n                    details.push(`‚ö†Ô∏è ${updateErrors} actualizaciones fallaron.`);\r\n                }\r\n            } catch (e: any) {\r\n                details.push(`‚ö†Ô∏è Error cr√≠tico en actualizaci√≥n de precios: ${e.message}`);\r\n            }\r\n        }\r\n\r\n        // 4b. Bulk inserts in batches of 100\r\n        if (toInsert.length > 0) {\r\n            const INSERT_CHUNK = 100;\r\n            for (let i = 0; i < toInsert.length; i += INSERT_CHUNK) {\r\n                const chunk = toInsert.slice(i, i + INSERT_CHUNK);\r\n                try {\r\n                    const upserted = await firstValueFrom(this.productRepo.upsertMany(chunk));\r\n                    inserted += (upserted || []).length;\r\n                } catch (e: any) {\r\n                    console.error('Batch error:', e);\r\n                    let errorMsg = e.message;\r\n                    if (errorMsg.includes('products_brand_id_fkey')) {\r\n                        errorMsg = 'Marca no encontrada (el ID o nombre no coincide)';\r\n                    } else if (errorMsg.includes('numeric field overflow')) {\r\n                        errorMsg = 'N√∫mero demasiado grande (precio o stock excede el l√≠mite)';\r\n                    } else if (errorMsg.includes('duplicate key')) {\r\n                        errorMsg = 'Nombre o SKU ya existe';\r\n                    }\r\n                    details.push(`‚ö†Ô∏è Error lote ${Math.floor(i / INSERT_CHUNK) + 1}: ${errorMsg}`);\r\n                }\r\n            }\r\n            details.push(`üÜï ${inserted} productos nuevos insertados.`);\r\n        }\r\n\r\n        if (skipped > 0) {\r\n            details.push(`‚õî ${skipped} filas omitidas (datos inv√°lidos o mal formateados).`);\r\n        }\r\n\r\n        return { inserted, priceUpdated, renamed, skipped, details };\r\n    }\r\n\r\n    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\r\n    // Helpers\r\n    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\r\n\r\n    /** Try to match a CSV row to an existing product by ID ‚Üí SKU ‚Üí Name */\r\n    private _findExisting(\r\n        row: CsvRow,\r\n        byId: Map<string, ImportProductSummary>,\r\n        bySku: Map<string, ImportProductSummary>,\r\n        byName: Map<string, ImportProductSummary>\r\n    ): ImportProductSummary | null {\r\n        if (row.id && byId.has(row.id)) return byId.get(row.id)!;\r\n        if (row.sku) {\r\n            const skuMatch = bySku.get(row.sku.trim().toLowerCase());\r\n            if (skuMatch) return skuMatch;\r\n        }\r\n        const normName = this._normaliseName(row.name);\r\n        return byName.get(normName) ?? null;\r\n    }\r\n\r\n    /** Normalise a product name for comparison: lowercase, trim, collapse spaces */\r\n    private _normaliseName(name: string): string {\r\n        return (name || '').toLowerCase().trim().replace(/\\s+/g, ' ');\r\n    }\r\n\r\n    /**\r\n     * Returns true if a product name is a generic \"repuesto\" marker.\r\n     * Covers: \"Repuesto\", \"repuesto\", \"Repuesto Generic\", \"Repuesto Samsung\", etc.\r\n     */\r\n    private _isGenericRepuesto(name: string): boolean {\r\n        const n = (name || '').trim().toLowerCase();\r\n        return n === 'repuesto' || n.startsWith('repuesto ') || n.endsWith(' repuesto');\r\n    }\r\n\r\n    private _isUuid(text: string): boolean {\r\n        const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-5][0-9a-f]{3}-[089ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\r\n        return uuidRegex.test(text);\r\n    }\r\n\r\n    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\r\n    // Bulk operations (used by BulkEditModal)\r\n    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\r\n\r\n    /** Build minimal clean payloads so only REAL DB columns reach Supabase */\r\n    async bulkCustomUpdate(updates: Array<{ id: string; payload: Record<string, any> }>): Promise<void> {\r\n        const products = updates.map(u => ({ id: u.id, ...u.payload }));\r\n        await firstValueFrom(this.productRepo.updateMany(products));\r\n    }\r\n\r\n    async bulkDelete(ids: string[]): Promise<void> {\r\n        await firstValueFrom(this.productRepo.bulkDelete(ids));\r\n    }\r\n\r\n    async bulkIncreasePrice(ids: string[], percentage: number): Promise<void> {\r\n        const response = await firstValueFrom(this.productRepo.findWithFilters({ ids: ids }));\r\n        const products = response.data;\r\n\r\n        if (!products || products.length === 0) return;\r\n\r\n        const updates = products.map(p => ({\r\n            id: p.id,\r\n            price: Math.round(p.price * (1 + percentage / 100))\r\n        }));\r\n\r\n        await firstValueFrom(this.productRepo.updateMany(updates));\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
